#!/usr/bin/env node

const __bundled_import_meta_url = require('url').pathToFileURL(__filename).href;

"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/commander/lib/error.js
var require_error = __commonJS({
  "node_modules/commander/lib/error.js"(exports2) {
    "use strict";
    var CommanderError2 = class extends Error {
      /**
       * Constructs the CommanderError class
       * @param {number} exitCode suggested exit code which could be used with process.exit
       * @param {string} code an id string representing the error
       * @param {string} message human-readable description of the error
       */
      constructor(exitCode, code, message) {
        super(message);
        Error.captureStackTrace(this, this.constructor);
        this.name = this.constructor.name;
        this.code = code;
        this.exitCode = exitCode;
        this.nestedError = void 0;
      }
    };
    var InvalidArgumentError2 = class extends CommanderError2 {
      /**
       * Constructs the InvalidArgumentError class
       * @param {string} [message] explanation of why argument is invalid
       */
      constructor(message) {
        super(1, "commander.invalidArgument", message);
        Error.captureStackTrace(this, this.constructor);
        this.name = this.constructor.name;
      }
    };
    exports2.CommanderError = CommanderError2;
    exports2.InvalidArgumentError = InvalidArgumentError2;
  }
});

// node_modules/commander/lib/argument.js
var require_argument = __commonJS({
  "node_modules/commander/lib/argument.js"(exports2) {
    "use strict";
    var { InvalidArgumentError: InvalidArgumentError2 } = require_error();
    var Argument2 = class {
      /**
       * Initialize a new command argument with the given name and description.
       * The default is that the argument is required, and you can explicitly
       * indicate this with <> around the name. Put [] around the name for an optional argument.
       *
       * @param {string} name
       * @param {string} [description]
       */
      constructor(name, description) {
        this.description = description || "";
        this.variadic = false;
        this.parseArg = void 0;
        this.defaultValue = void 0;
        this.defaultValueDescription = void 0;
        this.argChoices = void 0;
        switch (name[0]) {
          case "<":
            this.required = true;
            this._name = name.slice(1, -1);
            break;
          case "[":
            this.required = false;
            this._name = name.slice(1, -1);
            break;
          default:
            this.required = true;
            this._name = name;
            break;
        }
        if (this._name.length > 3 && this._name.slice(-3) === "...") {
          this.variadic = true;
          this._name = this._name.slice(0, -3);
        }
      }
      /**
       * Return argument name.
       *
       * @return {string}
       */
      name() {
        return this._name;
      }
      /**
       * @package
       */
      _concatValue(value, previous) {
        if (previous === this.defaultValue || !Array.isArray(previous)) {
          return [value];
        }
        return previous.concat(value);
      }
      /**
       * Set the default value, and optionally supply the description to be displayed in the help.
       *
       * @param {*} value
       * @param {string} [description]
       * @return {Argument}
       */
      default(value, description) {
        this.defaultValue = value;
        this.defaultValueDescription = description;
        return this;
      }
      /**
       * Set the custom handler for processing CLI command arguments into argument values.
       *
       * @param {Function} [fn]
       * @return {Argument}
       */
      argParser(fn) {
        this.parseArg = fn;
        return this;
      }
      /**
       * Only allow argument value to be one of choices.
       *
       * @param {string[]} values
       * @return {Argument}
       */
      choices(values) {
        this.argChoices = values.slice();
        this.parseArg = (arg, previous) => {
          if (!this.argChoices.includes(arg)) {
            throw new InvalidArgumentError2(
              `Allowed choices are ${this.argChoices.join(", ")}.`
            );
          }
          if (this.variadic) {
            return this._concatValue(arg, previous);
          }
          return arg;
        };
        return this;
      }
      /**
       * Make argument required.
       *
       * @returns {Argument}
       */
      argRequired() {
        this.required = true;
        return this;
      }
      /**
       * Make argument optional.
       *
       * @returns {Argument}
       */
      argOptional() {
        this.required = false;
        return this;
      }
    };
    function humanReadableArgName(arg) {
      const nameOutput = arg.name() + (arg.variadic === true ? "..." : "");
      return arg.required ? "<" + nameOutput + ">" : "[" + nameOutput + "]";
    }
    exports2.Argument = Argument2;
    exports2.humanReadableArgName = humanReadableArgName;
  }
});

// node_modules/commander/lib/help.js
var require_help = __commonJS({
  "node_modules/commander/lib/help.js"(exports2) {
    "use strict";
    var { humanReadableArgName } = require_argument();
    var Help2 = class {
      constructor() {
        this.helpWidth = void 0;
        this.sortSubcommands = false;
        this.sortOptions = false;
        this.showGlobalOptions = false;
      }
      /**
       * Get an array of the visible subcommands. Includes a placeholder for the implicit help command, if there is one.
       *
       * @param {Command} cmd
       * @returns {Command[]}
       */
      visibleCommands(cmd) {
        const visibleCommands = cmd.commands.filter((cmd2) => !cmd2._hidden);
        const helpCommand = cmd._getHelpCommand();
        if (helpCommand && !helpCommand._hidden) {
          visibleCommands.push(helpCommand);
        }
        if (this.sortSubcommands) {
          visibleCommands.sort((a, b) => {
            return a.name().localeCompare(b.name());
          });
        }
        return visibleCommands;
      }
      /**
       * Compare options for sort.
       *
       * @param {Option} a
       * @param {Option} b
       * @returns {number}
       */
      compareOptions(a, b) {
        const getSortKey = (option) => {
          return option.short ? option.short.replace(/^-/, "") : option.long.replace(/^--/, "");
        };
        return getSortKey(a).localeCompare(getSortKey(b));
      }
      /**
       * Get an array of the visible options. Includes a placeholder for the implicit help option, if there is one.
       *
       * @param {Command} cmd
       * @returns {Option[]}
       */
      visibleOptions(cmd) {
        const visibleOptions = cmd.options.filter((option) => !option.hidden);
        const helpOption = cmd._getHelpOption();
        if (helpOption && !helpOption.hidden) {
          const removeShort = helpOption.short && cmd._findOption(helpOption.short);
          const removeLong = helpOption.long && cmd._findOption(helpOption.long);
          if (!removeShort && !removeLong) {
            visibleOptions.push(helpOption);
          } else if (helpOption.long && !removeLong) {
            visibleOptions.push(
              cmd.createOption(helpOption.long, helpOption.description)
            );
          } else if (helpOption.short && !removeShort) {
            visibleOptions.push(
              cmd.createOption(helpOption.short, helpOption.description)
            );
          }
        }
        if (this.sortOptions) {
          visibleOptions.sort(this.compareOptions);
        }
        return visibleOptions;
      }
      /**
       * Get an array of the visible global options. (Not including help.)
       *
       * @param {Command} cmd
       * @returns {Option[]}
       */
      visibleGlobalOptions(cmd) {
        if (!this.showGlobalOptions) return [];
        const globalOptions = [];
        for (let ancestorCmd = cmd.parent; ancestorCmd; ancestorCmd = ancestorCmd.parent) {
          const visibleOptions = ancestorCmd.options.filter(
            (option) => !option.hidden
          );
          globalOptions.push(...visibleOptions);
        }
        if (this.sortOptions) {
          globalOptions.sort(this.compareOptions);
        }
        return globalOptions;
      }
      /**
       * Get an array of the arguments if any have a description.
       *
       * @param {Command} cmd
       * @returns {Argument[]}
       */
      visibleArguments(cmd) {
        if (cmd._argsDescription) {
          cmd.registeredArguments.forEach((argument) => {
            argument.description = argument.description || cmd._argsDescription[argument.name()] || "";
          });
        }
        if (cmd.registeredArguments.find((argument) => argument.description)) {
          return cmd.registeredArguments;
        }
        return [];
      }
      /**
       * Get the command term to show in the list of subcommands.
       *
       * @param {Command} cmd
       * @returns {string}
       */
      subcommandTerm(cmd) {
        const args = cmd.registeredArguments.map((arg) => humanReadableArgName(arg)).join(" ");
        return cmd._name + (cmd._aliases[0] ? "|" + cmd._aliases[0] : "") + (cmd.options.length ? " [options]" : "") + // simplistic check for non-help option
        (args ? " " + args : "");
      }
      /**
       * Get the option term to show in the list of options.
       *
       * @param {Option} option
       * @returns {string}
       */
      optionTerm(option) {
        return option.flags;
      }
      /**
       * Get the argument term to show in the list of arguments.
       *
       * @param {Argument} argument
       * @returns {string}
       */
      argumentTerm(argument) {
        return argument.name();
      }
      /**
       * Get the longest command term length.
       *
       * @param {Command} cmd
       * @param {Help} helper
       * @returns {number}
       */
      longestSubcommandTermLength(cmd, helper) {
        return helper.visibleCommands(cmd).reduce((max, command) => {
          return Math.max(max, helper.subcommandTerm(command).length);
        }, 0);
      }
      /**
       * Get the longest option term length.
       *
       * @param {Command} cmd
       * @param {Help} helper
       * @returns {number}
       */
      longestOptionTermLength(cmd, helper) {
        return helper.visibleOptions(cmd).reduce((max, option) => {
          return Math.max(max, helper.optionTerm(option).length);
        }, 0);
      }
      /**
       * Get the longest global option term length.
       *
       * @param {Command} cmd
       * @param {Help} helper
       * @returns {number}
       */
      longestGlobalOptionTermLength(cmd, helper) {
        return helper.visibleGlobalOptions(cmd).reduce((max, option) => {
          return Math.max(max, helper.optionTerm(option).length);
        }, 0);
      }
      /**
       * Get the longest argument term length.
       *
       * @param {Command} cmd
       * @param {Help} helper
       * @returns {number}
       */
      longestArgumentTermLength(cmd, helper) {
        return helper.visibleArguments(cmd).reduce((max, argument) => {
          return Math.max(max, helper.argumentTerm(argument).length);
        }, 0);
      }
      /**
       * Get the command usage to be displayed at the top of the built-in help.
       *
       * @param {Command} cmd
       * @returns {string}
       */
      commandUsage(cmd) {
        let cmdName = cmd._name;
        if (cmd._aliases[0]) {
          cmdName = cmdName + "|" + cmd._aliases[0];
        }
        let ancestorCmdNames = "";
        for (let ancestorCmd = cmd.parent; ancestorCmd; ancestorCmd = ancestorCmd.parent) {
          ancestorCmdNames = ancestorCmd.name() + " " + ancestorCmdNames;
        }
        return ancestorCmdNames + cmdName + " " + cmd.usage();
      }
      /**
       * Get the description for the command.
       *
       * @param {Command} cmd
       * @returns {string}
       */
      commandDescription(cmd) {
        return cmd.description();
      }
      /**
       * Get the subcommand summary to show in the list of subcommands.
       * (Fallback to description for backwards compatibility.)
       *
       * @param {Command} cmd
       * @returns {string}
       */
      subcommandDescription(cmd) {
        return cmd.summary() || cmd.description();
      }
      /**
       * Get the option description to show in the list of options.
       *
       * @param {Option} option
       * @return {string}
       */
      optionDescription(option) {
        const extraInfo = [];
        if (option.argChoices) {
          extraInfo.push(
            // use stringify to match the display of the default value
            `choices: ${option.argChoices.map((choice) => JSON.stringify(choice)).join(", ")}`
          );
        }
        if (option.defaultValue !== void 0) {
          const showDefault = option.required || option.optional || option.isBoolean() && typeof option.defaultValue === "boolean";
          if (showDefault) {
            extraInfo.push(
              `default: ${option.defaultValueDescription || JSON.stringify(option.defaultValue)}`
            );
          }
        }
        if (option.presetArg !== void 0 && option.optional) {
          extraInfo.push(`preset: ${JSON.stringify(option.presetArg)}`);
        }
        if (option.envVar !== void 0) {
          extraInfo.push(`env: ${option.envVar}`);
        }
        if (extraInfo.length > 0) {
          return `${option.description} (${extraInfo.join(", ")})`;
        }
        return option.description;
      }
      /**
       * Get the argument description to show in the list of arguments.
       *
       * @param {Argument} argument
       * @return {string}
       */
      argumentDescription(argument) {
        const extraInfo = [];
        if (argument.argChoices) {
          extraInfo.push(
            // use stringify to match the display of the default value
            `choices: ${argument.argChoices.map((choice) => JSON.stringify(choice)).join(", ")}`
          );
        }
        if (argument.defaultValue !== void 0) {
          extraInfo.push(
            `default: ${argument.defaultValueDescription || JSON.stringify(argument.defaultValue)}`
          );
        }
        if (extraInfo.length > 0) {
          const extraDescripton = `(${extraInfo.join(", ")})`;
          if (argument.description) {
            return `${argument.description} ${extraDescripton}`;
          }
          return extraDescripton;
        }
        return argument.description;
      }
      /**
       * Generate the built-in help text.
       *
       * @param {Command} cmd
       * @param {Help} helper
       * @returns {string}
       */
      formatHelp(cmd, helper) {
        const termWidth = helper.padWidth(cmd, helper);
        const helpWidth = helper.helpWidth || 80;
        const itemIndentWidth = 2;
        const itemSeparatorWidth = 2;
        function formatItem(term, description) {
          if (description) {
            const fullText = `${term.padEnd(termWidth + itemSeparatorWidth)}${description}`;
            return helper.wrap(
              fullText,
              helpWidth - itemIndentWidth,
              termWidth + itemSeparatorWidth
            );
          }
          return term;
        }
        function formatList(textArray) {
          return textArray.join("\n").replace(/^/gm, " ".repeat(itemIndentWidth));
        }
        let output = [`Usage: ${helper.commandUsage(cmd)}`, ""];
        const commandDescription = helper.commandDescription(cmd);
        if (commandDescription.length > 0) {
          output = output.concat([
            helper.wrap(commandDescription, helpWidth, 0),
            ""
          ]);
        }
        const argumentList = helper.visibleArguments(cmd).map((argument) => {
          return formatItem(
            helper.argumentTerm(argument),
            helper.argumentDescription(argument)
          );
        });
        if (argumentList.length > 0) {
          output = output.concat(["Arguments:", formatList(argumentList), ""]);
        }
        const optionList = helper.visibleOptions(cmd).map((option) => {
          return formatItem(
            helper.optionTerm(option),
            helper.optionDescription(option)
          );
        });
        if (optionList.length > 0) {
          output = output.concat(["Options:", formatList(optionList), ""]);
        }
        if (this.showGlobalOptions) {
          const globalOptionList = helper.visibleGlobalOptions(cmd).map((option) => {
            return formatItem(
              helper.optionTerm(option),
              helper.optionDescription(option)
            );
          });
          if (globalOptionList.length > 0) {
            output = output.concat([
              "Global Options:",
              formatList(globalOptionList),
              ""
            ]);
          }
        }
        const commandList = helper.visibleCommands(cmd).map((cmd2) => {
          return formatItem(
            helper.subcommandTerm(cmd2),
            helper.subcommandDescription(cmd2)
          );
        });
        if (commandList.length > 0) {
          output = output.concat(["Commands:", formatList(commandList), ""]);
        }
        return output.join("\n");
      }
      /**
       * Calculate the pad width from the maximum term length.
       *
       * @param {Command} cmd
       * @param {Help} helper
       * @returns {number}
       */
      padWidth(cmd, helper) {
        return Math.max(
          helper.longestOptionTermLength(cmd, helper),
          helper.longestGlobalOptionTermLength(cmd, helper),
          helper.longestSubcommandTermLength(cmd, helper),
          helper.longestArgumentTermLength(cmd, helper)
        );
      }
      /**
       * Wrap the given string to width characters per line, with lines after the first indented.
       * Do not wrap if insufficient room for wrapping (minColumnWidth), or string is manually formatted.
       *
       * @param {string} str
       * @param {number} width
       * @param {number} indent
       * @param {number} [minColumnWidth=40]
       * @return {string}
       *
       */
      wrap(str, width, indent, minColumnWidth = 40) {
        const indents = " \\f\\t\\v\xA0\u1680\u2000-\u200A\u202F\u205F\u3000\uFEFF";
        const manualIndent = new RegExp(`[\\n][${indents}]+`);
        if (str.match(manualIndent)) return str;
        const columnWidth = width - indent;
        if (columnWidth < minColumnWidth) return str;
        const leadingStr = str.slice(0, indent);
        const columnText = str.slice(indent).replace("\r\n", "\n");
        const indentString = " ".repeat(indent);
        const zeroWidthSpace = "\u200B";
        const breaks = `\\s${zeroWidthSpace}`;
        const regex = new RegExp(
          `
|.{1,${columnWidth - 1}}([${breaks}]|$)|[^${breaks}]+?([${breaks}]|$)`,
          "g"
        );
        const lines = columnText.match(regex) || [];
        return leadingStr + lines.map((line, i) => {
          if (line === "\n") return "";
          return (i > 0 ? indentString : "") + line.trimEnd();
        }).join("\n");
      }
    };
    exports2.Help = Help2;
  }
});

// node_modules/commander/lib/option.js
var require_option = __commonJS({
  "node_modules/commander/lib/option.js"(exports2) {
    "use strict";
    var { InvalidArgumentError: InvalidArgumentError2 } = require_error();
    var Option2 = class {
      /**
       * Initialize a new `Option` with the given `flags` and `description`.
       *
       * @param {string} flags
       * @param {string} [description]
       */
      constructor(flags, description) {
        this.flags = flags;
        this.description = description || "";
        this.required = flags.includes("<");
        this.optional = flags.includes("[");
        this.variadic = /\w\.\.\.[>\]]$/.test(flags);
        this.mandatory = false;
        const optionFlags = splitOptionFlags(flags);
        this.short = optionFlags.shortFlag;
        this.long = optionFlags.longFlag;
        this.negate = false;
        if (this.long) {
          this.negate = this.long.startsWith("--no-");
        }
        this.defaultValue = void 0;
        this.defaultValueDescription = void 0;
        this.presetArg = void 0;
        this.envVar = void 0;
        this.parseArg = void 0;
        this.hidden = false;
        this.argChoices = void 0;
        this.conflictsWith = [];
        this.implied = void 0;
      }
      /**
       * Set the default value, and optionally supply the description to be displayed in the help.
       *
       * @param {*} value
       * @param {string} [description]
       * @return {Option}
       */
      default(value, description) {
        this.defaultValue = value;
        this.defaultValueDescription = description;
        return this;
      }
      /**
       * Preset to use when option used without option-argument, especially optional but also boolean and negated.
       * The custom processing (parseArg) is called.
       *
       * @example
       * new Option('--color').default('GREYSCALE').preset('RGB');
       * new Option('--donate [amount]').preset('20').argParser(parseFloat);
       *
       * @param {*} arg
       * @return {Option}
       */
      preset(arg) {
        this.presetArg = arg;
        return this;
      }
      /**
       * Add option name(s) that conflict with this option.
       * An error will be displayed if conflicting options are found during parsing.
       *
       * @example
       * new Option('--rgb').conflicts('cmyk');
       * new Option('--js').conflicts(['ts', 'jsx']);
       *
       * @param {(string | string[])} names
       * @return {Option}
       */
      conflicts(names) {
        this.conflictsWith = this.conflictsWith.concat(names);
        return this;
      }
      /**
       * Specify implied option values for when this option is set and the implied options are not.
       *
       * The custom processing (parseArg) is not called on the implied values.
       *
       * @example
       * program
       *   .addOption(new Option('--log', 'write logging information to file'))
       *   .addOption(new Option('--trace', 'log extra details').implies({ log: 'trace.txt' }));
       *
       * @param {object} impliedOptionValues
       * @return {Option}
       */
      implies(impliedOptionValues) {
        let newImplied = impliedOptionValues;
        if (typeof impliedOptionValues === "string") {
          newImplied = { [impliedOptionValues]: true };
        }
        this.implied = Object.assign(this.implied || {}, newImplied);
        return this;
      }
      /**
       * Set environment variable to check for option value.
       *
       * An environment variable is only used if when processed the current option value is
       * undefined, or the source of the current value is 'default' or 'config' or 'env'.
       *
       * @param {string} name
       * @return {Option}
       */
      env(name) {
        this.envVar = name;
        return this;
      }
      /**
       * Set the custom handler for processing CLI option arguments into option values.
       *
       * @param {Function} [fn]
       * @return {Option}
       */
      argParser(fn) {
        this.parseArg = fn;
        return this;
      }
      /**
       * Whether the option is mandatory and must have a value after parsing.
       *
       * @param {boolean} [mandatory=true]
       * @return {Option}
       */
      makeOptionMandatory(mandatory = true) {
        this.mandatory = !!mandatory;
        return this;
      }
      /**
       * Hide option in help.
       *
       * @param {boolean} [hide=true]
       * @return {Option}
       */
      hideHelp(hide = true) {
        this.hidden = !!hide;
        return this;
      }
      /**
       * @package
       */
      _concatValue(value, previous) {
        if (previous === this.defaultValue || !Array.isArray(previous)) {
          return [value];
        }
        return previous.concat(value);
      }
      /**
       * Only allow option value to be one of choices.
       *
       * @param {string[]} values
       * @return {Option}
       */
      choices(values) {
        this.argChoices = values.slice();
        this.parseArg = (arg, previous) => {
          if (!this.argChoices.includes(arg)) {
            throw new InvalidArgumentError2(
              `Allowed choices are ${this.argChoices.join(", ")}.`
            );
          }
          if (this.variadic) {
            return this._concatValue(arg, previous);
          }
          return arg;
        };
        return this;
      }
      /**
       * Return option name.
       *
       * @return {string}
       */
      name() {
        if (this.long) {
          return this.long.replace(/^--/, "");
        }
        return this.short.replace(/^-/, "");
      }
      /**
       * Return option name, in a camelcase format that can be used
       * as a object attribute key.
       *
       * @return {string}
       */
      attributeName() {
        return camelcase(this.name().replace(/^no-/, ""));
      }
      /**
       * Check if `arg` matches the short or long flag.
       *
       * @param {string} arg
       * @return {boolean}
       * @package
       */
      is(arg) {
        return this.short === arg || this.long === arg;
      }
      /**
       * Return whether a boolean option.
       *
       * Options are one of boolean, negated, required argument, or optional argument.
       *
       * @return {boolean}
       * @package
       */
      isBoolean() {
        return !this.required && !this.optional && !this.negate;
      }
    };
    var DualOptions = class {
      /**
       * @param {Option[]} options
       */
      constructor(options) {
        this.positiveOptions = /* @__PURE__ */ new Map();
        this.negativeOptions = /* @__PURE__ */ new Map();
        this.dualOptions = /* @__PURE__ */ new Set();
        options.forEach((option) => {
          if (option.negate) {
            this.negativeOptions.set(option.attributeName(), option);
          } else {
            this.positiveOptions.set(option.attributeName(), option);
          }
        });
        this.negativeOptions.forEach((value, key) => {
          if (this.positiveOptions.has(key)) {
            this.dualOptions.add(key);
          }
        });
      }
      /**
       * Did the value come from the option, and not from possible matching dual option?
       *
       * @param {*} value
       * @param {Option} option
       * @returns {boolean}
       */
      valueFromOption(value, option) {
        const optionKey = option.attributeName();
        if (!this.dualOptions.has(optionKey)) return true;
        const preset = this.negativeOptions.get(optionKey).presetArg;
        const negativeValue = preset !== void 0 ? preset : false;
        return option.negate === (negativeValue === value);
      }
    };
    function camelcase(str) {
      return str.split("-").reduce((str2, word) => {
        return str2 + word[0].toUpperCase() + word.slice(1);
      });
    }
    function splitOptionFlags(flags) {
      let shortFlag;
      let longFlag;
      const flagParts = flags.split(/[ |,]+/);
      if (flagParts.length > 1 && !/^[[<]/.test(flagParts[1]))
        shortFlag = flagParts.shift();
      longFlag = flagParts.shift();
      if (!shortFlag && /^-[^-]$/.test(longFlag)) {
        shortFlag = longFlag;
        longFlag = void 0;
      }
      return { shortFlag, longFlag };
    }
    exports2.Option = Option2;
    exports2.DualOptions = DualOptions;
  }
});

// node_modules/commander/lib/suggestSimilar.js
var require_suggestSimilar = __commonJS({
  "node_modules/commander/lib/suggestSimilar.js"(exports2) {
    "use strict";
    var maxDistance = 3;
    function editDistance(a, b) {
      if (Math.abs(a.length - b.length) > maxDistance)
        return Math.max(a.length, b.length);
      const d = [];
      for (let i = 0; i <= a.length; i++) {
        d[i] = [i];
      }
      for (let j = 0; j <= b.length; j++) {
        d[0][j] = j;
      }
      for (let j = 1; j <= b.length; j++) {
        for (let i = 1; i <= a.length; i++) {
          let cost = 1;
          if (a[i - 1] === b[j - 1]) {
            cost = 0;
          } else {
            cost = 1;
          }
          d[i][j] = Math.min(
            d[i - 1][j] + 1,
            // deletion
            d[i][j - 1] + 1,
            // insertion
            d[i - 1][j - 1] + cost
            // substitution
          );
          if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {
            d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + 1);
          }
        }
      }
      return d[a.length][b.length];
    }
    function suggestSimilar(word, candidates) {
      if (!candidates || candidates.length === 0) return "";
      candidates = Array.from(new Set(candidates));
      const searchingOptions = word.startsWith("--");
      if (searchingOptions) {
        word = word.slice(2);
        candidates = candidates.map((candidate) => candidate.slice(2));
      }
      let similar = [];
      let bestDistance = maxDistance;
      const minSimilarity = 0.4;
      candidates.forEach((candidate) => {
        if (candidate.length <= 1) return;
        const distance = editDistance(word, candidate);
        const length = Math.max(word.length, candidate.length);
        const similarity = (length - distance) / length;
        if (similarity > minSimilarity) {
          if (distance < bestDistance) {
            bestDistance = distance;
            similar = [candidate];
          } else if (distance === bestDistance) {
            similar.push(candidate);
          }
        }
      });
      similar.sort((a, b) => a.localeCompare(b));
      if (searchingOptions) {
        similar = similar.map((candidate) => `--${candidate}`);
      }
      if (similar.length > 1) {
        return `
(Did you mean one of ${similar.join(", ")}?)`;
      }
      if (similar.length === 1) {
        return `
(Did you mean ${similar[0]}?)`;
      }
      return "";
    }
    exports2.suggestSimilar = suggestSimilar;
  }
});

// node_modules/commander/lib/command.js
var require_command = __commonJS({
  "node_modules/commander/lib/command.js"(exports2) {
    "use strict";
    var EventEmitter = require("events").EventEmitter;
    var childProcess = require("child_process");
    var path2 = require("path");
    var fs2 = require("fs");
    var process2 = require("process");
    var { Argument: Argument2, humanReadableArgName } = require_argument();
    var { CommanderError: CommanderError2 } = require_error();
    var { Help: Help2 } = require_help();
    var { Option: Option2, DualOptions } = require_option();
    var { suggestSimilar } = require_suggestSimilar();
    var Command2 = class _Command extends EventEmitter {
      /**
       * Initialize a new `Command`.
       *
       * @param {string} [name]
       */
      constructor(name) {
        super();
        this.commands = [];
        this.options = [];
        this.parent = null;
        this._allowUnknownOption = false;
        this._allowExcessArguments = true;
        this.registeredArguments = [];
        this._args = this.registeredArguments;
        this.args = [];
        this.rawArgs = [];
        this.processedArgs = [];
        this._scriptPath = null;
        this._name = name || "";
        this._optionValues = {};
        this._optionValueSources = {};
        this._storeOptionsAsProperties = false;
        this._actionHandler = null;
        this._executableHandler = false;
        this._executableFile = null;
        this._executableDir = null;
        this._defaultCommandName = null;
        this._exitCallback = null;
        this._aliases = [];
        this._combineFlagAndOptionalValue = true;
        this._description = "";
        this._summary = "";
        this._argsDescription = void 0;
        this._enablePositionalOptions = false;
        this._passThroughOptions = false;
        this._lifeCycleHooks = {};
        this._showHelpAfterError = false;
        this._showSuggestionAfterError = true;
        this._outputConfiguration = {
          writeOut: (str) => process2.stdout.write(str),
          writeErr: (str) => process2.stderr.write(str),
          getOutHelpWidth: () => process2.stdout.isTTY ? process2.stdout.columns : void 0,
          getErrHelpWidth: () => process2.stderr.isTTY ? process2.stderr.columns : void 0,
          outputError: (str, write) => write(str)
        };
        this._hidden = false;
        this._helpOption = void 0;
        this._addImplicitHelpCommand = void 0;
        this._helpCommand = void 0;
        this._helpConfiguration = {};
      }
      /**
       * Copy settings that are useful to have in common across root command and subcommands.
       *
       * (Used internally when adding a command using `.command()` so subcommands inherit parent settings.)
       *
       * @param {Command} sourceCommand
       * @return {Command} `this` command for chaining
       */
      copyInheritedSettings(sourceCommand) {
        this._outputConfiguration = sourceCommand._outputConfiguration;
        this._helpOption = sourceCommand._helpOption;
        this._helpCommand = sourceCommand._helpCommand;
        this._helpConfiguration = sourceCommand._helpConfiguration;
        this._exitCallback = sourceCommand._exitCallback;
        this._storeOptionsAsProperties = sourceCommand._storeOptionsAsProperties;
        this._combineFlagAndOptionalValue = sourceCommand._combineFlagAndOptionalValue;
        this._allowExcessArguments = sourceCommand._allowExcessArguments;
        this._enablePositionalOptions = sourceCommand._enablePositionalOptions;
        this._showHelpAfterError = sourceCommand._showHelpAfterError;
        this._showSuggestionAfterError = sourceCommand._showSuggestionAfterError;
        return this;
      }
      /**
       * @returns {Command[]}
       * @private
       */
      _getCommandAndAncestors() {
        const result = [];
        for (let command = this; command; command = command.parent) {
          result.push(command);
        }
        return result;
      }
      /**
       * Define a command.
       *
       * There are two styles of command: pay attention to where to put the description.
       *
       * @example
       * // Command implemented using action handler (description is supplied separately to `.command`)
       * program
       *   .command('clone <source> [destination]')
       *   .description('clone a repository into a newly created directory')
       *   .action((source, destination) => {
       *     console.log('clone command called');
       *   });
       *
       * // Command implemented using separate executable file (description is second parameter to `.command`)
       * program
       *   .command('start <service>', 'start named service')
       *   .command('stop [service]', 'stop named service, or all if no name supplied');
       *
       * @param {string} nameAndArgs - command name and arguments, args are `<required>` or `[optional]` and last may also be `variadic...`
       * @param {(object | string)} [actionOptsOrExecDesc] - configuration options (for action), or description (for executable)
       * @param {object} [execOpts] - configuration options (for executable)
       * @return {Command} returns new command for action handler, or `this` for executable command
       */
      command(nameAndArgs, actionOptsOrExecDesc, execOpts) {
        let desc = actionOptsOrExecDesc;
        let opts = execOpts;
        if (typeof desc === "object" && desc !== null) {
          opts = desc;
          desc = null;
        }
        opts = opts || {};
        const [, name, args] = nameAndArgs.match(/([^ ]+) *(.*)/);
        const cmd = this.createCommand(name);
        if (desc) {
          cmd.description(desc);
          cmd._executableHandler = true;
        }
        if (opts.isDefault) this._defaultCommandName = cmd._name;
        cmd._hidden = !!(opts.noHelp || opts.hidden);
        cmd._executableFile = opts.executableFile || null;
        if (args) cmd.arguments(args);
        this._registerCommand(cmd);
        cmd.parent = this;
        cmd.copyInheritedSettings(this);
        if (desc) return this;
        return cmd;
      }
      /**
       * Factory routine to create a new unattached command.
       *
       * See .command() for creating an attached subcommand, which uses this routine to
       * create the command. You can override createCommand to customise subcommands.
       *
       * @param {string} [name]
       * @return {Command} new command
       */
      createCommand(name) {
        return new _Command(name);
      }
      /**
       * You can customise the help with a subclass of Help by overriding createHelp,
       * or by overriding Help properties using configureHelp().
       *
       * @return {Help}
       */
      createHelp() {
        return Object.assign(new Help2(), this.configureHelp());
      }
      /**
       * You can customise the help by overriding Help properties using configureHelp(),
       * or with a subclass of Help by overriding createHelp().
       *
       * @param {object} [configuration] - configuration options
       * @return {(Command | object)} `this` command for chaining, or stored configuration
       */
      configureHelp(configuration) {
        if (configuration === void 0) return this._helpConfiguration;
        this._helpConfiguration = configuration;
        return this;
      }
      /**
       * The default output goes to stdout and stderr. You can customise this for special
       * applications. You can also customise the display of errors by overriding outputError.
       *
       * The configuration properties are all functions:
       *
       *     // functions to change where being written, stdout and stderr
       *     writeOut(str)
       *     writeErr(str)
       *     // matching functions to specify width for wrapping help
       *     getOutHelpWidth()
       *     getErrHelpWidth()
       *     // functions based on what is being written out
       *     outputError(str, write) // used for displaying errors, and not used for displaying help
       *
       * @param {object} [configuration] - configuration options
       * @return {(Command | object)} `this` command for chaining, or stored configuration
       */
      configureOutput(configuration) {
        if (configuration === void 0) return this._outputConfiguration;
        Object.assign(this._outputConfiguration, configuration);
        return this;
      }
      /**
       * Display the help or a custom message after an error occurs.
       *
       * @param {(boolean|string)} [displayHelp]
       * @return {Command} `this` command for chaining
       */
      showHelpAfterError(displayHelp = true) {
        if (typeof displayHelp !== "string") displayHelp = !!displayHelp;
        this._showHelpAfterError = displayHelp;
        return this;
      }
      /**
       * Display suggestion of similar commands for unknown commands, or options for unknown options.
       *
       * @param {boolean} [displaySuggestion]
       * @return {Command} `this` command for chaining
       */
      showSuggestionAfterError(displaySuggestion = true) {
        this._showSuggestionAfterError = !!displaySuggestion;
        return this;
      }
      /**
       * Add a prepared subcommand.
       *
       * See .command() for creating an attached subcommand which inherits settings from its parent.
       *
       * @param {Command} cmd - new subcommand
       * @param {object} [opts] - configuration options
       * @return {Command} `this` command for chaining
       */
      addCommand(cmd, opts) {
        if (!cmd._name) {
          throw new Error(`Command passed to .addCommand() must have a name
- specify the name in Command constructor or using .name()`);
        }
        opts = opts || {};
        if (opts.isDefault) this._defaultCommandName = cmd._name;
        if (opts.noHelp || opts.hidden) cmd._hidden = true;
        this._registerCommand(cmd);
        cmd.parent = this;
        cmd._checkForBrokenPassThrough();
        return this;
      }
      /**
       * Factory routine to create a new unattached argument.
       *
       * See .argument() for creating an attached argument, which uses this routine to
       * create the argument. You can override createArgument to return a custom argument.
       *
       * @param {string} name
       * @param {string} [description]
       * @return {Argument} new argument
       */
      createArgument(name, description) {
        return new Argument2(name, description);
      }
      /**
       * Define argument syntax for command.
       *
       * The default is that the argument is required, and you can explicitly
       * indicate this with <> around the name. Put [] around the name for an optional argument.
       *
       * @example
       * program.argument('<input-file>');
       * program.argument('[output-file]');
       *
       * @param {string} name
       * @param {string} [description]
       * @param {(Function|*)} [fn] - custom argument processing function
       * @param {*} [defaultValue]
       * @return {Command} `this` command for chaining
       */
      argument(name, description, fn, defaultValue) {
        const argument = this.createArgument(name, description);
        if (typeof fn === "function") {
          argument.default(defaultValue).argParser(fn);
        } else {
          argument.default(fn);
        }
        this.addArgument(argument);
        return this;
      }
      /**
       * Define argument syntax for command, adding multiple at once (without descriptions).
       *
       * See also .argument().
       *
       * @example
       * program.arguments('<cmd> [env]');
       *
       * @param {string} names
       * @return {Command} `this` command for chaining
       */
      arguments(names) {
        names.trim().split(/ +/).forEach((detail) => {
          this.argument(detail);
        });
        return this;
      }
      /**
       * Define argument syntax for command, adding a prepared argument.
       *
       * @param {Argument} argument
       * @return {Command} `this` command for chaining
       */
      addArgument(argument) {
        const previousArgument = this.registeredArguments.slice(-1)[0];
        if (previousArgument && previousArgument.variadic) {
          throw new Error(
            `only the last argument can be variadic '${previousArgument.name()}'`
          );
        }
        if (argument.required && argument.defaultValue !== void 0 && argument.parseArg === void 0) {
          throw new Error(
            `a default value for a required argument is never used: '${argument.name()}'`
          );
        }
        this.registeredArguments.push(argument);
        return this;
      }
      /**
       * Customise or override default help command. By default a help command is automatically added if your command has subcommands.
       *
       * @example
       *    program.helpCommand('help [cmd]');
       *    program.helpCommand('help [cmd]', 'show help');
       *    program.helpCommand(false); // suppress default help command
       *    program.helpCommand(true); // add help command even if no subcommands
       *
       * @param {string|boolean} enableOrNameAndArgs - enable with custom name and/or arguments, or boolean to override whether added
       * @param {string} [description] - custom description
       * @return {Command} `this` command for chaining
       */
      helpCommand(enableOrNameAndArgs, description) {
        if (typeof enableOrNameAndArgs === "boolean") {
          this._addImplicitHelpCommand = enableOrNameAndArgs;
          return this;
        }
        enableOrNameAndArgs = enableOrNameAndArgs ?? "help [command]";
        const [, helpName, helpArgs] = enableOrNameAndArgs.match(/([^ ]+) *(.*)/);
        const helpDescription = description ?? "display help for command";
        const helpCommand = this.createCommand(helpName);
        helpCommand.helpOption(false);
        if (helpArgs) helpCommand.arguments(helpArgs);
        if (helpDescription) helpCommand.description(helpDescription);
        this._addImplicitHelpCommand = true;
        this._helpCommand = helpCommand;
        return this;
      }
      /**
       * Add prepared custom help command.
       *
       * @param {(Command|string|boolean)} helpCommand - custom help command, or deprecated enableOrNameAndArgs as for `.helpCommand()`
       * @param {string} [deprecatedDescription] - deprecated custom description used with custom name only
       * @return {Command} `this` command for chaining
       */
      addHelpCommand(helpCommand, deprecatedDescription) {
        if (typeof helpCommand !== "object") {
          this.helpCommand(helpCommand, deprecatedDescription);
          return this;
        }
        this._addImplicitHelpCommand = true;
        this._helpCommand = helpCommand;
        return this;
      }
      /**
       * Lazy create help command.
       *
       * @return {(Command|null)}
       * @package
       */
      _getHelpCommand() {
        const hasImplicitHelpCommand = this._addImplicitHelpCommand ?? (this.commands.length && !this._actionHandler && !this._findCommand("help"));
        if (hasImplicitHelpCommand) {
          if (this._helpCommand === void 0) {
            this.helpCommand(void 0, void 0);
          }
          return this._helpCommand;
        }
        return null;
      }
      /**
       * Add hook for life cycle event.
       *
       * @param {string} event
       * @param {Function} listener
       * @return {Command} `this` command for chaining
       */
      hook(event, listener) {
        const allowedValues = ["preSubcommand", "preAction", "postAction"];
        if (!allowedValues.includes(event)) {
          throw new Error(`Unexpected value for event passed to hook : '${event}'.
Expecting one of '${allowedValues.join("', '")}'`);
        }
        if (this._lifeCycleHooks[event]) {
          this._lifeCycleHooks[event].push(listener);
        } else {
          this._lifeCycleHooks[event] = [listener];
        }
        return this;
      }
      /**
       * Register callback to use as replacement for calling process.exit.
       *
       * @param {Function} [fn] optional callback which will be passed a CommanderError, defaults to throwing
       * @return {Command} `this` command for chaining
       */
      exitOverride(fn) {
        if (fn) {
          this._exitCallback = fn;
        } else {
          this._exitCallback = (err) => {
            if (err.code !== "commander.executeSubCommandAsync") {
              throw err;
            } else {
            }
          };
        }
        return this;
      }
      /**
       * Call process.exit, and _exitCallback if defined.
       *
       * @param {number} exitCode exit code for using with process.exit
       * @param {string} code an id string representing the error
       * @param {string} message human-readable description of the error
       * @return never
       * @private
       */
      _exit(exitCode, code, message) {
        if (this._exitCallback) {
          this._exitCallback(new CommanderError2(exitCode, code, message));
        }
        process2.exit(exitCode);
      }
      /**
       * Register callback `fn` for the command.
       *
       * @example
       * program
       *   .command('serve')
       *   .description('start service')
       *   .action(function() {
       *      // do work here
       *   });
       *
       * @param {Function} fn
       * @return {Command} `this` command for chaining
       */
      action(fn) {
        const listener = (args) => {
          const expectedArgsCount = this.registeredArguments.length;
          const actionArgs = args.slice(0, expectedArgsCount);
          if (this._storeOptionsAsProperties) {
            actionArgs[expectedArgsCount] = this;
          } else {
            actionArgs[expectedArgsCount] = this.opts();
          }
          actionArgs.push(this);
          return fn.apply(this, actionArgs);
        };
        this._actionHandler = listener;
        return this;
      }
      /**
       * Factory routine to create a new unattached option.
       *
       * See .option() for creating an attached option, which uses this routine to
       * create the option. You can override createOption to return a custom option.
       *
       * @param {string} flags
       * @param {string} [description]
       * @return {Option} new option
       */
      createOption(flags, description) {
        return new Option2(flags, description);
      }
      /**
       * Wrap parseArgs to catch 'commander.invalidArgument'.
       *
       * @param {(Option | Argument)} target
       * @param {string} value
       * @param {*} previous
       * @param {string} invalidArgumentMessage
       * @private
       */
      _callParseArg(target, value, previous, invalidArgumentMessage) {
        try {
          return target.parseArg(value, previous);
        } catch (err) {
          if (err.code === "commander.invalidArgument") {
            const message = `${invalidArgumentMessage} ${err.message}`;
            this.error(message, { exitCode: err.exitCode, code: err.code });
          }
          throw err;
        }
      }
      /**
       * Check for option flag conflicts.
       * Register option if no conflicts found, or throw on conflict.
       *
       * @param {Option} option
       * @private
       */
      _registerOption(option) {
        const matchingOption = option.short && this._findOption(option.short) || option.long && this._findOption(option.long);
        if (matchingOption) {
          const matchingFlag = option.long && this._findOption(option.long) ? option.long : option.short;
          throw new Error(`Cannot add option '${option.flags}'${this._name && ` to command '${this._name}'`} due to conflicting flag '${matchingFlag}'
-  already used by option '${matchingOption.flags}'`);
        }
        this.options.push(option);
      }
      /**
       * Check for command name and alias conflicts with existing commands.
       * Register command if no conflicts found, or throw on conflict.
       *
       * @param {Command} command
       * @private
       */
      _registerCommand(command) {
        const knownBy = (cmd) => {
          return [cmd.name()].concat(cmd.aliases());
        };
        const alreadyUsed = knownBy(command).find(
          (name) => this._findCommand(name)
        );
        if (alreadyUsed) {
          const existingCmd = knownBy(this._findCommand(alreadyUsed)).join("|");
          const newCmd = knownBy(command).join("|");
          throw new Error(
            `cannot add command '${newCmd}' as already have command '${existingCmd}'`
          );
        }
        this.commands.push(command);
      }
      /**
       * Add an option.
       *
       * @param {Option} option
       * @return {Command} `this` command for chaining
       */
      addOption(option) {
        this._registerOption(option);
        const oname = option.name();
        const name = option.attributeName();
        if (option.negate) {
          const positiveLongFlag = option.long.replace(/^--no-/, "--");
          if (!this._findOption(positiveLongFlag)) {
            this.setOptionValueWithSource(
              name,
              option.defaultValue === void 0 ? true : option.defaultValue,
              "default"
            );
          }
        } else if (option.defaultValue !== void 0) {
          this.setOptionValueWithSource(name, option.defaultValue, "default");
        }
        const handleOptionValue = (val, invalidValueMessage, valueSource) => {
          if (val == null && option.presetArg !== void 0) {
            val = option.presetArg;
          }
          const oldValue = this.getOptionValue(name);
          if (val !== null && option.parseArg) {
            val = this._callParseArg(option, val, oldValue, invalidValueMessage);
          } else if (val !== null && option.variadic) {
            val = option._concatValue(val, oldValue);
          }
          if (val == null) {
            if (option.negate) {
              val = false;
            } else if (option.isBoolean() || option.optional) {
              val = true;
            } else {
              val = "";
            }
          }
          this.setOptionValueWithSource(name, val, valueSource);
        };
        this.on("option:" + oname, (val) => {
          const invalidValueMessage = `error: option '${option.flags}' argument '${val}' is invalid.`;
          handleOptionValue(val, invalidValueMessage, "cli");
        });
        if (option.envVar) {
          this.on("optionEnv:" + oname, (val) => {
            const invalidValueMessage = `error: option '${option.flags}' value '${val}' from env '${option.envVar}' is invalid.`;
            handleOptionValue(val, invalidValueMessage, "env");
          });
        }
        return this;
      }
      /**
       * Internal implementation shared by .option() and .requiredOption()
       *
       * @return {Command} `this` command for chaining
       * @private
       */
      _optionEx(config, flags, description, fn, defaultValue) {
        if (typeof flags === "object" && flags instanceof Option2) {
          throw new Error(
            "To add an Option object use addOption() instead of option() or requiredOption()"
          );
        }
        const option = this.createOption(flags, description);
        option.makeOptionMandatory(!!config.mandatory);
        if (typeof fn === "function") {
          option.default(defaultValue).argParser(fn);
        } else if (fn instanceof RegExp) {
          const regex = fn;
          fn = (val, def) => {
            const m = regex.exec(val);
            return m ? m[0] : def;
          };
          option.default(defaultValue).argParser(fn);
        } else {
          option.default(fn);
        }
        return this.addOption(option);
      }
      /**
       * Define option with `flags`, `description`, and optional argument parsing function or `defaultValue` or both.
       *
       * The `flags` string contains the short and/or long flags, separated by comma, a pipe or space. A required
       * option-argument is indicated by `<>` and an optional option-argument by `[]`.
       *
       * See the README for more details, and see also addOption() and requiredOption().
       *
       * @example
       * program
       *     .option('-p, --pepper', 'add pepper')
       *     .option('-p, --pizza-type <TYPE>', 'type of pizza') // required option-argument
       *     .option('-c, --cheese [CHEESE]', 'add extra cheese', 'mozzarella') // optional option-argument with default
       *     .option('-t, --tip <VALUE>', 'add tip to purchase cost', parseFloat) // custom parse function
       *
       * @param {string} flags
       * @param {string} [description]
       * @param {(Function|*)} [parseArg] - custom option processing function or default value
       * @param {*} [defaultValue]
       * @return {Command} `this` command for chaining
       */
      option(flags, description, parseArg, defaultValue) {
        return this._optionEx({}, flags, description, parseArg, defaultValue);
      }
      /**
       * Add a required option which must have a value after parsing. This usually means
       * the option must be specified on the command line. (Otherwise the same as .option().)
       *
       * The `flags` string contains the short and/or long flags, separated by comma, a pipe or space.
       *
       * @param {string} flags
       * @param {string} [description]
       * @param {(Function|*)} [parseArg] - custom option processing function or default value
       * @param {*} [defaultValue]
       * @return {Command} `this` command for chaining
       */
      requiredOption(flags, description, parseArg, defaultValue) {
        return this._optionEx(
          { mandatory: true },
          flags,
          description,
          parseArg,
          defaultValue
        );
      }
      /**
       * Alter parsing of short flags with optional values.
       *
       * @example
       * // for `.option('-f,--flag [value]'):
       * program.combineFlagAndOptionalValue(true);  // `-f80` is treated like `--flag=80`, this is the default behaviour
       * program.combineFlagAndOptionalValue(false) // `-fb` is treated like `-f -b`
       *
       * @param {boolean} [combine] - if `true` or omitted, an optional value can be specified directly after the flag.
       * @return {Command} `this` command for chaining
       */
      combineFlagAndOptionalValue(combine = true) {
        this._combineFlagAndOptionalValue = !!combine;
        return this;
      }
      /**
       * Allow unknown options on the command line.
       *
       * @param {boolean} [allowUnknown] - if `true` or omitted, no error will be thrown for unknown options.
       * @return {Command} `this` command for chaining
       */
      allowUnknownOption(allowUnknown = true) {
        this._allowUnknownOption = !!allowUnknown;
        return this;
      }
      /**
       * Allow excess command-arguments on the command line. Pass false to make excess arguments an error.
       *
       * @param {boolean} [allowExcess] - if `true` or omitted, no error will be thrown for excess arguments.
       * @return {Command} `this` command for chaining
       */
      allowExcessArguments(allowExcess = true) {
        this._allowExcessArguments = !!allowExcess;
        return this;
      }
      /**
       * Enable positional options. Positional means global options are specified before subcommands which lets
       * subcommands reuse the same option names, and also enables subcommands to turn on passThroughOptions.
       * The default behaviour is non-positional and global options may appear anywhere on the command line.
       *
       * @param {boolean} [positional]
       * @return {Command} `this` command for chaining
       */
      enablePositionalOptions(positional = true) {
        this._enablePositionalOptions = !!positional;
        return this;
      }
      /**
       * Pass through options that come after command-arguments rather than treat them as command-options,
       * so actual command-options come before command-arguments. Turning this on for a subcommand requires
       * positional options to have been enabled on the program (parent commands).
       * The default behaviour is non-positional and options may appear before or after command-arguments.
       *
       * @param {boolean} [passThrough] for unknown options.
       * @return {Command} `this` command for chaining
       */
      passThroughOptions(passThrough = true) {
        this._passThroughOptions = !!passThrough;
        this._checkForBrokenPassThrough();
        return this;
      }
      /**
       * @private
       */
      _checkForBrokenPassThrough() {
        if (this.parent && this._passThroughOptions && !this.parent._enablePositionalOptions) {
          throw new Error(
            `passThroughOptions cannot be used for '${this._name}' without turning on enablePositionalOptions for parent command(s)`
          );
        }
      }
      /**
       * Whether to store option values as properties on command object,
       * or store separately (specify false). In both cases the option values can be accessed using .opts().
       *
       * @param {boolean} [storeAsProperties=true]
       * @return {Command} `this` command for chaining
       */
      storeOptionsAsProperties(storeAsProperties = true) {
        if (this.options.length) {
          throw new Error("call .storeOptionsAsProperties() before adding options");
        }
        if (Object.keys(this._optionValues).length) {
          throw new Error(
            "call .storeOptionsAsProperties() before setting option values"
          );
        }
        this._storeOptionsAsProperties = !!storeAsProperties;
        return this;
      }
      /**
       * Retrieve option value.
       *
       * @param {string} key
       * @return {object} value
       */
      getOptionValue(key) {
        if (this._storeOptionsAsProperties) {
          return this[key];
        }
        return this._optionValues[key];
      }
      /**
       * Store option value.
       *
       * @param {string} key
       * @param {object} value
       * @return {Command} `this` command for chaining
       */
      setOptionValue(key, value) {
        return this.setOptionValueWithSource(key, value, void 0);
      }
      /**
       * Store option value and where the value came from.
       *
       * @param {string} key
       * @param {object} value
       * @param {string} source - expected values are default/config/env/cli/implied
       * @return {Command} `this` command for chaining
       */
      setOptionValueWithSource(key, value, source) {
        if (this._storeOptionsAsProperties) {
          this[key] = value;
        } else {
          this._optionValues[key] = value;
        }
        this._optionValueSources[key] = source;
        return this;
      }
      /**
       * Get source of option value.
       * Expected values are default | config | env | cli | implied
       *
       * @param {string} key
       * @return {string}
       */
      getOptionValueSource(key) {
        return this._optionValueSources[key];
      }
      /**
       * Get source of option value. See also .optsWithGlobals().
       * Expected values are default | config | env | cli | implied
       *
       * @param {string} key
       * @return {string}
       */
      getOptionValueSourceWithGlobals(key) {
        let source;
        this._getCommandAndAncestors().forEach((cmd) => {
          if (cmd.getOptionValueSource(key) !== void 0) {
            source = cmd.getOptionValueSource(key);
          }
        });
        return source;
      }
      /**
       * Get user arguments from implied or explicit arguments.
       * Side-effects: set _scriptPath if args included script. Used for default program name, and subcommand searches.
       *
       * @private
       */
      _prepareUserArgs(argv, parseOptions) {
        if (argv !== void 0 && !Array.isArray(argv)) {
          throw new Error("first parameter to parse must be array or undefined");
        }
        parseOptions = parseOptions || {};
        if (argv === void 0 && parseOptions.from === void 0) {
          if (process2.versions?.electron) {
            parseOptions.from = "electron";
          }
          const execArgv = process2.execArgv ?? [];
          if (execArgv.includes("-e") || execArgv.includes("--eval") || execArgv.includes("-p") || execArgv.includes("--print")) {
            parseOptions.from = "eval";
          }
        }
        if (argv === void 0) {
          argv = process2.argv;
        }
        this.rawArgs = argv.slice();
        let userArgs;
        switch (parseOptions.from) {
          case void 0:
          case "node":
            this._scriptPath = argv[1];
            userArgs = argv.slice(2);
            break;
          case "electron":
            if (process2.defaultApp) {
              this._scriptPath = argv[1];
              userArgs = argv.slice(2);
            } else {
              userArgs = argv.slice(1);
            }
            break;
          case "user":
            userArgs = argv.slice(0);
            break;
          case "eval":
            userArgs = argv.slice(1);
            break;
          default:
            throw new Error(
              `unexpected parse option { from: '${parseOptions.from}' }`
            );
        }
        if (!this._name && this._scriptPath)
          this.nameFromFilename(this._scriptPath);
        this._name = this._name || "program";
        return userArgs;
      }
      /**
       * Parse `argv`, setting options and invoking commands when defined.
       *
       * Use parseAsync instead of parse if any of your action handlers are async.
       *
       * Call with no parameters to parse `process.argv`. Detects Electron and special node options like `node --eval`. Easy mode!
       *
       * Or call with an array of strings to parse, and optionally where the user arguments start by specifying where the arguments are `from`:
       * - `'node'`: default, `argv[0]` is the application and `argv[1]` is the script being run, with user arguments after that
       * - `'electron'`: `argv[0]` is the application and `argv[1]` varies depending on whether the electron application is packaged
       * - `'user'`: just user arguments
       *
       * @example
       * program.parse(); // parse process.argv and auto-detect electron and special node flags
       * program.parse(process.argv); // assume argv[0] is app and argv[1] is script
       * program.parse(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]
       *
       * @param {string[]} [argv] - optional, defaults to process.argv
       * @param {object} [parseOptions] - optionally specify style of options with from: node/user/electron
       * @param {string} [parseOptions.from] - where the args are from: 'node', 'user', 'electron'
       * @return {Command} `this` command for chaining
       */
      parse(argv, parseOptions) {
        const userArgs = this._prepareUserArgs(argv, parseOptions);
        this._parseCommand([], userArgs);
        return this;
      }
      /**
       * Parse `argv`, setting options and invoking commands when defined.
       *
       * Call with no parameters to parse `process.argv`. Detects Electron and special node options like `node --eval`. Easy mode!
       *
       * Or call with an array of strings to parse, and optionally where the user arguments start by specifying where the arguments are `from`:
       * - `'node'`: default, `argv[0]` is the application and `argv[1]` is the script being run, with user arguments after that
       * - `'electron'`: `argv[0]` is the application and `argv[1]` varies depending on whether the electron application is packaged
       * - `'user'`: just user arguments
       *
       * @example
       * await program.parseAsync(); // parse process.argv and auto-detect electron and special node flags
       * await program.parseAsync(process.argv); // assume argv[0] is app and argv[1] is script
       * await program.parseAsync(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]
       *
       * @param {string[]} [argv]
       * @param {object} [parseOptions]
       * @param {string} parseOptions.from - where the args are from: 'node', 'user', 'electron'
       * @return {Promise}
       */
      async parseAsync(argv, parseOptions) {
        const userArgs = this._prepareUserArgs(argv, parseOptions);
        await this._parseCommand([], userArgs);
        return this;
      }
      /**
       * Execute a sub-command executable.
       *
       * @private
       */
      _executeSubCommand(subcommand, args) {
        args = args.slice();
        let launchWithNode = false;
        const sourceExt = [".js", ".ts", ".tsx", ".mjs", ".cjs"];
        function findFile(baseDir, baseName) {
          const localBin = path2.resolve(baseDir, baseName);
          if (fs2.existsSync(localBin)) return localBin;
          if (sourceExt.includes(path2.extname(baseName))) return void 0;
          const foundExt = sourceExt.find(
            (ext) => fs2.existsSync(`${localBin}${ext}`)
          );
          if (foundExt) return `${localBin}${foundExt}`;
          return void 0;
        }
        this._checkForMissingMandatoryOptions();
        this._checkForConflictingOptions();
        let executableFile = subcommand._executableFile || `${this._name}-${subcommand._name}`;
        let executableDir = this._executableDir || "";
        if (this._scriptPath) {
          let resolvedScriptPath;
          try {
            resolvedScriptPath = fs2.realpathSync(this._scriptPath);
          } catch (err) {
            resolvedScriptPath = this._scriptPath;
          }
          executableDir = path2.resolve(
            path2.dirname(resolvedScriptPath),
            executableDir
          );
        }
        if (executableDir) {
          let localFile = findFile(executableDir, executableFile);
          if (!localFile && !subcommand._executableFile && this._scriptPath) {
            const legacyName = path2.basename(
              this._scriptPath,
              path2.extname(this._scriptPath)
            );
            if (legacyName !== this._name) {
              localFile = findFile(
                executableDir,
                `${legacyName}-${subcommand._name}`
              );
            }
          }
          executableFile = localFile || executableFile;
        }
        launchWithNode = sourceExt.includes(path2.extname(executableFile));
        let proc;
        if (process2.platform !== "win32") {
          if (launchWithNode) {
            args.unshift(executableFile);
            args = incrementNodeInspectorPort(process2.execArgv).concat(args);
            proc = childProcess.spawn(process2.argv[0], args, { stdio: "inherit" });
          } else {
            proc = childProcess.spawn(executableFile, args, { stdio: "inherit" });
          }
        } else {
          args.unshift(executableFile);
          args = incrementNodeInspectorPort(process2.execArgv).concat(args);
          proc = childProcess.spawn(process2.execPath, args, { stdio: "inherit" });
        }
        if (!proc.killed) {
          const signals = ["SIGUSR1", "SIGUSR2", "SIGTERM", "SIGINT", "SIGHUP"];
          signals.forEach((signal) => {
            process2.on(signal, () => {
              if (proc.killed === false && proc.exitCode === null) {
                proc.kill(signal);
              }
            });
          });
        }
        const exitCallback = this._exitCallback;
        proc.on("close", (code) => {
          code = code ?? 1;
          if (!exitCallback) {
            process2.exit(code);
          } else {
            exitCallback(
              new CommanderError2(
                code,
                "commander.executeSubCommandAsync",
                "(close)"
              )
            );
          }
        });
        proc.on("error", (err) => {
          if (err.code === "ENOENT") {
            const executableDirMessage = executableDir ? `searched for local subcommand relative to directory '${executableDir}'` : "no directory for search for local subcommand, use .executableDir() to supply a custom directory";
            const executableMissing = `'${executableFile}' does not exist
 - if '${subcommand._name}' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead
 - if the default executable name is not suitable, use the executableFile option to supply a custom name or path
 - ${executableDirMessage}`;
            throw new Error(executableMissing);
          } else if (err.code === "EACCES") {
            throw new Error(`'${executableFile}' not executable`);
          }
          if (!exitCallback) {
            process2.exit(1);
          } else {
            const wrappedError = new CommanderError2(
              1,
              "commander.executeSubCommandAsync",
              "(error)"
            );
            wrappedError.nestedError = err;
            exitCallback(wrappedError);
          }
        });
        this.runningCommand = proc;
      }
      /**
       * @private
       */
      _dispatchSubcommand(commandName, operands, unknown) {
        const subCommand = this._findCommand(commandName);
        if (!subCommand) this.help({ error: true });
        let promiseChain;
        promiseChain = this._chainOrCallSubCommandHook(
          promiseChain,
          subCommand,
          "preSubcommand"
        );
        promiseChain = this._chainOrCall(promiseChain, () => {
          if (subCommand._executableHandler) {
            this._executeSubCommand(subCommand, operands.concat(unknown));
          } else {
            return subCommand._parseCommand(operands, unknown);
          }
        });
        return promiseChain;
      }
      /**
       * Invoke help directly if possible, or dispatch if necessary.
       * e.g. help foo
       *
       * @private
       */
      _dispatchHelpCommand(subcommandName) {
        if (!subcommandName) {
          this.help();
        }
        const subCommand = this._findCommand(subcommandName);
        if (subCommand && !subCommand._executableHandler) {
          subCommand.help();
        }
        return this._dispatchSubcommand(
          subcommandName,
          [],
          [this._getHelpOption()?.long ?? this._getHelpOption()?.short ?? "--help"]
        );
      }
      /**
       * Check this.args against expected this.registeredArguments.
       *
       * @private
       */
      _checkNumberOfArguments() {
        this.registeredArguments.forEach((arg, i) => {
          if (arg.required && this.args[i] == null) {
            this.missingArgument(arg.name());
          }
        });
        if (this.registeredArguments.length > 0 && this.registeredArguments[this.registeredArguments.length - 1].variadic) {
          return;
        }
        if (this.args.length > this.registeredArguments.length) {
          this._excessArguments(this.args);
        }
      }
      /**
       * Process this.args using this.registeredArguments and save as this.processedArgs!
       *
       * @private
       */
      _processArguments() {
        const myParseArg = (argument, value, previous) => {
          let parsedValue = value;
          if (value !== null && argument.parseArg) {
            const invalidValueMessage = `error: command-argument value '${value}' is invalid for argument '${argument.name()}'.`;
            parsedValue = this._callParseArg(
              argument,
              value,
              previous,
              invalidValueMessage
            );
          }
          return parsedValue;
        };
        this._checkNumberOfArguments();
        const processedArgs = [];
        this.registeredArguments.forEach((declaredArg, index) => {
          let value = declaredArg.defaultValue;
          if (declaredArg.variadic) {
            if (index < this.args.length) {
              value = this.args.slice(index);
              if (declaredArg.parseArg) {
                value = value.reduce((processed, v) => {
                  return myParseArg(declaredArg, v, processed);
                }, declaredArg.defaultValue);
              }
            } else if (value === void 0) {
              value = [];
            }
          } else if (index < this.args.length) {
            value = this.args[index];
            if (declaredArg.parseArg) {
              value = myParseArg(declaredArg, value, declaredArg.defaultValue);
            }
          }
          processedArgs[index] = value;
        });
        this.processedArgs = processedArgs;
      }
      /**
       * Once we have a promise we chain, but call synchronously until then.
       *
       * @param {(Promise|undefined)} promise
       * @param {Function} fn
       * @return {(Promise|undefined)}
       * @private
       */
      _chainOrCall(promise2, fn) {
        if (promise2 && promise2.then && typeof promise2.then === "function") {
          return promise2.then(() => fn());
        }
        return fn();
      }
      /**
       *
       * @param {(Promise|undefined)} promise
       * @param {string} event
       * @return {(Promise|undefined)}
       * @private
       */
      _chainOrCallHooks(promise2, event) {
        let result = promise2;
        const hooks = [];
        this._getCommandAndAncestors().reverse().filter((cmd) => cmd._lifeCycleHooks[event] !== void 0).forEach((hookedCommand) => {
          hookedCommand._lifeCycleHooks[event].forEach((callback2) => {
            hooks.push({ hookedCommand, callback: callback2 });
          });
        });
        if (event === "postAction") {
          hooks.reverse();
        }
        hooks.forEach((hookDetail) => {
          result = this._chainOrCall(result, () => {
            return hookDetail.callback(hookDetail.hookedCommand, this);
          });
        });
        return result;
      }
      /**
       *
       * @param {(Promise|undefined)} promise
       * @param {Command} subCommand
       * @param {string} event
       * @return {(Promise|undefined)}
       * @private
       */
      _chainOrCallSubCommandHook(promise2, subCommand, event) {
        let result = promise2;
        if (this._lifeCycleHooks[event] !== void 0) {
          this._lifeCycleHooks[event].forEach((hook) => {
            result = this._chainOrCall(result, () => {
              return hook(this, subCommand);
            });
          });
        }
        return result;
      }
      /**
       * Process arguments in context of this command.
       * Returns action result, in case it is a promise.
       *
       * @private
       */
      _parseCommand(operands, unknown) {
        const parsed = this.parseOptions(unknown);
        this._parseOptionsEnv();
        this._parseOptionsImplied();
        operands = operands.concat(parsed.operands);
        unknown = parsed.unknown;
        this.args = operands.concat(unknown);
        if (operands && this._findCommand(operands[0])) {
          return this._dispatchSubcommand(operands[0], operands.slice(1), unknown);
        }
        if (this._getHelpCommand() && operands[0] === this._getHelpCommand().name()) {
          return this._dispatchHelpCommand(operands[1]);
        }
        if (this._defaultCommandName) {
          this._outputHelpIfRequested(unknown);
          return this._dispatchSubcommand(
            this._defaultCommandName,
            operands,
            unknown
          );
        }
        if (this.commands.length && this.args.length === 0 && !this._actionHandler && !this._defaultCommandName) {
          this.help({ error: true });
        }
        this._outputHelpIfRequested(parsed.unknown);
        this._checkForMissingMandatoryOptions();
        this._checkForConflictingOptions();
        const checkForUnknownOptions = () => {
          if (parsed.unknown.length > 0) {
            this.unknownOption(parsed.unknown[0]);
          }
        };
        const commandEvent = `command:${this.name()}`;
        if (this._actionHandler) {
          checkForUnknownOptions();
          this._processArguments();
          let promiseChain;
          promiseChain = this._chainOrCallHooks(promiseChain, "preAction");
          promiseChain = this._chainOrCall(
            promiseChain,
            () => this._actionHandler(this.processedArgs)
          );
          if (this.parent) {
            promiseChain = this._chainOrCall(promiseChain, () => {
              this.parent.emit(commandEvent, operands, unknown);
            });
          }
          promiseChain = this._chainOrCallHooks(promiseChain, "postAction");
          return promiseChain;
        }
        if (this.parent && this.parent.listenerCount(commandEvent)) {
          checkForUnknownOptions();
          this._processArguments();
          this.parent.emit(commandEvent, operands, unknown);
        } else if (operands.length) {
          if (this._findCommand("*")) {
            return this._dispatchSubcommand("*", operands, unknown);
          }
          if (this.listenerCount("command:*")) {
            this.emit("command:*", operands, unknown);
          } else if (this.commands.length) {
            this.unknownCommand();
          } else {
            checkForUnknownOptions();
            this._processArguments();
          }
        } else if (this.commands.length) {
          checkForUnknownOptions();
          this.help({ error: true });
        } else {
          checkForUnknownOptions();
          this._processArguments();
        }
      }
      /**
       * Find matching command.
       *
       * @private
       * @return {Command | undefined}
       */
      _findCommand(name) {
        if (!name) return void 0;
        return this.commands.find(
          (cmd) => cmd._name === name || cmd._aliases.includes(name)
        );
      }
      /**
       * Return an option matching `arg` if any.
       *
       * @param {string} arg
       * @return {Option}
       * @package
       */
      _findOption(arg) {
        return this.options.find((option) => option.is(arg));
      }
      /**
       * Display an error message if a mandatory option does not have a value.
       * Called after checking for help flags in leaf subcommand.
       *
       * @private
       */
      _checkForMissingMandatoryOptions() {
        this._getCommandAndAncestors().forEach((cmd) => {
          cmd.options.forEach((anOption) => {
            if (anOption.mandatory && cmd.getOptionValue(anOption.attributeName()) === void 0) {
              cmd.missingMandatoryOptionValue(anOption);
            }
          });
        });
      }
      /**
       * Display an error message if conflicting options are used together in this.
       *
       * @private
       */
      _checkForConflictingLocalOptions() {
        const definedNonDefaultOptions = this.options.filter((option) => {
          const optionKey = option.attributeName();
          if (this.getOptionValue(optionKey) === void 0) {
            return false;
          }
          return this.getOptionValueSource(optionKey) !== "default";
        });
        const optionsWithConflicting = definedNonDefaultOptions.filter(
          (option) => option.conflictsWith.length > 0
        );
        optionsWithConflicting.forEach((option) => {
          const conflictingAndDefined = definedNonDefaultOptions.find(
            (defined) => option.conflictsWith.includes(defined.attributeName())
          );
          if (conflictingAndDefined) {
            this._conflictingOption(option, conflictingAndDefined);
          }
        });
      }
      /**
       * Display an error message if conflicting options are used together.
       * Called after checking for help flags in leaf subcommand.
       *
       * @private
       */
      _checkForConflictingOptions() {
        this._getCommandAndAncestors().forEach((cmd) => {
          cmd._checkForConflictingLocalOptions();
        });
      }
      /**
       * Parse options from `argv` removing known options,
       * and return argv split into operands and unknown arguments.
       *
       * Examples:
       *
       *     argv => operands, unknown
       *     --known kkk op => [op], []
       *     op --known kkk => [op], []
       *     sub --unknown uuu op => [sub], [--unknown uuu op]
       *     sub -- --unknown uuu op => [sub --unknown uuu op], []
       *
       * @param {string[]} argv
       * @return {{operands: string[], unknown: string[]}}
       */
      parseOptions(argv) {
        const operands = [];
        const unknown = [];
        let dest = operands;
        const args = argv.slice();
        function maybeOption(arg) {
          return arg.length > 1 && arg[0] === "-";
        }
        let activeVariadicOption = null;
        while (args.length) {
          const arg = args.shift();
          if (arg === "--") {
            if (dest === unknown) dest.push(arg);
            dest.push(...args);
            break;
          }
          if (activeVariadicOption && !maybeOption(arg)) {
            this.emit(`option:${activeVariadicOption.name()}`, arg);
            continue;
          }
          activeVariadicOption = null;
          if (maybeOption(arg)) {
            const option = this._findOption(arg);
            if (option) {
              if (option.required) {
                const value = args.shift();
                if (value === void 0) this.optionMissingArgument(option);
                this.emit(`option:${option.name()}`, value);
              } else if (option.optional) {
                let value = null;
                if (args.length > 0 && !maybeOption(args[0])) {
                  value = args.shift();
                }
                this.emit(`option:${option.name()}`, value);
              } else {
                this.emit(`option:${option.name()}`);
              }
              activeVariadicOption = option.variadic ? option : null;
              continue;
            }
          }
          if (arg.length > 2 && arg[0] === "-" && arg[1] !== "-") {
            const option = this._findOption(`-${arg[1]}`);
            if (option) {
              if (option.required || option.optional && this._combineFlagAndOptionalValue) {
                this.emit(`option:${option.name()}`, arg.slice(2));
              } else {
                this.emit(`option:${option.name()}`);
                args.unshift(`-${arg.slice(2)}`);
              }
              continue;
            }
          }
          if (/^--[^=]+=/.test(arg)) {
            const index = arg.indexOf("=");
            const option = this._findOption(arg.slice(0, index));
            if (option && (option.required || option.optional)) {
              this.emit(`option:${option.name()}`, arg.slice(index + 1));
              continue;
            }
          }
          if (maybeOption(arg)) {
            dest = unknown;
          }
          if ((this._enablePositionalOptions || this._passThroughOptions) && operands.length === 0 && unknown.length === 0) {
            if (this._findCommand(arg)) {
              operands.push(arg);
              if (args.length > 0) unknown.push(...args);
              break;
            } else if (this._getHelpCommand() && arg === this._getHelpCommand().name()) {
              operands.push(arg);
              if (args.length > 0) operands.push(...args);
              break;
            } else if (this._defaultCommandName) {
              unknown.push(arg);
              if (args.length > 0) unknown.push(...args);
              break;
            }
          }
          if (this._passThroughOptions) {
            dest.push(arg);
            if (args.length > 0) dest.push(...args);
            break;
          }
          dest.push(arg);
        }
        return { operands, unknown };
      }
      /**
       * Return an object containing local option values as key-value pairs.
       *
       * @return {object}
       */
      opts() {
        if (this._storeOptionsAsProperties) {
          const result = {};
          const len = this.options.length;
          for (let i = 0; i < len; i++) {
            const key = this.options[i].attributeName();
            result[key] = key === this._versionOptionName ? this._version : this[key];
          }
          return result;
        }
        return this._optionValues;
      }
      /**
       * Return an object containing merged local and global option values as key-value pairs.
       *
       * @return {object}
       */
      optsWithGlobals() {
        return this._getCommandAndAncestors().reduce(
          (combinedOptions, cmd) => Object.assign(combinedOptions, cmd.opts()),
          {}
        );
      }
      /**
       * Display error message and exit (or call exitOverride).
       *
       * @param {string} message
       * @param {object} [errorOptions]
       * @param {string} [errorOptions.code] - an id string representing the error
       * @param {number} [errorOptions.exitCode] - used with process.exit
       */
      error(message, errorOptions) {
        this._outputConfiguration.outputError(
          `${message}
`,
          this._outputConfiguration.writeErr
        );
        if (typeof this._showHelpAfterError === "string") {
          this._outputConfiguration.writeErr(`${this._showHelpAfterError}
`);
        } else if (this._showHelpAfterError) {
          this._outputConfiguration.writeErr("\n");
          this.outputHelp({ error: true });
        }
        const config = errorOptions || {};
        const exitCode = config.exitCode || 1;
        const code = config.code || "commander.error";
        this._exit(exitCode, code, message);
      }
      /**
       * Apply any option related environment variables, if option does
       * not have a value from cli or client code.
       *
       * @private
       */
      _parseOptionsEnv() {
        this.options.forEach((option) => {
          if (option.envVar && option.envVar in process2.env) {
            const optionKey = option.attributeName();
            if (this.getOptionValue(optionKey) === void 0 || ["default", "config", "env"].includes(
              this.getOptionValueSource(optionKey)
            )) {
              if (option.required || option.optional) {
                this.emit(`optionEnv:${option.name()}`, process2.env[option.envVar]);
              } else {
                this.emit(`optionEnv:${option.name()}`);
              }
            }
          }
        });
      }
      /**
       * Apply any implied option values, if option is undefined or default value.
       *
       * @private
       */
      _parseOptionsImplied() {
        const dualHelper = new DualOptions(this.options);
        const hasCustomOptionValue = (optionKey) => {
          return this.getOptionValue(optionKey) !== void 0 && !["default", "implied"].includes(this.getOptionValueSource(optionKey));
        };
        this.options.filter(
          (option) => option.implied !== void 0 && hasCustomOptionValue(option.attributeName()) && dualHelper.valueFromOption(
            this.getOptionValue(option.attributeName()),
            option
          )
        ).forEach((option) => {
          Object.keys(option.implied).filter((impliedKey) => !hasCustomOptionValue(impliedKey)).forEach((impliedKey) => {
            this.setOptionValueWithSource(
              impliedKey,
              option.implied[impliedKey],
              "implied"
            );
          });
        });
      }
      /**
       * Argument `name` is missing.
       *
       * @param {string} name
       * @private
       */
      missingArgument(name) {
        const message = `error: missing required argument '${name}'`;
        this.error(message, { code: "commander.missingArgument" });
      }
      /**
       * `Option` is missing an argument.
       *
       * @param {Option} option
       * @private
       */
      optionMissingArgument(option) {
        const message = `error: option '${option.flags}' argument missing`;
        this.error(message, { code: "commander.optionMissingArgument" });
      }
      /**
       * `Option` does not have a value, and is a mandatory option.
       *
       * @param {Option} option
       * @private
       */
      missingMandatoryOptionValue(option) {
        const message = `error: required option '${option.flags}' not specified`;
        this.error(message, { code: "commander.missingMandatoryOptionValue" });
      }
      /**
       * `Option` conflicts with another option.
       *
       * @param {Option} option
       * @param {Option} conflictingOption
       * @private
       */
      _conflictingOption(option, conflictingOption) {
        const findBestOptionFromValue = (option2) => {
          const optionKey = option2.attributeName();
          const optionValue = this.getOptionValue(optionKey);
          const negativeOption = this.options.find(
            (target) => target.negate && optionKey === target.attributeName()
          );
          const positiveOption = this.options.find(
            (target) => !target.negate && optionKey === target.attributeName()
          );
          if (negativeOption && (negativeOption.presetArg === void 0 && optionValue === false || negativeOption.presetArg !== void 0 && optionValue === negativeOption.presetArg)) {
            return negativeOption;
          }
          return positiveOption || option2;
        };
        const getErrorMessage = (option2) => {
          const bestOption = findBestOptionFromValue(option2);
          const optionKey = bestOption.attributeName();
          const source = this.getOptionValueSource(optionKey);
          if (source === "env") {
            return `environment variable '${bestOption.envVar}'`;
          }
          return `option '${bestOption.flags}'`;
        };
        const message = `error: ${getErrorMessage(option)} cannot be used with ${getErrorMessage(conflictingOption)}`;
        this.error(message, { code: "commander.conflictingOption" });
      }
      /**
       * Unknown option `flag`.
       *
       * @param {string} flag
       * @private
       */
      unknownOption(flag) {
        if (this._allowUnknownOption) return;
        let suggestion = "";
        if (flag.startsWith("--") && this._showSuggestionAfterError) {
          let candidateFlags = [];
          let command = this;
          do {
            const moreFlags = command.createHelp().visibleOptions(command).filter((option) => option.long).map((option) => option.long);
            candidateFlags = candidateFlags.concat(moreFlags);
            command = command.parent;
          } while (command && !command._enablePositionalOptions);
          suggestion = suggestSimilar(flag, candidateFlags);
        }
        const message = `error: unknown option '${flag}'${suggestion}`;
        this.error(message, { code: "commander.unknownOption" });
      }
      /**
       * Excess arguments, more than expected.
       *
       * @param {string[]} receivedArgs
       * @private
       */
      _excessArguments(receivedArgs) {
        if (this._allowExcessArguments) return;
        const expected = this.registeredArguments.length;
        const s = expected === 1 ? "" : "s";
        const forSubcommand = this.parent ? ` for '${this.name()}'` : "";
        const message = `error: too many arguments${forSubcommand}. Expected ${expected} argument${s} but got ${receivedArgs.length}.`;
        this.error(message, { code: "commander.excessArguments" });
      }
      /**
       * Unknown command.
       *
       * @private
       */
      unknownCommand() {
        const unknownName = this.args[0];
        let suggestion = "";
        if (this._showSuggestionAfterError) {
          const candidateNames = [];
          this.createHelp().visibleCommands(this).forEach((command) => {
            candidateNames.push(command.name());
            if (command.alias()) candidateNames.push(command.alias());
          });
          suggestion = suggestSimilar(unknownName, candidateNames);
        }
        const message = `error: unknown command '${unknownName}'${suggestion}`;
        this.error(message, { code: "commander.unknownCommand" });
      }
      /**
       * Get or set the program version.
       *
       * This method auto-registers the "-V, --version" option which will print the version number.
       *
       * You can optionally supply the flags and description to override the defaults.
       *
       * @param {string} [str]
       * @param {string} [flags]
       * @param {string} [description]
       * @return {(this | string | undefined)} `this` command for chaining, or version string if no arguments
       */
      version(str, flags, description) {
        if (str === void 0) return this._version;
        this._version = str;
        flags = flags || "-V, --version";
        description = description || "output the version number";
        const versionOption = this.createOption(flags, description);
        this._versionOptionName = versionOption.attributeName();
        this._registerOption(versionOption);
        this.on("option:" + versionOption.name(), () => {
          this._outputConfiguration.writeOut(`${str}
`);
          this._exit(0, "commander.version", str);
        });
        return this;
      }
      /**
       * Set the description.
       *
       * @param {string} [str]
       * @param {object} [argsDescription]
       * @return {(string|Command)}
       */
      description(str, argsDescription) {
        if (str === void 0 && argsDescription === void 0)
          return this._description;
        this._description = str;
        if (argsDescription) {
          this._argsDescription = argsDescription;
        }
        return this;
      }
      /**
       * Set the summary. Used when listed as subcommand of parent.
       *
       * @param {string} [str]
       * @return {(string|Command)}
       */
      summary(str) {
        if (str === void 0) return this._summary;
        this._summary = str;
        return this;
      }
      /**
       * Set an alias for the command.
       *
       * You may call more than once to add multiple aliases. Only the first alias is shown in the auto-generated help.
       *
       * @param {string} [alias]
       * @return {(string|Command)}
       */
      alias(alias) {
        if (alias === void 0) return this._aliases[0];
        let command = this;
        if (this.commands.length !== 0 && this.commands[this.commands.length - 1]._executableHandler) {
          command = this.commands[this.commands.length - 1];
        }
        if (alias === command._name)
          throw new Error("Command alias can't be the same as its name");
        const matchingCommand = this.parent?._findCommand(alias);
        if (matchingCommand) {
          const existingCmd = [matchingCommand.name()].concat(matchingCommand.aliases()).join("|");
          throw new Error(
            `cannot add alias '${alias}' to command '${this.name()}' as already have command '${existingCmd}'`
          );
        }
        command._aliases.push(alias);
        return this;
      }
      /**
       * Set aliases for the command.
       *
       * Only the first alias is shown in the auto-generated help.
       *
       * @param {string[]} [aliases]
       * @return {(string[]|Command)}
       */
      aliases(aliases) {
        if (aliases === void 0) return this._aliases;
        aliases.forEach((alias) => this.alias(alias));
        return this;
      }
      /**
       * Set / get the command usage `str`.
       *
       * @param {string} [str]
       * @return {(string|Command)}
       */
      usage(str) {
        if (str === void 0) {
          if (this._usage) return this._usage;
          const args = this.registeredArguments.map((arg) => {
            return humanReadableArgName(arg);
          });
          return [].concat(
            this.options.length || this._helpOption !== null ? "[options]" : [],
            this.commands.length ? "[command]" : [],
            this.registeredArguments.length ? args : []
          ).join(" ");
        }
        this._usage = str;
        return this;
      }
      /**
       * Get or set the name of the command.
       *
       * @param {string} [str]
       * @return {(string|Command)}
       */
      name(str) {
        if (str === void 0) return this._name;
        this._name = str;
        return this;
      }
      /**
       * Set the name of the command from script filename, such as process.argv[1],
       * or require.main.filename, or __filename.
       *
       * (Used internally and public although not documented in README.)
       *
       * @example
       * program.nameFromFilename(require.main.filename);
       *
       * @param {string} filename
       * @return {Command}
       */
      nameFromFilename(filename) {
        this._name = path2.basename(filename, path2.extname(filename));
        return this;
      }
      /**
       * Get or set the directory for searching for executable subcommands of this command.
       *
       * @example
       * program.executableDir(__dirname);
       * // or
       * program.executableDir('subcommands');
       *
       * @param {string} [path]
       * @return {(string|null|Command)}
       */
      executableDir(path3) {
        if (path3 === void 0) return this._executableDir;
        this._executableDir = path3;
        return this;
      }
      /**
       * Return program help documentation.
       *
       * @param {{ error: boolean }} [contextOptions] - pass {error:true} to wrap for stderr instead of stdout
       * @return {string}
       */
      helpInformation(contextOptions) {
        const helper = this.createHelp();
        if (helper.helpWidth === void 0) {
          helper.helpWidth = contextOptions && contextOptions.error ? this._outputConfiguration.getErrHelpWidth() : this._outputConfiguration.getOutHelpWidth();
        }
        return helper.formatHelp(this, helper);
      }
      /**
       * @private
       */
      _getHelpContext(contextOptions) {
        contextOptions = contextOptions || {};
        const context = { error: !!contextOptions.error };
        let write;
        if (context.error) {
          write = (arg) => this._outputConfiguration.writeErr(arg);
        } else {
          write = (arg) => this._outputConfiguration.writeOut(arg);
        }
        context.write = contextOptions.write || write;
        context.command = this;
        return context;
      }
      /**
       * Output help information for this command.
       *
       * Outputs built-in help, and custom text added using `.addHelpText()`.
       *
       * @param {{ error: boolean } | Function} [contextOptions] - pass {error:true} to write to stderr instead of stdout
       */
      outputHelp(contextOptions) {
        let deprecatedCallback;
        if (typeof contextOptions === "function") {
          deprecatedCallback = contextOptions;
          contextOptions = void 0;
        }
        const context = this._getHelpContext(contextOptions);
        this._getCommandAndAncestors().reverse().forEach((command) => command.emit("beforeAllHelp", context));
        this.emit("beforeHelp", context);
        let helpInformation = this.helpInformation(context);
        if (deprecatedCallback) {
          helpInformation = deprecatedCallback(helpInformation);
          if (typeof helpInformation !== "string" && !Buffer.isBuffer(helpInformation)) {
            throw new Error("outputHelp callback must return a string or a Buffer");
          }
        }
        context.write(helpInformation);
        if (this._getHelpOption()?.long) {
          this.emit(this._getHelpOption().long);
        }
        this.emit("afterHelp", context);
        this._getCommandAndAncestors().forEach(
          (command) => command.emit("afterAllHelp", context)
        );
      }
      /**
       * You can pass in flags and a description to customise the built-in help option.
       * Pass in false to disable the built-in help option.
       *
       * @example
       * program.helpOption('-?, --help' 'show help'); // customise
       * program.helpOption(false); // disable
       *
       * @param {(string | boolean)} flags
       * @param {string} [description]
       * @return {Command} `this` command for chaining
       */
      helpOption(flags, description) {
        if (typeof flags === "boolean") {
          if (flags) {
            this._helpOption = this._helpOption ?? void 0;
          } else {
            this._helpOption = null;
          }
          return this;
        }
        flags = flags ?? "-h, --help";
        description = description ?? "display help for command";
        this._helpOption = this.createOption(flags, description);
        return this;
      }
      /**
       * Lazy create help option.
       * Returns null if has been disabled with .helpOption(false).
       *
       * @returns {(Option | null)} the help option
       * @package
       */
      _getHelpOption() {
        if (this._helpOption === void 0) {
          this.helpOption(void 0, void 0);
        }
        return this._helpOption;
      }
      /**
       * Supply your own option to use for the built-in help option.
       * This is an alternative to using helpOption() to customise the flags and description etc.
       *
       * @param {Option} option
       * @return {Command} `this` command for chaining
       */
      addHelpOption(option) {
        this._helpOption = option;
        return this;
      }
      /**
       * Output help information and exit.
       *
       * Outputs built-in help, and custom text added using `.addHelpText()`.
       *
       * @param {{ error: boolean }} [contextOptions] - pass {error:true} to write to stderr instead of stdout
       */
      help(contextOptions) {
        this.outputHelp(contextOptions);
        let exitCode = process2.exitCode || 0;
        if (exitCode === 0 && contextOptions && typeof contextOptions !== "function" && contextOptions.error) {
          exitCode = 1;
        }
        this._exit(exitCode, "commander.help", "(outputHelp)");
      }
      /**
       * Add additional text to be displayed with the built-in help.
       *
       * Position is 'before' or 'after' to affect just this command,
       * and 'beforeAll' or 'afterAll' to affect this command and all its subcommands.
       *
       * @param {string} position - before or after built-in help
       * @param {(string | Function)} text - string to add, or a function returning a string
       * @return {Command} `this` command for chaining
       */
      addHelpText(position, text) {
        const allowedValues = ["beforeAll", "before", "after", "afterAll"];
        if (!allowedValues.includes(position)) {
          throw new Error(`Unexpected value for position to addHelpText.
Expecting one of '${allowedValues.join("', '")}'`);
        }
        const helpEvent = `${position}Help`;
        this.on(helpEvent, (context) => {
          let helpStr;
          if (typeof text === "function") {
            helpStr = text({ error: context.error, command: context.command });
          } else {
            helpStr = text;
          }
          if (helpStr) {
            context.write(`${helpStr}
`);
          }
        });
        return this;
      }
      /**
       * Output help information if help flags specified
       *
       * @param {Array} args - array of options to search for help flags
       * @private
       */
      _outputHelpIfRequested(args) {
        const helpOption = this._getHelpOption();
        const helpRequested = helpOption && args.find((arg) => helpOption.is(arg));
        if (helpRequested) {
          this.outputHelp();
          this._exit(0, "commander.helpDisplayed", "(outputHelp)");
        }
      }
    };
    function incrementNodeInspectorPort(args) {
      return args.map((arg) => {
        if (!arg.startsWith("--inspect")) {
          return arg;
        }
        let debugOption;
        let debugHost = "127.0.0.1";
        let debugPort = "9229";
        let match;
        if ((match = arg.match(/^(--inspect(-brk)?)$/)) !== null) {
          debugOption = match[1];
        } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+)$/)) !== null) {
          debugOption = match[1];
          if (/^\d+$/.test(match[3])) {
            debugPort = match[3];
          } else {
            debugHost = match[3];
          }
        } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+):(\d+)$/)) !== null) {
          debugOption = match[1];
          debugHost = match[3];
          debugPort = match[4];
        }
        if (debugOption && debugPort !== "0") {
          return `${debugOption}=${debugHost}:${parseInt(debugPort) + 1}`;
        }
        return arg;
      });
    }
    exports2.Command = Command2;
  }
});

// node_modules/commander/index.js
var require_commander = __commonJS({
  "node_modules/commander/index.js"(exports2) {
    "use strict";
    var { Argument: Argument2 } = require_argument();
    var { Command: Command2 } = require_command();
    var { CommanderError: CommanderError2, InvalidArgumentError: InvalidArgumentError2 } = require_error();
    var { Help: Help2 } = require_help();
    var { Option: Option2 } = require_option();
    exports2.program = new Command2();
    exports2.createCommand = (name) => new Command2(name);
    exports2.createOption = (flags, description) => new Option2(flags, description);
    exports2.createArgument = (name, description) => new Argument2(name, description);
    exports2.Command = Command2;
    exports2.Option = Option2;
    exports2.Argument = Argument2;
    exports2.Help = Help2;
    exports2.CommanderError = CommanderError2;
    exports2.InvalidArgumentError = InvalidArgumentError2;
    exports2.InvalidOptionArgumentError = InvalidArgumentError2;
  }
});

// ../../node_modules/vscode-jsonrpc/lib/is.js
var require_is = __commonJS({
  "../../node_modules/vscode-jsonrpc/lib/is.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function boolean(value) {
      return value === true || value === false;
    }
    exports2.boolean = boolean;
    function string(value) {
      return typeof value === "string" || value instanceof String;
    }
    exports2.string = string;
    function number(value) {
      return typeof value === "number" || value instanceof Number;
    }
    exports2.number = number;
    function error(value) {
      return value instanceof Error;
    }
    exports2.error = error;
    function func(value) {
      return typeof value === "function";
    }
    exports2.func = func;
    function array(value) {
      return Array.isArray(value);
    }
    exports2.array = array;
    function stringArray(value) {
      return array(value) && value.every((elem) => string(elem));
    }
    exports2.stringArray = stringArray;
  }
});

// ../../node_modules/vscode-jsonrpc/lib/messages.js
var require_messages = __commonJS({
  "../../node_modules/vscode-jsonrpc/lib/messages.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var is = require_is();
    var ErrorCodes;
    (function(ErrorCodes2) {
      ErrorCodes2.ParseError = -32700;
      ErrorCodes2.InvalidRequest = -32600;
      ErrorCodes2.MethodNotFound = -32601;
      ErrorCodes2.InvalidParams = -32602;
      ErrorCodes2.InternalError = -32603;
      ErrorCodes2.serverErrorStart = -32099;
      ErrorCodes2.serverErrorEnd = -32e3;
      ErrorCodes2.ServerNotInitialized = -32002;
      ErrorCodes2.UnknownErrorCode = -32001;
      ErrorCodes2.RequestCancelled = -32800;
      ErrorCodes2.MessageWriteError = 1;
      ErrorCodes2.MessageReadError = 2;
    })(ErrorCodes = exports2.ErrorCodes || (exports2.ErrorCodes = {}));
    var ResponseError = class _ResponseError extends Error {
      constructor(code, message, data) {
        super(message);
        this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;
        this.data = data;
        Object.setPrototypeOf(this, _ResponseError.prototype);
      }
      toJson() {
        return {
          code: this.code,
          message: this.message,
          data: this.data
        };
      }
    };
    exports2.ResponseError = ResponseError;
    var AbstractMessageType = class {
      constructor(_method, _numberOfParams) {
        this._method = _method;
        this._numberOfParams = _numberOfParams;
      }
      get method() {
        return this._method;
      }
      get numberOfParams() {
        return this._numberOfParams;
      }
    };
    exports2.AbstractMessageType = AbstractMessageType;
    var RequestType0 = class extends AbstractMessageType {
      constructor(method) {
        super(method, 0);
        this._ = void 0;
      }
    };
    exports2.RequestType0 = RequestType0;
    var RequestType = class extends AbstractMessageType {
      constructor(method) {
        super(method, 1);
        this._ = void 0;
      }
    };
    exports2.RequestType = RequestType;
    var RequestType1 = class extends AbstractMessageType {
      constructor(method) {
        super(method, 1);
        this._ = void 0;
      }
    };
    exports2.RequestType1 = RequestType1;
    var RequestType2 = class extends AbstractMessageType {
      constructor(method) {
        super(method, 2);
        this._ = void 0;
      }
    };
    exports2.RequestType2 = RequestType2;
    var RequestType3 = class extends AbstractMessageType {
      constructor(method) {
        super(method, 3);
        this._ = void 0;
      }
    };
    exports2.RequestType3 = RequestType3;
    var RequestType4 = class extends AbstractMessageType {
      constructor(method) {
        super(method, 4);
        this._ = void 0;
      }
    };
    exports2.RequestType4 = RequestType4;
    var RequestType5 = class extends AbstractMessageType {
      constructor(method) {
        super(method, 5);
        this._ = void 0;
      }
    };
    exports2.RequestType5 = RequestType5;
    var RequestType6 = class extends AbstractMessageType {
      constructor(method) {
        super(method, 6);
        this._ = void 0;
      }
    };
    exports2.RequestType6 = RequestType6;
    var RequestType7 = class extends AbstractMessageType {
      constructor(method) {
        super(method, 7);
        this._ = void 0;
      }
    };
    exports2.RequestType7 = RequestType7;
    var RequestType8 = class extends AbstractMessageType {
      constructor(method) {
        super(method, 8);
        this._ = void 0;
      }
    };
    exports2.RequestType8 = RequestType8;
    var RequestType9 = class extends AbstractMessageType {
      constructor(method) {
        super(method, 9);
        this._ = void 0;
      }
    };
    exports2.RequestType9 = RequestType9;
    var NotificationType = class extends AbstractMessageType {
      constructor(method) {
        super(method, 1);
        this._ = void 0;
      }
    };
    exports2.NotificationType = NotificationType;
    var NotificationType0 = class extends AbstractMessageType {
      constructor(method) {
        super(method, 0);
        this._ = void 0;
      }
    };
    exports2.NotificationType0 = NotificationType0;
    var NotificationType1 = class extends AbstractMessageType {
      constructor(method) {
        super(method, 1);
        this._ = void 0;
      }
    };
    exports2.NotificationType1 = NotificationType1;
    var NotificationType2 = class extends AbstractMessageType {
      constructor(method) {
        super(method, 2);
        this._ = void 0;
      }
    };
    exports2.NotificationType2 = NotificationType2;
    var NotificationType3 = class extends AbstractMessageType {
      constructor(method) {
        super(method, 3);
        this._ = void 0;
      }
    };
    exports2.NotificationType3 = NotificationType3;
    var NotificationType4 = class extends AbstractMessageType {
      constructor(method) {
        super(method, 4);
        this._ = void 0;
      }
    };
    exports2.NotificationType4 = NotificationType4;
    var NotificationType5 = class extends AbstractMessageType {
      constructor(method) {
        super(method, 5);
        this._ = void 0;
      }
    };
    exports2.NotificationType5 = NotificationType5;
    var NotificationType6 = class extends AbstractMessageType {
      constructor(method) {
        super(method, 6);
        this._ = void 0;
      }
    };
    exports2.NotificationType6 = NotificationType6;
    var NotificationType7 = class extends AbstractMessageType {
      constructor(method) {
        super(method, 7);
        this._ = void 0;
      }
    };
    exports2.NotificationType7 = NotificationType7;
    var NotificationType8 = class extends AbstractMessageType {
      constructor(method) {
        super(method, 8);
        this._ = void 0;
      }
    };
    exports2.NotificationType8 = NotificationType8;
    var NotificationType9 = class extends AbstractMessageType {
      constructor(method) {
        super(method, 9);
        this._ = void 0;
      }
    };
    exports2.NotificationType9 = NotificationType9;
    function isRequestMessage(message) {
      let candidate = message;
      return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
    }
    exports2.isRequestMessage = isRequestMessage;
    function isNotificationMessage(message) {
      let candidate = message;
      return candidate && is.string(candidate.method) && message.id === void 0;
    }
    exports2.isNotificationMessage = isNotificationMessage;
    function isResponseMessage(message) {
      let candidate = message;
      return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
    }
    exports2.isResponseMessage = isResponseMessage;
  }
});

// ../../node_modules/vscode-jsonrpc/lib/events.js
var require_events = __commonJS({
  "../../node_modules/vscode-jsonrpc/lib/events.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var Disposable;
    (function(Disposable2) {
      function create(func) {
        return {
          dispose: func
        };
      }
      Disposable2.create = create;
    })(Disposable = exports2.Disposable || (exports2.Disposable = {}));
    var Event;
    (function(Event2) {
      const _disposable = { dispose() {
      } };
      Event2.None = function() {
        return _disposable;
      };
    })(Event = exports2.Event || (exports2.Event = {}));
    var CallbackList = class {
      add(callback2, context = null, bucket) {
        if (!this._callbacks) {
          this._callbacks = [];
          this._contexts = [];
        }
        this._callbacks.push(callback2);
        this._contexts.push(context);
        if (Array.isArray(bucket)) {
          bucket.push({ dispose: () => this.remove(callback2, context) });
        }
      }
      remove(callback2, context = null) {
        if (!this._callbacks) {
          return;
        }
        var foundCallbackWithDifferentContext = false;
        for (var i = 0, len = this._callbacks.length; i < len; i++) {
          if (this._callbacks[i] === callback2) {
            if (this._contexts[i] === context) {
              this._callbacks.splice(i, 1);
              this._contexts.splice(i, 1);
              return;
            } else {
              foundCallbackWithDifferentContext = true;
            }
          }
        }
        if (foundCallbackWithDifferentContext) {
          throw new Error("When adding a listener with a context, you should remove it with the same context");
        }
      }
      invoke(...args) {
        if (!this._callbacks) {
          return [];
        }
        var ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
        for (var i = 0, len = callbacks.length; i < len; i++) {
          try {
            ret.push(callbacks[i].apply(contexts[i], args));
          } catch (e) {
            console.error(e);
          }
        }
        return ret;
      }
      isEmpty() {
        return !this._callbacks || this._callbacks.length === 0;
      }
      dispose() {
        this._callbacks = void 0;
        this._contexts = void 0;
      }
    };
    var Emitter = class _Emitter {
      constructor(_options) {
        this._options = _options;
      }
      /**
       * For the public to allow to subscribe
       * to events from this Emitter
       */
      get event() {
        if (!this._event) {
          this._event = (listener, thisArgs, disposables) => {
            if (!this._callbacks) {
              this._callbacks = new CallbackList();
            }
            if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
              this._options.onFirstListenerAdd(this);
            }
            this._callbacks.add(listener, thisArgs);
            let result;
            result = {
              dispose: () => {
                this._callbacks.remove(listener, thisArgs);
                result.dispose = _Emitter._noop;
                if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                  this._options.onLastListenerRemove(this);
                }
              }
            };
            if (Array.isArray(disposables)) {
              disposables.push(result);
            }
            return result;
          };
        }
        return this._event;
      }
      /**
       * To be kept private to fire an event to
       * subscribers
       */
      fire(event) {
        if (this._callbacks) {
          this._callbacks.invoke.call(this._callbacks, event);
        }
      }
      dispose() {
        if (this._callbacks) {
          this._callbacks.dispose();
          this._callbacks = void 0;
        }
      }
    };
    Emitter._noop = function() {
    };
    exports2.Emitter = Emitter;
  }
});

// ../../node_modules/vscode-jsonrpc/lib/messageReader.js
var require_messageReader = __commonJS({
  "../../node_modules/vscode-jsonrpc/lib/messageReader.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var events_1 = require_events();
    var Is = require_is();
    var DefaultSize = 8192;
    var CR = Buffer.from("\r", "ascii")[0];
    var LF = Buffer.from("\n", "ascii")[0];
    var CRLF = "\r\n";
    var MessageBuffer = class {
      constructor(encoding = "utf8") {
        this.encoding = encoding;
        this.index = 0;
        this.buffer = Buffer.allocUnsafe(DefaultSize);
      }
      append(chunk) {
        var toAppend = chunk;
        if (typeof chunk === "string") {
          var str = chunk;
          var bufferLen = Buffer.byteLength(str, this.encoding);
          toAppend = Buffer.allocUnsafe(bufferLen);
          toAppend.write(str, 0, bufferLen, this.encoding);
        }
        if (this.buffer.length - this.index >= toAppend.length) {
          toAppend.copy(this.buffer, this.index, 0, toAppend.length);
        } else {
          var newSize = (Math.ceil((this.index + toAppend.length) / DefaultSize) + 1) * DefaultSize;
          if (this.index === 0) {
            this.buffer = Buffer.allocUnsafe(newSize);
            toAppend.copy(this.buffer, 0, 0, toAppend.length);
          } else {
            this.buffer = Buffer.concat([this.buffer.slice(0, this.index), toAppend], newSize);
          }
        }
        this.index += toAppend.length;
      }
      tryReadHeaders() {
        let result = void 0;
        let current = 0;
        while (current + 3 < this.index && (this.buffer[current] !== CR || this.buffer[current + 1] !== LF || this.buffer[current + 2] !== CR || this.buffer[current + 3] !== LF)) {
          current++;
        }
        if (current + 3 >= this.index) {
          return result;
        }
        result = /* @__PURE__ */ Object.create(null);
        let headers = this.buffer.toString("ascii", 0, current).split(CRLF);
        headers.forEach((header) => {
          let index = header.indexOf(":");
          if (index === -1) {
            throw new Error("Message header must separate key and value using :");
          }
          let key = header.substr(0, index);
          let value = header.substr(index + 1).trim();
          result[key] = value;
        });
        let nextStart = current + 4;
        this.buffer = this.buffer.slice(nextStart);
        this.index = this.index - nextStart;
        return result;
      }
      tryReadContent(length) {
        if (this.index < length) {
          return null;
        }
        let result = this.buffer.toString(this.encoding, 0, length);
        let nextStart = length;
        this.buffer.copy(this.buffer, 0, nextStart);
        this.index = this.index - nextStart;
        return result;
      }
      get numberOfBytes() {
        return this.index;
      }
    };
    var MessageReader;
    (function(MessageReader2) {
      function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.listen) && Is.func(candidate.dispose) && Is.func(candidate.onError) && Is.func(candidate.onClose) && Is.func(candidate.onPartialMessage);
      }
      MessageReader2.is = is;
    })(MessageReader = exports2.MessageReader || (exports2.MessageReader = {}));
    var AbstractMessageReader = class {
      constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
        this.partialMessageEmitter = new events_1.Emitter();
      }
      dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
      }
      get onError() {
        return this.errorEmitter.event;
      }
      fireError(error) {
        this.errorEmitter.fire(this.asError(error));
      }
      get onClose() {
        return this.closeEmitter.event;
      }
      fireClose() {
        this.closeEmitter.fire(void 0);
      }
      get onPartialMessage() {
        return this.partialMessageEmitter.event;
      }
      firePartialMessage(info) {
        this.partialMessageEmitter.fire(info);
      }
      asError(error) {
        if (error instanceof Error) {
          return error;
        } else {
          return new Error(`Reader recevied error. Reason: ${Is.string(error.message) ? error.message : "unknown"}`);
        }
      }
    };
    exports2.AbstractMessageReader = AbstractMessageReader;
    var StreamMessageReader2 = class extends AbstractMessageReader {
      constructor(readable, encoding = "utf8") {
        super();
        this.readable = readable;
        this.buffer = new MessageBuffer(encoding);
        this._partialMessageTimeout = 1e4;
      }
      set partialMessageTimeout(timeout) {
        this._partialMessageTimeout = timeout;
      }
      get partialMessageTimeout() {
        return this._partialMessageTimeout;
      }
      listen(callback2) {
        this.nextMessageLength = -1;
        this.messageToken = 0;
        this.partialMessageTimer = void 0;
        this.callback = callback2;
        this.readable.on("data", (data) => {
          this.onData(data);
        });
        this.readable.on("error", (error) => this.fireError(error));
        this.readable.on("close", () => this.fireClose());
      }
      onData(data) {
        this.buffer.append(data);
        while (true) {
          if (this.nextMessageLength === -1) {
            let headers = this.buffer.tryReadHeaders();
            if (!headers) {
              return;
            }
            let contentLength = headers["Content-Length"];
            if (!contentLength) {
              throw new Error("Header must provide a Content-Length property.");
            }
            let length = parseInt(contentLength);
            if (isNaN(length)) {
              throw new Error("Content-Length value must be a number.");
            }
            this.nextMessageLength = length;
          }
          var msg = this.buffer.tryReadContent(this.nextMessageLength);
          if (msg === null) {
            this.setPartialMessageTimer();
            return;
          }
          this.clearPartialMessageTimer();
          this.nextMessageLength = -1;
          this.messageToken++;
          var json = JSON.parse(msg);
          this.callback(json);
        }
      }
      clearPartialMessageTimer() {
        if (this.partialMessageTimer) {
          clearTimeout(this.partialMessageTimer);
          this.partialMessageTimer = void 0;
        }
      }
      setPartialMessageTimer() {
        this.clearPartialMessageTimer();
        if (this._partialMessageTimeout <= 0) {
          return;
        }
        this.partialMessageTimer = setTimeout((token, timeout) => {
          this.partialMessageTimer = void 0;
          if (token === this.messageToken) {
            this.firePartialMessage({ messageToken: token, waitingTime: timeout });
            this.setPartialMessageTimer();
          }
        }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
      }
    };
    exports2.StreamMessageReader = StreamMessageReader2;
    var IPCMessageReader = class extends AbstractMessageReader {
      constructor(process2) {
        super();
        this.process = process2;
        let eventEmitter = this.process;
        eventEmitter.on("error", (error) => this.fireError(error));
        eventEmitter.on("close", () => this.fireClose());
      }
      listen(callback2) {
        this.process.on("message", callback2);
      }
    };
    exports2.IPCMessageReader = IPCMessageReader;
    var SocketMessageReader = class extends StreamMessageReader2 {
      constructor(socket, encoding = "utf-8") {
        super(socket, encoding);
      }
    };
    exports2.SocketMessageReader = SocketMessageReader;
  }
});

// ../../node_modules/vscode-jsonrpc/lib/messageWriter.js
var require_messageWriter = __commonJS({
  "../../node_modules/vscode-jsonrpc/lib/messageWriter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var events_1 = require_events();
    var Is = require_is();
    var ContentLength = "Content-Length: ";
    var CRLF = "\r\n";
    var MessageWriter;
    (function(MessageWriter2) {
      function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.dispose) && Is.func(candidate.onClose) && Is.func(candidate.onError) && Is.func(candidate.write);
      }
      MessageWriter2.is = is;
    })(MessageWriter = exports2.MessageWriter || (exports2.MessageWriter = {}));
    var AbstractMessageWriter = class {
      constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
      }
      dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
      }
      get onError() {
        return this.errorEmitter.event;
      }
      fireError(error, message, count) {
        this.errorEmitter.fire([this.asError(error), message, count]);
      }
      get onClose() {
        return this.closeEmitter.event;
      }
      fireClose() {
        this.closeEmitter.fire(void 0);
      }
      asError(error) {
        if (error instanceof Error) {
          return error;
        } else {
          return new Error(`Writer recevied error. Reason: ${Is.string(error.message) ? error.message : "unknown"}`);
        }
      }
    };
    exports2.AbstractMessageWriter = AbstractMessageWriter;
    var StreamMessageWriter2 = class extends AbstractMessageWriter {
      constructor(writable, encoding = "utf8") {
        super();
        this.writable = writable;
        this.encoding = encoding;
        this.errorCount = 0;
        this.writable.on("error", (error) => this.fireError(error));
        this.writable.on("close", () => this.fireClose());
      }
      write(msg) {
        let json = JSON.stringify(msg);
        let contentLength = Buffer.byteLength(json, this.encoding);
        let headers = [
          ContentLength,
          contentLength.toString(),
          CRLF,
          CRLF
        ];
        try {
          this.writable.write(headers.join(""), "ascii");
          this.writable.write(json, this.encoding);
          this.errorCount = 0;
        } catch (error) {
          this.errorCount++;
          this.fireError(error, msg, this.errorCount);
        }
      }
    };
    exports2.StreamMessageWriter = StreamMessageWriter2;
    var IPCMessageWriter = class extends AbstractMessageWriter {
      constructor(process2) {
        super();
        this.process = process2;
        this.errorCount = 0;
        this.queue = [];
        this.sending = false;
        let eventEmitter = this.process;
        eventEmitter.on("error", (error) => this.fireError(error));
        eventEmitter.on("close", () => this.fireClose);
      }
      write(msg) {
        if (!this.sending && this.queue.length === 0) {
          this.doWriteMessage(msg);
        } else {
          this.queue.push(msg);
        }
      }
      doWriteMessage(msg) {
        try {
          if (this.process.send) {
            this.sending = true;
            this.process.send(msg, void 0, void 0, (error) => {
              this.sending = false;
              if (error) {
                this.errorCount++;
                this.fireError(error, msg, this.errorCount);
              } else {
                this.errorCount = 0;
              }
              if (this.queue.length > 0) {
                this.doWriteMessage(this.queue.shift());
              }
            });
          }
        } catch (error) {
          this.errorCount++;
          this.fireError(error, msg, this.errorCount);
        }
      }
    };
    exports2.IPCMessageWriter = IPCMessageWriter;
    var SocketMessageWriter = class extends AbstractMessageWriter {
      constructor(socket, encoding = "utf8") {
        super();
        this.socket = socket;
        this.queue = [];
        this.sending = false;
        this.encoding = encoding;
        this.errorCount = 0;
        this.socket.on("error", (error) => this.fireError(error));
        this.socket.on("close", () => this.fireClose());
      }
      write(msg) {
        if (!this.sending && this.queue.length === 0) {
          this.doWriteMessage(msg);
        } else {
          this.queue.push(msg);
        }
      }
      doWriteMessage(msg) {
        let json = JSON.stringify(msg);
        let contentLength = Buffer.byteLength(json, this.encoding);
        let headers = [
          ContentLength,
          contentLength.toString(),
          CRLF,
          CRLF
        ];
        try {
          this.sending = true;
          this.socket.write(headers.join(""), "ascii", (error) => {
            if (error) {
              this.handleError(error, msg);
            }
            try {
              this.socket.write(json, this.encoding, (error2) => {
                this.sending = false;
                if (error2) {
                  this.handleError(error2, msg);
                } else {
                  this.errorCount = 0;
                }
                if (this.queue.length > 0) {
                  this.doWriteMessage(this.queue.shift());
                }
              });
            } catch (error2) {
              this.handleError(error2, msg);
            }
          });
        } catch (error) {
          this.handleError(error, msg);
        }
      }
      handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
      }
    };
    exports2.SocketMessageWriter = SocketMessageWriter;
  }
});

// ../../node_modules/vscode-jsonrpc/lib/cancellation.js
var require_cancellation = __commonJS({
  "../../node_modules/vscode-jsonrpc/lib/cancellation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var events_1 = require_events();
    var Is = require_is();
    var CancellationToken;
    (function(CancellationToken2) {
      CancellationToken2.None = Object.freeze({
        isCancellationRequested: false,
        onCancellationRequested: events_1.Event.None
      });
      CancellationToken2.Cancelled = Object.freeze({
        isCancellationRequested: true,
        onCancellationRequested: events_1.Event.None
      });
      function is(value) {
        let candidate = value;
        return candidate && (candidate === CancellationToken2.None || candidate === CancellationToken2.Cancelled || Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested);
      }
      CancellationToken2.is = is;
    })(CancellationToken = exports2.CancellationToken || (exports2.CancellationToken = {}));
    var shortcutEvent = Object.freeze(function(callback2, context) {
      let handle = setTimeout(callback2.bind(context), 0);
      return { dispose() {
        clearTimeout(handle);
      } };
    });
    var MutableToken = class {
      constructor() {
        this._isCancelled = false;
      }
      cancel() {
        if (!this._isCancelled) {
          this._isCancelled = true;
          if (this._emitter) {
            this._emitter.fire(void 0);
            this._emitter = void 0;
          }
        }
      }
      get isCancellationRequested() {
        return this._isCancelled;
      }
      get onCancellationRequested() {
        if (this._isCancelled) {
          return shortcutEvent;
        }
        if (!this._emitter) {
          this._emitter = new events_1.Emitter();
        }
        return this._emitter.event;
      }
    };
    var CancellationTokenSource = class {
      get token() {
        if (!this._token) {
          this._token = new MutableToken();
        }
        return this._token;
      }
      cancel() {
        if (!this._token) {
          this._token = CancellationToken.Cancelled;
        } else {
          this._token.cancel();
        }
      }
      dispose() {
        this.cancel();
      }
    };
    exports2.CancellationTokenSource = CancellationTokenSource;
  }
});

// ../../node_modules/vscode-jsonrpc/lib/linkedMap.js
var require_linkedMap = __commonJS({
  "../../node_modules/vscode-jsonrpc/lib/linkedMap.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var Touch;
    (function(Touch2) {
      Touch2.None = 0;
      Touch2.First = 1;
      Touch2.Last = 2;
    })(Touch = exports2.Touch || (exports2.Touch = {}));
    var LinkedMap = class {
      constructor() {
        this._map = /* @__PURE__ */ new Map();
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
      }
      clear() {
        this._map.clear();
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
      }
      isEmpty() {
        return !this._head && !this._tail;
      }
      get size() {
        return this._size;
      }
      has(key) {
        return this._map.has(key);
      }
      get(key) {
        const item = this._map.get(key);
        if (!item) {
          return void 0;
        }
        return item.value;
      }
      set(key, value, touch = Touch.None) {
        let item = this._map.get(key);
        if (item) {
          item.value = value;
          if (touch !== Touch.None) {
            this.touch(item, touch);
          }
        } else {
          item = { key, value, next: void 0, previous: void 0 };
          switch (touch) {
            case Touch.None:
              this.addItemLast(item);
              break;
            case Touch.First:
              this.addItemFirst(item);
              break;
            case Touch.Last:
              this.addItemLast(item);
              break;
            default:
              this.addItemLast(item);
              break;
          }
          this._map.set(key, item);
          this._size++;
        }
      }
      delete(key) {
        const item = this._map.get(key);
        if (!item) {
          return false;
        }
        this._map.delete(key);
        this.removeItem(item);
        this._size--;
        return true;
      }
      shift() {
        if (!this._head && !this._tail) {
          return void 0;
        }
        if (!this._head || !this._tail) {
          throw new Error("Invalid list");
        }
        const item = this._head;
        this._map.delete(item.key);
        this.removeItem(item);
        this._size--;
        return item.value;
      }
      forEach(callbackfn, thisArg) {
        let current = this._head;
        while (current) {
          if (thisArg) {
            callbackfn.bind(thisArg)(current.value, current.key, this);
          } else {
            callbackfn(current.value, current.key, this);
          }
          current = current.next;
        }
      }
      forEachReverse(callbackfn, thisArg) {
        let current = this._tail;
        while (current) {
          if (thisArg) {
            callbackfn.bind(thisArg)(current.value, current.key, this);
          } else {
            callbackfn(current.value, current.key, this);
          }
          current = current.previous;
        }
      }
      values() {
        let result = [];
        let current = this._head;
        while (current) {
          result.push(current.value);
          current = current.next;
        }
        return result;
      }
      keys() {
        let result = [];
        let current = this._head;
        while (current) {
          result.push(current.key);
          current = current.next;
        }
        return result;
      }
      /* JSON RPC run on es5 which has no Symbol.iterator
          public keys(): IterableIterator<K> {
              let current = this._head;
              let iterator: IterableIterator<K> = {
                  [Symbol.iterator]() {
                      return iterator;
                  },
                  next():IteratorResult<K> {
                      if (current) {
                          let result = { value: current.key, done: false };
                          current = current.next;
                          return result;
                      } else {
                          return { value: undefined, done: true };
                      }
                  }
              };
              return iterator;
          }
      
          public values(): IterableIterator<V> {
              let current = this._head;
              let iterator: IterableIterator<V> = {
                  [Symbol.iterator]() {
                      return iterator;
                  },
                  next():IteratorResult<V> {
                      if (current) {
                          let result = { value: current.value, done: false };
                          current = current.next;
                          return result;
                      } else {
                          return { value: undefined, done: true };
                      }
                  }
              };
              return iterator;
          }
          */
      addItemFirst(item) {
        if (!this._head && !this._tail) {
          this._tail = item;
        } else if (!this._head) {
          throw new Error("Invalid list");
        } else {
          item.next = this._head;
          this._head.previous = item;
        }
        this._head = item;
      }
      addItemLast(item) {
        if (!this._head && !this._tail) {
          this._head = item;
        } else if (!this._tail) {
          throw new Error("Invalid list");
        } else {
          item.previous = this._tail;
          this._tail.next = item;
        }
        this._tail = item;
      }
      removeItem(item) {
        if (item === this._head && item === this._tail) {
          this._head = void 0;
          this._tail = void 0;
        } else if (item === this._head) {
          this._head = item.next;
        } else if (item === this._tail) {
          this._tail = item.previous;
        } else {
          const next = item.next;
          const previous = item.previous;
          if (!next || !previous) {
            throw new Error("Invalid list");
          }
          next.previous = previous;
          previous.next = next;
        }
      }
      touch(item, touch) {
        if (!this._head || !this._tail) {
          throw new Error("Invalid list");
        }
        if (touch !== Touch.First && touch !== Touch.Last) {
          return;
        }
        if (touch === Touch.First) {
          if (item === this._head) {
            return;
          }
          const next = item.next;
          const previous = item.previous;
          if (item === this._tail) {
            previous.next = void 0;
            this._tail = previous;
          } else {
            next.previous = previous;
            previous.next = next;
          }
          item.previous = void 0;
          item.next = this._head;
          this._head.previous = item;
          this._head = item;
        } else if (touch === Touch.Last) {
          if (item === this._tail) {
            return;
          }
          const next = item.next;
          const previous = item.previous;
          if (item === this._head) {
            next.previous = void 0;
            this._head = next;
          } else {
            next.previous = previous;
            previous.next = next;
          }
          item.next = void 0;
          item.previous = this._tail;
          this._tail.next = item;
          this._tail = item;
        }
      }
    };
    exports2.LinkedMap = LinkedMap;
  }
});

// ../../node_modules/vscode-jsonrpc/lib/pipeSupport.js
var require_pipeSupport = __commonJS({
  "../../node_modules/vscode-jsonrpc/lib/pipeSupport.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var path_1 = require("path");
    var os_1 = require("os");
    var crypto_1 = require("crypto");
    var net_1 = require("net");
    var messageReader_1 = require_messageReader();
    var messageWriter_1 = require_messageWriter();
    function generateRandomPipeName() {
      const randomSuffix = crypto_1.randomBytes(21).toString("hex");
      if (process.platform === "win32") {
        return `\\\\.\\pipe\\vscode-jsonrpc-${randomSuffix}-sock`;
      } else {
        return path_1.join(os_1.tmpdir(), `vscode-${randomSuffix}.sock`);
      }
    }
    exports2.generateRandomPipeName = generateRandomPipeName;
    function createClientPipeTransport(pipeName, encoding = "utf-8") {
      let connectResolve;
      let connected = new Promise((resolve3, _reject) => {
        connectResolve = resolve3;
      });
      return new Promise((resolve3, reject) => {
        let server = net_1.createServer((socket) => {
          server.close();
          connectResolve([
            new messageReader_1.SocketMessageReader(socket, encoding),
            new messageWriter_1.SocketMessageWriter(socket, encoding)
          ]);
        });
        server.on("error", reject);
        server.listen(pipeName, () => {
          server.removeListener("error", reject);
          resolve3({
            onConnected: () => {
              return connected;
            }
          });
        });
      });
    }
    exports2.createClientPipeTransport = createClientPipeTransport;
    function createServerPipeTransport(pipeName, encoding = "utf-8") {
      const socket = net_1.createConnection(pipeName);
      return [
        new messageReader_1.SocketMessageReader(socket, encoding),
        new messageWriter_1.SocketMessageWriter(socket, encoding)
      ];
    }
    exports2.createServerPipeTransport = createServerPipeTransport;
  }
});

// ../../node_modules/vscode-jsonrpc/lib/socketSupport.js
var require_socketSupport = __commonJS({
  "../../node_modules/vscode-jsonrpc/lib/socketSupport.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var net_1 = require("net");
    var messageReader_1 = require_messageReader();
    var messageWriter_1 = require_messageWriter();
    function createClientSocketTransport(port, encoding = "utf-8") {
      let connectResolve;
      let connected = new Promise((resolve3, _reject) => {
        connectResolve = resolve3;
      });
      return new Promise((resolve3, reject) => {
        let server = net_1.createServer((socket) => {
          server.close();
          connectResolve([
            new messageReader_1.SocketMessageReader(socket, encoding),
            new messageWriter_1.SocketMessageWriter(socket, encoding)
          ]);
        });
        server.on("error", reject);
        server.listen(port, "127.0.0.1", () => {
          server.removeListener("error", reject);
          resolve3({
            onConnected: () => {
              return connected;
            }
          });
        });
      });
    }
    exports2.createClientSocketTransport = createClientSocketTransport;
    function createServerSocketTransport(port, encoding = "utf-8") {
      const socket = net_1.createConnection(port, "127.0.0.1");
      return [
        new messageReader_1.SocketMessageReader(socket, encoding),
        new messageWriter_1.SocketMessageWriter(socket, encoding)
      ];
    }
    exports2.createServerSocketTransport = createServerSocketTransport;
  }
});

// ../../node_modules/vscode-jsonrpc/lib/main.js
var require_main = __commonJS({
  "../../node_modules/vscode-jsonrpc/lib/main.js"(exports2) {
    "use strict";
    function __export(m) {
      for (var p in m) if (!exports2.hasOwnProperty(p)) exports2[p] = m[p];
    }
    Object.defineProperty(exports2, "__esModule", { value: true });
    var Is = require_is();
    var messages_1 = require_messages();
    exports2.RequestType = messages_1.RequestType;
    exports2.RequestType0 = messages_1.RequestType0;
    exports2.RequestType1 = messages_1.RequestType1;
    exports2.RequestType2 = messages_1.RequestType2;
    exports2.RequestType3 = messages_1.RequestType3;
    exports2.RequestType4 = messages_1.RequestType4;
    exports2.RequestType5 = messages_1.RequestType5;
    exports2.RequestType6 = messages_1.RequestType6;
    exports2.RequestType7 = messages_1.RequestType7;
    exports2.RequestType8 = messages_1.RequestType8;
    exports2.RequestType9 = messages_1.RequestType9;
    exports2.ResponseError = messages_1.ResponseError;
    exports2.ErrorCodes = messages_1.ErrorCodes;
    exports2.NotificationType = messages_1.NotificationType;
    exports2.NotificationType0 = messages_1.NotificationType0;
    exports2.NotificationType1 = messages_1.NotificationType1;
    exports2.NotificationType2 = messages_1.NotificationType2;
    exports2.NotificationType3 = messages_1.NotificationType3;
    exports2.NotificationType4 = messages_1.NotificationType4;
    exports2.NotificationType5 = messages_1.NotificationType5;
    exports2.NotificationType6 = messages_1.NotificationType6;
    exports2.NotificationType7 = messages_1.NotificationType7;
    exports2.NotificationType8 = messages_1.NotificationType8;
    exports2.NotificationType9 = messages_1.NotificationType9;
    var messageReader_1 = require_messageReader();
    exports2.MessageReader = messageReader_1.MessageReader;
    exports2.StreamMessageReader = messageReader_1.StreamMessageReader;
    exports2.IPCMessageReader = messageReader_1.IPCMessageReader;
    exports2.SocketMessageReader = messageReader_1.SocketMessageReader;
    var messageWriter_1 = require_messageWriter();
    exports2.MessageWriter = messageWriter_1.MessageWriter;
    exports2.StreamMessageWriter = messageWriter_1.StreamMessageWriter;
    exports2.IPCMessageWriter = messageWriter_1.IPCMessageWriter;
    exports2.SocketMessageWriter = messageWriter_1.SocketMessageWriter;
    var events_1 = require_events();
    exports2.Disposable = events_1.Disposable;
    exports2.Event = events_1.Event;
    exports2.Emitter = events_1.Emitter;
    var cancellation_1 = require_cancellation();
    exports2.CancellationTokenSource = cancellation_1.CancellationTokenSource;
    exports2.CancellationToken = cancellation_1.CancellationToken;
    var linkedMap_1 = require_linkedMap();
    __export(require_pipeSupport());
    __export(require_socketSupport());
    var CancelNotification;
    (function(CancelNotification2) {
      CancelNotification2.type = new messages_1.NotificationType("$/cancelRequest");
    })(CancelNotification || (CancelNotification = {}));
    exports2.NullLogger = Object.freeze({
      error: () => {
      },
      warn: () => {
      },
      info: () => {
      },
      log: () => {
      }
    });
    var Trace;
    (function(Trace2) {
      Trace2[Trace2["Off"] = 0] = "Off";
      Trace2[Trace2["Messages"] = 1] = "Messages";
      Trace2[Trace2["Verbose"] = 2] = "Verbose";
    })(Trace = exports2.Trace || (exports2.Trace = {}));
    (function(Trace2) {
      function fromString(value) {
        value = value.toLowerCase();
        switch (value) {
          case "off":
            return Trace2.Off;
          case "messages":
            return Trace2.Messages;
          case "verbose":
            return Trace2.Verbose;
          default:
            return Trace2.Off;
        }
      }
      Trace2.fromString = fromString;
      function toString(value) {
        switch (value) {
          case Trace2.Off:
            return "off";
          case Trace2.Messages:
            return "messages";
          case Trace2.Verbose:
            return "verbose";
          default:
            return "off";
        }
      }
      Trace2.toString = toString;
    })(Trace = exports2.Trace || (exports2.Trace = {}));
    var TraceFormat;
    (function(TraceFormat2) {
      TraceFormat2["Text"] = "text";
      TraceFormat2["JSON"] = "json";
    })(TraceFormat = exports2.TraceFormat || (exports2.TraceFormat = {}));
    (function(TraceFormat2) {
      function fromString(value) {
        value = value.toLowerCase();
        if (value === "json") {
          return TraceFormat2.JSON;
        } else {
          return TraceFormat2.Text;
        }
      }
      TraceFormat2.fromString = fromString;
    })(TraceFormat = exports2.TraceFormat || (exports2.TraceFormat = {}));
    var SetTraceNotification;
    (function(SetTraceNotification2) {
      SetTraceNotification2.type = new messages_1.NotificationType("$/setTraceNotification");
    })(SetTraceNotification = exports2.SetTraceNotification || (exports2.SetTraceNotification = {}));
    var LogTraceNotification;
    (function(LogTraceNotification2) {
      LogTraceNotification2.type = new messages_1.NotificationType("$/logTraceNotification");
    })(LogTraceNotification = exports2.LogTraceNotification || (exports2.LogTraceNotification = {}));
    var ConnectionErrors;
    (function(ConnectionErrors2) {
      ConnectionErrors2[ConnectionErrors2["Closed"] = 1] = "Closed";
      ConnectionErrors2[ConnectionErrors2["Disposed"] = 2] = "Disposed";
      ConnectionErrors2[ConnectionErrors2["AlreadyListening"] = 3] = "AlreadyListening";
    })(ConnectionErrors = exports2.ConnectionErrors || (exports2.ConnectionErrors = {}));
    var ConnectionError = class _ConnectionError extends Error {
      constructor(code, message) {
        super(message);
        this.code = code;
        Object.setPrototypeOf(this, _ConnectionError.prototype);
      }
    };
    exports2.ConnectionError = ConnectionError;
    var ConnectionStrategy;
    (function(ConnectionStrategy2) {
      function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.cancelUndispatched);
      }
      ConnectionStrategy2.is = is;
    })(ConnectionStrategy = exports2.ConnectionStrategy || (exports2.ConnectionStrategy = {}));
    var ConnectionState;
    (function(ConnectionState2) {
      ConnectionState2[ConnectionState2["New"] = 1] = "New";
      ConnectionState2[ConnectionState2["Listening"] = 2] = "Listening";
      ConnectionState2[ConnectionState2["Closed"] = 3] = "Closed";
      ConnectionState2[ConnectionState2["Disposed"] = 4] = "Disposed";
    })(ConnectionState || (ConnectionState = {}));
    function _createMessageConnection(messageReader, messageWriter, logger, strategy) {
      let sequenceNumber = 0;
      let notificationSquenceNumber = 0;
      let unknownResponseSquenceNumber = 0;
      const version = "2.0";
      let starRequestHandler = void 0;
      let requestHandlers = /* @__PURE__ */ Object.create(null);
      let starNotificationHandler = void 0;
      let notificationHandlers = /* @__PURE__ */ Object.create(null);
      let timer;
      let messageQueue = new linkedMap_1.LinkedMap();
      let responsePromises = /* @__PURE__ */ Object.create(null);
      let requestTokens = /* @__PURE__ */ Object.create(null);
      let trace = Trace.Off;
      let traceFormat = TraceFormat.Text;
      let tracer;
      let state = ConnectionState.New;
      let errorEmitter = new events_1.Emitter();
      let closeEmitter = new events_1.Emitter();
      let unhandledNotificationEmitter = new events_1.Emitter();
      let disposeEmitter = new events_1.Emitter();
      function createRequestQueueKey(id) {
        return "req-" + id.toString();
      }
      function createResponseQueueKey(id) {
        if (id === null) {
          return "res-unknown-" + (++unknownResponseSquenceNumber).toString();
        } else {
          return "res-" + id.toString();
        }
      }
      function createNotificationQueueKey() {
        return "not-" + (++notificationSquenceNumber).toString();
      }
      function addMessageToQueue(queue, message) {
        if (messages_1.isRequestMessage(message)) {
          queue.set(createRequestQueueKey(message.id), message);
        } else if (messages_1.isResponseMessage(message)) {
          queue.set(createResponseQueueKey(message.id), message);
        } else {
          queue.set(createNotificationQueueKey(), message);
        }
      }
      function cancelUndispatched(_message) {
        return void 0;
      }
      function isListening() {
        return state === ConnectionState.Listening;
      }
      function isClosed() {
        return state === ConnectionState.Closed;
      }
      function isDisposed() {
        return state === ConnectionState.Disposed;
      }
      function closeHandler() {
        if (state === ConnectionState.New || state === ConnectionState.Listening) {
          state = ConnectionState.Closed;
          closeEmitter.fire(void 0);
        }
      }
      ;
      function readErrorHandler(error) {
        errorEmitter.fire([error, void 0, void 0]);
      }
      function writeErrorHandler(data) {
        errorEmitter.fire(data);
      }
      messageReader.onClose(closeHandler);
      messageReader.onError(readErrorHandler);
      messageWriter.onClose(closeHandler);
      messageWriter.onError(writeErrorHandler);
      function triggerMessageQueue() {
        if (timer || messageQueue.size === 0) {
          return;
        }
        timer = setImmediate(() => {
          timer = void 0;
          processMessageQueue();
        });
      }
      function processMessageQueue() {
        if (messageQueue.size === 0) {
          return;
        }
        let message = messageQueue.shift();
        try {
          if (messages_1.isRequestMessage(message)) {
            handleRequest(message);
          } else if (messages_1.isNotificationMessage(message)) {
            handleNotification(message);
          } else if (messages_1.isResponseMessage(message)) {
            handleResponse(message);
          } else {
            handleInvalidMessage(message);
          }
        } finally {
          triggerMessageQueue();
        }
      }
      let callback2 = (message) => {
        try {
          if (messages_1.isNotificationMessage(message) && message.method === CancelNotification.type.method) {
            let key = createRequestQueueKey(message.params.id);
            let toCancel = messageQueue.get(key);
            if (messages_1.isRequestMessage(toCancel)) {
              let response = strategy && strategy.cancelUndispatched ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
              if (response && (response.error !== void 0 || response.result !== void 0)) {
                messageQueue.delete(key);
                response.id = toCancel.id;
                traceSendingResponse(response, message.method, Date.now());
                messageWriter.write(response);
                return;
              }
            }
          }
          addMessageToQueue(messageQueue, message);
        } finally {
          triggerMessageQueue();
        }
      };
      function handleRequest(requestMessage) {
        if (isDisposed()) {
          return;
        }
        function reply(resultOrError, method, startTime2) {
          let message = {
            jsonrpc: version,
            id: requestMessage.id
          };
          if (resultOrError instanceof messages_1.ResponseError) {
            message.error = resultOrError.toJson();
          } else {
            message.result = resultOrError === void 0 ? null : resultOrError;
          }
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message);
        }
        function replyError(error, method, startTime2) {
          let message = {
            jsonrpc: version,
            id: requestMessage.id,
            error: error.toJson()
          };
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message);
        }
        function replySuccess(result, method, startTime2) {
          if (result === void 0) {
            result = null;
          }
          let message = {
            jsonrpc: version,
            id: requestMessage.id,
            result
          };
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message);
        }
        traceReceivedRequest(requestMessage);
        let element = requestHandlers[requestMessage.method];
        let type;
        let requestHandler;
        if (element) {
          type = element.type;
          requestHandler = element.handler;
        }
        let startTime = Date.now();
        if (requestHandler || starRequestHandler) {
          let cancellationSource = new cancellation_1.CancellationTokenSource();
          let tokenKey = String(requestMessage.id);
          requestTokens[tokenKey] = cancellationSource;
          try {
            let handlerResult;
            if (requestMessage.params === void 0 || type !== void 0 && type.numberOfParams === 0) {
              handlerResult = requestHandler ? requestHandler(cancellationSource.token) : starRequestHandler(requestMessage.method, cancellationSource.token);
            } else if (Is.array(requestMessage.params) && (type === void 0 || type.numberOfParams > 1)) {
              handlerResult = requestHandler ? requestHandler(...requestMessage.params, cancellationSource.token) : starRequestHandler(requestMessage.method, ...requestMessage.params, cancellationSource.token);
            } else {
              handlerResult = requestHandler ? requestHandler(requestMessage.params, cancellationSource.token) : starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
            }
            let promise2 = handlerResult;
            if (!handlerResult) {
              delete requestTokens[tokenKey];
              replySuccess(handlerResult, requestMessage.method, startTime);
            } else if (promise2.then) {
              promise2.then((resultOrError) => {
                delete requestTokens[tokenKey];
                reply(resultOrError, requestMessage.method, startTime);
              }, (error) => {
                delete requestTokens[tokenKey];
                if (error instanceof messages_1.ResponseError) {
                  replyError(error, requestMessage.method, startTime);
                } else if (error && Is.string(error.message)) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                } else {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                }
              });
            } else {
              delete requestTokens[tokenKey];
              reply(handlerResult, requestMessage.method, startTime);
            }
          } catch (error) {
            delete requestTokens[tokenKey];
            if (error instanceof messages_1.ResponseError) {
              reply(error, requestMessage.method, startTime);
            } else if (error && Is.string(error.message)) {
              replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
            } else {
              replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
            }
          }
        } else {
          replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
        }
      }
      function handleResponse(responseMessage) {
        if (isDisposed()) {
          return;
        }
        if (responseMessage.id === null) {
          if (responseMessage.error) {
            logger.error(`Received response message without id: Error is: 
${JSON.stringify(responseMessage.error, void 0, 4)}`);
          } else {
            logger.error(`Received response message without id. No further error information provided.`);
          }
        } else {
          let key = String(responseMessage.id);
          let responsePromise = responsePromises[key];
          traceReceivedResponse(responseMessage, responsePromise);
          if (responsePromise) {
            delete responsePromises[key];
            try {
              if (responseMessage.error) {
                let error = responseMessage.error;
                responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
              } else if (responseMessage.result !== void 0) {
                responsePromise.resolve(responseMessage.result);
              } else {
                throw new Error("Should never happen.");
              }
            } catch (error) {
              if (error.message) {
                logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
              } else {
                logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
              }
            }
          }
        }
      }
      function handleNotification(message) {
        if (isDisposed()) {
          return;
        }
        let type = void 0;
        let notificationHandler;
        if (message.method === CancelNotification.type.method) {
          notificationHandler = (params) => {
            let id = params.id;
            let source = requestTokens[String(id)];
            if (source) {
              source.cancel();
            }
          };
        } else {
          let element = notificationHandlers[message.method];
          if (element) {
            notificationHandler = element.handler;
            type = element.type;
          }
        }
        if (notificationHandler || starNotificationHandler) {
          try {
            traceReceivedNotification(message);
            if (message.params === void 0 || type !== void 0 && type.numberOfParams === 0) {
              notificationHandler ? notificationHandler() : starNotificationHandler(message.method);
            } else if (Is.array(message.params) && (type === void 0 || type.numberOfParams > 1)) {
              notificationHandler ? notificationHandler(...message.params) : starNotificationHandler(message.method, ...message.params);
            } else {
              notificationHandler ? notificationHandler(message.params) : starNotificationHandler(message.method, message.params);
            }
          } catch (error) {
            if (error.message) {
              logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
            } else {
              logger.error(`Notification handler '${message.method}' failed unexpectedly.`);
            }
          }
        } else {
          unhandledNotificationEmitter.fire(message);
        }
      }
      function handleInvalidMessage(message) {
        if (!message) {
          logger.error("Received empty message.");
          return;
        }
        logger.error(`Received message which is neither a response nor a notification message:
${JSON.stringify(message, null, 4)}`);
        let responseMessage = message;
        if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {
          let key = String(responseMessage.id);
          let responseHandler = responsePromises[key];
          if (responseHandler) {
            responseHandler.reject(new Error("The received response has neither a result nor an error property."));
          }
        }
      }
      function traceSendingRequest(message) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose && message.params) {
            data = `Params: ${JSON.stringify(message.params, null, 4)}

`;
          }
          tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
        } else {
          logLSPMessage("send-request", message);
        }
      }
      function traceSendingNotification(message) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose) {
            if (message.params) {
              data = `Params: ${JSON.stringify(message.params, null, 4)}

`;
            } else {
              data = "No parameters provided.\n\n";
            }
          }
          tracer.log(`Sending notification '${message.method}'.`, data);
        } else {
          logLSPMessage("send-notification", message);
        }
      }
      function traceSendingResponse(message, method, startTime) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose) {
            if (message.error && message.error.data) {
              data = `Error data: ${JSON.stringify(message.error.data, null, 4)}

`;
            } else {
              if (message.result) {
                data = `Result: ${JSON.stringify(message.result, null, 4)}

`;
              } else if (message.error === void 0) {
                data = "No result returned.\n\n";
              }
            }
          }
          tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
        } else {
          logLSPMessage("send-response", message);
        }
      }
      function traceReceivedRequest(message) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose && message.params) {
            data = `Params: ${JSON.stringify(message.params, null, 4)}

`;
          }
          tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
        } else {
          logLSPMessage("receive-request", message);
        }
      }
      function traceReceivedNotification(message) {
        if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose) {
            if (message.params) {
              data = `Params: ${JSON.stringify(message.params, null, 4)}

`;
            } else {
              data = "No parameters provided.\n\n";
            }
          }
          tracer.log(`Received notification '${message.method}'.`, data);
        } else {
          logLSPMessage("receive-notification", message);
        }
      }
      function traceReceivedResponse(message, responsePromise) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose) {
            if (message.error && message.error.data) {
              data = `Error data: ${JSON.stringify(message.error.data, null, 4)}

`;
            } else {
              if (message.result) {
                data = `Result: ${JSON.stringify(message.result, null, 4)}

`;
              } else if (message.error === void 0) {
                data = "No result returned.\n\n";
              }
            }
          }
          if (responsePromise) {
            let error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : "";
            tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
          } else {
            tracer.log(`Received response ${message.id} without active response promise.`, data);
          }
        } else {
          logLSPMessage("receive-response", message);
        }
      }
      function logLSPMessage(type, message) {
        if (!tracer || trace === Trace.Off) {
          return;
        }
        const lspMessage = {
          isLSPMessage: true,
          type,
          message,
          timestamp: Date.now()
        };
        tracer.log(lspMessage);
      }
      function throwIfClosedOrDisposed() {
        if (isClosed()) {
          throw new ConnectionError(ConnectionErrors.Closed, "Connection is closed.");
        }
        if (isDisposed()) {
          throw new ConnectionError(ConnectionErrors.Disposed, "Connection is disposed.");
        }
      }
      function throwIfListening() {
        if (isListening()) {
          throw new ConnectionError(ConnectionErrors.AlreadyListening, "Connection is already listening");
        }
      }
      function throwIfNotListening() {
        if (!isListening()) {
          throw new Error("Call listen() first.");
        }
      }
      function undefinedToNull(param) {
        if (param === void 0) {
          return null;
        } else {
          return param;
        }
      }
      function computeMessageParams(type, params) {
        let result;
        let numberOfParams = type.numberOfParams;
        switch (numberOfParams) {
          case 0:
            result = null;
            break;
          case 1:
            result = undefinedToNull(params[0]);
            break;
          default:
            result = [];
            for (let i = 0; i < params.length && i < numberOfParams; i++) {
              result.push(undefinedToNull(params[i]));
            }
            if (params.length < numberOfParams) {
              for (let i = params.length; i < numberOfParams; i++) {
                result.push(null);
              }
            }
            break;
        }
        return result;
      }
      let connection = {
        sendNotification: (type, ...params) => {
          throwIfClosedOrDisposed();
          let method;
          let messageParams;
          if (Is.string(type)) {
            method = type;
            switch (params.length) {
              case 0:
                messageParams = null;
                break;
              case 1:
                messageParams = params[0];
                break;
              default:
                messageParams = params;
                break;
            }
          } else {
            method = type.method;
            messageParams = computeMessageParams(type, params);
          }
          let notificationMessage = {
            jsonrpc: version,
            method,
            params: messageParams
          };
          traceSendingNotification(notificationMessage);
          messageWriter.write(notificationMessage);
        },
        onNotification: (type, handler) => {
          throwIfClosedOrDisposed();
          if (Is.func(type)) {
            starNotificationHandler = type;
          } else if (handler) {
            if (Is.string(type)) {
              notificationHandlers[type] = { type: void 0, handler };
            } else {
              notificationHandlers[type.method] = { type, handler };
            }
          }
        },
        sendRequest: (type, ...params) => {
          throwIfClosedOrDisposed();
          throwIfNotListening();
          let method;
          let messageParams;
          let token = void 0;
          if (Is.string(type)) {
            method = type;
            switch (params.length) {
              case 0:
                messageParams = null;
                break;
              case 1:
                if (cancellation_1.CancellationToken.is(params[0])) {
                  messageParams = null;
                  token = params[0];
                } else {
                  messageParams = undefinedToNull(params[0]);
                }
                break;
              default:
                const last = params.length - 1;
                if (cancellation_1.CancellationToken.is(params[last])) {
                  token = params[last];
                  if (params.length === 2) {
                    messageParams = undefinedToNull(params[0]);
                  } else {
                    messageParams = params.slice(0, last).map((value) => undefinedToNull(value));
                  }
                } else {
                  messageParams = params.map((value) => undefinedToNull(value));
                }
                break;
            }
          } else {
            method = type.method;
            messageParams = computeMessageParams(type, params);
            let numberOfParams = type.numberOfParams;
            token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : void 0;
          }
          let id = sequenceNumber++;
          let result = new Promise((resolve3, reject) => {
            let requestMessage = {
              jsonrpc: version,
              id,
              method,
              params: messageParams
            };
            let responsePromise = { method, timerStart: Date.now(), resolve: resolve3, reject };
            traceSendingRequest(requestMessage);
            try {
              messageWriter.write(requestMessage);
            } catch (e) {
              responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, e.message ? e.message : "Unknown reason"));
              responsePromise = null;
            }
            if (responsePromise) {
              responsePromises[String(id)] = responsePromise;
            }
          });
          if (token) {
            token.onCancellationRequested(() => {
              connection.sendNotification(CancelNotification.type, { id });
            });
          }
          return result;
        },
        onRequest: (type, handler) => {
          throwIfClosedOrDisposed();
          if (Is.func(type)) {
            starRequestHandler = type;
          } else if (handler) {
            if (Is.string(type)) {
              requestHandlers[type] = { type: void 0, handler };
            } else {
              requestHandlers[type.method] = { type, handler };
            }
          }
        },
        trace: (_value, _tracer, sendNotificationOrTraceOptions) => {
          let _sendNotification = false;
          let _traceFormat = TraceFormat.Text;
          if (sendNotificationOrTraceOptions !== void 0) {
            if (Is.boolean(sendNotificationOrTraceOptions)) {
              _sendNotification = sendNotificationOrTraceOptions;
            } else {
              _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
              _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;
            }
          }
          trace = _value;
          traceFormat = _traceFormat;
          if (trace === Trace.Off) {
            tracer = void 0;
          } else {
            tracer = _tracer;
          }
          if (_sendNotification && !isClosed() && !isDisposed()) {
            connection.sendNotification(SetTraceNotification.type, { value: Trace.toString(_value) });
          }
        },
        onError: errorEmitter.event,
        onClose: closeEmitter.event,
        onUnhandledNotification: unhandledNotificationEmitter.event,
        onDispose: disposeEmitter.event,
        dispose: () => {
          if (isDisposed()) {
            return;
          }
          state = ConnectionState.Disposed;
          disposeEmitter.fire(void 0);
          let error = new Error("Connection got disposed.");
          Object.keys(responsePromises).forEach((key) => {
            responsePromises[key].reject(error);
          });
          responsePromises = /* @__PURE__ */ Object.create(null);
          requestTokens = /* @__PURE__ */ Object.create(null);
          messageQueue = new linkedMap_1.LinkedMap();
          if (Is.func(messageWriter.dispose)) {
            messageWriter.dispose();
          }
          if (Is.func(messageReader.dispose)) {
            messageReader.dispose();
          }
        },
        listen: () => {
          throwIfClosedOrDisposed();
          throwIfListening();
          state = ConnectionState.Listening;
          messageReader.listen(callback2);
        },
        inspect: () => {
          console.log("inspect");
        }
      };
      connection.onNotification(LogTraceNotification.type, (params) => {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        tracer.log(params.message, trace === Trace.Verbose ? params.verbose : void 0);
      });
      return connection;
    }
    function isMessageReader(value) {
      return value.listen !== void 0 && value.read === void 0;
    }
    function isMessageWriter(value) {
      return value.write !== void 0 && value.end === void 0;
    }
    function createMessageConnection2(input, output, logger, strategy) {
      if (!logger) {
        logger = exports2.NullLogger;
      }
      let reader = isMessageReader(input) ? input : new messageReader_1.StreamMessageReader(input);
      let writer = isMessageWriter(output) ? output : new messageWriter_1.StreamMessageWriter(output);
      return _createMessageConnection(reader, writer, logger, strategy);
    }
    exports2.createMessageConnection = createMessageConnection2;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/keyExchangeAlgorithm.js
var require_keyExchangeAlgorithm = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/keyExchangeAlgorithm.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.KeyExchangeAlgorithm = void 0;
    var KeyExchangeAlgorithm = class {
      constructor(name, keySizeInBits, hashAlgorithmName, hashDigestLength) {
        this.name = name;
        this.keySizeInBits = keySizeInBits;
        this.hashAlgorithmName = hashAlgorithmName;
        this.hashDigestLength = hashDigestLength;
      }
    };
    exports2.KeyExchangeAlgorithm = KeyExchangeAlgorithm;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/io/bigInt.js
var require_bigInt = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/io/bigInt.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BigInt = void 0;
    var buffer_1 = require("buffer");
    var sshData_1 = require_sshData();
    var BigInt2 = class _BigInt {
      /**
       * Creates a new BigInt instance from a buffer of signed bytes.
       *
       * The first (high) bit of the first (high) byte is the sign bit. Therefore if the
       * highest byte of an unsigned integer is greater than 127, the bytes must include
       * a leading zero byte to prevent interpretation as a negative value.
       */
      constructor(buffer) {
        this.buffer = buffer;
        if (buffer.length === 0) {
          throw new Error("BigInt buffer length must be greater than zero.");
        }
      }
      /**
       * Gets a value that indicates the sign of the big integer:
       * 1 for positive, 0 for zero, -1 for negative.
       */
      get sign() {
        const highByte = this.buffer[0];
        if (highByte === 0) {
          return this.buffer.length > 1 ? 1 : 0;
        } else {
          return (highByte & 128) === 0 ? 1 : -1;
        }
      }
      static fromInt32(value) {
        if (value === 0) {
          return _BigInt.zero;
        }
        let isNegative = false;
        if (value < 0) {
          isNegative = true;
          value = -value;
        }
        const bytes = [];
        for (let bit = 24; bit >= 0; bit -= 8) {
          if (value >= 1 << bit || bytes.length > 0) {
            bytes.push(value >> bit);
            value = value & ~((1 << bit) - 1);
          }
        }
        if (isNegative) {
          if ((bytes[0] & 128) === 0) {
            bytes[0] |= 128;
          } else {
            bytes.splice(0, 0, 128);
          }
        }
        return new _BigInt(buffer_1.Buffer.from(new Uint8Array(bytes)));
      }
      toInt32() {
        if (this.buffer.length > 4) {
          throw new TypeError("BigInt value cannot be converted to a 32-bit signed integer.");
        }
        let value = this.buffer[0];
        if (this.sign < 0) {
          value &= 127;
        }
        for (let i = 1; i < this.buffer.length; i++) {
          value = (value << 8) + this.buffer[i];
        }
        if (this.sign < 0) {
          value = -value;
        }
        return value;
      }
      /**
       * Creates a new BigInt instance from a byte buffer.
       * @param bytes Source byte buffer.
       * @param options.unsigned True if the bytes should be interpreted as unsigned. If false,
       * the high bit of the high byte is the sign bit. The default is false.
       */
      static fromBytes(bytes, options) {
        if (!buffer_1.Buffer.isBuffer(bytes)) {
          throw new TypeError("Buffer expected.");
        } else if (bytes.length === 0) {
          throw new Error("BigInt buffer length must be greater than zero.");
        }
        options = options !== null && options !== void 0 ? options : {};
        const highBit = (bytes[0] & 128) !== 0;
        const prependZeroCount = options.unsigned && highBit ? 1 : 0;
        let skipZeroCount = 0;
        for (let i = 0; i < bytes.length - 1 && bytes[i] === 0; i++) {
          if ((bytes[i + 1] & 128) === 0) {
            skipZeroCount++;
          }
        }
        const newBytes = buffer_1.Buffer.alloc(bytes.length + prependZeroCount - skipZeroCount);
        bytes.copy(newBytes, prependZeroCount, skipZeroCount, bytes.length);
        return new _BigInt(newBytes);
      }
      /**
       * Converts a BigInt instance to a byte buffer.
       *
       * @param options.unsigned True if the returned bytes will be interprted as unsigned.
       * If false, a positive integer may have a leading zero to prevent it from being
       * interpreted as negative.
       * @param options.length Desired length of the resulting buffer. The value will be zero-
       * padded to fill the length. Only applies when `options.unsigned` is true.
       */
      toBytes(options) {
        options = options !== null && options !== void 0 ? options : {};
        let bytes = this.buffer;
        if (options.unsigned) {
          if (this.sign < 0) {
            throw new TypeError("Cannot format a negative BigInt as unsigned.");
          } else if (bytes[0] === 0 && bytes.length > 1) {
            bytes = bytes.slice(1, bytes.length);
          }
          if (options.length !== void 0) {
            if (bytes.length > options.length) {
              throw new Error(`BigInt (${bytes.length} bytes) is too large for length ${options.length}.`);
            } else if (bytes.length < options.length) {
              const padded = buffer_1.Buffer.alloc(options.length);
              bytes.copy(padded, options.length - bytes.length);
              return padded;
            }
          }
        }
        const newBytes = buffer_1.Buffer.alloc(bytes.length);
        bytes.copy(newBytes, 0, 0, bytes.length);
        return newBytes;
      }
      copyTo(buffer, offset = 0) {
        this.buffer.copy(buffer, offset, 0, this.buffer.length);
      }
      equals(other) {
        return other instanceof _BigInt && this.buffer.equals(other.buffer);
      }
      toString(name) {
        return (0, sshData_1.formatBuffer)(this.buffer, name !== null && name !== void 0 ? name : "BigInt");
      }
    };
    exports2.BigInt = BigInt2;
    BigInt2.zero = new BigInt2(buffer_1.Buffer.alloc(1));
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/io/sshData.js
var require_sshData = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/io/sshData.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.formatBuffer = exports2.SshDataWriter = exports2.SshDataReader = void 0;
    var buffer_1 = require("buffer");
    var sshAlgorithms_1 = require_sshAlgorithms();
    var bigInt_1 = require_bigInt();
    var SshDataReader = class {
      constructor(buffer) {
        this.buffer = buffer;
        this.position = 0;
      }
      get available() {
        return this.buffer.length - this.position;
      }
      read(length) {
        if (this.available < length) {
          throw new Error("Attempted to read past end of buffer.");
        }
        const data = this.buffer.slice(this.position, this.position + length);
        this.position += length;
        return data;
      }
      readByte() {
        if (this.available === 0) {
          throw new Error("Attempted to read past end of buffer.");
        }
        const value = this.buffer[this.position];
        this.position++;
        return value;
      }
      readBinary() {
        const length = this.readUInt32();
        if (this.available < length) {
          throw new Error("Attempted to read past end of buffer.");
        }
        const data = this.buffer.slice(this.position, this.position + length);
        this.position += length;
        return data;
      }
      readString(encoding) {
        const bytes = this.readBinary();
        return bytes.toString();
      }
      readList(encoding) {
        const stringList = this.readString(encoding);
        return stringList.length === 0 ? [] : stringList.split(",");
      }
      readBoolean() {
        return this.readByte() !== 0;
      }
      readUInt32() {
        if (this.available < 4) {
          throw new Error("Attempted to read past end of buffer.");
        }
        const value0 = this.buffer[this.position + 0];
        const value1 = this.buffer[this.position + 1];
        const value2 = this.buffer[this.position + 2];
        const value3 = this.buffer[this.position + 3];
        this.position += 4;
        const value = (value0 << 24 | value1 << 16 | value2 << 8 | value3) >>> 0;
        return value;
      }
      readUInt64() {
        if (this.available < 8) {
          throw new Error("Attempted to read past end of buffer.");
        }
        const value0 = this.buffer[this.position + 0];
        const value1 = this.buffer[this.position + 1];
        const value2 = this.buffer[this.position + 2];
        const value3 = this.buffer[this.position + 3];
        const value4 = this.buffer[this.position + 4];
        const value5 = this.buffer[this.position + 5];
        const value6 = this.buffer[this.position + 6];
        const value7 = this.buffer[this.position + 7];
        this.position += 8;
        const high = (value0 << 24 | value1 << 16 | value2 << 8 | value3) >>> 0;
        const low = (value4 << 24 | value5 << 16 | value6 << 8 | value7) >>> 0;
        return high * 4294967296 + low;
      }
      readBigInt() {
        const data = this.readBinary();
        if (data.length === 0) {
          return bigInt_1.BigInt.zero;
        }
        return bigInt_1.BigInt.fromBytes(data);
      }
    };
    exports2.SshDataReader = SshDataReader;
    SshDataReader.mpintZero = buffer_1.Buffer.alloc(1);
    var SshDataWriter = class {
      constructor(buffer) {
        this.buffer = buffer;
        this.position = 0;
      }
      write(data) {
        this.ensureCapacity(this.position + data.length);
        data.copy(this.buffer, this.position);
        this.position += data.length;
      }
      writeByte(value) {
        this.ensureCapacity(this.position + 1);
        this.buffer[this.position] = value;
        this.position++;
      }
      writeBinary(data) {
        this.ensureCapacity(this.position + 4 + data.length);
        this.writeUInt32(data.length);
        data.copy(this.buffer, this.position);
        this.position += data.length;
      }
      writeString(value, encoding) {
        this.writeBinary(buffer_1.Buffer.from(value));
      }
      writeList(value, encoding) {
        this.writeString(value ? value.join(",") : "", encoding);
      }
      writeBoolean(value) {
        this.writeByte(value ? 1 : 0);
      }
      writeUInt32(value) {
        this.ensureCapacity(this.position + 4);
        this.buffer[this.position + 0] = value >>> 24;
        this.buffer[this.position + 1] = value >>> 16;
        this.buffer[this.position + 2] = value >>> 8;
        this.buffer[this.position + 3] = value >>> 0;
        this.position += 4;
      }
      /* @internal */
      static writeUInt32(buffer, offset, value) {
        buffer[offset + 0] = value >>> 24;
        buffer[offset + 1] = value >>> 16;
        buffer[offset + 2] = value >>> 8;
        buffer[offset + 3] = value >>> 0;
      }
      writeUInt64(value) {
        this.ensureCapacity(this.position + 8);
        const low = value & 4294967295;
        const high = (value - low) / 4294967296;
        this.buffer[this.position + 0] = high >>> 24;
        this.buffer[this.position + 1] = high >>> 16;
        this.buffer[this.position + 2] = high >>> 8;
        this.buffer[this.position + 3] = high >>> 0;
        this.buffer[this.position + 4] = low >>> 24;
        this.buffer[this.position + 5] = low >>> 16;
        this.buffer[this.position + 6] = low >>> 8;
        this.buffer[this.position + 7] = low >>> 0;
        this.position += 8;
      }
      writeBigInt(value) {
        const data = value.toBytes();
        if (data.length === 1 && data[0] === 0) {
          this.writeUInt32(0);
        } else {
          this.writeBinary(data);
        }
      }
      writeRandom(length) {
        this.ensureCapacity(this.position + length);
        const randomBuffer = this.buffer.slice(this.position, this.position + length);
        sshAlgorithms_1.SshAlgorithms.random.getBytes(randomBuffer);
        this.position += length;
      }
      skip(length) {
        this.ensureCapacity(this.position + length);
        this.position += length;
      }
      ensureCapacity(capacity) {
        if (this.buffer.length < capacity) {
          let newLength = Math.max(512, this.buffer.length * 2);
          while (newLength < capacity)
            newLength *= 2;
          const newBuffer = buffer_1.Buffer.alloc(newLength);
          this.buffer.copy(newBuffer, 0, 0, this.position);
          this.buffer = newBuffer;
        }
      }
      toBuffer() {
        return this.buffer.slice(0, this.position);
      }
    };
    exports2.SshDataWriter = SshDataWriter;
    function makeCrcTable() {
      let c;
      const table = [];
      for (let n = 0; n < 256; n++) {
        c = n;
        for (let k = 0; k < 8; k++) {
          c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
        }
        table[n] = c;
      }
      return table;
    }
    var crcTable;
    function crc32(data) {
      if (!crcTable) {
        crcTable = makeCrcTable();
      }
      let crc = 0 ^ -1;
      for (let i = 0; i < data.length; i++) {
        crc = crc >>> 8 ^ crcTable[(crc ^ data[i]) & 255];
      }
      const result = (crc ^ -1) >>> 0;
      return (result + 4294967296).toString(16).substr(-8).toUpperCase();
    }
    function formatBuffer(data, name, formatData) {
      let s = `${name === void 0 ? "Buffer" : name}[${data.length}] (${crc32(data)})
`;
      if (formatData === false) {
        return s;
      }
      const max = Math.min(2048, data.length);
      for (let lineOffset = 0; lineOffset < max; lineOffset += 16) {
        if (lineOffset < 1e3)
          s += "0";
        if (lineOffset < 100)
          s += "0";
        if (lineOffset < 10)
          s += "0";
        s += lineOffset + ":";
        for (let i = lineOffset; i < lineOffset + 16; i++) {
          if (i < max) {
            s += " " + data.slice(i, i + 1).toString("hex");
          } else {
            s += "   ";
          }
        }
        s += "  ";
        for (let i = lineOffset; i < lineOffset + 16; i++) {
          if (i < max) {
            const c = data[i];
            s += c > 32 && c <= 127 ? data.slice(i, i + 1).toString() : ".";
          } else {
            s += " ";
          }
        }
        s += "\n";
      }
      if (max < data.length) {
        s += "...\n";
      }
      return s;
    }
    exports2.formatBuffer = formatBuffer;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/publicKeyAlgorithm.js
var require_publicKeyAlgorithm = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/publicKeyAlgorithm.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PublicKeyAlgorithm = void 0;
    var buffer_1 = require("buffer");
    var sshData_1 = require_sshData();
    var PublicKeyAlgorithm = class {
      constructor(name, keyAlgorithmName, hashAlgorithmName) {
        this.name = name;
        this.keyAlgorithmName = keyAlgorithmName;
        this.hashAlgorithmName = hashAlgorithmName;
      }
      readSignatureData(signatureData) {
        const reader = new sshData_1.SshDataReader(signatureData);
        const algorithmName = reader.readString("ascii");
        if (algorithmName !== this.name) {
          throw new Error(`Mismatched public key algorithm: got '${algorithmName}', expected '${this.name}'.`);
        }
        const signature = reader.readBinary();
        return signature;
      }
      createSignatureData(signature) {
        const writer = new sshData_1.SshDataWriter(buffer_1.Buffer.alloc(this.name.length + signature.length + 20));
        writer.writeString(this.name, "ascii");
        writer.writeBinary(signature);
        return writer.toBuffer();
      }
    };
    exports2.PublicKeyAlgorithm = PublicKeyAlgorithm;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/encryptionAlgorithm.js
var require_encryptionAlgorithm = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/encryptionAlgorithm.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EncryptionAlgorithm = void 0;
    var EncryptionAlgorithm = class {
      constructor(name) {
        this.name = name;
      }
    };
    exports2.EncryptionAlgorithm = EncryptionAlgorithm;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/hmacAlgorithm.js
var require_hmacAlgorithm = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/hmacAlgorithm.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.HmacAlgorithm = void 0;
    var HmacAlgorithm = class {
      constructor(name, algorithmName, keyLength, digestLength) {
        this.name = name;
        this.algorithmName = algorithmName;
        this.keyLength = keyLength;
        this.digestLength = digestLength;
      }
    };
    exports2.HmacAlgorithm = HmacAlgorithm;
  }
});

// ../../node_modules/diffie-hellman/index.js
var require_diffie_hellman = __commonJS({
  "../../node_modules/diffie-hellman/index.js"(exports2) {
    "use strict";
    var crypto2 = require("crypto");
    exports2.DiffieHellmanGroup = crypto2.DiffieHellmanGroup;
    exports2.createDiffieHellmanGroup = crypto2.createDiffieHellmanGroup;
    exports2.getDiffieHellman = crypto2.getDiffieHellman;
    exports2.createDiffieHellman = crypto2.createDiffieHellman;
    exports2.DiffieHellman = crypto2.DiffieHellman;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/web/webHmac.js
var require_webHmac = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/web/webHmac.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WebHmac = void 0;
    var buffer_1 = require("buffer");
    var hmacAlgorithm_1 = require_hmacAlgorithm();
    var WebHmac = class _WebHmac extends hmacAlgorithm_1.HmacAlgorithm {
      constructor(name, algorithmName, encryptThenMac = false) {
        super(name, algorithmName, _WebHmac.getHashKeyLength(algorithmName), _WebHmac.getHashDigestLength(algorithmName));
        this.encryptThenMac = encryptThenMac;
      }
      async createSigner(key) {
        const hmac = new WebSignerVerifier(this.algorithmName, true, this.digestLength, this.encryptThenMac);
        await hmac.init(key);
        return hmac;
      }
      async createVerifier(key) {
        const hmac = new WebSignerVerifier(this.algorithmName, false, this.digestLength, this.encryptThenMac);
        await hmac.init(key);
        return hmac;
      }
      static getHashKeyLength(hashAlgorithmName) {
        if (hashAlgorithmName === "SHA2-512")
          return 512 / 8;
        if (hashAlgorithmName === "SHA2-384")
          return 384 / 8;
        if (hashAlgorithmName === "SHA2-256")
          return 256 / 8;
        throw new Error(`Unsupported hash algorithm: ${hashAlgorithmName}`);
      }
      static getHashDigestLength(hashAlgorithmName) {
        return this.getHashKeyLength(hashAlgorithmName);
      }
      static getWebHashAlgorithmName(hashAlgorithmName) {
        if (hashAlgorithmName === "SHA2-512")
          return "SHA-512";
        if (hashAlgorithmName === "SHA2-384")
          return "SHA-384";
        if (hashAlgorithmName === "SHA2-256")
          return "SHA-256";
        throw new Error(`Unsupported hash algorithm: ${hashAlgorithmName}`);
      }
    };
    exports2.WebHmac = WebHmac;
    var WebSignerVerifier = class {
      constructor(algorithmName, isSigning, digestLength, encryptThenMac) {
        this.algorithmName = algorithmName;
        this.isSigning = isSigning;
        this.digestLength = digestLength;
        this.encryptThenMac = encryptThenMac;
      }
      async init(key) {
        try {
          const name = this.algorithmName.replace("SHA2-", "SHA-");
          this.key = await crypto.subtle.importKey("raw", key, { name: "HMAC", hash: { name } }, false, this.isSigning ? ["sign"] : ["verify"]);
        } catch (e) {
          throw new Error("Failed to initialize HMAC: " + e);
        }
      }
      async sign(data) {
        return buffer_1.Buffer.from(await crypto.subtle.sign({ name: "HMAC", hash: { name: this.algorithmName } }, this.key, data));
      }
      async verify(data, signature) {
        return await crypto.subtle.verify({ name: "HMAC", hash: { name: this.algorithmName } }, this.key, signature, data);
      }
      dispose() {
      }
    };
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/ecdsaCurves.js
var require_ecdsaCurves = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/ecdsaCurves.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.curves = void 0;
    exports2.curves = [
      {
        shortName: "P-256",
        name: "nistp256",
        oid: "1.2.840.10045.3.1.7",
        keySize: 256
      },
      {
        shortName: "P-384",
        name: "nistp384",
        oid: "1.3.132.0.34",
        keySize: 384
      },
      {
        shortName: "P-521",
        name: "nistp521",
        oid: "1.3.132.0.35",
        keySize: 521
      }
    ];
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/web/jsonWebKeyFormatter.js
var require_jsonWebKeyFormatter = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/web/jsonWebKeyFormatter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.JsonWebKeyFormatter = void 0;
    var bigInt_1 = require_bigInt();
    var ecdsaCurves_1 = require_ecdsaCurves();
    var JsonWebKeyFormatter = class _JsonWebKeyFormatter {
      static formatRsa(rsa, includePrivate) {
        const formatBigInt = _JsonWebKeyFormatter.formatBigInt;
        let jwk;
        if (includePrivate !== false && rsa.d && rsa.p && rsa.q && rsa.dp && rsa.dq && rsa.qi) {
          jwk = {
            kty: "RSA",
            n: formatBigInt(rsa.modulus),
            e: formatBigInt(rsa.exponent),
            d: formatBigInt(rsa.d),
            p: formatBigInt(rsa.p),
            q: formatBigInt(rsa.q),
            dp: formatBigInt(rsa.dp),
            dq: formatBigInt(rsa.dq),
            qi: formatBigInt(rsa.qi)
          };
        } else if (!includePrivate) {
          jwk = {
            kty: "RSA",
            n: formatBigInt(rsa.modulus),
            e: formatBigInt(rsa.exponent)
          };
        } else {
          throw new Error("Missing private key parameters.");
        }
        return jwk;
      }
      static parseRsa(jwk, includePrivate) {
        if ((jwk === null || jwk === void 0 ? void 0 : jwk.kty) !== "RSA" || !(jwk.n && jwk.e))
          throw new Error("Invalid RSA JWK.");
        const parseBigInt = _JsonWebKeyFormatter.parseBigInt;
        let rsa;
        if (includePrivate !== false && jwk.d && jwk.p && jwk.q && jwk.dp && jwk.dq && jwk.qi) {
          rsa = {
            modulus: parseBigInt(jwk.n),
            exponent: parseBigInt(jwk.e),
            d: parseBigInt(jwk.d),
            p: parseBigInt(jwk.p),
            q: parseBigInt(jwk.q),
            dp: parseBigInt(jwk.dp),
            dq: parseBigInt(jwk.dq),
            qi: parseBigInt(jwk.qi)
          };
        } else {
          rsa = {
            modulus: parseBigInt(jwk.n),
            exponent: parseBigInt(jwk.e)
          };
        }
        return rsa;
      }
      static formatEC(ec, includePrivate) {
        const formatBigInt = _JsonWebKeyFormatter.formatBigInt;
        const curve = ecdsaCurves_1.curves.find((c) => c.oid === ec.curve.oid || c.name === ec.curve.name || c.shortName === ec.curve.name);
        const keySizeInBytes = Math.ceil(curve.keySize / 8);
        const jwk = {
          kty: "EC",
          crv: ec.curve.name,
          x: formatBigInt(ec.x, keySizeInBytes),
          y: formatBigInt(ec.y, keySizeInBytes)
        };
        if (includePrivate !== false && ec.d) {
          jwk.d = formatBigInt(ec.d, keySizeInBytes);
        } else if (includePrivate) {
          throw new Error("Missing private key parameters.");
        }
        return jwk;
      }
      static parseEC(jwk, includePrivate) {
        if ((jwk === null || jwk === void 0 ? void 0 : jwk.kty) !== "EC" || !(jwk.crv && jwk.x && jwk.y))
          throw new Error("Invalid EC JWK.");
        const parseBigInt = _JsonWebKeyFormatter.parseBigInt;
        const ec = {
          curve: { name: jwk.crv },
          x: parseBigInt(jwk.x),
          y: parseBigInt(jwk.y)
        };
        if (includePrivate !== false && jwk.d) {
          ec.d = parseBigInt(jwk.d);
        }
        return ec;
      }
      static formatBigInt(value, length) {
        return _JsonWebKeyFormatter.base64UrlEncode(value.toBytes({ unsigned: true, length }));
      }
      static parseBigInt(value) {
        return bigInt_1.BigInt.fromBytes(Buffer.from(value, "base64"), { unsigned: true });
      }
      static base64UrlEncode(data) {
        return data.toString("base64").replace(/=+$/g, "").replace(/\+/g, "-").replace(/\//g, "_");
      }
    };
    exports2.JsonWebKeyFormatter = JsonWebKeyFormatter;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/web/webKeyExchange.js
var require_webKeyExchange = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/web/webKeyExchange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WebECDiffieHellman = exports2.WebDiffieHellman = void 0;
    var buffer_1 = require("buffer");
    var diffie_hellman_1 = require_diffie_hellman();
    var keyExchangeAlgorithm_1 = require_keyExchangeAlgorithm();
    var webHmac_1 = require_webHmac();
    var bigInt_1 = require_bigInt();
    var jsonWebKeyFormatter_1 = require_jsonWebKeyFormatter();
    var WebDiffieHellman = class extends keyExchangeAlgorithm_1.KeyExchangeAlgorithm {
      constructor(name, keySizeInBits, hashAlgorithmName) {
        super(name, keySizeInBits, hashAlgorithmName, webHmac_1.WebHmac.getHashDigestLength(hashAlgorithmName));
      }
      createKeyExchange() {
        return new WebDiffieHellmanKex(this.keySizeInBits, webHmac_1.WebHmac.getWebHashAlgorithmName(this.hashAlgorithmName), this.hashDigestLength);
      }
    };
    exports2.WebDiffieHellman = WebDiffieHellman;
    var WebDiffieHellmanKex = class {
      constructor(bitLength, hashAlgorithmName, digestLength) {
        this.hashAlgorithmName = hashAlgorithmName;
        this.digestLength = digestLength;
        switch (bitLength) {
          case 1024:
            this.dh = (0, diffie_hellman_1.getDiffieHellman)("modp2");
            break;
          case 2048:
            this.dh = (0, diffie_hellman_1.getDiffieHellman)("modp14");
            break;
          case 4096:
            this.dh = (0, diffie_hellman_1.getDiffieHellman)("modp16");
            break;
          default:
            throw new Error("Invalid DH bit length.");
        }
      }
      startKeyExchange() {
        const exchangeValueKeys = this.dh.generateKeys();
        const exchangeValue = bigInt_1.BigInt.fromBytes(exchangeValueKeys, { unsigned: true }).toBytes();
        return Promise.resolve(exchangeValue);
      }
      decryptKeyExchange(exchangeValue) {
        const key = this.dh.computeSecret(exchangeValue);
        const sharedSecret = bigInt_1.BigInt.fromBytes(key, { unsigned: true }).toBytes();
        return Promise.resolve(sharedSecret);
      }
      async sign(data) {
        const hashBuffer = await crypto.subtle.digest(this.hashAlgorithmName, data);
        return buffer_1.Buffer.from(hashBuffer);
      }
      dispose() {
      }
    };
    var WebECDiffieHellman = class extends keyExchangeAlgorithm_1.KeyExchangeAlgorithm {
      constructor(name, keySizeInBits, hashAlgorithmName) {
        super(name, keySizeInBits, hashAlgorithmName, webHmac_1.WebHmac.getHashDigestLength(hashAlgorithmName));
      }
      createKeyExchange() {
        return new WebECDiffieHellmanKex(this.keySizeInBits, webHmac_1.WebHmac.getWebHashAlgorithmName(this.hashAlgorithmName), this.hashDigestLength);
      }
    };
    exports2.WebECDiffieHellman = WebECDiffieHellman;
    var WebECDiffieHellmanKex = class {
      constructor(bitLength, hashAlgorithmName, digestLength) {
        this.bitLength = bitLength;
        this.hashAlgorithmName = hashAlgorithmName;
        this.digestLength = digestLength;
        this.algorithm = {
          name: "ECDH",
          namedCurve: "P-" + bitLength
        };
      }
      async startKeyExchange() {
        if (!this.keyPair) {
          this.keyPair = await crypto.subtle.generateKey(
            this.algorithm,
            true,
            // exportable
            ["deriveBits"]
          );
        }
        const jwk = await crypto.subtle.exportKey("jwk", this.keyPair.publicKey);
        const ec = jsonWebKeyFormatter_1.JsonWebKeyFormatter.parseEC(jwk);
        const length = Math.ceil(this.bitLength / 8);
        const publicKeyBytes = buffer_1.Buffer.alloc(1 + length * 2);
        publicKeyBytes[0] = 4;
        ec.x.toBytes({ unsigned: true, length }).copy(publicKeyBytes, 1);
        ec.y.toBytes({ unsigned: true, length }).copy(publicKeyBytes, 1 + length);
        return buffer_1.Buffer.from(publicKeyBytes);
      }
      async decryptKeyExchange(exchangeValue) {
        if (!this.keyPair) {
          throw new Error("Key exchange not started.");
        }
        const xy = exchangeValue;
        const jwk = jsonWebKeyFormatter_1.JsonWebKeyFormatter.formatEC({
          curve: { name: this.algorithm.namedCurve },
          x: bigInt_1.BigInt.fromBytes(xy.slice(1, 1 + (xy.length - 1) / 2), { unsigned: true }),
          y: bigInt_1.BigInt.fromBytes(xy.slice(1 + (xy.length - 1) / 2), { unsigned: true })
        });
        const otherPublicKey = await crypto.subtle.importKey("jwk", jwk, this.algorithm, false, []);
        const sharedSecretBytes = buffer_1.Buffer.from(await crypto.subtle.deriveBits(Object.assign(Object.assign({}, this.algorithm), { public: otherPublicKey }), this.keyPair.privateKey, Math.ceil(this.bitLength / 8) * 8));
        const sharedSecret = bigInt_1.BigInt.fromBytes(sharedSecretBytes, { unsigned: true }).toBytes();
        return sharedSecret;
      }
      async sign(data) {
        const hashBuffer = await crypto.subtle.digest(this.hashAlgorithmName, data);
        return buffer_1.Buffer.from(hashBuffer);
      }
      dispose() {
      }
    };
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/web/webRsa.js
var require_webRsa = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/web/webRsa.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WebRsa = void 0;
    var buffer_1 = require("buffer");
    var publicKeyAlgorithm_1 = require_publicKeyAlgorithm();
    var webHmac_1 = require_webHmac();
    var sshData_1 = require_sshData();
    var jsonWebKeyFormatter_1 = require_jsonWebKeyFormatter();
    var WebRsaKeyPair = class _WebRsaKeyPair {
      /* @internal */
      constructor(hashAlgorithm) {
        this.hashAlgorithm = hashAlgorithm;
        this.comment = null;
      }
      get hasPublicKey() {
        return !!this.publicKey;
      }
      get hasPrivateKey() {
        return !!this.privateKey;
      }
      get keyAlgorithmName() {
        return WebRsa.keyAlgorithmName;
      }
      async generate(keySizeInBits) {
        keySizeInBits = keySizeInBits !== null && keySizeInBits !== void 0 ? keySizeInBits : _WebRsaKeyPair.defaultKeySize;
        try {
          const keyGenParams = {
            name: "RSASSA-PKCS1-v1_5",
            modulusLength: keySizeInBits,
            publicExponent: new Uint8Array([1, 0, 1]),
            hash: { name: this.hashAlgorithm }
          };
          const keyPair = await crypto.subtle.generateKey(keyGenParams, true, ["sign", "verify"]);
          this.publicKey = keyPair.publicKey;
          this.privateKey = keyPair.privateKey;
        } catch (e) {
          throw new Error("Failed to generate RSA key pair: " + e);
        }
      }
      async setPublicKeyBytes(keyBytes) {
        if (!keyBytes) {
          throw new TypeError("Buffer is required.");
        }
        const reader = new sshData_1.SshDataReader(keyBytes);
        const algorithmName = reader.readString("ascii");
        if (algorithmName !== this.keyAlgorithmName && algorithmName !== WebRsa.rsaWithSha256 && algorithmName !== WebRsa.rsaWithSha512) {
          throw new Error(`Invalid RSA key algorithm: ${algorithmName}`);
        }
        const exponent = reader.readBigInt();
        const modulus = reader.readBigInt();
        const jwk = jsonWebKeyFormatter_1.JsonWebKeyFormatter.formatRsa({ modulus, exponent }, false);
        jwk.alg = "RS" + this.hashAlgorithm.replace("SHA-", "");
        jwk.key_ops = ["verify"];
        try {
          const importParams = {
            name: "RSASSA-PKCS1-v1_5",
            hash: { name: this.hashAlgorithm }
          };
          this.publicKey = await crypto.subtle.importKey("jwk", jwk, importParams, true, ["verify"]);
        } catch (e) {
          throw new Error("Failed to import RSA public key: " + e);
        }
      }
      async getPublicKeyBytes(algorithmName) {
        if (!this.publicKey) {
          return null;
        }
        if (!algorithmName) {
          algorithmName = this.keyAlgorithmName;
        }
        let jwk;
        try {
          jwk = await crypto.subtle.exportKey("jwk", this.publicKey);
        } catch (e) {
          throw new Error("Failed to export RSA public key: " + e);
        }
        const { modulus, exponent } = jsonWebKeyFormatter_1.JsonWebKeyFormatter.parseRsa(jwk, false);
        const keyBuffer = buffer_1.Buffer.alloc(512);
        const keyWriter = new sshData_1.SshDataWriter(keyBuffer);
        keyWriter.writeString(algorithmName, "ascii");
        keyWriter.writeBigInt(exponent);
        keyWriter.writeBigInt(modulus);
        const keyBytes = keyWriter.toBuffer();
        return keyBytes;
      }
      async importParameters(parameters) {
        const privateJwk = parameters.d ? jsonWebKeyFormatter_1.JsonWebKeyFormatter.formatRsa(parameters, true) : null;
        const publicJwk = jsonWebKeyFormatter_1.JsonWebKeyFormatter.formatRsa(parameters, false);
        const importParams = {
          name: "RSASSA-PKCS1-v1_5",
          hash: { name: this.hashAlgorithm }
        };
        try {
          this.publicKey = await crypto.subtle.importKey("jwk", publicJwk, importParams, true, [
            "verify"
          ]);
          if (privateJwk) {
            this.privateKey = await crypto.subtle.importKey("jwk", privateJwk, importParams, true, [
              "sign"
            ]);
          } else {
            this.privateKey = void 0;
          }
        } catch (e) {
          if (!(e instanceof Error))
            throw e;
          throw new Error("Failed to import RSA key pair: " + e.message);
        }
      }
      async exportParameters() {
        var _a;
        if (!this.publicKey)
          throw new Error("Public key not set.");
        let jwk;
        try {
          jwk = await crypto.subtle.exportKey("jwk", (_a = this.privateKey) !== null && _a !== void 0 ? _a : this.publicKey);
        } catch (e) {
          if (!(e instanceof Error))
            throw e;
          throw new Error("Failed to export RSA public key: " + e.message);
        }
        return jsonWebKeyFormatter_1.JsonWebKeyFormatter.parseRsa(jwk, !!this.privateKey);
      }
      dispose() {
      }
    };
    WebRsaKeyPair.defaultKeySize = 2048;
    var WebRsa = class _WebRsa extends publicKeyAlgorithm_1.PublicKeyAlgorithm {
      constructor(name, hashAlgorithmName) {
        super(name, _WebRsa.keyAlgorithmName, hashAlgorithmName);
      }
      createKeyPair() {
        const hashAlgorithm = _WebRsa.convertHashAlgorithmName(this.hashAlgorithmName);
        return new WebRsaKeyPair(hashAlgorithm);
      }
      async generateKeyPair(keySizeInBits) {
        const hashAlgorithm = _WebRsa.convertHashAlgorithmName(this.hashAlgorithmName);
        const rsaKey = new WebRsaKeyPair(hashAlgorithm);
        await rsaKey.generate(keySizeInBits);
        return rsaKey;
      }
      createSigner(keyPair) {
        if (!(keyPair instanceof WebRsaKeyPair)) {
          throw new TypeError("RSA key pair object expected.");
        }
        const hashAlgorithm = _WebRsa.convertHashAlgorithmName(this.hashAlgorithmName);
        return new WebRsaSignerVerifier(keyPair, hashAlgorithm, webHmac_1.WebHmac.getHashDigestLength(this.hashAlgorithmName));
      }
      createVerifier(keyPair) {
        if (!(keyPair instanceof WebRsaKeyPair)) {
          throw new TypeError("RSA key pair object expected.");
        }
        const hashAlgorithm = _WebRsa.convertHashAlgorithmName(this.hashAlgorithmName);
        return new WebRsaSignerVerifier(keyPair, hashAlgorithm, webHmac_1.WebHmac.getHashDigestLength(this.hashAlgorithmName));
      }
      static convertHashAlgorithmName(hashAlgorithmName) {
        return hashAlgorithmName.replace("SHA2-", "SHA-");
      }
    };
    exports2.WebRsa = WebRsa;
    WebRsa.keyAlgorithmName = "ssh-rsa";
    WebRsa.rsaWithSha256 = "rsa-sha2-256";
    WebRsa.rsaWithSha512 = "rsa-sha2-512";
    WebRsa.KeyPair = WebRsaKeyPair;
    var WebRsaSignerVerifier = class {
      constructor(keyPair, hashAlgorithm, digestLength) {
        this.keyPair = keyPair;
        this.hashAlgorithm = hashAlgorithm;
        this.digestLength = digestLength;
      }
      async sign(data) {
        if (!this.keyPair.privateKey) {
          throw new Error("Private key not set.");
        }
        await this.convertKeyHashAlgorithm();
        const signature = buffer_1.Buffer.from(await crypto.subtle.sign("RSASSA-PKCS1-v1_5", this.keyPair.privateKey, data));
        return signature;
      }
      async verify(data, signature) {
        if (!this.keyPair.publicKey) {
          throw new Error("Public key not set.");
        }
        await this.convertKeyHashAlgorithm();
        const result = await crypto.subtle.verify("RSASSA-PKCS1-v1_5", this.keyPair.publicKey, signature, data);
        return result;
      }
      async convertKeyHashAlgorithm() {
        if (this.keyPair.hashAlgorithm !== this.hashAlgorithm) {
          const parameters = await this.keyPair.exportParameters();
          this.keyPair = new WebRsaKeyPair(this.hashAlgorithm);
          await this.keyPair.importParameters(parameters);
        }
      }
      dispose() {
      }
    };
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/web/webECDsa.js
var require_webECDsa = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/web/webECDsa.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WebECDsa = void 0;
    var buffer_1 = require("buffer");
    var publicKeyAlgorithm_1 = require_publicKeyAlgorithm();
    var sshData_1 = require_sshData();
    var ecdsaCurves_1 = require_ecdsaCurves();
    var bigInt_1 = require_bigInt();
    var jsonWebKeyFormatter_1 = require_jsonWebKeyFormatter();
    var WebECDsaKeyPair = class {
      /**
       * Constructs a new ECDSA key pair object.
       *
       * @param algorithmName Key pair algorithm name. If unspecified, the key pair object must be
       * initialized before use via `importParameters()`.
       */
      constructor(algorithmName) {
        this.comment = null;
        if (algorithmName) {
          this.algorithmName = algorithmName;
        }
      }
      get hasPublicKey() {
        return !!this.publicKey;
      }
      get hasPrivateKey() {
        return !!this.privateKey;
      }
      get keyAlgorithmName() {
        return this.algorithmName;
      }
      get algorithmName() {
        return this.algorithm;
      }
      set algorithmName(value) {
        const curveName = value.split("-")[2];
        this.curve = ecdsaCurves_1.curves.find((c) => c.name === curveName);
        if (!this.curve) {
          throw new Error("Invalid or unsupported ECDSA algorithm: " + value);
        }
        this.algorithm = value;
      }
      async generate() {
        try {
          const keyGenParams = {
            name: "ECDSA",
            namedCurve: this.curve.shortName
          };
          const keyPair = await crypto.subtle.generateKey(keyGenParams, true, ["sign", "verify"]);
          this.publicKey = keyPair.publicKey;
          this.privateKey = keyPair.privateKey;
        } catch (e) {
          throw new Error("Failed to generate RSA key pair: " + e);
        }
      }
      async setPublicKeyBytes(keyBytes, algorithmName) {
        if (!keyBytes) {
          throw new TypeError("Buffer is required.");
        }
        const reader = new sshData_1.SshDataReader(keyBytes);
        const readAlgorithmName = reader.readString("ascii");
        this.algorithmName = algorithmName || readAlgorithmName;
        const curveName = reader.readString("ascii");
        if (curveName !== this.curve.name) {
          throw new Error("EC curve name does not match.");
        }
        const key = reader.readBinary();
        const n = Math.ceil(this.curve.keySize / 8);
        const x = bigInt_1.BigInt.fromBytes(key.slice(1, 1 + n), { unsigned: true });
        const y = bigInt_1.BigInt.fromBytes(key.slice(1 + n, key.length), { unsigned: true });
        const jwk = jsonWebKeyFormatter_1.JsonWebKeyFormatter.formatEC({
          curve: { name: this.curve.shortName, oid: this.curve.oid },
          x,
          y
        });
        try {
          const importParams = {
            name: "ECDSA",
            namedCurve: this.curve.shortName
          };
          this.publicKey = await crypto.subtle.importKey("jwk", jwk, importParams, true, ["verify"]);
        } catch (e) {
          throw new Error("Failed to import EC public key: " + e);
        }
      }
      async getPublicKeyBytes(algorithmName) {
        if (!this.publicKey) {
          return null;
        }
        let jwk;
        try {
          jwk = await crypto.subtle.exportKey("jwk", this.publicKey);
        } catch (e) {
          throw new Error("Failed to export ECDSA public key: " + e);
        }
        const x = buffer_1.Buffer.from(jwk.x, "base64");
        const y = buffer_1.Buffer.from(jwk.y, "base64");
        const n = Math.ceil(this.curve.keySize / 8);
        if (x.length !== n || y.length !== n) {
          throw new Error("Unexpected key length.");
        }
        algorithmName = algorithmName || this.algorithmName || this.keyAlgorithmName;
        const keyBuffer = buffer_1.Buffer.alloc(algorithmName.length + x.length + y.length + 10);
        const keyWriter = new sshData_1.SshDataWriter(keyBuffer);
        keyWriter.writeString(algorithmName, "ascii");
        keyWriter.writeString(this.curve.name, "ascii");
        keyWriter.writeUInt32(1 + x.length + y.length);
        keyWriter.writeByte(4);
        keyWriter.write(x);
        keyWriter.write(y);
        const keyBytes = keyWriter.toBuffer();
        return keyBytes;
      }
      async importParameters(parameters) {
        if (!parameters.curve)
          throw new TypeError("A curve is required.");
        let curve;
        if (parameters.curve.oid) {
          curve = ecdsaCurves_1.curves.find((c) => c.oid === parameters.curve.oid);
          if (!curve) {
            throw new Error(`Unsupported curve OID: ${parameters.curve.oid}`);
          }
        } else if (parameters.curve.name) {
          curve = ecdsaCurves_1.curves.find((c) => c.name === parameters.curve.name);
          if (!curve) {
            throw new Error(`Unsupported curve: ${parameters.curve.name}`);
          }
        } else {
          throw new TypeError("A curve OID or name is required.");
        }
        this.algorithmName = "ecdsa-sha2-" + curve.name;
        const importParams = {
          name: "ECDSA",
          namedCurve: this.curve.shortName
        };
        const jwk = jsonWebKeyFormatter_1.JsonWebKeyFormatter.formatEC(parameters);
        jwk.crv = this.curve.shortName;
        try {
          if (jwk.d) {
            this.privateKey = await crypto.subtle.importKey("jwk", jwk, importParams, true, [
              "sign"
            ]);
            jwk.d = void 0;
          } else {
            this.privateKey = void 0;
          }
          this.publicKey = await crypto.subtle.importKey("jwk", jwk, importParams, true, ["verify"]);
        } catch (e) {
          throw new Error("Failed to import ECDSA key pair: " + e);
        }
      }
      async exportParameters() {
        var _a;
        const exportKey = (_a = this.privateKey) !== null && _a !== void 0 ? _a : this.publicKey;
        if (!exportKey) {
          throw new Error("Key not present.");
        }
        let jwk;
        try {
          jwk = await crypto.subtle.exportKey("jwk", exportKey);
        } catch (e) {
          throw new Error("Failed to export ECDSA key pair: " + e);
        }
        const parameters = jsonWebKeyFormatter_1.JsonWebKeyFormatter.parseEC(jwk);
        parameters.curve = { name: this.curve.name, oid: this.curve.oid };
        return parameters;
      }
      dispose() {
      }
    };
    var WebECDsa = class _WebECDsa extends publicKeyAlgorithm_1.PublicKeyAlgorithm {
      constructor(name, hashAlgorithmName) {
        super(name, name, hashAlgorithmName);
      }
      createKeyPair() {
        return new WebECDsaKeyPair(this.name);
      }
      async generateKeyPair() {
        const ecdsaKey = new WebECDsaKeyPair(this.name);
        await ecdsaKey.generate();
        return ecdsaKey;
      }
      createSigner(keyPair) {
        if (!(keyPair instanceof WebECDsaKeyPair)) {
          throw new TypeError("ECDSA key pair object expected.");
        }
        const hashAlgorithm = _WebECDsa.convertHashAlgorithmName(this.hashAlgorithmName);
        return new WebECDsaSignerVerifier(keyPair, hashAlgorithm);
      }
      createVerifier(keyPair) {
        if (!(keyPair instanceof WebECDsaKeyPair)) {
          throw new TypeError("ECDSA key pair object expected.");
        }
        const hashAlgorithm = _WebECDsa.convertHashAlgorithmName(this.hashAlgorithmName);
        return new WebECDsaSignerVerifier(keyPair, hashAlgorithm);
      }
      static convertHashAlgorithmName(hashAlgorithmName) {
        return hashAlgorithmName.replace("SHA2-", "SHA-");
      }
      /* @internal */
      static getSignatureLength(keySizeInBits) {
        const keySizeInBytes = Math.ceil(keySizeInBits / 8);
        return (4 + 1 + keySizeInBytes) * 2;
      }
    };
    exports2.WebECDsa = WebECDsa;
    WebECDsa.ecdsaSha2Nistp256 = "ecdsa-sha2-nistp256";
    WebECDsa.ecdsaSha2Nistp384 = "ecdsa-sha2-nistp384";
    WebECDsa.ecdsaSha2Nistp521 = "ecdsa-sha2-nistp521";
    WebECDsa.curves = ecdsaCurves_1.curves;
    WebECDsa.KeyPair = WebECDsaKeyPair;
    var WebECDsaSignerVerifier = class {
      constructor(keyPair, hashAlgorithm) {
        this.keyPair = keyPair;
        this.hashAlgorithm = hashAlgorithm;
      }
      get digestLength() {
        const curve = this.keyPair.curve;
        if (!curve) {
          return 0;
        } else {
          return WebECDsa.getSignatureLength(curve.keySize);
        }
      }
      async sign(data) {
        if (!this.keyPair.privateKey) {
          throw new Error("Private key not set.");
        }
        let signature = buffer_1.Buffer.from(await crypto.subtle.sign({ name: "ECDSA", hash: { name: this.hashAlgorithm } }, this.keyPair.privateKey, data));
        const keySizeInBytes = Math.ceil(this.keyPair.curve.keySize / 8);
        if (signature.length !== 2 * keySizeInBytes) {
          throw new Error(`Unexpected signature length: ${signature.length}`);
        }
        const x = bigInt_1.BigInt.fromBytes(signature.slice(0, keySizeInBytes), { unsigned: true });
        const y = bigInt_1.BigInt.fromBytes(signature.slice(keySizeInBytes, signature.length), {
          unsigned: true
        });
        const signatureWriter = new sshData_1.SshDataWriter(buffer_1.Buffer.alloc(this.digestLength));
        signatureWriter.writeBinary(x.toBytes({ unsigned: true, length: keySizeInBytes + 1 }));
        signatureWriter.writeBinary(y.toBytes({ unsigned: true, length: keySizeInBytes + 1 }));
        signature = signatureWriter.toBuffer();
        return signature;
      }
      async verify(data, signature) {
        if (!this.keyPair.publicKey) {
          throw new Error("Public key not set.");
        }
        const signatureReader = new sshData_1.SshDataReader(signature);
        const x = signatureReader.readBigInt();
        const y = signatureReader.readBigInt();
        const keySizeInBytes = Math.ceil(this.keyPair.curve.keySize / 8);
        signature = buffer_1.Buffer.alloc(2 * keySizeInBytes);
        x.toBytes({ unsigned: true, length: keySizeInBytes }).copy(signature, 0);
        y.toBytes({ unsigned: true, length: keySizeInBytes }).copy(signature, keySizeInBytes);
        const result = await crypto.subtle.verify({ name: "ECDSA", hash: { name: this.hashAlgorithm } }, this.keyPair.publicKey, signature, data);
        return result;
      }
      dispose() {
      }
    };
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/web/webEncryption.js
var require_webEncryption = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/web/webEncryption.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WebEncryption = void 0;
    var buffer_1 = require("buffer");
    var encryptionAlgorithm_1 = require_encryptionAlgorithm();
    var WebEncryption = class _WebEncryption extends encryptionAlgorithm_1.EncryptionAlgorithm {
      constructor(name, algorithmName, cipherMode, keySizeInBits) {
        super(name);
        this.algorithmName = algorithmName;
        this.cipherMode = cipherMode;
        this.keySizeInBits = keySizeInBits;
        this.blockSizeInBits = _WebEncryption.getBlockSize(algorithmName);
      }
      get keyLength() {
        return this.keySizeInBits / 8;
      }
      get blockLength() {
        return this.blockSizeInBits / 8;
      }
      async createCipher(isEncryption, key, iv) {
        const cipher = new WebCipher(isEncryption, this.algorithmName, this.cipherMode, this.keySizeInBits, this.blockSizeInBits);
        await cipher.init(key, iv);
        return cipher;
      }
      static getBlockSize(algorithmName) {
        if (algorithmName === "AES") {
          return 128;
        } else {
          throw new Error(`Unsupported encryption algorithm: ${algorithmName}`);
        }
      }
    };
    exports2.WebEncryption = WebEncryption;
    var WebCipher = class {
      get blockLength() {
        return this.blockSizeInBits / 8;
      }
      constructor(isEncryption, algorithmName, cipherMode, keySizeInBits, blockSizeInBits) {
        this.isEncryption = isEncryption;
        this.algorithmName = algorithmName;
        this.cipherMode = cipherMode;
        this.keySizeInBits = keySizeInBits;
        this.blockSizeInBits = blockSizeInBits;
        this.tag = null;
        if (this.algorithmName === "AES" && this.cipherMode === "CTR") {
          this.transform = this.aesCtr.bind(this, isEncryption);
        } else if (this.algorithmName === "AES" && this.cipherMode === "CBC") {
          this.transform = this.aesCbc.bind(this, isEncryption);
        } else if (this.algorithmName === "AES" && this.cipherMode === "GCM") {
          this.transform = this.aesGcm.bind(this, isEncryption);
          this.associatedData = buffer_1.Buffer.alloc(4);
          this.decryptBuffer = buffer_1.Buffer.alloc(this.blockLength * 4);
        } else {
          throw new Error(`Unsupported encryption algorithm: ${this.algorithmName}-${this.cipherMode}`);
        }
      }
      async init(key, iv) {
        try {
          const name = `${this.algorithmName}-${this.cipherMode}`;
          this.key = await crypto.subtle.importKey("raw", key, { name, length: this.keySizeInBits }, false, this.isEncryption ? ["encrypt"] : ["decrypt"]);
        } catch (e) {
          throw new Error("Failed to initialize AES: " + e);
        }
        if (this.cipherMode === "GCM") {
          this.iv = buffer_1.Buffer.from(iv.slice(0, 12));
        } else {
          this.iv = buffer_1.Buffer.from(iv);
        }
      }
      async aesCtr(isEncryption, data) {
        if (data.length % this.blockLength !== 0) {
          const message = `Encrypt/decrypt input has invalid length ${data.length}, not a multiple of block size ${this.blockLength}.`;
          throw new Error(message);
        }
        let result;
        if (isEncryption) {
          result = buffer_1.Buffer.from(await crypto.subtle.encrypt({ name: "AES-CTR", counter: this.iv, length: this.blockSizeInBits }, this.key, data));
        } else {
          result = buffer_1.Buffer.from(await crypto.subtle.decrypt({ name: "AES-CTR", counter: this.iv, length: this.blockSizeInBits }, this.key, data));
        }
        if (result.length !== data.length) {
          const message = `Result from encrypt/decrypt has invalid length ${result.length}, expected ${data.length}.`;
          throw new Error(message);
        }
        const incrementCount = data.length / this.blockLength;
        for (let i = 0; i < incrementCount; i++) {
          for (let k = this.iv.length - 1; k >= 0; k--) {
            this.iv[k] = this.iv[k] + 1;
            if (this.iv[k])
              break;
          }
        }
        return result;
      }
      async aesCbc(isEncryption, data) {
        if (isEncryption) {
          let result = buffer_1.Buffer.from(await crypto.subtle.encrypt({ name: "AES-CBC", iv: this.iv }, this.key, data));
          result = result.slice(0, data.length);
          return result;
        } else {
          return buffer_1.Buffer.from(await crypto.subtle.decrypt({ name: "AES-CBC", iv: this.iv }, this.key, data));
        }
      }
      async aesGcm(isEncryption, data) {
        if (data.length % this.blockLength !== 0) {
          const message = `Encrypt/decrypt input has invalid length ${data.length}, not a multiple of block size ${this.blockLength}.`;
          throw new Error(message);
        }
        const packetLength = data.length;
        this.associatedData[0] = packetLength >>> 24;
        this.associatedData[1] = packetLength >>> 16;
        this.associatedData[2] = packetLength >>> 8;
        this.associatedData[3] = packetLength;
        let result;
        if (isEncryption) {
          result = buffer_1.Buffer.from(await crypto.subtle.encrypt({
            name: "AES-GCM",
            iv: this.iv,
            additionalData: this.associatedData,
            tagLength: this.digestLength * 8
            // tagLength is in bits, not bytes
          }, this.key, data));
          this.tag = result.slice(result.length - this.digestLength);
          result = result.slice(0, result.length - this.digestLength);
        } else {
          if (!this.tag) {
            throw new Error("AES-GCM tag was not set before decrypting.");
          }
          const inputLength = data.length + this.digestLength;
          if (this.decryptBuffer.length < inputLength) {
            let newLength = this.decryptBuffer.length * 2;
            while (newLength < inputLength)
              newLength *= 2;
            this.decryptBuffer = buffer_1.Buffer.alloc(newLength);
          }
          const input = this.decryptBuffer.slice(0, inputLength);
          data.copy(input, 0);
          this.tag.copy(input, data.length);
          result = buffer_1.Buffer.from(await crypto.subtle.decrypt({
            name: "AES-GCM",
            iv: this.iv,
            additionalData: this.associatedData,
            tagLength: this.digestLength * 8
            // tagLength is in bits, not bytes
          }, this.key, input));
        }
        if (result.length !== data.length) {
          const message = `Result from encrypt/decrypt has invalid length ${result.length}, expected ${data.length}.`;
          throw new Error(message);
        }
        let k = 12;
        while (--k >= 4) {
          this.iv[k]++;
          if (this.iv[k] !== 0) {
            break;
          }
        }
        return result;
      }
      get digestLength() {
        return 16;
      }
      get authenticatedEncryption() {
        return this.cipherMode === "GCM";
      }
      async sign(data) {
        if (!this.tag) {
          throw new Error("AES-GCM tag was not obtained by encrypting.");
        }
        return this.tag;
      }
      async verify(data, signature) {
        if (signature.length !== this.digestLength) {
          throw new Error("Incorrect AES-GCM tag length.");
        }
        this.tag = signature;
        return true;
      }
      dispose() {
      }
    };
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/web/webRandom.js
var require_webRandom = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/web/webRandom.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WebRandom = void 0;
    var WebRandom = class {
      getBytes(buffer) {
        crypto.getRandomValues(buffer);
      }
    };
    exports2.WebRandom = WebRandom;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/node/nodeHmac.js
var require_nodeHmac = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/node/nodeHmac.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NodeHmac = void 0;
    var crypto2 = require("crypto");
    var buffer_1 = require("buffer");
    var hmacAlgorithm_1 = require_hmacAlgorithm();
    var NodeHmac = class _NodeHmac extends hmacAlgorithm_1.HmacAlgorithm {
      constructor(name, algorithmName, encryptThenMac = false) {
        super(name, algorithmName, _NodeHmac.getHashKeyLength(algorithmName), _NodeHmac.getHashDigestLength(algorithmName));
        this.encryptThenMac = encryptThenMac;
      }
      async createSigner(key) {
        const hmac = new NodeSignerVerifier(_NodeHmac.getNodeHashAlgorithmName(this.algorithmName), this.digestLength, this.encryptThenMac, key);
        return hmac;
      }
      async createVerifier(key) {
        const hmac = new NodeSignerVerifier(_NodeHmac.getNodeHashAlgorithmName(this.algorithmName), this.digestLength, this.encryptThenMac, key);
        return hmac;
      }
      static getHashKeyLength(hashAlgorithmName) {
        if (hashAlgorithmName === "SHA2-512")
          return 512 / 8;
        if (hashAlgorithmName === "SHA2-384")
          return 384 / 8;
        if (hashAlgorithmName === "SHA2-256")
          return 256 / 8;
        throw new Error(`Unsupported hash algorithm: ${hashAlgorithmName}`);
      }
      static getHashDigestLength(hashAlgorithmName) {
        return this.getHashKeyLength(hashAlgorithmName);
      }
      static getNodeHashAlgorithmName(hashAlgorithmName) {
        if (hashAlgorithmName === "SHA2-512")
          return "sha512";
        if (hashAlgorithmName === "SHA2-384")
          return "sha384";
        if (hashAlgorithmName === "SHA2-256")
          return "sha256";
        throw new Error(`Unsupported hash algorithm: ${hashAlgorithmName}`);
      }
    };
    exports2.NodeHmac = NodeHmac;
    var NodeSignerVerifier = class {
      constructor(algorithmName, digestLength, encryptThenMac, key) {
        this.algorithmName = algorithmName;
        this.digestLength = digestLength;
        this.encryptThenMac = encryptThenMac;
        this.key = crypto2.createSecretKey ? crypto2.createSecretKey(key) : buffer_1.Buffer.from(key);
      }
      async sign(data) {
        const signer = crypto2.createHmac(this.algorithmName, this.key);
        signer.update(data);
        const hmac = signer.digest();
        return hmac;
      }
      async verify(data, signature) {
        const verifier = crypto2.createHmac(this.algorithmName, this.key);
        verifier.update(data);
        const hmac = verifier.digest();
        const result = hmac.equals(signature);
        return result;
      }
      dispose() {
      }
    };
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/node/nodeKeyExchange.js
var require_nodeKeyExchange = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/node/nodeKeyExchange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NodeECDiffieHellman = exports2.NodeDiffieHellman = void 0;
    var crypto2 = require("crypto");
    var buffer_1 = require("buffer");
    var keyExchangeAlgorithm_1 = require_keyExchangeAlgorithm();
    var nodeHmac_1 = require_nodeHmac();
    var bigInt_1 = require_bigInt();
    var NodeDiffieHellman = class extends keyExchangeAlgorithm_1.KeyExchangeAlgorithm {
      constructor(name, keySizeInBits, hashAlgorithmName) {
        super(name, keySizeInBits, hashAlgorithmName, nodeHmac_1.NodeHmac.getHashDigestLength(hashAlgorithmName));
      }
      createKeyExchange() {
        return new NodeDiffieHellmanKex(this.keySizeInBits, nodeHmac_1.NodeHmac.getNodeHashAlgorithmName(this.hashAlgorithmName), this.hashDigestLength);
      }
    };
    exports2.NodeDiffieHellman = NodeDiffieHellman;
    var NodeDiffieHellmanKex = class {
      constructor(bitLength, hashAlgorithmName, digestLength) {
        this.hashAlgorithmName = hashAlgorithmName;
        this.digestLength = digestLength;
        switch (bitLength) {
          case 1024:
            this.dh = crypto2.getDiffieHellman("modp2");
            break;
          case 2048:
            this.dh = crypto2.getDiffieHellman("modp14");
            break;
          case 4096:
            this.dh = crypto2.getDiffieHellman("modp16");
            break;
          default:
            throw new Error("Invalid DH bit length.");
        }
      }
      startKeyExchange() {
        const exchangeValueKeys = this.dh.generateKeys();
        const exchangeValue = bigInt_1.BigInt.fromBytes(exchangeValueKeys, { unsigned: true }).toBytes();
        return Promise.resolve(exchangeValue);
      }
      decryptKeyExchange(exchangeValue) {
        const key = this.dh.computeSecret(exchangeValue);
        const sharedSecret = bigInt_1.BigInt.fromBytes(key, { unsigned: true }).toBytes();
        return Promise.resolve(sharedSecret);
      }
      async sign(data) {
        const hash = crypto2.createHash(this.hashAlgorithmName);
        hash.update(data);
        return buffer_1.Buffer.from(hash.digest());
      }
      dispose() {
      }
    };
    var NodeECDiffieHellman = class extends keyExchangeAlgorithm_1.KeyExchangeAlgorithm {
      constructor(name, keySizeInBits, hashAlgorithmName) {
        super(name, keySizeInBits, hashAlgorithmName, nodeHmac_1.NodeHmac.getHashDigestLength(hashAlgorithmName));
      }
      createKeyExchange() {
        return new NodeECDiffieHellmanKex(this.keySizeInBits, nodeHmac_1.NodeHmac.getNodeHashAlgorithmName(this.hashAlgorithmName), this.hashDigestLength);
      }
    };
    exports2.NodeECDiffieHellman = NodeECDiffieHellman;
    var NodeECDiffieHellmanKex = class {
      constructor(bitLength, hashAlgorithmName, digestLength) {
        this.hashAlgorithmName = hashAlgorithmName;
        this.digestLength = digestLength;
        switch (bitLength) {
          case 256:
            this.ecdh = crypto2.createECDH("prime256v1");
            break;
          case 384:
            this.ecdh = crypto2.createECDH("secp384r1");
            break;
          case 521:
            this.ecdh = crypto2.createECDH("secp521r1");
            break;
          default:
            throw new Error("Invalid ECDH bit length.");
        }
      }
      startKeyExchange() {
        const exchangeValue = this.ecdh.generateKeys();
        return Promise.resolve(exchangeValue);
      }
      decryptKeyExchange(exchangeValue) {
        const sharedSecretBytes = this.ecdh.computeSecret(exchangeValue);
        const sharedSecret = bigInt_1.BigInt.fromBytes(sharedSecretBytes, { unsigned: true }).toBytes();
        return Promise.resolve(sharedSecret);
      }
      async sign(data) {
        const hash = crypto2.createHash(this.hashAlgorithmName);
        hash.update(data);
        return buffer_1.Buffer.from(hash.digest());
      }
      dispose() {
      }
    };
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/io/derData.js
var require_derData = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/io/derData.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DerWriter = exports2.DerReader = void 0;
    var buffer_1 = require("buffer");
    var bigInt_1 = require_bigInt();
    var DerReader = class _DerReader {
      constructor(buffer, dataType = 32 | 16) {
        this.buffer = buffer;
        this.position = 0;
        this.readType(dataType);
        const length = this.readLength();
        if (length > this.buffer.length - this.position) {
          throw new Error("Read out of bounds.");
        }
        this.buffer = this.buffer.slice(0, this.position + length);
      }
      get available() {
        return this.buffer.length - this.position;
      }
      readNull() {
        this.readType(
          5
          /* DerType.Null */
        );
        if (this.readByte() !== 0) {
          throw new Error("Expected a 0 after Null type.");
        }
      }
      readInteger() {
        this.readType(
          2
          /* DerType.Integer */
        );
        const length = this.readLength();
        const bytes = this.readBytes(length);
        const result = new bigInt_1.BigInt(bytes);
        return result;
      }
      readOctetString() {
        this.readType(
          4
          /* DerType.OctetString */
        );
        const length = this.readLength();
        const result = this.readBytes(length);
        return result;
      }
      readBitString() {
        this.readType(
          3
          /* DerType.BitString */
        );
        const length = this.readLength();
        const padding = this.readByte();
        if (padding !== 0) {
          throw new Error("Padded bit strings are not supported.");
        }
        const result = this.readBytes(length - 1);
        return result;
      }
      readObjectIdentifier(expected) {
        this.readType(
          6
          /* DerType.ObjectIdentifier */
        );
        const length = this.readLength();
        const end = this.position + length;
        const values = [];
        const first = this.readByte();
        values.push(Math.trunc(first / 40));
        values.push(first % 40);
        let next = 0;
        while (this.position < end) {
          const b = this.readByte();
          if ((b & 128) !== 0) {
            next = next * 128 + (b & 127);
          } else {
            next = next * 128 + b;
            values.push(next);
            next = 0;
          }
        }
        if (next !== 0) {
          throw new Error("Invalid OID format.");
        }
        const result = values.join(".");
        if (expected && result !== expected) {
          throw new Error(`Expected OID ${expected}, found: ${result}`);
        }
        return result;
      }
      readSequence() {
        const start = this.position;
        this.readType(
          32 | 16
          /* DerType.Sequence */
        );
        const length = this.readLength();
        this.position += length;
        return new _DerReader(this.buffer.slice(start, this.position));
      }
      tryReadTagged(tagId) {
        if (this.position >= this.buffer.length) {
          return null;
        }
        const type = this.buffer[this.position];
        if ((type & 160) === 0 || (type & ~160) !== tagId) {
          return null;
        }
        const start = this.position;
        this.position++;
        const length = this.readLength();
        this.position += length;
        const taggedData = new _DerReader(this.buffer.slice(start, this.position), type);
        return taggedData;
      }
      /** Reads the type of the next value in the sequence WITHOUT advancing the reader position. */
      peek() {
        if (this.position >= this.buffer.length) {
          throw new Error("Read out of bounds.");
        }
        return this.buffer[this.position];
      }
      readLength() {
        let length = this.readByte();
        if (length === 128) {
          throw new Error("Indefinite-length encoding is not supported.");
        }
        if (length > 127) {
          const size = length & 127;
          if (size > 4) {
            throw new Error(`DER length size is ${size} and cannot be more than 4 bytes.`);
          }
          length = 0;
          for (let i = 0; i < size; i++) {
            const next = this.readByte();
            length = (length << 8) + next;
          }
          if (length < 0) {
            throw new Error("Corrupted data - negative length found");
          }
        }
        return length;
      }
      readByte() {
        if (this.position >= this.buffer.length) {
          throw new Error("Read out of bounds.");
        }
        return this.buffer[this.position++];
      }
      readBytes(length) {
        if (this.position + length > this.buffer.length) {
          throw new Error("Read out of bounds.");
        }
        const result = this.buffer.slice(this.position, this.position + length);
        this.position += length;
        return result;
      }
      readType(expectedType) {
        const type = this.readByte();
        if (type !== expectedType) {
          throw new Error(`Expected ${expectedType} data type, found : ${type}`);
        }
      }
    };
    exports2.DerReader = DerReader;
    var DerWriter = class _DerWriter {
      constructor(buffer, dataType = 32 | 16) {
        this.buffer = buffer;
        this.dataType = dataType;
        this.position = 0;
        this.buffer = buffer;
      }
      toBuffer() {
        const length = this.position;
        const lengthBytes = _DerWriter.getLength(length);
        this.ensureCapacity(1 + lengthBytes.length + length);
        const result = this.buffer.slice(0, 1 + lengthBytes.length + length);
        this.buffer.copy(result, 1 + lengthBytes.length);
        result[0] = this.dataType;
        lengthBytes.copy(result, 1, 0);
        this.buffer = this.buffer.slice(1 + lengthBytes.length, result.length);
        this.position = length;
        return result;
      }
      writeSequence(data) {
        this.writeBytes(data.toBuffer());
      }
      writeTagged(tagId, data) {
        if (tagId > 15)
          throw new Error("Invalid DER tag.");
        this.writeByte(160 | tagId);
        const lengthBytes = _DerWriter.getLength(data.position);
        this.writeBytes(lengthBytes);
        this.writeBytes(data.buffer.slice(0, data.position));
      }
      writeNull() {
        this.writeByte(
          5
          /* DerType.Null */
        );
        this.writeByte(0);
      }
      writeInteger(value) {
        this.writeByte(
          2
          /* DerType.Integer */
        );
        const integerBytes = value.toBytes();
        const lengthBytes = _DerWriter.getLength(integerBytes.length);
        this.writeBytes(lengthBytes);
        this.writeBytes(integerBytes);
      }
      writeOctetString(data) {
        this.writeByte(
          4
          /* DerType.OctetString */
        );
        const lengthBytes = _DerWriter.getLength(data.length);
        this.writeBytes(lengthBytes);
        this.writeBytes(data);
      }
      writeBitString(data) {
        this.writeByte(
          3
          /* DerType.BitString */
        );
        const lengthBytes = _DerWriter.getLength(1 + data.length);
        this.writeBytes(lengthBytes);
        this.writeByte(0);
        this.writeBytes(data);
      }
      writeObjectIdentifier(oid) {
        if (!oid)
          throw new TypeError("OID value is null or empty.");
        const values = oid.split(".").map(Number);
        if (values.length < 2 || values[0] > 3 || values[1] >= 40) {
          throw new Error(`Invalid OID: ${oid}`);
        }
        this.writeByte(
          6
          /* DerType.ObjectIdentifier */
        );
        let length = values.length - 1;
        for (let i = 2; i < values.length; i++) {
          let value = values[i];
          while (value > 128) {
            length++;
            value /= 128;
          }
        }
        const lengthBytes = _DerWriter.getLength(length);
        this.writeBytes(lengthBytes);
        this.writeByte(values[0] * 40 + values[1]);
        for (let i = 2; i < values.length; i++) {
          let value = values[i];
          if (value >= 128) {
            const bytes = [];
            bytes.push(value & 127);
            while (value >= 128) {
              value /= 128;
              bytes.push(128 | value & 127);
            }
            while (bytes.length > 0) {
              this.writeByte(bytes.pop());
            }
          } else {
            this.writeByte(value);
          }
        }
      }
      static getLength(length) {
        if (length > 127) {
          let size = 1;
          for (let val = length >> 8; val !== 0; val >>= 8) {
            size++;
          }
          const lengthBytes = _DerWriter.lengthBuffer.slice(0, size + 1);
          lengthBytes[0] = size | 128;
          for (let i = (size - 1) * 8, j = 1; i >= 0; i -= 8, j++) {
            lengthBytes[j] = length >> i;
          }
          return lengthBytes;
        } else {
          const lengthBytes = _DerWriter.lengthBuffer.slice(0, 1);
          lengthBytes[0] = length;
          return lengthBytes;
        }
      }
      writeByte(value) {
        this.ensureCapacity(this.position + 1);
        this.buffer[this.position++] = value;
      }
      writeBytes(value) {
        this.ensureCapacity(this.position + value.length);
        value.copy(this.buffer, this.position);
        this.position += value.length;
      }
      ensureCapacity(capacity) {
        if (this.buffer.length < capacity) {
          let newLength = Math.max(512, this.buffer.length * 2);
          while (newLength < capacity)
            newLength *= 2;
          const newBuffer = buffer_1.Buffer.alloc(newLength);
          this.buffer.copy(newBuffer, 0, 0, this.position);
          this.buffer = newBuffer;
        }
      }
    };
    exports2.DerWriter = DerWriter;
    DerWriter.lengthBuffer = buffer_1.Buffer.alloc(10);
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/node/keyFormatters.js
var require_keyFormatters = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/node/keyFormatters.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Sec1KeyFormatter = exports2.Pkcs1KeyFormatter = exports2.parsePem = exports2.formatPem = void 0;
    var bigInt_1 = require_bigInt();
    var derData_1 = require_derData();
    var ecdsaCurves_1 = require_ecdsaCurves();
    function formatPem(keyBytes, name) {
      const key = `-----BEGIN ${name}-----
` + keyBytes.toString("base64").match(/.{1,64}/g).join("\n") + `
-----END ${name}-----
`;
      return key;
    }
    exports2.formatPem = formatPem;
    function parsePem(key) {
      const keyBase64 = key.replace(/-+[^-\n]+KEY-+/g, "").replace(/\s/g, "");
      const keyBytes = Buffer.from(keyBase64, "base64");
      return keyBytes;
    }
    exports2.parsePem = parsePem;
    var Pkcs1KeyFormatter = class {
      static formatRsaPublic(rsa) {
        const writer = new derData_1.DerWriter(Buffer.alloc(1024));
        writer.writeInteger(rsa.modulus);
        writer.writeInteger(rsa.exponent);
        return writer.toBuffer();
      }
      static formatRsaPrivate(rsa) {
        if (!(rsa.d && rsa.p && rsa.q && rsa.dp && rsa.dq && rsa.qi)) {
          throw new Error("Missing private key parameters.");
        }
        const writer = new derData_1.DerWriter(Buffer.alloc(2048));
        writer.writeInteger(bigInt_1.BigInt.fromInt32(0));
        writer.writeInteger(rsa.modulus);
        writer.writeInteger(rsa.exponent);
        writer.writeInteger(rsa.d);
        writer.writeInteger(rsa.p);
        writer.writeInteger(rsa.q);
        writer.writeInteger(rsa.dp);
        writer.writeInteger(rsa.dq);
        writer.writeInteger(rsa.qi);
        return writer.toBuffer();
      }
      static parseRsaPublic(keyBytes) {
        const reader = new derData_1.DerReader(keyBytes);
        const modulus = reader.readInteger();
        const exponent = reader.readInteger();
        return { modulus, exponent };
      }
      static parseRsaPrivate(keyBytes) {
        const reader = new derData_1.DerReader(keyBytes);
        const version = reader.readInteger();
        const modulus = reader.readInteger();
        const exponent = reader.readInteger();
        const d = reader.readInteger();
        const p = reader.readInteger();
        const q = reader.readInteger();
        const dp = reader.readInteger();
        const dq = reader.readInteger();
        const qi = reader.readInteger();
        return { modulus, exponent, d, p, q, dp, dq, qi };
      }
    };
    exports2.Pkcs1KeyFormatter = Pkcs1KeyFormatter;
    var Sec1KeyFormatter = class _Sec1KeyFormatter {
      static formatECPublic(ec) {
        const curve = ecdsaCurves_1.curves.find((c) => c.oid === ec.curve.oid);
        const keySizeInBytes = Math.ceil(curve.keySize / 8);
        const writer = new derData_1.DerWriter(Buffer.alloc(512));
        const oidsWriter = new derData_1.DerWriter(Buffer.alloc(100));
        oidsWriter.writeObjectIdentifier(_Sec1KeyFormatter.ecPublicKeyOid);
        oidsWriter.writeObjectIdentifier(ec.curve.oid);
        writer.writeSequence(oidsWriter);
        const x = ec.x.toBytes({ unsigned: true, length: keySizeInBytes });
        const y = ec.y.toBytes({ unsigned: true, length: keySizeInBytes });
        const publicKeyData = Buffer.alloc(1 + x.length + y.length);
        publicKeyData[0] = 4;
        x.copy(publicKeyData, 1);
        y.copy(publicKeyData, 1 + x.length);
        writer.writeBitString(publicKeyData);
        return writer.toBuffer();
      }
      static formatECPrivate(ec) {
        const curve = ecdsaCurves_1.curves.find((c) => c.oid === ec.curve.oid);
        const keySizeInBytes = Math.ceil(curve.keySize / 8);
        const writer = new derData_1.DerWriter(Buffer.alloc(512));
        writer.writeInteger(bigInt_1.BigInt.fromInt32(1));
        writer.writeOctetString(ec.d.toBytes({ unsigned: true, length: keySizeInBytes }));
        const curveWriter = new derData_1.DerWriter(Buffer.alloc(100));
        curveWriter.writeObjectIdentifier(ec.curve.oid);
        writer.writeTagged(0, curveWriter);
        const x = ec.x.toBytes({ unsigned: true, length: keySizeInBytes });
        const y = ec.y.toBytes({ unsigned: true, length: keySizeInBytes });
        const publicKeyData = Buffer.alloc(1 + x.length + y.length);
        publicKeyData[0] = 4;
        x.copy(publicKeyData, 1);
        y.copy(publicKeyData, 1 + x.length);
        const keyWriter = new derData_1.DerWriter(Buffer.alloc(512));
        keyWriter.writeBitString(publicKeyData);
        writer.writeTagged(1, keyWriter);
        return writer.toBuffer();
      }
      static parseECPublic(keyBytes) {
        var _a;
        const reader = new derData_1.DerReader(keyBytes);
        const oidsReader = reader.readSequence();
        const keyTypeOid = oidsReader.readObjectIdentifier();
        if (keyTypeOid !== _Sec1KeyFormatter.ecPublicKeyOid) {
          throw new Error(`Unexpected key type OID: ${keyTypeOid}`);
        }
        const curveOid = oidsReader.readObjectIdentifier();
        const curveName = (_a = ecdsaCurves_1.curves.find((c) => c.oid === curveOid)) === null || _a === void 0 ? void 0 : _a.name;
        const xy = reader.readBitString();
        if (xy.length % 2 !== 1) {
          throw new Error(`Unexpected key data length: ${xy.length}`);
        }
        const x = bigInt_1.BigInt.fromBytes(xy.slice(1, 1 + (xy.length - 1) / 2), { unsigned: true });
        const y = bigInt_1.BigInt.fromBytes(xy.slice(1 + (xy.length - 1) / 2), { unsigned: true });
        const ec = {
          curve: { name: curveName, oid: curveOid },
          x,
          y
        };
        return ec;
      }
      static parseECPrivate(keyBytes) {
        var _a;
        const reader = new derData_1.DerReader(keyBytes);
        const version = reader.readInteger().toInt32();
        if (version !== 1) {
          throw new Error(`Unsupported SEC1 format version: ${version}`);
        }
        const d = bigInt_1.BigInt.fromBytes(reader.readOctetString(), { unsigned: true });
        const curveReader = reader.tryReadTagged(0);
        if (!curveReader) {
          throw new Error("SEC1 curve info not found.");
        }
        const curveOid = curveReader.readObjectIdentifier();
        const curveName = (_a = ecdsaCurves_1.curves.find((c) => c.oid === curveOid)) === null || _a === void 0 ? void 0 : _a.name;
        const publicKeyReader = reader.tryReadTagged(1);
        if (!publicKeyReader) {
          throw new Error("SEC1 public key data not found.");
        }
        const xy = publicKeyReader.readBitString();
        if (xy.length % 2 !== 1) {
          throw new Error(`Unexpected key data length: ${xy.length}`);
        }
        const x = bigInt_1.BigInt.fromBytes(xy.slice(1, 1 + (xy.length - 1) / 2), { unsigned: true });
        const y = bigInt_1.BigInt.fromBytes(xy.slice(1 + (xy.length - 1) / 2), { unsigned: true });
        const ec = {
          curve: { name: curveName, oid: curveOid },
          x,
          y,
          d
        };
        return ec;
      }
    };
    exports2.Sec1KeyFormatter = Sec1KeyFormatter;
    Sec1KeyFormatter.ecPublicKeyOid = "1.2.840.10045.2.1";
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/node/nodeRsa.js
var require_nodeRsa = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/node/nodeRsa.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NodeRsa = void 0;
    var crypto2 = require("crypto");
    var buffer_1 = require("buffer");
    var publicKeyAlgorithm_1 = require_publicKeyAlgorithm();
    var sshData_1 = require_sshData();
    var nodeHmac_1 = require_nodeHmac();
    var keyFormatters_1 = require_keyFormatters();
    var nodeVersionParts = process.versions.node.split(".").map((v) => parseInt(v, 10));
    var nodeGenerateKeyPairSupport = nodeVersionParts[0] > 10 || nodeVersionParts[0] === 10 && nodeVersionParts[1] >= 12;
    var nodeKeyObjectSupport = nodeVersionParts[0] > 11 || nodeVersionParts[0] === 11 && nodeVersionParts[1] >= 6;
    var NodeRsaKeyPair = class _NodeRsaKeyPair {
      /* @internal */
      constructor() {
        this.comment = null;
      }
      get hasPublicKey() {
        return !!this.publicKey;
      }
      get hasPrivateKey() {
        return !!this.privateKey;
      }
      get keyAlgorithmName() {
        return NodeRsa.keyAlgorithmName;
      }
      generate(keySizeInBits) {
        keySizeInBits = keySizeInBits !== null && keySizeInBits !== void 0 ? keySizeInBits : _NodeRsaKeyPair.defaultKeySize;
        if (nodeGenerateKeyPairSupport && nodeKeyObjectSupport) {
          return this.generateNodeKeyPairObjects(keySizeInBits);
        } else if (nodeGenerateKeyPairSupport) {
          return this.generateNodeKeyPairBuffers(keySizeInBits);
        } else {
          return this.generateExternalKeyPair(keySizeInBits);
        }
      }
      async generateNodeKeyPairObjects(keySizeInBits) {
        [this.publicKey, this.privateKey] = await new Promise((resolve3, reject) => {
          const keyGenParams = {
            modulusLength: keySizeInBits
          };
          try {
            crypto2.generateKeyPair("rsa", keyGenParams, (err, publicKey, privateKey) => {
              if (err) {
                reject(err);
              } else {
                resolve3([publicKey, privateKey]);
              }
            });
          } catch (err) {
            reject(err);
          }
        });
      }
      async generateNodeKeyPairBuffers(keySizeInBits) {
        [this.publicKey, this.privateKey] = await new Promise((resolve3, reject) => {
          const keyGenParams = {
            modulusLength: keySizeInBits,
            publicKeyEncoding: { type: "pkcs1", format: "pem" },
            privateKeyEncoding: {
              type: "pkcs1",
              format: "pem",
              cipher: void 0,
              passphrase: void 0
            }
          };
          try {
            crypto2.generateKeyPair("rsa", keyGenParams, (err, publicKey, privateKey) => {
              if (err) {
                reject(err);
              } else {
                resolve3([publicKey, privateKey]);
              }
            });
          } catch (err) {
            reject(err);
          }
        });
      }
      async generateExternalKeyPair(keySizeInBits) {
        const externRsa = await Promise.resolve().then(() => require("node-rsa"));
        const keyPair = new externRsa({ b: keySizeInBits });
        this.publicKey = keyPair.exportKey("pkcs1-public-pem");
        this.privateKey = keyPair.exportKey("pkcs1-private-pem");
        if (!this.publicKey.endsWith("\n"))
          this.publicKey += "\n";
        if (!this.privateKey.endsWith("\n"))
          this.privateKey += "\n";
      }
      async setPublicKeyBytes(keyBytes) {
        if (!keyBytes) {
          throw new TypeError("Buffer is required.");
        }
        const reader = new sshData_1.SshDataReader(keyBytes);
        const algorithmName = reader.readString("ascii");
        if (algorithmName !== this.keyAlgorithmName && algorithmName !== NodeRsa.rsaWithSha256 && algorithmName !== NodeRsa.rsaWithSha512) {
          throw new Error(`Invalid RSA key algorithm: ${algorithmName}`);
        }
        const exponent = reader.readBigInt();
        const modulus = reader.readBigInt();
        keyBytes = keyFormatters_1.Pkcs1KeyFormatter.formatRsaPublic({ modulus, exponent });
        if (nodeKeyObjectSupport) {
          this.publicKey = crypto2.createPublicKey({
            key: keyBytes,
            type: "pkcs1",
            format: "der"
          });
        } else {
          this.publicKey = (0, keyFormatters_1.formatPem)(keyBytes, "RSA PUBLIC KEY");
        }
      }
      async getPublicKeyBytes(algorithmName) {
        if (!this.publicKey) {
          return null;
        }
        if (!algorithmName) {
          algorithmName = this.keyAlgorithmName;
        }
        let keyBytes;
        if (typeof this.publicKey === "string") {
          keyBytes = (0, keyFormatters_1.parsePem)(this.publicKey);
        } else {
          keyBytes = this.publicKey.export({
            type: "pkcs1",
            format: "der"
          });
        }
        const parameters = keyFormatters_1.Pkcs1KeyFormatter.parseRsaPublic(keyBytes);
        const keyBuffer = buffer_1.Buffer.alloc(512);
        const keyWriter = new sshData_1.SshDataWriter(keyBuffer);
        keyWriter.writeString(algorithmName, "ascii");
        keyWriter.writeBigInt(parameters.exponent);
        keyWriter.writeBigInt(parameters.modulus);
        keyBytes = keyWriter.toBuffer();
        return keyBytes;
      }
      async importParameters(parameters) {
        if (nodeKeyObjectSupport) {
          this.publicKey = crypto2.createPublicKey({
            key: keyFormatters_1.Pkcs1KeyFormatter.formatRsaPublic(parameters),
            format: "der",
            type: "pkcs1"
          });
          if (parameters.d) {
            this.privateKey = crypto2.createPrivateKey({
              key: keyFormatters_1.Pkcs1KeyFormatter.formatRsaPrivate(parameters),
              format: "der",
              type: "pkcs1"
            });
          } else {
            this.privateKey = void 0;
          }
        } else {
          const publicKeyBytes = keyFormatters_1.Pkcs1KeyFormatter.formatRsaPublic(parameters);
          this.publicKey = (0, keyFormatters_1.formatPem)(publicKeyBytes, "RSA PUBLIC KEY");
          if (parameters.d) {
            const privateKeyBytes = keyFormatters_1.Pkcs1KeyFormatter.formatRsaPrivate(parameters);
            this.privateKey = (0, keyFormatters_1.formatPem)(privateKeyBytes, "RSA PRIVATE KEY");
          }
        }
      }
      async exportParameters() {
        var _a, _b;
        if (!this.publicKey)
          throw new Error("Public key not set.");
        let keyBytes;
        if (nodeKeyObjectSupport) {
          keyBytes = ((_a = this.privateKey) !== null && _a !== void 0 ? _a : this.publicKey).export({
            format: "der",
            type: "pkcs1"
          });
        } else {
          keyBytes = (0, keyFormatters_1.parsePem)((_b = this.privateKey) !== null && _b !== void 0 ? _b : this.publicKey);
        }
        return this.privateKey ? keyFormatters_1.Pkcs1KeyFormatter.parseRsaPrivate(keyBytes) : keyFormatters_1.Pkcs1KeyFormatter.parseRsaPublic(keyBytes);
      }
      dispose() {
        this.publicKey = void 0;
        this.privateKey = void 0;
      }
    };
    NodeRsaKeyPair.defaultKeySize = 2048;
    var NodeRsa = class _NodeRsa extends publicKeyAlgorithm_1.PublicKeyAlgorithm {
      constructor(name, hashAlgorithmName) {
        super(name, _NodeRsa.keyAlgorithmName, hashAlgorithmName);
      }
      createKeyPair() {
        return new NodeRsaKeyPair();
      }
      async generateKeyPair(keySizeInBits) {
        const rsaKey = new NodeRsaKeyPair();
        await rsaKey.generate(keySizeInBits);
        return rsaKey;
      }
      createSigner(keyPair) {
        if (!(keyPair instanceof NodeRsaKeyPair)) {
          throw new TypeError("RSA key pair object expected.");
        }
        return new NodeRsaSignerVerifier(keyPair, _NodeRsa.convertHashAlgorithmName(this.hashAlgorithmName), nodeHmac_1.NodeHmac.getHashDigestLength(this.hashAlgorithmName));
      }
      createVerifier(keyPair) {
        if (!(keyPair instanceof NodeRsaKeyPair)) {
          throw new TypeError("RSA key pair object expected.");
        }
        return new NodeRsaSignerVerifier(keyPair, _NodeRsa.convertHashAlgorithmName(this.hashAlgorithmName), nodeHmac_1.NodeHmac.getHashDigestLength(this.hashAlgorithmName));
      }
      static convertHashAlgorithmName(hashAlgorithmName) {
        return hashAlgorithmName.replace("SHA2-", "SHA");
      }
    };
    exports2.NodeRsa = NodeRsa;
    NodeRsa.keyAlgorithmName = "ssh-rsa";
    NodeRsa.rsaWithSha256 = "rsa-sha2-256";
    NodeRsa.rsaWithSha512 = "rsa-sha2-512";
    NodeRsa.KeyPair = NodeRsaKeyPair;
    var NodeRsaSignerVerifier = class {
      constructor(keyPair, hashAlgorithmName, digestLength) {
        this.keyPair = keyPair;
        this.hashAlgorithmName = hashAlgorithmName;
        this.digestLength = digestLength;
      }
      async sign(data) {
        if (!this.keyPair.privateKey) {
          throw new Error("Private key not set.");
        }
        const signer = crypto2.createSign(this.hashAlgorithmName);
        signer.update(data);
        const signature = signer.sign(this.keyPair.privateKey);
        return signature;
      }
      async verify(data, signature) {
        if (!this.keyPair.publicKey) {
          throw new Error("Public key not set.");
        }
        const verifier = crypto2.createVerify(this.hashAlgorithmName);
        verifier.update(data);
        const result = verifier.verify(this.keyPair.publicKey, signature);
        return result;
      }
      dispose() {
      }
    };
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/node/nodeECDsa.js
var require_nodeECDsa = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/node/nodeECDsa.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NodeECDsa = void 0;
    var crypto2 = require("crypto");
    var buffer_1 = require("buffer");
    var publicKeyAlgorithm_1 = require_publicKeyAlgorithm();
    var ecdsaCurves_1 = require_ecdsaCurves();
    var bigInt_1 = require_bigInt();
    var derData_1 = require_derData();
    var sshData_1 = require_sshData();
    var keyFormatters_1 = require_keyFormatters();
    var nodeVersionParts = process.versions.node.split(".").map((v) => parseInt(v, 10));
    var nodeGenerateKeyPairSupport = nodeVersionParts[0] > 10 || nodeVersionParts[0] === 10 && nodeVersionParts[1] >= 12;
    var nodeKeyObjectSupport = nodeVersionParts[0] > 11 || nodeVersionParts[0] === 11 && nodeVersionParts[1] >= 6;
    var NodeECDsaKeyPair = class {
      /**
       * Constructs a new ECDSA key pair object.
       *
       * @param algorithmName Key pair algorithm name. If unspecified, the key pair object must be
       * initialized before use via `importParameters()`.
       */
      constructor(algorithmName) {
        this.comment = null;
        if (algorithmName) {
          this.algorithmName = algorithmName;
        }
      }
      get hasPublicKey() {
        return !!this.publicKey;
      }
      get hasPrivateKey() {
        return !!this.privateKey;
      }
      get keyAlgorithmName() {
        return this.algorithmName;
      }
      get algorithmName() {
        return this.algorithm;
      }
      set algorithmName(value) {
        const curveName = value.split("-")[2];
        this.curve = ecdsaCurves_1.curves.find((c) => c.name === curveName);
        if (!this.curve) {
          throw new Error("Invalid or unsupported ECDSA algorithm: " + value);
        }
        this.algorithm = value;
      }
      generate() {
        if (nodeGenerateKeyPairSupport && nodeKeyObjectSupport) {
          return this.generateNodeKeyPairObjects();
        } else if (nodeGenerateKeyPairSupport) {
          return this.generateNodeKeyPairBuffers();
        } else {
          return this.generateExternalKeyPair();
        }
      }
      async generateNodeKeyPairObjects() {
        [this.publicKey, this.privateKey] = await new Promise((resolve3, reject) => {
          const keyGenParams = {
            namedCurve: this.curve.shortName
          };
          try {
            crypto2.generateKeyPair("ec", keyGenParams, (err, publicKey, privateKey) => {
              if (err) {
                reject(err);
              } else {
                resolve3([publicKey, privateKey]);
              }
            });
          } catch (err) {
            reject(err);
          }
        });
      }
      async generateNodeKeyPairBuffers() {
        [this.publicKey, this.privateKey] = await new Promise((resolve3, reject) => {
          const keyGenParams = {
            namedCurve: this.curve.shortName,
            publicKeyEncoding: { type: "spki", format: "pem" },
            privateKeyEncoding: {
              type: "sec1",
              format: "pem",
              cipher: void 0,
              passphrase: void 0
            }
          };
          try {
            crypto2.generateKeyPair("ec", keyGenParams, (err, publicKey, privateKey) => {
              if (err) {
                reject(err);
              } else {
                resolve3([publicKey, privateKey]);
              }
            });
          } catch (err) {
            reject(err);
          }
        });
      }
      async generateExternalKeyPair() {
        throw new Error("This version of node does not support generating key pairs. Use node >= 10.12.");
      }
      async setPublicKeyBytes(keyBytes, algorithmName) {
        if (!keyBytes) {
          throw new TypeError("Buffer is required.");
        }
        const reader = new sshData_1.SshDataReader(keyBytes);
        const readAlgorithmName = reader.readString("ascii");
        this.algorithmName = algorithmName || readAlgorithmName;
        const curveName = reader.readString("ascii");
        this.algorithmName = `ecdsa-sha2-${curveName}`;
        const xy = reader.readBinary();
        const x = bigInt_1.BigInt.fromBytes(xy.slice(1, 1 + (xy.length - 1) / 2), { unsigned: true });
        const y = bigInt_1.BigInt.fromBytes(xy.slice(1 + (xy.length - 1) / 2), { unsigned: true });
        const derKeyBytes = keyFormatters_1.Sec1KeyFormatter.formatECPublic({
          curve: { name: this.curve.name, oid: this.curve.oid },
          x,
          y
        });
        if (nodeKeyObjectSupport) {
          this.publicKey = crypto2.createPublicKey({
            key: derKeyBytes,
            type: "spki",
            format: "der"
          });
        } else {
          this.publicKey = (0, keyFormatters_1.formatPem)(derKeyBytes, "PUBLIC KEY");
        }
      }
      async getPublicKeyBytes(algorithmName) {
        if (!this.publicKey) {
          return null;
        }
        let derKeyBytes;
        if (typeof this.publicKey === "string") {
          derKeyBytes = (0, keyFormatters_1.parsePem)(this.publicKey);
        } else {
          derKeyBytes = this.publicKey.export({
            type: "spki",
            format: "der"
          });
        }
        const ec = keyFormatters_1.Sec1KeyFormatter.parseECPublic(derKeyBytes);
        algorithmName = algorithmName || this.algorithmName || this.keyAlgorithmName;
        const keyWriter = new sshData_1.SshDataWriter(buffer_1.Buffer.alloc(512));
        keyWriter.writeString(algorithmName, "ascii");
        keyWriter.writeString(this.curve.name, "ascii");
        const keySizeInBytes = Math.ceil(this.curve.keySize / 8);
        const xBytes = ec.x.toBytes({ unsigned: true, length: keySizeInBytes });
        const yBytes = ec.y.toBytes({ unsigned: true, length: keySizeInBytes });
        keyWriter.writeUInt32(1 + xBytes.length + yBytes.length);
        keyWriter.writeByte(4);
        keyWriter.write(xBytes);
        keyWriter.write(yBytes);
        const keyBytes = keyWriter.toBuffer();
        return keyBytes;
      }
      async importParameters(parameters) {
        if (!parameters.curve)
          throw new TypeError("A curve is required.");
        let curve;
        if (parameters.curve.oid) {
          curve = ecdsaCurves_1.curves.find((c) => c.oid === parameters.curve.oid);
          if (!curve) {
            throw new Error(`Unsupported curve OID: ${parameters.curve.oid}`);
          }
        } else if (parameters.curve.name) {
          curve = ecdsaCurves_1.curves.find((c) => c.name === parameters.curve.name);
          if (!curve) {
            throw new Error(`Unsupported curve: ${parameters.curve.name}`);
          }
        } else {
          throw new TypeError("A curve OID or name is required.");
        }
        this.algorithmName = "ecdsa-sha2-" + curve.name;
        const publicKeyBytes = keyFormatters_1.Sec1KeyFormatter.formatECPublic(parameters);
        if (nodeKeyObjectSupport) {
          this.publicKey = crypto2.createPublicKey({
            key: publicKeyBytes,
            type: "spki",
            format: "der"
          });
        } else {
          this.publicKey = (0, keyFormatters_1.formatPem)(publicKeyBytes, "EC PUBLIC KEY");
        }
        if (parameters.d) {
          const privateKeyBytes = keyFormatters_1.Sec1KeyFormatter.formatECPrivate(parameters);
          if (nodeKeyObjectSupport) {
            this.privateKey = crypto2.createPrivateKey({
              key: privateKeyBytes,
              type: "sec1",
              format: "der"
            });
          } else {
            this.privateKey = (0, keyFormatters_1.formatPem)(privateKeyBytes, "EC PRIVATE KEY");
          }
        } else {
          this.privateKey = void 0;
        }
      }
      async exportParameters() {
        var _a, _b;
        if (!this.publicKey) {
          throw new Error("Key is not present.");
        }
        let derKeyBytes;
        if (typeof this.publicKey === "string") {
          derKeyBytes = (0, keyFormatters_1.parsePem)((_a = this.privateKey) !== null && _a !== void 0 ? _a : this.publicKey);
        } else {
          derKeyBytes = ((_b = this.privateKey) !== null && _b !== void 0 ? _b : this.publicKey).export({
            type: this.privateKey ? "sec1" : "spki",
            format: "der"
          });
        }
        return this.privateKey ? keyFormatters_1.Sec1KeyFormatter.parseECPrivate(derKeyBytes) : keyFormatters_1.Sec1KeyFormatter.parseECPublic(derKeyBytes);
      }
      dispose() {
      }
    };
    var NodeECDsa = class _NodeECDsa extends publicKeyAlgorithm_1.PublicKeyAlgorithm {
      constructor(name, hashAlgorithmName) {
        super(
          name,
          name,
          // The key algorithm name is the same (unlike RSA).
          hashAlgorithmName
        );
      }
      createKeyPair() {
        return new NodeECDsaKeyPair(this.name);
      }
      async generateKeyPair() {
        const ecdsaKey = new NodeECDsaKeyPair(this.name);
        await ecdsaKey.generate();
        return ecdsaKey;
      }
      createSigner(keyPair) {
        if (!(keyPair instanceof NodeECDsaKeyPair)) {
          throw new TypeError("ECDSA key pair object expected.");
        }
        return new NodeECDsaSignerVerifier(keyPair, _NodeECDsa.convertHashAlgorithmName(this.hashAlgorithmName));
      }
      createVerifier(keyPair) {
        if (!(keyPair instanceof NodeECDsaKeyPair)) {
          throw new TypeError("ECDSA key pair object expected.");
        }
        return new NodeECDsaSignerVerifier(keyPair, _NodeECDsa.convertHashAlgorithmName(this.hashAlgorithmName));
      }
      static convertHashAlgorithmName(hashAlgorithmName) {
        return hashAlgorithmName.replace("SHA2-", "SHA");
      }
      /* @internal */
      static getSignatureLength(keySizeInBits) {
        const keySizeInBytes = Math.ceil(keySizeInBits / 8);
        return (4 + 1 + keySizeInBytes) * 2;
      }
    };
    exports2.NodeECDsa = NodeECDsa;
    NodeECDsa.ecdsaSha2Nistp256 = "ecdsa-sha2-nistp256";
    NodeECDsa.ecdsaSha2Nistp384 = "ecdsa-sha2-nistp384";
    NodeECDsa.ecdsaSha2Nistp521 = "ecdsa-sha2-nistp521";
    NodeECDsa.curves = ecdsaCurves_1.curves;
    NodeECDsa.KeyPair = NodeECDsaKeyPair;
    var NodeECDsaSignerVerifier = class {
      constructor(keyPair, hashAlgorithmName) {
        this.keyPair = keyPair;
        this.hashAlgorithmName = hashAlgorithmName;
      }
      get digestLength() {
        const curve = this.keyPair.curve;
        if (!curve) {
          return 0;
        } else {
          return NodeECDsa.getSignatureLength(curve.keySize);
        }
      }
      async sign(data) {
        if (!this.keyPair.privateKey) {
          throw new Error("Private key not set.");
        }
        const signer = crypto2.createSign(this.hashAlgorithmName);
        signer.update(data);
        let signature = signer.sign(this.keyPair.privateKey);
        const signatureReader = new derData_1.DerReader(signature);
        const x = signatureReader.readInteger();
        const y = signatureReader.readInteger();
        const keySizeInBytes = Math.ceil(this.keyPair.curve.keySize / 8);
        const signatureWriter = new sshData_1.SshDataWriter(buffer_1.Buffer.alloc(this.digestLength));
        signatureWriter.writeBinary(x.toBytes({ unsigned: true, length: keySizeInBytes + 1 }));
        signatureWriter.writeBinary(y.toBytes({ unsigned: true, length: keySizeInBytes + 1 }));
        signature = signatureWriter.toBuffer();
        return signature;
      }
      async verify(data, signature) {
        if (!this.keyPair.publicKey) {
          throw new Error("Public key not set.");
        }
        const signatureReader = new sshData_1.SshDataReader(signature);
        const x = signatureReader.readBigInt();
        const y = signatureReader.readBigInt();
        const signatureWriter = new derData_1.DerWriter(buffer_1.Buffer.alloc(signature.length));
        signatureWriter.writeInteger(x);
        signatureWriter.writeInteger(y);
        signature = signatureWriter.toBuffer();
        const verifier = crypto2.createVerify(this.hashAlgorithmName);
        verifier.update(data);
        const result = verifier.verify(this.keyPair.publicKey, signature);
        return result;
      }
      dispose() {
      }
    };
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/node/nodeEncryption.js
var require_nodeEncryption = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/node/nodeEncryption.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NodeEncryption = void 0;
    var crypto2 = require("crypto");
    var buffer_1 = require("buffer");
    var encryptionAlgorithm_1 = require_encryptionAlgorithm();
    var NodeEncryption = class _NodeEncryption extends encryptionAlgorithm_1.EncryptionAlgorithm {
      constructor(name, algorithmName, cipherMode, keySizeInBits) {
        super(name);
        this.algorithmName = algorithmName;
        this.cipherMode = cipherMode;
        this.keySizeInBits = keySizeInBits;
        if (algorithmName !== "AES") {
          throw new Error(`Unsupported encryption algorithm: ${algorithmName}`);
        }
        this.blockSizeInBits = _NodeEncryption.getBlockSize(algorithmName);
      }
      get keyLength() {
        return this.keySizeInBits / 8;
      }
      get blockLength() {
        return this.blockSizeInBits / 8;
      }
      async createCipher(isEncryption, key, iv) {
        let cipher;
        if (this.cipherMode === "CTR" || this.cipherMode === "CBC") {
          cipher = new NodeAesCipher(isEncryption, this.keySizeInBits, this.blockSizeInBits, key, iv, this.cipherMode);
        } else if (this.cipherMode === "GCM") {
          cipher = new NodeAesGcmCipher(isEncryption, this.keySizeInBits, this.blockSizeInBits, key, iv);
        } else {
          throw new Error(`Unsupported cipher mode: ${this.cipherMode}`);
        }
        return cipher;
      }
      static getBlockSize(algorithmName) {
        if (algorithmName === "AES") {
          return 128;
        } else {
          throw new Error(`Unsupported encryption algorithm: ${algorithmName}`);
        }
      }
    };
    exports2.NodeEncryption = NodeEncryption;
    var NodeAesCipher = class {
      constructor(isEncryption, keySizeInBits, blockSizeInBits, key, iv, cipherMode) {
        this.isEncryption = isEncryption;
        this.keySizeInBits = keySizeInBits;
        this.blockSizeInBits = blockSizeInBits;
        const nodeAlgorithm = `AES-${this.keySizeInBits}-${cipherMode}`;
        this.cipher = this.isEncryption ? crypto2.createCipheriv(nodeAlgorithm, key, iv) : crypto2.createDecipheriv(nodeAlgorithm, key, iv);
        this.cipher.setAutoPadding(false);
      }
      get blockLength() {
        return this.blockSizeInBits / 8;
      }
      transform(data) {
        const result = this.cipher.update(data);
        if (result.length !== data.length) {
          const message = `Result from encrypt/decrypt has invalid length ${result.length}, expected ${data.length}.`;
          throw new Error(message);
        }
        return Promise.resolve(result);
      }
      dispose() {
      }
    };
    var NodeAesGcmCipher = class {
      constructor(isEncryption, keySizeInBits, blockSizeInBits, key, iv) {
        this.isEncryption = isEncryption;
        this.keySizeInBits = keySizeInBits;
        this.blockSizeInBits = blockSizeInBits;
        this.tag = null;
        this.algorithmName = `aes-${this.keySizeInBits}-gcm`;
        this.key = buffer_1.Buffer.alloc(key.length);
        key.copy(this.key);
        this.nonce = buffer_1.Buffer.alloc(12);
        iv.copy(this.nonce, 0, 0, 12);
        this.associatedData = buffer_1.Buffer.alloc(4);
      }
      get blockLength() {
        return this.blockSizeInBits / 8;
      }
      get digestLength() {
        return 16;
      }
      get authenticatedEncryption() {
        return true;
      }
      transform(data) {
        if (data.length % this.blockLength !== 0) {
          const message = `Encrypt/decrypt input has invalid length ${data.length}, not a multiple of block size ${this.blockLength}.`;
          throw new Error(message);
        }
        const cipher = this.isEncryption ? crypto2.createCipheriv(this.algorithmName, this.key, this.nonce) : crypto2.createDecipheriv(this.algorithmName, this.key, this.nonce);
        const packetLength = data.length;
        this.associatedData[0] = packetLength >>> 24;
        this.associatedData[1] = packetLength >>> 16;
        this.associatedData[2] = packetLength >>> 8;
        this.associatedData[3] = packetLength;
        cipher.setAAD(this.associatedData);
        if (!this.isEncryption) {
          if (!this.tag) {
            throw new Error("AES-GCM tag was not set before decrypting.");
          }
          cipher.setAuthTag(this.tag);
        }
        const result = cipher.update(data);
        if (result.length !== data.length) {
          const message = `Result from encrypt/decrypt has invalid length ${result.length}, expected ${data.length}.`;
          throw new Error(message);
        }
        cipher.final();
        if (this.isEncryption) {
          this.tag = cipher.getAuthTag();
        } else {
          this.tag = null;
        }
        let k = 12;
        while (--k >= 4) {
          this.nonce[k]++;
          if (this.nonce[k] !== 0) {
            break;
          }
        }
        return Promise.resolve(result);
      }
      async sign(data) {
        if (!this.tag) {
          throw new Error("AES-GCM tag was not obtained by encrypting.");
        }
        return this.tag;
      }
      async verify(data, signature) {
        if (signature.length !== this.digestLength) {
          throw new Error("Incorrect AES-GCM tag length.");
        }
        this.tag = signature;
        return true;
      }
      dispose() {
      }
    };
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/node/nodeRandom.js
var require_nodeRandom = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/node/nodeRandom.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NodeRandom = void 0;
    var crypto2 = require("crypto");
    var NodeRandom = class {
      getBytes(buffer) {
        const randomBytes = crypto2.randomBytes(buffer.length);
        randomBytes.copy(buffer);
      }
    };
    exports2.NodeRandom = NodeRandom;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/sshAlgorithms.js
var require_sshAlgorithms = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/sshAlgorithms.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.algorithmNames = exports2.SshAlgorithms = exports2.Encryption = exports2.ECDsa = exports2.Rsa = exports2.HmacAlgorithm = exports2.EncryptionAlgorithm = exports2.PublicKeyAlgorithm = exports2.KeyExchangeAlgorithm = void 0;
    var keyExchangeAlgorithm_1 = require_keyExchangeAlgorithm();
    Object.defineProperty(exports2, "KeyExchangeAlgorithm", { enumerable: true, get: function() {
      return keyExchangeAlgorithm_1.KeyExchangeAlgorithm;
    } });
    var publicKeyAlgorithm_1 = require_publicKeyAlgorithm();
    Object.defineProperty(exports2, "PublicKeyAlgorithm", { enumerable: true, get: function() {
      return publicKeyAlgorithm_1.PublicKeyAlgorithm;
    } });
    var encryptionAlgorithm_1 = require_encryptionAlgorithm();
    Object.defineProperty(exports2, "EncryptionAlgorithm", { enumerable: true, get: function() {
      return encryptionAlgorithm_1.EncryptionAlgorithm;
    } });
    var hmacAlgorithm_1 = require_hmacAlgorithm();
    Object.defineProperty(exports2, "HmacAlgorithm", { enumerable: true, get: function() {
      return hmacAlgorithm_1.HmacAlgorithm;
    } });
    var useWebCrypto = typeof self === "object" && !!(typeof crypto === "object" && crypto.subtle);
    var webKeyExchange_1 = require_webKeyExchange();
    var webRsa_1 = require_webRsa();
    var webECDsa_1 = require_webECDsa();
    var webEncryption_1 = require_webEncryption();
    var webHmac_1 = require_webHmac();
    var webRandom_1 = require_webRandom();
    var DiffieHellman = useWebCrypto ? webKeyExchange_1.WebDiffieHellman : require_nodeKeyExchange().NodeDiffieHellman;
    var ECDiffieHellman = useWebCrypto ? webKeyExchange_1.WebECDiffieHellman : require_nodeKeyExchange().NodeECDiffieHellman;
    var Rsa = useWebCrypto ? webRsa_1.WebRsa : require_nodeRsa().NodeRsa;
    exports2.Rsa = Rsa;
    var ECDsa = useWebCrypto ? webECDsa_1.WebECDsa : require_nodeECDsa().NodeECDsa;
    exports2.ECDsa = ECDsa;
    var Encryption = useWebCrypto ? webEncryption_1.WebEncryption : require_nodeEncryption().NodeEncryption;
    exports2.Encryption = Encryption;
    var Hmac = useWebCrypto ? webHmac_1.WebHmac : require_nodeHmac().NodeHmac;
    var Random = useWebCrypto ? webRandom_1.WebRandom : require_nodeRandom().NodeRandom;
    var SshAlgorithms = class {
    };
    exports2.SshAlgorithms = SshAlgorithms;
    SshAlgorithms.keyExchange = {
      none: null,
      dhGroup14Sha256: new DiffieHellman("diffie-hellman-group14-sha256", 2048, "SHA2-256"),
      dhGroup16Sha512: new DiffieHellman("diffie-hellman-group16-sha512", 4096, "SHA2-512"),
      ecdhNistp256Sha256: new ECDiffieHellman("ecdh-sha2-nistp256", 256, "SHA2-256"),
      ecdhNistp384Sha384: new ECDiffieHellman("ecdh-sha2-nistp384", 384, "SHA2-384"),
      ecdhNistp521Sha512: new ECDiffieHellman("ecdh-sha2-nistp521", 521, "SHA2-512")
    };
    SshAlgorithms.publicKey = {
      none: null,
      rsaWithSha256: new Rsa("rsa-sha2-256", "SHA2-256"),
      rsaWithSha512: new Rsa("rsa-sha2-512", "SHA2-512"),
      ecdsaSha2Nistp256: new ECDsa("ecdsa-sha2-nistp256", "SHA2-256"),
      ecdsaSha2Nistp384: new ECDsa("ecdsa-sha2-nistp384", "SHA2-384"),
      ecdsaSha2Nistp521: new ECDsa("ecdsa-sha2-nistp521", "SHA2-512")
    };
    SshAlgorithms.encryption = {
      none: null,
      ////aes256Cbc: new Encryption('aes256-cbc', 'AES', 'CBC', 256) },
      aes256Ctr: new Encryption("aes256-ctr", "AES", "CTR", 256),
      aes256Gcm: new Encryption("aes256-gcm@openssh.com", "AES", "GCM", 256)
    };
    SshAlgorithms.hmac = {
      none: null,
      hmacSha256: new Hmac("hmac-sha2-256", "SHA2-256"),
      hmacSha512: new Hmac("hmac-sha2-512", "SHA2-512"),
      hmacSha256Etm: new Hmac("hmac-sha2-256-etm@openssh.com", "SHA2-256", true),
      hmacSha512Etm: new Hmac("hmac-sha2-512-etm@openssh.com", "SHA2-512", true)
    };
    SshAlgorithms.compression = {
      none: null
    };
    SshAlgorithms.random = new Random();
    function algorithmNames(list) {
      return list.map((a) => a ? a.name : "none");
    }
    exports2.algorithmNames = algorithmNames;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/trace.js
var require_trace = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/trace.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SshTraceEventIds = exports2.TraceLevel = void 0;
    var TraceLevel;
    (function(TraceLevel2) {
      TraceLevel2["Error"] = "error";
      TraceLevel2["Warning"] = "warning";
      TraceLevel2["Info"] = "info";
      TraceLevel2["Verbose"] = "verbose";
    })(TraceLevel = exports2.TraceLevel || (exports2.TraceLevel = {}));
    var baseEventId = 9e3;
    var SshTraceEventIds = class {
    };
    exports2.SshTraceEventIds = SshTraceEventIds;
    SshTraceEventIds.unknownError = baseEventId + 0;
    SshTraceEventIds.streamReadError = baseEventId + 1;
    SshTraceEventIds.streamWriteError = baseEventId + 2;
    SshTraceEventIds.streamCloseError = baseEventId + 3;
    SshTraceEventIds.sendMessageFailed = baseEventId + 4;
    SshTraceEventIds.receiveMessageFailed = baseEventId + 5;
    SshTraceEventIds.handleMessageFailed = baseEventId + 6;
    SshTraceEventIds.serverAuthenticationFailed = baseEventId + 7;
    SshTraceEventIds.clientAuthenticationFailed = baseEventId + 8;
    SshTraceEventIds.authenticationError = baseEventId + 9;
    SshTraceEventIds.channelWindowAdjustFailed = baseEventId + 10;
    SshTraceEventIds.channelWaitForWindowAdjust = baseEventId + 11;
    SshTraceEventIds.sessionReconnectInitFailed = baseEventId + 20;
    SshTraceEventIds.serverSessionReconnectFailed = baseEventId + 21;
    SshTraceEventIds.clientSessionReconnectFailed = baseEventId + 22;
    SshTraceEventIds.sessionRequestFailed = baseEventId + 23;
    SshTraceEventIds.channelRequestFailed = baseEventId + 24;
    SshTraceEventIds.serverListenFailed = baseEventId + 50;
    SshTraceEventIds.portForwardServerListenFailed = baseEventId + 51;
    SshTraceEventIds.portForwardRequestInvalid = baseEventId + 52;
    SshTraceEventIds.portForwardChannelInvalid = baseEventId + 53;
    SshTraceEventIds.portForwardChannelOpenFailed = baseEventId + 54;
    SshTraceEventIds.portForwardConnectionFailed = baseEventId + 55;
    SshTraceEventIds.metricsError = baseEventId + 61;
    SshTraceEventIds.keepAliveFailed = baseEventId + 62;
    SshTraceEventIds.keepAliveRequestReceived = baseEventId + 63;
    SshTraceEventIds.keepAliveResponseNotReceived = baseEventId + 64;
    SshTraceEventIds.protocolVersion = baseEventId + 100;
    SshTraceEventIds.sendingMessage = baseEventId + 101;
    SshTraceEventIds.receivingMessage = baseEventId + 102;
    SshTraceEventIds.sendingChannelData = baseEventId + 103;
    SshTraceEventIds.receivingChannelData = baseEventId + 104;
    SshTraceEventIds.sessionEncrypted = baseEventId + 110;
    SshTraceEventIds.sessionAuthenticating = baseEventId + 111;
    SshTraceEventIds.sessionAuthenticated = baseEventId + 112;
    SshTraceEventIds.sessionClosing = baseEventId + 113;
    SshTraceEventIds.sessionConnecting = baseEventId + 114;
    SshTraceEventIds.channelOpened = baseEventId + 120;
    SshTraceEventIds.channelOpenFailed = baseEventId + 121;
    SshTraceEventIds.channelEofReceived = baseEventId + 122;
    SshTraceEventIds.channelClosed = baseEventId + 123;
    SshTraceEventIds.serverListening = baseEventId + 150;
    SshTraceEventIds.serverClientConnected = baseEventId + 151;
    SshTraceEventIds.portForwardServerListening = baseEventId + 152;
    SshTraceEventIds.portForwardConnectionAccepted = baseEventId + 153;
    SshTraceEventIds.portForwardChannelOpened = baseEventId + 154;
    SshTraceEventIds.portForwardChannelClosed = baseEventId + 155;
    SshTraceEventIds.portForwardConnectionOpened = baseEventId + 156;
    SshTraceEventIds.portForwardConnectionClosed = baseEventId + 157;
    SshTraceEventIds.sessionDisconnected = baseEventId + 160;
    SshTraceEventIds.clientSessionReconnecting = baseEventId + 161;
    SshTraceEventIds.serverSessionReconnecting = baseEventId + 162;
    SshTraceEventIds.clientSessionStartReconnecting = baseEventId + 163;
    SshTraceEventIds.algorithmNegotiation = baseEventId + 170;
    SshTraceEventIds.debugMessage = baseEventId + 200;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/services/serviceActivation.js
var require_serviceActivation = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/services/serviceActivation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.findService = exports2.serviceActivation = void 0;
    function serviceActivation(activation) {
      return (constructor) => {
        if (!constructor.activations) {
          constructor.activations = [];
        }
        constructor.activations.push(activation);
      };
    }
    exports2.serviceActivation = serviceActivation;
    function findService(serviceConfigs, predicate) {
      for (const serviceType of serviceConfigs.keys()) {
        const activations = serviceType.activations;
        let foundActivation = false;
        for (const activation of activations) {
          foundActivation = true;
          if (predicate(activation)) {
            return serviceType;
          }
        }
        if (!foundActivation) {
          throw new Error(`SSH service type '${serviceType.name}' must have one or more 'serviceActivation' decorators.`);
        }
      }
      return null;
    }
    exports2.findService = findService;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/messages/sshMessage.js
var require_sshMessage = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/messages/sshMessage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SshMessage = void 0;
    var buffer_1 = require("buffer");
    var sshData_1 = require_sshData();
    var SshMessage = class {
      get messageType() {
        return 0;
      }
      toBuffer() {
        const writer = new sshData_1.SshDataWriter(buffer_1.Buffer.alloc(16));
        this.write(writer);
        return writer.toBuffer();
      }
      read(reader) {
        this.rawBytes = reader.buffer;
        const number = reader.readByte();
        if (number !== this.messageType) {
          throw new Error(`Message type ${number} is not valid.`);
        }
        this.onRead(reader);
      }
      write(writer) {
        if (this.rawBytes) {
          writer.write(this.rawBytes);
        } else {
          writer.writeByte(this.messageType);
          this.onWrite(writer);
        }
      }
      /**
       * Rewrites the message to its buffer to ensure the buffer has the correct values.
       * This should be called after modifying properties of a message that was (potentially)
       * received, before re-sending it.
       */
      rewrite() {
        if (this.rawBytes) {
          const writer = new sshData_1.SshDataWriter(buffer_1.Buffer.alloc(16));
          writer.writeByte(this.messageType);
          this.onWrite(writer);
          this.rawBytes = writer.toBuffer();
        }
      }
      onRead(reader) {
        throw new Error("Not supported.");
      }
      onWrite(writer) {
        throw new Error("Not supported.");
      }
      validateField(value, name) {
        if (typeof value === "undefined") {
          throw new Error(`${this.constructor.name} ${name} is required.`);
        }
        return value;
      }
      toString() {
        return this.constructor.name;
      }
      static create(config, messageType, messageContext, data) {
        let messageClass = config.messages.get(messageType);
        if (!messageClass && messageContext) {
          const contextMessageTypes = config.contextualMessages.get(messageContext);
          if (contextMessageTypes) {
            messageClass = contextMessageTypes.get(messageType);
          }
        }
        if (messageClass) {
          const message = new messageClass();
          message.read(new sshData_1.SshDataReader(data));
          return message;
        } else {
          return null;
        }
      }
      convertTo(otherMessage, copy = false) {
        const reader = new sshData_1.SshDataReader(copy ? buffer_1.Buffer.from(this.rawBytes) : this.rawBytes);
        otherMessage.read(reader);
        return otherMessage;
      }
    };
    exports2.SshMessage = SshMessage;
    SshMessage.index = /* @__PURE__ */ new Map();
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/messages/connectionMessages.js
var require_connectionMessages = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/messages/connectionMessages.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ChannelFailureMessage = exports2.ChannelSuccessMessage = exports2.ChannelSignalMessage = exports2.CommandRequestMessage = exports2.ChannelRequestMessage = exports2.ChannelRequestType = exports2.ChannelCloseMessage = exports2.ChannelEofMessage = exports2.ChannelExtendedDataMessage = exports2.ChannelDataMessage = exports2.ChannelWindowAdjustMessage = exports2.ChannelOpenFailureMessage = exports2.SshChannelOpenFailureReason = exports2.ChannelOpenConfirmationMessage = exports2.ChannelOpenMessage = exports2.ChannelMessage = exports2.ConnectionMessage = void 0;
    var sshMessage_1 = require_sshMessage();
    var sshData_1 = require_sshData();
    var ConnectionMessage = class extends sshMessage_1.SshMessage {
    };
    exports2.ConnectionMessage = ConnectionMessage;
    var ChannelMessage = class extends ConnectionMessage {
      get recipientChannel() {
        return this.recipientChannelValue;
      }
      set recipientChannel(value) {
        if (value !== this.recipientChannelValue) {
          this.recipientChannelValue = value;
          if (this.rawBytes) {
            sshData_1.SshDataWriter.writeUInt32(this.rawBytes, 1, value !== null && value !== void 0 ? value : 0);
          }
        }
      }
      onRead(reader) {
        this.recipientChannel = reader.readUInt32();
      }
      onWrite(writer) {
        writer.writeUInt32(this.validateField(this.recipientChannel, "recipient channel"));
      }
      toString() {
        return `${super.toString()} (recipientChannel=${this.recipientChannel})`;
      }
    };
    exports2.ChannelMessage = ChannelMessage;
    var ChannelOpenMessage = class _ChannelOpenMessage extends ConnectionMessage {
      get messageType() {
        return 90;
      }
      get senderChannel() {
        return this.senderChannelValue;
      }
      set senderChannel(value) {
        if (value !== this.senderChannelValue) {
          this.senderChannelValue = value;
          if (this.rawBytes && this.channelType) {
            sshData_1.SshDataWriter.writeUInt32(this.rawBytes, 1 + 4 + this.channelType.length, value !== null && value !== void 0 ? value : 0);
          }
        }
      }
      onRead(reader) {
        this.channelType = reader.readString("ascii");
        this.senderChannel = reader.readUInt32();
        this.maxWindowSize = reader.readUInt32();
        this.maxPacketSize = reader.readUInt32();
      }
      onWrite(writer) {
        writer.writeString(this.validateField(this.channelType, "channel type"), "ascii");
        writer.writeUInt32(this.validateField(this.senderChannel, "sender channel"));
        writer.writeUInt32(this.maxWindowSize || _ChannelOpenMessage.defaultMaxWindowSize);
        writer.writeUInt32(this.maxPacketSize || _ChannelOpenMessage.defaultMaxPacketSize);
      }
      toString() {
        return `${super.toString()}(channelType=${this.channelType}, senderChannel=${this.senderChannel})`;
      }
    };
    exports2.ChannelOpenMessage = ChannelOpenMessage;
    ChannelOpenMessage.defaultMaxPacketSize = 32 * 1024;
    ChannelOpenMessage.defaultMaxWindowSize = 1024 * 1024;
    var ChannelOpenConfirmationMessage = class extends ChannelMessage {
      get messageType() {
        return 91;
      }
      onRead(reader) {
        super.onRead(reader);
        this.senderChannel = reader.readUInt32();
        this.maxWindowSize = reader.readUInt32();
        this.maxPacketSize = reader.readUInt32();
      }
      onWrite(writer) {
        super.onWrite(writer);
        writer.writeUInt32(this.validateField(this.senderChannel, "sender channel"));
        writer.writeUInt32(this.validateField(this.maxWindowSize, "max window size"));
        writer.writeUInt32(this.validateField(this.maxPacketSize, "max packet size"));
      }
      toString() {
        return `${super.toString()}(senderChannel=${this.senderChannel})`;
      }
    };
    exports2.ChannelOpenConfirmationMessage = ChannelOpenConfirmationMessage;
    var SshChannelOpenFailureReason;
    (function(SshChannelOpenFailureReason2) {
      SshChannelOpenFailureReason2[SshChannelOpenFailureReason2["none"] = 0] = "none";
      SshChannelOpenFailureReason2[SshChannelOpenFailureReason2["administrativelyProhibited"] = 1] = "administrativelyProhibited";
      SshChannelOpenFailureReason2[SshChannelOpenFailureReason2["connectFailed"] = 2] = "connectFailed";
      SshChannelOpenFailureReason2[SshChannelOpenFailureReason2["unknownChannelType"] = 3] = "unknownChannelType";
      SshChannelOpenFailureReason2[SshChannelOpenFailureReason2["resourceShortage"] = 4] = "resourceShortage";
    })(SshChannelOpenFailureReason = exports2.SshChannelOpenFailureReason || (exports2.SshChannelOpenFailureReason = {}));
    var ChannelOpenFailureMessage = class extends ChannelMessage {
      get messageType() {
        return 92;
      }
      onRead(reader) {
        super.onRead(reader);
        this.reasonCode = reader.readUInt32();
        this.description = reader.readString("utf8");
        this.language = reader.readString("ascii");
      }
      onWrite(writer) {
        super.onWrite(writer);
        writer.writeUInt32(this.validateField(this.reasonCode, "reason code"));
        writer.writeString(this.description || "", "utf8");
        writer.writeString(this.language || "en", "ascii");
      }
      toString() {
        return `${super.toString()} (${SshChannelOpenFailureReason[this.reasonCode || 0]}: ${this.description})`;
      }
    };
    exports2.ChannelOpenFailureMessage = ChannelOpenFailureMessage;
    var ChannelWindowAdjustMessage = class extends ChannelMessage {
      get messageType() {
        return 93;
      }
      onRead(reader) {
        super.onRead(reader);
        this.bytesToAdd = reader.readUInt32();
      }
      onWrite(writer) {
        super.onWrite(writer);
        writer.writeUInt32(this.validateField(this.bytesToAdd, "bytes to add"));
      }
      toString() {
        return `${super.toString()} (bytesToAdd=${this.bytesToAdd})`;
      }
    };
    exports2.ChannelWindowAdjustMessage = ChannelWindowAdjustMessage;
    var ChannelDataMessage = class extends ChannelMessage {
      get messageType() {
        return 94;
      }
      onRead(reader) {
        super.onRead(reader);
        this.data = reader.readBinary();
      }
      onWrite(writer) {
        super.onWrite(writer);
        writer.writeBinary(this.validateField(this.data, "data"));
      }
      toString() {
        return this.data ? (0, sshData_1.formatBuffer)(this.data, "") : "[0]";
      }
    };
    exports2.ChannelDataMessage = ChannelDataMessage;
    var ChannelExtendedDataMessage = class extends ChannelMessage {
      get messageType() {
        return 95;
      }
      onRead(reader) {
        super.onRead(reader);
        this.dataTypeCode = reader.readUInt32();
        this.data = reader.readBinary();
      }
      onWrite(writer) {
        super.onWrite(writer);
        writer.writeUInt32(this.validateField(this.dataTypeCode, "data type code"));
        writer.writeBinary(this.validateField(this.data, "data"));
      }
      toString() {
        return `${super.toString()} (dataTypeCode=${this.dataTypeCode}, data=${this.data ? (0, sshData_1.formatBuffer)(this.data, "") : "[0]"})`;
      }
    };
    exports2.ChannelExtendedDataMessage = ChannelExtendedDataMessage;
    var ChannelEofMessage = class extends ChannelMessage {
      get messageType() {
        return 96;
      }
    };
    exports2.ChannelEofMessage = ChannelEofMessage;
    var ChannelCloseMessage = class extends ChannelMessage {
      get messageType() {
        return 97;
      }
    };
    exports2.ChannelCloseMessage = ChannelCloseMessage;
    var ChannelRequestType;
    (function(ChannelRequestType2) {
      ChannelRequestType2["command"] = "exec";
      ChannelRequestType2["shell"] = "shell";
      ChannelRequestType2["terminal"] = "pty-req";
      ChannelRequestType2["signal"] = "signal";
      ChannelRequestType2["exitSignal"] = "exit-signal";
      ChannelRequestType2["exitStatus"] = "exit-status";
    })(ChannelRequestType = exports2.ChannelRequestType || (exports2.ChannelRequestType = {}));
    var ChannelRequestMessage = class extends ChannelMessage {
      constructor(requestType, wantReply) {
        super();
        this.requestType = requestType;
        this.wantReply = wantReply !== null && wantReply !== void 0 ? wantReply : false;
      }
      get messageType() {
        return 98;
      }
      onRead(reader) {
        super.onRead(reader);
        this.requestType = reader.readString("ascii");
        this.wantReply = reader.readBoolean();
      }
      onWrite(writer) {
        if (typeof this.recipientChannel === "undefined") {
          this.recipientChannel = 0;
        }
        super.onWrite(writer);
        writer.writeString(this.validateField(this.requestType, "request type"), "ascii");
        writer.writeBoolean(this.wantReply);
      }
    };
    exports2.ChannelRequestMessage = ChannelRequestMessage;
    var CommandRequestMessage = class extends ChannelRequestMessage {
      constructor() {
        super();
        this.requestType = ChannelRequestType.command;
      }
      onRead(reader) {
        super.onRead(reader);
        this.command = reader.readString("utf8");
      }
      onWrite(writer) {
        super.onWrite(writer);
        writer.writeString(this.validateField(this.command, "command"), "utf8");
      }
      toString() {
        return `${super.toString()} (requestType=${this.requestType})`;
      }
    };
    exports2.CommandRequestMessage = CommandRequestMessage;
    var ChannelSignalMessage = class extends ChannelRequestMessage {
      constructor() {
        super();
      }
      get signal() {
        return this.signalValue;
      }
      set signal(value) {
        this.requestType = ChannelRequestType.signal;
        this.signalValue = value;
      }
      get exitSignal() {
        return this.signalValue;
      }
      set exitSignal(value) {
        this.requestType = ChannelRequestType.exitSignal;
        this.signalValue = value;
      }
      get errorMessage() {
        return this.errorMessageValue;
      }
      set errorMessage(value) {
        if (this.requestType !== ChannelRequestType.exitSignal) {
          throw new Error(`Error message property is only valid for ${ChannelRequestType.exitSignal} messages.`);
        }
        this.errorMessageValue = value;
      }
      get exitStatus() {
        return this.statusValue;
      }
      set exitStatus(value) {
        this.requestType = ChannelRequestType.exitStatus;
        this.statusValue = value;
      }
      onRead(reader) {
        super.onRead(reader);
        switch (this.requestType) {
          case ChannelRequestType.exitStatus:
            this.exitStatus = reader.readUInt32();
            break;
          case ChannelRequestType.signal:
            this.signal = reader.readString("ascii");
            break;
          case ChannelRequestType.exitSignal:
            this.exitSignal = reader.readString("ascii");
            reader.readBoolean();
            this.errorMessage = reader.readString("utf8");
            reader.readString("ascii");
            break;
          default:
            break;
        }
      }
      onWrite(writer) {
        if (!this.requestType) {
          throw new Error("Signal message request type not set.");
        }
        this.wantReply = false;
        super.onWrite(writer);
        switch (this.requestType) {
          case ChannelRequestType.exitStatus:
            writer.writeUInt32(this.validateField(this.exitStatus, "exit status"));
            break;
          case ChannelRequestType.signal:
            writer.writeString(this.validateField(this.signal, "signal"), "ascii");
            break;
          case ChannelRequestType.exitSignal:
            writer.writeString(this.validateField(this.exitSignal, "exit signal"), "ascii");
            writer.writeBoolean(false);
            writer.writeString(this.errorMessage || "", "utf8");
            writer.writeString("", "ascii");
            break;
          default:
            throw new Error(`Unknown signal message request type: ${this.requestType}`);
        }
      }
    };
    exports2.ChannelSignalMessage = ChannelSignalMessage;
    var ChannelSuccessMessage = class extends ChannelMessage {
      get messageType() {
        return 99;
      }
    };
    exports2.ChannelSuccessMessage = ChannelSuccessMessage;
    var ChannelFailureMessage = class extends ChannelMessage {
      get messageType() {
        return 100;
      }
    };
    exports2.ChannelFailureMessage = ChannelFailureMessage;
    sshMessage_1.SshMessage.index.set(90, ChannelOpenMessage);
    sshMessage_1.SshMessage.index.set(91, ChannelOpenConfirmationMessage);
    sshMessage_1.SshMessage.index.set(92, ChannelOpenFailureMessage);
    sshMessage_1.SshMessage.index.set(93, ChannelWindowAdjustMessage);
    sshMessage_1.SshMessage.index.set(94, ChannelDataMessage);
    sshMessage_1.SshMessage.index.set(95, ChannelExtendedDataMessage);
    sshMessage_1.SshMessage.index.set(96, ChannelEofMessage);
    sshMessage_1.SshMessage.index.set(97, ChannelCloseMessage);
    sshMessage_1.SshMessage.index.set(98, ChannelRequestMessage);
    sshMessage_1.SshMessage.index.set(99, ChannelSuccessMessage);
    sshMessage_1.SshMessage.index.set(100, ChannelFailureMessage);
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/messages/transportMessages.js
var require_transportMessages = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/messages/transportMessages.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SessionReconnectFailureMessage = exports2.SshReconnectFailureReason = exports2.SessionReconnectResponseMessage = exports2.SessionReconnectRequestMessage = exports2.SessionChannelRequestMessage = exports2.ExtensionInfoMessage = exports2.SessionRequestFailureMessage = exports2.SessionRequestSuccessMessage = exports2.SessionRequestMessage = exports2.ServiceAcceptMessage = exports2.ServiceRequestMessage = exports2.DebugMessage = exports2.UnimplementedMessage = exports2.IgnoreMessage = exports2.DisconnectMessage = exports2.SshDisconnectReason = void 0;
    var sshMessage_1 = require_sshMessage();
    var connectionMessages_1 = require_connectionMessages();
    var SshDisconnectReason;
    (function(SshDisconnectReason2) {
      SshDisconnectReason2[SshDisconnectReason2["none"] = 0] = "none";
      SshDisconnectReason2[SshDisconnectReason2["hostNotAllowedToConnect"] = 1] = "hostNotAllowedToConnect";
      SshDisconnectReason2[SshDisconnectReason2["protocolError"] = 2] = "protocolError";
      SshDisconnectReason2[SshDisconnectReason2["keyExchangeFailed"] = 3] = "keyExchangeFailed";
      SshDisconnectReason2[SshDisconnectReason2["reserved"] = 4] = "reserved";
      SshDisconnectReason2[SshDisconnectReason2["macError"] = 5] = "macError";
      SshDisconnectReason2[SshDisconnectReason2["compressionError"] = 6] = "compressionError";
      SshDisconnectReason2[SshDisconnectReason2["serviceNotAvailable"] = 7] = "serviceNotAvailable";
      SshDisconnectReason2[SshDisconnectReason2["protocolVersionNotSupported"] = 8] = "protocolVersionNotSupported";
      SshDisconnectReason2[SshDisconnectReason2["hostKeyNotVerifiable"] = 9] = "hostKeyNotVerifiable";
      SshDisconnectReason2[SshDisconnectReason2["connectionLost"] = 10] = "connectionLost";
      SshDisconnectReason2[SshDisconnectReason2["byApplication"] = 11] = "byApplication";
      SshDisconnectReason2[SshDisconnectReason2["tooManyConnections"] = 12] = "tooManyConnections";
      SshDisconnectReason2[SshDisconnectReason2["authCancelledByUser"] = 13] = "authCancelledByUser";
      SshDisconnectReason2[SshDisconnectReason2["noMoreAuthMethodsAvailable"] = 14] = "noMoreAuthMethodsAvailable";
      SshDisconnectReason2[SshDisconnectReason2["illegalUserName"] = 15] = "illegalUserName";
    })(SshDisconnectReason = exports2.SshDisconnectReason || (exports2.SshDisconnectReason = {}));
    var DisconnectMessage = class extends sshMessage_1.SshMessage {
      get messageType() {
        return 1;
      }
      onRead(reader) {
        this.reasonCode = reader.readUInt32();
        this.description = reader.readString("utf8");
        if (reader.available >= 4) {
          this.language = reader.readString("ascii");
        } else {
          this.language = null;
        }
      }
      onWrite(writer) {
        writer.writeUInt32(this.validateField(this.reasonCode, "reason code"));
        writer.writeString(this.description || "", "utf8");
        if (this.language) {
          writer.writeString(this.language, "ascii");
        }
      }
      toString() {
        return `${super.toString()} (${SshDisconnectReason[this.reasonCode || 0]}: ${this.description})`;
      }
    };
    exports2.DisconnectMessage = DisconnectMessage;
    var IgnoreMessage = class extends sshMessage_1.SshMessage {
      get messageType() {
        return 2;
      }
      onRead(reader) {
      }
      onWrite(writer) {
      }
    };
    exports2.IgnoreMessage = IgnoreMessage;
    var UnimplementedMessage = class extends sshMessage_1.SshMessage {
      get messageType() {
        return 3;
      }
      onRead(reader) {
        this.sequenceNumber = reader.readUInt32();
      }
      onWrite(writer) {
        writer.writeUInt32(this.validateField(this.sequenceNumber, "sequence number"));
      }
      toString() {
        return this.unimplementedMessageType ? `${super.toString()} (messageType=${this.unimplementedMessageType})` : `${super.toString()} (sequenceNumber=${this.sequenceNumber})`;
      }
    };
    exports2.UnimplementedMessage = UnimplementedMessage;
    var DebugMessage = class extends sshMessage_1.SshMessage {
      constructor(message) {
        super();
        this.alwaysDisplay = false;
        this.message = message;
      }
      get messageType() {
        return 4;
      }
      onRead(reader) {
        this.alwaysDisplay = reader.readBoolean();
        this.message = reader.readString("utf8");
        this.language = reader.readString("ascii");
      }
      onWrite(writer) {
        var _a, _b;
        writer.writeBoolean(this.alwaysDisplay);
        writer.writeString((_a = this.message) !== null && _a !== void 0 ? _a : "", "utf8");
        writer.writeString((_b = this.language) !== null && _b !== void 0 ? _b : "", "ascii");
      }
      toString() {
        return `${super.toString()}: ${this.message}`;
      }
    };
    exports2.DebugMessage = DebugMessage;
    var ServiceRequestMessage = class extends sshMessage_1.SshMessage {
      get messageType() {
        return 5;
      }
      onRead(reader) {
        this.serviceName = reader.readString("ascii");
      }
      onWrite(writer) {
        writer.writeString(this.validateField(this.serviceName, "service name"), "ascii");
      }
    };
    exports2.ServiceRequestMessage = ServiceRequestMessage;
    var ServiceAcceptMessage = class extends sshMessage_1.SshMessage {
      get messageType() {
        return 6;
      }
      onRead(reader) {
        this.serviceName = reader.readString("ascii");
      }
      onWrite(writer) {
        writer.writeString(this.validateField(this.serviceName, "service name"), "ascii");
      }
    };
    exports2.ServiceAcceptMessage = ServiceAcceptMessage;
    var SessionRequestMessage = class extends sshMessage_1.SshMessage {
      constructor(requestType, wantReply) {
        super();
        this.requestType = requestType;
        this.wantReply = wantReply !== null && wantReply !== void 0 ? wantReply : false;
      }
      get messageType() {
        return 80;
      }
      onRead(reader) {
        this.requestType = reader.readString("ascii");
        this.wantReply = reader.readBoolean();
      }
      onWrite(writer) {
        writer.writeString(this.validateField(this.requestType, "request type"), "ascii");
        writer.writeBoolean(this.wantReply);
      }
      toString() {
        return `${super.toString()} (requestType=${this.requestType})`;
      }
    };
    exports2.SessionRequestMessage = SessionRequestMessage;
    var SessionRequestSuccessMessage = class extends sshMessage_1.SshMessage {
      get messageType() {
        return 81;
      }
      onRead(reader) {
      }
      onWrite(writer) {
      }
    };
    exports2.SessionRequestSuccessMessage = SessionRequestSuccessMessage;
    var SessionRequestFailureMessage = class extends sshMessage_1.SshMessage {
      get messageType() {
        return 82;
      }
      onRead(reader) {
      }
      onWrite(writer) {
      }
    };
    exports2.SessionRequestFailureMessage = SessionRequestFailureMessage;
    var ExtensionInfoMessage = class extends sshMessage_1.SshMessage {
      constructor() {
        super(...arguments);
        this.extensionInfo = {};
      }
      get messageType() {
        return 7;
      }
      onRead(reader) {
        const count = reader.readUInt32();
        this.extensionInfo = {};
        for (let i = 0; i < count; i++) {
          const key = reader.readString("ascii");
          const value = reader.readString("utf8");
          this.extensionInfo[key] = value;
        }
      }
      onWrite(writer) {
        const keys = Object.keys(this.extensionInfo);
        writer.writeUInt32(keys.length);
        for (const key of keys) {
          writer.writeString(key, "ascii");
          writer.writeString(this.extensionInfo[key] || "", "utf8");
        }
      }
      toString() {
        let extensionInfoDetails = "";
        for (const [key, value] of Object.entries(this.extensionInfo)) {
          if (extensionInfoDetails) {
            extensionInfoDetails += "; ";
          }
          extensionInfoDetails += key;
          if (value) {
            extensionInfoDetails += "=" + value;
          }
        }
        return `${super.toString()} (${extensionInfoDetails})`;
      }
    };
    exports2.ExtensionInfoMessage = ExtensionInfoMessage;
    ExtensionInfoMessage.serverIndicator = "ext-info-c";
    ExtensionInfoMessage.clientIndicator = "ext-info-c";
    var SessionChannelRequestMessage = class extends SessionRequestMessage {
      onRead(reader) {
        super.onRead(reader);
        this.senderChannel = reader.readUInt32();
        const request = new connectionMessages_1.ChannelRequestMessage();
        request.read(reader);
        this.request = request;
      }
      onWrite(writer) {
        super.onWrite(writer);
        writer.writeUInt32(this.validateField(this.senderChannel, "sender channel"));
        this.validateField(this.request, "request message").write(writer);
      }
    };
    exports2.SessionChannelRequestMessage = SessionChannelRequestMessage;
    var SessionReconnectRequestMessage = class extends SessionRequestMessage {
      onRead(reader) {
        super.onRead(reader);
        this.clientReconnectToken = reader.readBinary();
        this.lastReceivedSequenceNumber = reader.readUInt64();
      }
      onWrite(writer) {
        super.onWrite(writer);
        writer.writeBinary(this.validateField(this.clientReconnectToken, "clientReconnectToken"));
        writer.writeUInt64(this.validateField(this.lastReceivedSequenceNumber, "lastReceivedSequenceNumber"));
      }
    };
    exports2.SessionReconnectRequestMessage = SessionReconnectRequestMessage;
    var SessionReconnectResponseMessage = class extends SessionRequestSuccessMessage {
      onRead(reader) {
        super.onRead(reader);
        this.serverReconnectToken = reader.readBinary();
        this.lastReceivedSequenceNumber = reader.readUInt64();
      }
      onWrite(writer) {
        super.onWrite(writer);
        writer.writeBinary(this.validateField(this.serverReconnectToken, "serverReconnectToken"));
        writer.writeUInt64(this.validateField(this.lastReceivedSequenceNumber, "lastReceivedSequenceNumber"));
      }
    };
    exports2.SessionReconnectResponseMessage = SessionReconnectResponseMessage;
    var SshReconnectFailureReason;
    (function(SshReconnectFailureReason2) {
      SshReconnectFailureReason2[SshReconnectFailureReason2["none"] = 0] = "none";
      SshReconnectFailureReason2[SshReconnectFailureReason2["unknownServerFailure"] = 1] = "unknownServerFailure";
      SshReconnectFailureReason2[SshReconnectFailureReason2["sessionNotFound"] = 2] = "sessionNotFound";
      SshReconnectFailureReason2[SshReconnectFailureReason2["invalidClientReconnectToken"] = 3] = "invalidClientReconnectToken";
      SshReconnectFailureReason2[SshReconnectFailureReason2["serverDroppedMessages"] = 4] = "serverDroppedMessages";
      SshReconnectFailureReason2[SshReconnectFailureReason2["unknownClientFailure"] = 101] = "unknownClientFailure";
      SshReconnectFailureReason2[SshReconnectFailureReason2["differentServerHostKey"] = 102] = "differentServerHostKey";
      SshReconnectFailureReason2[SshReconnectFailureReason2["invalidServerReconnectToken"] = 103] = "invalidServerReconnectToken";
      SshReconnectFailureReason2[SshReconnectFailureReason2["clientDroppedMessages"] = 104] = "clientDroppedMessages";
    })(SshReconnectFailureReason = exports2.SshReconnectFailureReason || (exports2.SshReconnectFailureReason = {}));
    var SessionReconnectFailureMessage = class extends SessionRequestFailureMessage {
      onRead(reader) {
        if (reader.available > 0) {
          this.reasonCode = reader.readUInt32();
          this.description = reader.readString("utf8");
          this.language = reader.readString("ascii");
        }
      }
      onWrite(writer) {
        writer.writeUInt32(this.validateField(this.reasonCode, "reason code"));
        writer.writeString(this.description || "", "utf8");
        writer.writeString(this.language || "en", "ascii");
      }
      toString() {
        return `${super.toString()} (${SshReconnectFailureReason[this.reasonCode || 0]}: ${this.description})`;
      }
    };
    exports2.SessionReconnectFailureMessage = SessionReconnectFailureMessage;
    sshMessage_1.SshMessage.index.set(1, DisconnectMessage);
    sshMessage_1.SshMessage.index.set(2, IgnoreMessage);
    sshMessage_1.SshMessage.index.set(3, UnimplementedMessage);
    sshMessage_1.SshMessage.index.set(5, ServiceRequestMessage);
    sshMessage_1.SshMessage.index.set(6, ServiceAcceptMessage);
    sshMessage_1.SshMessage.index.set(7, ExtensionInfoMessage);
    sshMessage_1.SshMessage.index.set(80, SessionRequestMessage);
    sshMessage_1.SshMessage.index.set(81, SessionRequestSuccessMessage);
    sshMessage_1.SshMessage.index.set(82, SessionRequestFailureMessage);
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/metrics/channelMetrics.js
var require_channelMetrics = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/metrics/channelMetrics.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ChannelMetrics = void 0;
    var ChannelMetrics = class {
      /* @internal */
      constructor() {
        this.bytesSentSum = 0;
        this.bytesReceivedSum = 0;
      }
      /**
       * Gets the total cumulative number of bytes sent for the duration of the channel,
       * not including message framing, padding, and MAC bytes.
       */
      get bytesSent() {
        return this.bytesSentSum;
      }
      /**
       * Gets the total cumulative number of bytes received for the duration of the channel,
       * not including message framing, padding, and MAC bytes.
       */
      get bytesReceived() {
        return this.bytesReceivedSum;
      }
      /* @internal */
      addBytesSent(count) {
        this.bytesSentSum += count;
      }
      /* @internal */
      addBytesReceived(count) {
        this.bytesReceivedSum += count;
      }
      toString() {
        return `Bytes S/R: ${this.bytesSent} / ${this.bytesReceived}; `;
      }
    };
    exports2.ChannelMetrics = ChannelMetrics;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/util/promiseCompletionSource.js
var require_promiseCompletionSource = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/util/promiseCompletionSource.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PromiseCompletionSource = void 0;
    var PromiseCompletionSource = class {
      constructor() {
        this.promise = new Promise((resolve3, reject) => {
          this.resolve = resolve3;
          this.reject = reject;
        });
      }
      resolve(result) {
      }
      reject(e) {
      }
    };
    exports2.PromiseCompletionSource = PromiseCompletionSource;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/errors.js
var require_errors = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/errors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ObjectDisposedError = exports2.SshChannelError = exports2.SshReconnectError = exports2.SshConnectionError = void 0;
    var SshConnectionError = class extends Error {
      constructor(message, reason) {
        super(message);
        this.reason = reason;
      }
    };
    exports2.SshConnectionError = SshConnectionError;
    var SshReconnectError = class extends Error {
      constructor(message, reason) {
        super(message);
        this.reason = reason;
      }
    };
    exports2.SshReconnectError = SshReconnectError;
    var SshChannelError = class extends Error {
      constructor(message, reason) {
        super(message);
        this.reason = reason;
      }
    };
    exports2.SshChannelError = SshChannelError;
    var ObjectDisposedError = class extends Error {
      // eslint-disable-next-line @typescript-eslint/ban-types
      constructor(objectOrMessage) {
        var _a, _b;
        let message;
        if (typeof objectOrMessage === "string") {
          message = objectOrMessage;
        } else if (typeof objectOrMessage === "function") {
          message = objectOrMessage.name + " disposed.";
        } else {
          message = ((_b = (_a = objectOrMessage === null || objectOrMessage === void 0 ? void 0 : objectOrMessage.constructor) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : "Object ") + " disposed.";
        }
        super(message);
      }
    };
    exports2.ObjectDisposedError = ObjectDisposedError;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/events/sshRequestEventArgs.js
var require_sshRequestEventArgs = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/events/sshRequestEventArgs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SshRequestEventArgs = void 0;
    var vscode_jsonrpc_1 = require_main();
    var SshRequestEventArgs = class {
      constructor(requestType, request, principal, cancellation) {
        this.requestType = requestType;
        this.request = request;
        this.principal = principal;
        this.cancellationValue = cancellation !== null && cancellation !== void 0 ? cancellation : vscode_jsonrpc_1.CancellationToken.None;
      }
      /**
       * Gets a token that is cancelled if the session ends before the request handler
       * completes.
       */
      get cancellation() {
        return this.cancellationValue;
      }
      /* @internal */
      set cancellation(value) {
        this.cancellationValue = value;
      }
      toString() {
        return `RequestType: ${this.requestType}` + this.request ? ` Request: ${this.request}` : "";
      }
    };
    exports2.SshRequestEventArgs = SshRequestEventArgs;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/events/sshChannelClosedEventArgs.js
var require_sshChannelClosedEventArgs = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/events/sshChannelClosedEventArgs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SshChannelClosedEventArgs = void 0;
    var SshChannelClosedEventArgs = class {
      constructor(exitStatusOrSignalOrError, errorMessage) {
        if (typeof exitStatusOrSignalOrError === "number") {
          this.exitStatus = exitStatusOrSignalOrError;
        } else if (typeof exitStatusOrSignalOrError === "string") {
          this.exitSignal = exitStatusOrSignalOrError;
          this.errorMessage = errorMessage;
        } else if (exitStatusOrSignalOrError instanceof Error) {
          this.error = exitStatusOrSignalOrError;
        }
      }
    };
    exports2.SshChannelClosedEventArgs = SshChannelClosedEventArgs;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/util/cancellation.js
var require_cancellation2 = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/util/cancellation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.withCancellation = exports2.CancellationError = exports2.CancellationTokenSource = exports2.CancellationToken = void 0;
    var vscode_jsonrpc_1 = require_main();
    Object.defineProperty(exports2, "CancellationToken", { enumerable: true, get: function() {
      return vscode_jsonrpc_1.CancellationToken;
    } });
    Object.defineProperty(exports2, "CancellationTokenSource", { enumerable: true, get: function() {
      return vscode_jsonrpc_1.CancellationTokenSource;
    } });
    var CancellationError = class extends Error {
      constructor(message) {
        super(message || "Operation cancelled.");
      }
    };
    exports2.CancellationError = CancellationError;
    function withCancellation(promise2, cancellation) {
      if (!cancellation) {
        return promise2;
      }
      return Promise.race([
        promise2,
        new Promise((resolve3, reject) => {
          if (cancellation.isCancellationRequested) {
            reject(new CancellationError());
          } else {
            cancellation.onCancellationRequested(() => {
              reject(new CancellationError());
            });
          }
        })
      ]);
    }
    exports2.withCancellation = withCancellation;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/util/semaphore.js
var require_semaphore = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/util/semaphore.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Semaphore = void 0;
    var promiseCompletionSource_1 = require_promiseCompletionSource();
    var cancellation_1 = require_cancellation2();
    var errors_1 = require_errors();
    var Semaphore = class {
      /**
       * Creates a new semaphore instance.
       * @param initialCount Optional initial count. Defaults to 0.
       */
      constructor(initialCount = 0) {
        this.completions = [];
        this.disposed = false;
        this.count = initialCount;
      }
      /**
       * Gets the current available count of the semaphore.
       */
      get currentCount() {
        return this.count;
      }
      /**
       * Releases the semaphore, increasing the available count or unblicking one or more awaiters.
       * @param releaseCount Optional specified count to release. Defaults to 1.
       * @returns The previous count (before release).
       */
      release(releaseCount = 1) {
        if (this.disposed)
          throw new errors_1.ObjectDisposedError(this);
        const previousCount = this.count;
        for (; releaseCount > 0; releaseCount--) {
          if (this.completions.length > 0) {
            const completion = this.completions.shift();
            completion.resolve(true);
          } else {
            this.count++;
          }
        }
        return previousCount;
      }
      /**
       * Releases the semaphore, but does not throw an `ObjectDisposedError` if it is already disposed.
       */
      tryRelease() {
        try {
          this.release();
        } catch (e) {
          if (!(e instanceof errors_1.ObjectDisposedError)) {
            throw e;
          }
        }
      }
      async wait(timeoutOrCancellation, cancellation) {
        const millisecondsTimeout = typeof timeoutOrCancellation === "number" ? timeoutOrCancellation : void 0;
        if (typeof cancellation === "undefined" && typeof timeoutOrCancellation === "object") {
          cancellation = timeoutOrCancellation;
        }
        if (this.disposed)
          throw new errors_1.ObjectDisposedError(this);
        if (cancellation === null || cancellation === void 0 ? void 0 : cancellation.isCancellationRequested)
          throw new cancellation_1.CancellationError();
        if (this.count > 0) {
          this.count--;
          return true;
        } else if (millisecondsTimeout === 0) {
          return false;
        } else {
          const completion = new promiseCompletionSource_1.PromiseCompletionSource();
          this.completions.push(completion);
          const promises = [completion.promise];
          if (millisecondsTimeout) {
            promises.push(new Promise((resolve3) => setTimeout(() => resolve3(false), millisecondsTimeout)));
          }
          if (cancellation) {
            const cancellationCompletion = new promiseCompletionSource_1.PromiseCompletionSource();
            cancellation.onCancellationRequested(() => {
              cancellationCompletion.reject(new cancellation_1.CancellationError());
            });
            promises.push(cancellationCompletion.promise);
          }
          if (await Promise.race(promises)) {
            return true;
          } else {
            const completionIndex = this.completions.indexOf(completion);
            if (completionIndex >= 0)
              this.completions.splice(completionIndex, 1);
            return false;
          }
        }
      }
      /**
       * Disposes the semaphore and throws a diposed error to any awaiters.
       */
      dispose() {
        if (this.disposed)
          return;
        this.disposed = true;
        for (const completion of this.completions) {
          completion.reject(new errors_1.ObjectDisposedError(this));
        }
        this.completions.splice(0, this.completions.length);
        this.count = 0;
      }
    };
    exports2.Semaphore = Semaphore;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/pipeExtensions.js
var require_pipeExtensions = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/pipeExtensions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PipeExtensions = void 0;
    var buffer_1 = require("buffer");
    var vscode_jsonrpc_1 = require_main();
    var transportMessages_1 = require_transportMessages();
    var connectionMessages_1 = require_connectionMessages();
    var promiseCompletionSource_1 = require_promiseCompletionSource();
    var errors_1 = require_errors();
    var trace_1 = require_trace();
    var PipeExtensions = class _PipeExtensions {
      static async pipeSession(session, toSession) {
        if (!session)
          throw new TypeError("Session is required.");
        if (!toSession)
          throw new TypeError("Target session is required");
        const endCompletion = new promiseCompletionSource_1.PromiseCompletionSource();
        session.onRequest((e) => {
          e.responsePromise = _PipeExtensions.forwardSessionRequest(e, toSession, e.cancellation);
        });
        toSession.onRequest((e) => {
          e.responsePromise = _PipeExtensions.forwardSessionRequest(e, session, e.cancellation);
        });
        session.onChannelOpening((e) => {
          if (e.isRemoteRequest) {
            e.openingPromise = _PipeExtensions.forwardChannel(e, toSession, e.cancellation);
          }
        });
        toSession.onChannelOpening((e) => {
          if (e.isRemoteRequest) {
            e.openingPromise = _PipeExtensions.forwardChannel(e, session, e.cancellation);
          }
        });
        session.onClosed((e) => {
          endCompletion.resolve(_PipeExtensions.forwardSessionClose(toSession, e));
        });
        toSession.onClosed((e) => {
          endCompletion.resolve(_PipeExtensions.forwardSessionClose(session, e));
        });
        const endPromise = await endCompletion.promise;
        await endPromise;
      }
      static async pipeChannel(channel, toChannel) {
        if (!channel)
          throw new TypeError("Channel is required.");
        if (!toChannel)
          throw new TypeError("Target channel is required");
        const endCompletion = new promiseCompletionSource_1.PromiseCompletionSource();
        let closed = false;
        channel.onRequest((e) => {
          e.responsePromise = _PipeExtensions.forwardChannelRequest(e, toChannel, e.cancellation);
        });
        toChannel.onRequest((e) => {
          e.responsePromise = _PipeExtensions.forwardChannelRequest(e, channel, e.cancellation);
        });
        channel.onDataReceived((data) => {
          void _PipeExtensions.forwardData(channel, toChannel, data).catch();
        });
        toChannel.onDataReceived((data) => {
          void _PipeExtensions.forwardData(toChannel, channel, data).catch();
        });
        channel.onEof(() => {
          void _PipeExtensions.forwardData(channel, toChannel, buffer_1.Buffer.alloc(0)).catch();
        });
        toChannel.onEof(() => {
          void _PipeExtensions.forwardData(toChannel, channel, buffer_1.Buffer.alloc(0)).catch();
        });
        channel.onExtendedDataReceived((data) => {
          void _PipeExtensions.forwardExtendedData(channel, toChannel, data.dataTypeCode, data.data).catch();
        });
        toChannel.onExtendedDataReceived((data) => {
          void _PipeExtensions.forwardExtendedData(toChannel, channel, data.dataTypeCode, data.data).catch();
        });
        channel.onClosed((e) => {
          if (!closed) {
            closed = true;
            endCompletion.resolve(_PipeExtensions.forwardChannelClose(channel, toChannel, e));
          }
        });
        toChannel.onClosed((e) => {
          if (!closed) {
            closed = true;
            endCompletion.resolve(_PipeExtensions.forwardChannelClose(toChannel, channel, e));
          }
        });
        const endTask = await endCompletion.promise;
        await endTask;
      }
      static async forwardSessionRequest(e, toSession, cancellation) {
        if (!e.request.wantReply) {
          return toSession.request(e.request, cancellation).then(() => new transportMessages_1.SessionRequestSuccessMessage());
        }
        return toSession.requestResponse(e.request, transportMessages_1.SessionRequestSuccessMessage, transportMessages_1.SessionRequestFailureMessage, cancellation);
      }
      static async forwardChannel(e, toSession, cancellation) {
        var _a;
        try {
          const toChannel = await toSession.openChannel(e.request, null, cancellation);
          void _PipeExtensions.pipeChannel(e.channel, toChannel).catch();
          return new connectionMessages_1.ChannelOpenConfirmationMessage();
        } catch (err) {
          if (!(err instanceof Error))
            throw err;
          const failureMessage = new connectionMessages_1.ChannelOpenFailureMessage();
          if (err instanceof errors_1.SshChannelError) {
            failureMessage.reasonCode = (_a = err.reason) !== null && _a !== void 0 ? _a : connectionMessages_1.SshChannelOpenFailureReason.connectFailed;
          } else {
            failureMessage.reasonCode = connectionMessages_1.SshChannelOpenFailureReason.connectFailed;
          }
          failureMessage.description = err.message;
          return failureMessage;
        }
      }
      static async forwardChannelRequest(e, toChannel, cancellation) {
        e.request.recipientChannel = toChannel.remoteChannelId;
        const result = await toChannel.request(e.request, cancellation);
        return result ? new connectionMessages_1.ChannelSuccessMessage() : new connectionMessages_1.ChannelFailureMessage();
      }
      static async forwardSessionClose(session, e) {
        var _a;
        return session.close(e.reason, e.message, (_a = e.error) !== null && _a !== void 0 ? _a : void 0);
      }
      static async forwardData(channel, toChannel, data) {
        const buffer = buffer_1.Buffer.alloc(data.length);
        data.copy(buffer);
        const promise2 = toChannel.send(buffer, vscode_jsonrpc_1.CancellationToken.None);
        channel.adjustWindow(buffer.length);
        return promise2;
      }
      static async forwardExtendedData(channel, toChannel, dataTypeCode, data) {
        const buffer = buffer_1.Buffer.alloc(data.length);
        data.copy(buffer);
        const promise2 = toChannel.sendExtendedData(dataTypeCode, buffer, vscode_jsonrpc_1.CancellationToken.None);
        channel.adjustWindow(buffer.length);
        return promise2;
      }
      static async forwardChannelClose(fromChannel, toChannel, e) {
        const message = `Piping channel closure.
Source: ${fromChannel.session} ${fromChannel}
Destination: ${toChannel.session} ${toChannel}
`;
        toChannel.session.trace(trace_1.TraceLevel.Verbose, trace_1.SshTraceEventIds.channelClosed, message);
        if (e.error) {
          toChannel.close(e.error);
          return Promise.resolve();
        } else if (e.exitSignal) {
          return toChannel.close(e.exitSignal, e.errorMessage);
        } else if (typeof e.exitStatus === "number") {
          return toChannel.close(e.exitStatus);
        } else {
          return toChannel.close();
        }
      }
    };
    exports2.PipeExtensions = PipeExtensions;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/util/queue.js
var require_queue = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/util/queue.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Queue = void 0;
    var Queue2 = class {
      constructor() {
        this.array = new Array();
        this.first = 0;
        this.count = 0;
        this.version = 0;
      }
      /**
       * Gets the current size of the queue.
       */
      get size() {
        return this.count;
      }
      /**
       * Adds an item to the end of the queue.
       */
      enqueue(item) {
        if (this.count === this.array.length) {
          const newArray = new Array(Math.max(16, this.count * 2));
          for (let i = 0; i < this.count; i++) {
            newArray[i] = this.array[(this.first + i) % this.count];
          }
          this.array = newArray;
          this.first = 0;
        }
        this.array[(this.first + this.count) % this.array.length] = item;
        this.count++;
        this.version++;
      }
      /**
       * Removes an item from the front of the queue.
       * @returns The removed item, or `undefined` if the queue is empty.
       */
      dequeue() {
        if (this.count === 0)
          return void 0;
        const item = this.array[this.first];
        this.array[this.first] = void 0;
        this.first = (this.first + 1) % this.array.length;
        this.count--;
        this.version++;
        return item;
      }
      /**
       * Gets the item at the front of the queue without removing it.
       * @returns The front item, or `undefined` if the queue is empty.
       */
      peek() {
        if (this.count === 0)
          return void 0;
        const item = this.array[this.first];
        return item;
      }
      /**
       * Clears the queue.
       */
      clear() {
        this.first = 0;
        this.count = 0;
        this.array.fill(void 0);
        this.version++;
      }
      /**
       * Creates an iterator over the items in the queue.
       * (Any changes to the queue will invalidate the iterator.)
       */
      *[Symbol.iterator]() {
        const iteratorVersion = this.version;
        for (let i = 0; i < this.count; i++) {
          const item = this.array[(this.first + i) % this.array.length];
          yield item;
          if (this.version !== iteratorVersion) {
            throw new Error("Iterator is invalid due to changes in the collection.");
          }
        }
      }
    };
    exports2.Queue = Queue2;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/sshChannel.js
var require_sshChannel = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/sshChannel.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SshChannel = void 0;
    var vscode_jsonrpc_1 = require_main();
    var serviceActivation_1 = require_serviceActivation();
    var connectionMessages_1 = require_connectionMessages();
    var transportMessages_1 = require_transportMessages();
    var channelMetrics_1 = require_channelMetrics();
    var promiseCompletionSource_1 = require_promiseCompletionSource();
    var errors_1 = require_errors();
    var sshRequestEventArgs_1 = require_sshRequestEventArgs();
    var sshChannelClosedEventArgs_1 = require_sshChannelClosedEventArgs();
    var cancellation_1 = require_cancellation2();
    var semaphore_1 = require_semaphore();
    var trace_1 = require_trace();
    var pipeExtensions_1 = require_pipeExtensions();
    var queue_1 = require_queue();
    var SshChannel = class _SshChannel {
      /* @internal */
      constructor(connectionService, channelType, channelId, remoteChannelId, remoteMaxWindowSize, remoteMaxPacketSize, openMessage, openConfirmationMessage) {
        this.connectionService = connectionService;
        this.channelType = channelType;
        this.channelId = channelId;
        this.remoteChannelId = remoteChannelId;
        this.openMessage = openMessage;
        this.openConfirmationMessage = openConfirmationMessage;
        this.remoteClosed = false;
        this.localClosed = false;
        this.sentEof = false;
        this.disposed = false;
        this.openSendingWindowCompletionSource = null;
        this.requestCompletionSources = new queue_1.Queue();
        this.sendSemaphore = new semaphore_1.Semaphore(0);
        this.metrics = new channelMetrics_1.ChannelMetrics();
        this.dataReceivedEmitter = new vscode_jsonrpc_1.Emitter();
        this.extendedDataReceivedEmitter = new vscode_jsonrpc_1.Emitter();
        this.onDataReceived = this.dataReceivedEmitter.event;
        this.onExtendedDataReceived = this.extendedDataReceivedEmitter.event;
        this.eofEmitter = new vscode_jsonrpc_1.Emitter();
        this.onEof = this.eofEmitter.event;
        this.closedEmitter = new vscode_jsonrpc_1.Emitter();
        this.onClosed = this.closedEmitter.event;
        this.requestEmitter = new vscode_jsonrpc_1.Emitter();
        this.onRequest = this.requestEmitter.event;
        this.isMaxWindowSizeLocked = false;
        this.remoteWindowSize = remoteMaxWindowSize;
        this.maxWindowSizeValue = _SshChannel.defaultMaxWindowSize;
        this.windowSize = this.maxWindowSizeValue;
        this.maxPacketSize = Math.min(remoteMaxPacketSize, _SshChannel.defaultMaxPacketSize);
      }
      get session() {
        return this.connectionService.session;
      }
      get isClosed() {
        return this.localClosed || this.remoteClosed;
      }
      /**
       * Gets the maximum window size for received data. The other side will not send more
       * data than the window size until it receives an acknowledgement that some of the data was
       * received and processed by this side.
       */
      get maxWindowSize() {
        return this.maxWindowSizeValue;
      }
      /**
       * Sets the maximum window size for received data. The other side will not send more
       * data than the window size until it receives an acknowledgement that some of the data was
       * received and processed by this side.
       *
       * The default value is `defaultMaxWindowSize`. The value may be configured for a channel
       * opened by this side by setting `ChannelOpenMessage.maxWindowSize` in the message object
       * passed to `SshSession.openChannel()`, or for a channel opened by the other side by
       * assigning to this property while handling the `SshSession.onChannelOpening` event.
       * Changing the maximum window size at any other time is not valid because the other
       * side would not be aware of the change.
       */
      set maxWindowSize(value) {
        if (this.isMaxWindowSizeLocked) {
          throw new Error("Cannot change the max window size after opening the channel.");
        }
        if (value < this.maxPacketSize) {
          throw new Error("Maximum window size cannot be less than maximum packet size.");
        }
        this.maxWindowSizeValue = value;
      }
      /**
       * Sends a channel request and waits for a response.
       *
       * Note if `wantReply` is `false`, this method returns `true` immediately after sending the
       * request, without waiting for a reply.
       *
       * @returns The authorization status of the response; if false, the other side denied the
       * request.
       * @throws `ObjectDisposedError` if the channel was closed before sending the request.
       * @throws `SshChannelError` if the channel was closed while waiting for a reply to the request.
       */
      async request(request, cancellation) {
        if (!request)
          throw new TypeError("Request is required.");
        if (this.disposed)
          throw new errors_1.ObjectDisposedError(this);
        request.recipientChannel = this.remoteChannelId;
        if (!request.wantReply) {
          await this.session.sendMessage(request, cancellation);
          return true;
        }
        const requestCompletionSource = new promiseCompletionSource_1.PromiseCompletionSource();
        if (cancellation) {
          if (cancellation.isCancellationRequested)
            throw new cancellation_1.CancellationError();
          cancellation.onCancellationRequested(() => {
            requestCompletionSource.reject(new cancellation_1.CancellationError());
          });
        }
        this.requestCompletionSources.enqueue(requestCompletionSource);
        await this.session.sendMessage(request, cancellation);
        return await requestCompletionSource.promise;
      }
      async send(data, cancellation) {
        return this.sendCommon(data, void 0, cancellation);
      }
      async sendExtendedData(dataTypeCode, data, cancellation) {
        return this.sendCommon(data, dataTypeCode, cancellation);
      }
      async sendCommon(data, extendedDataType, cancellation) {
        if (this.disposed)
          throw new errors_1.ObjectDisposedError(this);
        if (data.length === 0) {
          await this.sendEof();
          return;
        } else if (this.sentEof) {
          throw new Error("Cannot send more data after EOF.");
        }
        await this.sendSemaphore.wait(cancellation);
        try {
          let offset = 0;
          let count = data.length;
          while (count > 0) {
            let packetSize = Math.min(Math.min(this.remoteWindowSize, this.maxPacketSize), count);
            while (packetSize === 0) {
              if (!this.openSendingWindowCompletionSource) {
                this.openSendingWindowCompletionSource = new promiseCompletionSource_1.PromiseCompletionSource();
              }
              this.session.trace(trace_1.TraceLevel.Warning, trace_1.SshTraceEventIds.channelWaitForWindowAdjust, `${this} send window is full. Waiting for window adjustment before sending.`);
              await (0, cancellation_1.withCancellation)(this.openSendingWindowCompletionSource.promise, cancellation);
              this.openSendingWindowCompletionSource = null;
              packetSize = Math.min(Math.min(this.remoteWindowSize, this.maxPacketSize), count);
            }
            let msg;
            if (extendedDataType !== void 0) {
              msg = new connectionMessages_1.ChannelExtendedDataMessage();
              msg.dataTypeCode = extendedDataType;
            } else {
              msg = new connectionMessages_1.ChannelDataMessage();
            }
            msg.recipientChannel = this.remoteChannelId;
            msg.data = Buffer.from(data.slice(offset, offset + packetSize));
            await this.session.sendMessage(msg, cancellation);
            this.remoteWindowSize -= packetSize;
            count -= packetSize;
            offset += packetSize;
            this.metrics.addBytesSent(packetSize);
          }
        } finally {
          this.sendSemaphore.tryRelease();
        }
      }
      /* @internal */
      enableSending() {
        this.sendSemaphore.tryRelease();
      }
      async sendEof(cancellation) {
        if (this.sentEof) {
          return;
        }
        await this.sendSemaphore.wait(cancellation);
        try {
          this.sentEof = true;
          const msg = new connectionMessages_1.ChannelEofMessage();
          msg.recipientChannel = this.remoteChannelId;
          await this.session.sendMessage(msg, cancellation);
        } finally {
          this.sendSemaphore.tryRelease();
        }
      }
      /* @internal */
      async handleRequest(request, cancellation) {
        if (!request.requestType) {
          throw new errors_1.SshConnectionError("Channel request type not specified.", transportMessages_1.SshDisconnectReason.protocolError);
        }
        if (request.requestType === connectionMessages_1.ChannelRequestType.exitStatus) {
          const signal = new connectionMessages_1.ChannelSignalMessage();
          request.convertTo(signal);
          this.exitStatus = signal.exitStatus;
          return true;
        } else if (request.requestType === connectionMessages_1.ChannelRequestType.exitSignal) {
          const signal = new connectionMessages_1.ChannelSignalMessage();
          request.convertTo(signal);
          this.exitSignal = signal.exitSignal;
          this.exitErrorMessage = signal.errorMessage;
          return true;
        } else if (request.requestType === connectionMessages_1.ChannelRequestType.signal) {
          const signal = new connectionMessages_1.ChannelSignalMessage();
          request.convertTo(signal);
        }
        const args = new sshRequestEventArgs_1.SshRequestEventArgs(request.requestType, request, this.session.principal, cancellation);
        const serviceType = (0, serviceActivation_1.findService)(this.session.config.services, (a) => (!a.channelType || a.channelType === this.channelType) && a.channelRequest === request.requestType);
        await this.sendSemaphore.wait(cancellation);
        try {
          let response = null;
          if (serviceType) {
            const service = this.session.activateService(serviceType);
            await service.onChannelRequest(this, args, cancellation);
          } else {
            this.requestEmitter.fire(args);
          }
          if (args.responsePromise) {
            response = await args.responsePromise;
            args.isAuthorized = response instanceof connectionMessages_1.ChannelSuccessMessage;
          }
          if (request.wantReply) {
            if (args.isAuthorized) {
              response = response !== null && response !== void 0 ? response : new connectionMessages_1.ChannelSuccessMessage();
              response.recipientChannel = this.remoteChannelId;
            } else {
              response = response !== null && response !== void 0 ? response : new connectionMessages_1.ChannelFailureMessage();
              response.recipientChannel = this.remoteChannelId;
            }
            await this.session.sendMessage(response, cancellation);
          }
        } finally {
          this.sendSemaphore.tryRelease();
        }
        return args.isAuthorized || false;
      }
      /* @internal */
      handleResponse(result) {
        const requestCompletionSource = this.requestCompletionSources.dequeue();
        if (requestCompletionSource) {
          requestCompletionSource.resolve(result);
        }
      }
      /* @internal */
      handleDataReceived(data) {
        this.metrics.addBytesReceived(data.length);
        this.dataReceivedEmitter.fire(data);
      }
      handleExtendedDataReceived(data) {
        this.metrics.addBytesReceived(data.data.length);
        this.extendedDataReceivedEmitter.fire(data);
      }
      /**
       * Adjusts the local receiving window size by the specified amount, notifying
       * the remote side that it is free to send more data.
       *
       * This method MUST be called either immediately or eventually by the
       * `onDataReceived` event handler as incoming data is processed.
       */
      adjustWindow(messageLength) {
        if (this.disposed)
          return;
        this.windowSize -= messageLength;
        if (this.windowSize <= this.maxWindowSizeValue / 2) {
          const windowAdjustMessage = new connectionMessages_1.ChannelWindowAdjustMessage();
          windowAdjustMessage.recipientChannel = this.remoteChannelId;
          windowAdjustMessage.bytesToAdd = this.maxWindowSizeValue - this.windowSize;
          this.windowSize = this.maxWindowSizeValue;
          this.session.sendMessage(windowAdjustMessage).catch((e) => {
            this.session.trace(trace_1.TraceLevel.Error, trace_1.SshTraceEventIds.channelWindowAdjustFailed, `Error sending window adjust message: ${e.message}`, e);
          });
        }
      }
      /* @internal */
      adjustRemoteWindow(bytesToAdd) {
        this.remoteWindowSize += bytesToAdd;
        if (this.openSendingWindowCompletionSource) {
          this.openSendingWindowCompletionSource.resolve(void 0);
        }
      }
      /* @internal */
      handleEof() {
        this.session.trace(trace_1.TraceLevel.Info, trace_1.SshTraceEventIds.channelEofReceived, `${this} EOF received.`);
        this.eofEmitter.fire();
      }
      close(exitStatusOrSignal, errorMessage, cancellation) {
        if (exitStatusOrSignal instanceof Error) {
          const error = exitStatusOrSignal;
          if (!this.localClosed) {
            this.localClosed = true;
            this.session.trace(trace_1.TraceLevel.Info, trace_1.SshTraceEventIds.channelClosed, `${this} Closed: ${error.message}`);
            this.closedEmitter.fire(new sshChannelClosedEventArgs_1.SshChannelClosedEventArgs(error));
          }
          this.disposeInternal();
          return;
        }
        if (typeof exitStatusOrSignal === "number") {
          return this.closeWithStatus(exitStatusOrSignal, errorMessage);
        } else if (typeof exitStatusOrSignal === "string") {
          return this.closeWithSignal(exitStatusOrSignal, errorMessage, cancellation);
        } else {
          return this.closeDefault(exitStatusOrSignal);
        }
      }
      async closeDefault(cancellation) {
        if (!this.remoteClosed && !this.localClosed) {
          this.remoteClosed = true;
          await this.sendSemaphore.wait(cancellation);
          try {
            const closeMessage = new connectionMessages_1.ChannelCloseMessage();
            closeMessage.recipientChannel = this.remoteChannelId;
            await this.session.sendMessage(closeMessage);
          } catch (e) {
          } finally {
            this.sendSemaphore.tryRelease();
          }
        }
        if (!this.localClosed) {
          this.localClosed = true;
          const closedMessage = this.raiseClosedEvent();
        }
        this.disposeInternal();
      }
      async closeWithStatus(exitStatus, cancellation) {
        if (!this.remoteClosed && !this.localClosed) {
          this.exitStatus = exitStatus;
          const signalMessage = new connectionMessages_1.ChannelSignalMessage();
          signalMessage.recipientChannel = this.remoteChannelId;
          signalMessage.exitStatus = exitStatus;
          await this.session.sendMessage(signalMessage);
        }
        await this.closeDefault(cancellation);
      }
      async closeWithSignal(exitSignal, errorMessage, cancellation) {
        if (!this.remoteClosed && !this.localClosed) {
          this.exitSignal = exitSignal;
          this.exitErrorMessage = errorMessage;
          const signalMessage = new connectionMessages_1.ChannelSignalMessage();
          signalMessage.recipientChannel = this.remoteChannelId;
          signalMessage.exitSignal = exitSignal;
          signalMessage.errorMessage = errorMessage;
          await this.session.sendMessage(signalMessage);
        }
        await this.closeDefault(cancellation);
      }
      /* @internal */
      handleClose() {
        if (!this.localClosed) {
          this.localClosed = true;
          const closedMessage = this.raiseClosedEvent(true);
        }
        this.disposeInternal();
      }
      raiseClosedEvent(closedByRemote = false) {
        const metricsMessage = ` (S: ${this.metrics.bytesSent}, R: ${this.metrics.bytesReceived})`;
        const originMessage = closedByRemote ? "remotely" : "locally";
        let closedMessage;
        let args;
        if (typeof this.exitStatus !== "undefined") {
          args = new sshChannelClosedEventArgs_1.SshChannelClosedEventArgs(this.exitStatus);
          closedMessage = `${this} closed ${originMessage}: status=${this.exitStatus}`;
        } else if (typeof this.exitSignal !== "undefined") {
          args = new sshChannelClosedEventArgs_1.SshChannelClosedEventArgs(this.exitSignal, this.exitErrorMessage);
          closedMessage = `${this} closed ${originMessage}: signal=${this.exitSignal} ${this.exitErrorMessage}`;
        } else {
          args = new sshChannelClosedEventArgs_1.SshChannelClosedEventArgs();
          closedMessage = `${this} closed ${originMessage}.`;
        }
        this.session.trace(trace_1.TraceLevel.Info, trace_1.SshTraceEventIds.channelClosed, closedMessage + metricsMessage);
        this.closedEmitter.fire(args);
        return closedMessage;
      }
      dispose() {
        if (!this.disposed && !this.localClosed) {
          if (!this.remoteClosed) {
            this.remoteClosed = true;
            const closeMessage = new connectionMessages_1.ChannelCloseMessage();
            closeMessage.recipientChannel = this.remoteChannelId;
            this.session.sendMessage(closeMessage).catch((e) => {
            });
          }
          const message = this.session.isClosed ? `${this.session} closed.` : `${this} disposed.`;
          this.session.trace(trace_1.TraceLevel.Info, trace_1.SshTraceEventIds.channelClosed, message);
          const args = new sshChannelClosedEventArgs_1.SshChannelClosedEventArgs("SIGABRT", message);
          this.localClosed = true;
          this.closedEmitter.fire(args);
        }
        this.disposeInternal();
      }
      disposeInternal() {
        if (this.disposed)
          return;
        this.disposed = true;
        this.cancelPendingRequests();
        this.connectionService.removeChannel(this);
        this.sendSemaphore.dispose();
      }
      /**
       * Pipes one SSH channel into another, relaying all data between them.
       * @param toChannel Channel to which the current channel will be connected via the pipe.
       * @returns A promise that resolves when the channels are closed.
       */
      pipe(toChannel) {
        return pipeExtensions_1.PipeExtensions.pipeChannel(this, toChannel);
      }
      cancelPendingRequests() {
        for (const completion of this.requestCompletionSources) {
          completion.resolve(false);
        }
      }
      toString() {
        return `SshChannel(Type: ${this.channelType}, Id: ${this.channelId}, RemoteId: ${this.remoteChannelId})`;
      }
    };
    exports2.SshChannel = SshChannel;
    SshChannel.sessionChannelType = "session";
    SshChannel.defaultMaxPacketSize = connectionMessages_1.ChannelOpenMessage.defaultMaxPacketSize;
    SshChannel.defaultMaxWindowSize = connectionMessages_1.ChannelOpenMessage.defaultMaxWindowSize;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/package.json
var require_package = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/package.json"(exports2, module2) {
    module2.exports = {
      name: "@microsoft/dev-tunnels-ssh",
      version: "3.12.12",
      description: "SSH library for Dev Tunnels",
      repository: "https://github.com/microsoft/dev-tunnels-ssh.git",
      keywords: [
        "SSH"
      ],
      author: "Microsoft",
      license: "MIT",
      dependencies: {
        buffer: "^5.2.1",
        debug: "^4.1.1",
        "diffie-hellman": "^5.0.3",
        "vscode-jsonrpc": "^4.0.0"
      },
      main: "./index.js"
    };
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/sshVersionInfo.js
var require_sshVersionInfo = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/sshVersionInfo.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SshVersionInfo = void 0;
    var packageJson = require_package();
    var packageName = packageJson.name.replace(/^@\w+\//, "");
    var packageVersion = packageJson.version;
    var SshVersionInfo = class _SshVersionInfo {
      /**
       * Attempts to parse an SSH version string into a version info object.
       */
      static tryParse(versionString) {
        if (!versionString) {
          throw new TypeError("Version string expected.");
        }
        if (!versionString.startsWith("SSH-")) {
          return null;
        }
        const firstDashIndex = 3;
        const secondDashIndex = versionString.indexOf("-", firstDashIndex + 1);
        if (secondDashIndex <= 0) {
          return null;
        }
        const protocolVersion = versionString.substring(firstDashIndex + 1, secondDashIndex);
        if (!/^\d+\.\d+$/.test(protocolVersion)) {
          return null;
        }
        let name;
        let version;
        const nameAndVersion = versionString.substring(secondDashIndex + 1);
        const spaceIndex = nameAndVersion.indexOf(" ");
        const lastUnderscoreBeforeSpace = nameAndVersion.lastIndexOf("_", spaceIndex >= 0 ? spaceIndex : nameAndVersion.length - 1);
        if (lastUnderscoreBeforeSpace >= 0) {
          name = nameAndVersion.substring(0, lastUnderscoreBeforeSpace).replace(/_/g, " ");
          version = nameAndVersion.substring(lastUnderscoreBeforeSpace + 1);
          for (let i = 0; i < version.length; i++) {
            const c = version[i];
            if (!(c >= "0" && c <= "9") && c !== ".") {
              version = version.substring(0, i);
              break;
            }
          }
          if (!/^\d+(\.\d+)*$/.test(version)) {
            version = null;
          }
        } else {
          name = nameAndVersion;
          version = null;
        }
        return new _SshVersionInfo(versionString, protocolVersion, name, version);
      }
      /**
       * Gets the version info for the current SSH library.
       */
      static getLocalVersion() {
        const protocolVersion = "2.0";
        const versionString = `SSH-${protocolVersion}-${packageName}_${packageVersion}`;
        return new _SshVersionInfo(versionString, protocolVersion, packageName, packageVersion);
      }
      constructor(versionString, protocolVersion, name, version) {
        this.versionString = versionString;
        this.protocolVersion = protocolVersion;
        this.name = name;
        this.version = version;
      }
      /** Returns the original SSH version string that was parsed. */
      toString() {
        return this.versionString;
      }
      /**
       * Gets a value indicating whether this version info represents some version of
       * this library.
       */
      get isVsSsh() {
        return this.isVsSshCS || this.isVsSshTS;
      }
      get isVsSshCS() {
        return this.name === "Microsoft.VisualStudio.Ssh" || this.name === "Microsoft.DevTunnels.Ssh";
      }
      get isVsSshTS() {
        return this.name === "vs-ssh" || this.name === "dev-tunnels-ssh";
      }
    };
    exports2.SshVersionInfo = SshVersionInfo;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/messages/kexMessages.js
var require_kexMessages = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/messages/kexMessages.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NewKeysMessage = exports2.KeyExchangeDhReplyMessage = exports2.KeyExchangeDhInitMessage = exports2.KeyExchangeInitMessage = exports2.KeyExchangeMessage = void 0;
    var buffer_1 = require("buffer");
    var sshMessage_1 = require_sshMessage();
    var sshAlgorithms_1 = require_sshAlgorithms();
    var KeyExchangeMessage = class extends sshMessage_1.SshMessage {
    };
    exports2.KeyExchangeMessage = KeyExchangeMessage;
    var keyExchangeInitCookieLength = 16;
    var KeyExchangeInitMessage = class _KeyExchangeInitMessage extends KeyExchangeMessage {
      get messageType() {
        return 20;
      }
      onRead(reader) {
        this.cookie = reader.read(keyExchangeInitCookieLength);
        this.keyExchangeAlgorithms = reader.readList("ascii");
        this.serverHostKeyAlgorithms = reader.readList("ascii");
        this.encryptionAlgorithmsClientToServer = reader.readList("ascii");
        this.encryptionAlgorithmsServerToClient = reader.readList("ascii");
        this.macAlgorithmsClientToServer = reader.readList("ascii");
        this.macAlgorithmsServerToClient = reader.readList("ascii");
        this.compressionAlgorithmsClientToServer = reader.readList("ascii");
        this.compressionAlgorithmsServerToClient = reader.readList("ascii");
        this.languagesClientToServer = reader.readList("ascii");
        this.languagesServerToClient = reader.readList("ascii");
        this.firstKexPacketFollows = reader.readBoolean();
        this.reserved = reader.readUInt32();
      }
      onWrite(writer) {
        var _a;
        if (!this.cookie) {
          this.cookie = buffer_1.Buffer.alloc(keyExchangeInitCookieLength);
          sshAlgorithms_1.SshAlgorithms.random.getBytes(this.cookie);
        }
        writer.write(this.cookie);
        writer.writeList(this.keyExchangeAlgorithms || [], "ascii");
        writer.writeList(this.serverHostKeyAlgorithms || [], "ascii");
        writer.writeList(this.encryptionAlgorithmsClientToServer || [], "ascii");
        writer.writeList(this.encryptionAlgorithmsServerToClient || [], "ascii");
        writer.writeList(this.macAlgorithmsClientToServer || [], "ascii");
        writer.writeList(this.macAlgorithmsServerToClient || [], "ascii");
        writer.writeList(this.compressionAlgorithmsClientToServer || [], "ascii");
        writer.writeList(this.compressionAlgorithmsServerToClient || [], "ascii");
        writer.writeList(this.languagesClientToServer || [], "ascii");
        writer.writeList(this.languagesServerToClient || [], "ascii");
        writer.writeBoolean((_a = this.firstKexPacketFollows) !== null && _a !== void 0 ? _a : false);
        writer.writeUInt32(this.reserved || 0);
      }
      static CreateNone() {
        const noneArray = ["none"];
        const emptyArray = [""];
        const message = new _KeyExchangeInitMessage();
        message.cookie = buffer_1.Buffer.alloc(keyExchangeInitCookieLength);
        message.keyExchangeAlgorithms = noneArray;
        message.serverHostKeyAlgorithms = noneArray;
        message.encryptionAlgorithmsClientToServer = noneArray;
        message.encryptionAlgorithmsServerToClient = noneArray;
        message.macAlgorithmsClientToServer = noneArray;
        message.macAlgorithmsServerToClient = noneArray;
        message.compressionAlgorithmsClientToServer = noneArray;
        message.compressionAlgorithmsServerToClient = noneArray;
        message.languagesClientToServer = emptyArray;
        message.languagesServerToClient = emptyArray;
        message.rawBytes = message.toBuffer();
        return message;
      }
      get allowsNone() {
        const includesNone = (algorithms) => (algorithms === null || algorithms === void 0 ? void 0 : algorithms.includes("none")) === true;
        return includesNone(this.keyExchangeAlgorithms) && includesNone(this.serverHostKeyAlgorithms) && includesNone(this.encryptionAlgorithmsClientToServer) && includesNone(this.encryptionAlgorithmsServerToClient) && includesNone(this.macAlgorithmsClientToServer) && includesNone(this.macAlgorithmsServerToClient) && includesNone(this.compressionAlgorithmsClientToServer) && includesNone(this.compressionAlgorithmsServerToClient) && this.firstKexPacketFollows !== true;
      }
    };
    exports2.KeyExchangeInitMessage = KeyExchangeInitMessage;
    KeyExchangeInitMessage.none = KeyExchangeInitMessage.CreateNone();
    var KeyExchangeDhInitMessage = class extends KeyExchangeMessage {
      get messageType() {
        return 30;
      }
      onRead(reader) {
        this.e = reader.readBinary();
      }
      onWrite(writer) {
        writer.writeBinary(this.validateField(this.e, "E"));
      }
    };
    exports2.KeyExchangeDhInitMessage = KeyExchangeDhInitMessage;
    var KeyExchangeDhReplyMessage = class extends KeyExchangeMessage {
      get messageType() {
        return 31;
      }
      onRead(reader) {
        this.hostKey = reader.readBinary();
        this.f = reader.readBinary();
        this.signature = reader.readBinary();
      }
      onWrite(writer) {
        writer.writeBinary(this.validateField(this.hostKey, "host key"));
        writer.writeBinary(this.validateField(this.f, "F"));
        writer.writeBinary(this.validateField(this.signature, "signature"));
      }
    };
    exports2.KeyExchangeDhReplyMessage = KeyExchangeDhReplyMessage;
    var NewKeysMessage = class extends KeyExchangeMessage {
      get messageType() {
        return 21;
      }
      onRead(reader) {
      }
      onWrite(writer) {
      }
    };
    exports2.NewKeysMessage = NewKeysMessage;
    sshMessage_1.SshMessage.index.set(20, KeyExchangeInitMessage);
    sshMessage_1.SshMessage.index.set(30, KeyExchangeDhInitMessage);
    sshMessage_1.SshMessage.index.set(31, KeyExchangeDhReplyMessage);
    sshMessage_1.SshMessage.index.set(21, NewKeysMessage);
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/io/sshProtocol.js
var require_sshProtocol = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/io/sshProtocol.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SshProtocol = void 0;
    var buffer_1 = require("buffer");
    var queue_1 = require_queue();
    var semaphore_1 = require_semaphore();
    var sshMessage_1 = require_sshMessage();
    var sshData_1 = require_sshData();
    var transportMessages_1 = require_transportMessages();
    var kexMessages_1 = require_kexMessages();
    var connectionMessages_1 = require_connectionMessages();
    var errors_1 = require_errors();
    var trace_1 = require_trace();
    var SequencedMessage = class {
      constructor(sequence, message) {
        this.sequence = sequence;
        this.message = message;
      }
    };
    var SshProtocol = class _SshProtocol {
      constructor(stream, config, metrics, trace) {
        this.config = config;
        this.metrics = metrics;
        this.trace = trace;
        this.sessionSemaphore = new semaphore_1.Semaphore(1);
        this.inboundPacketSequence = 0;
        this.outboundPacketSequence = 0;
        this.inboundFlow = 0;
        this.outboundFlow = 0;
        this.recentSentMessages = new queue_1.Queue();
        this.sendWriter = new sshData_1.SshDataWriter(buffer_1.Buffer.alloc(1024));
        this.receiveWriter = new sshData_1.SshDataWriter(buffer_1.Buffer.alloc(1024));
        this.traceChannelData = false;
        this.extensions = null;
        this.kexService = null;
        this.algorithms = null;
        this.messageContext = null;
        this.outgoingMessagesHaveLatencyInfo = false;
        this.incomingMessagesHaveLatencyInfo = false;
        this.outgoingMessagesHaveReconnectInfo = false;
        this.incomingMessagesHaveReconnectInfo = false;
        this.stream = stream;
        this.traceChannelData = config.traceChannelData;
      }
      get lastIncomingSequence() {
        return this.inboundPacketSequence - 1;
      }
      getSentMessages(startingSequenceNumber) {
        if (startingSequenceNumber === this.outboundPacketSequence + 1) {
          return [];
        }
        if (this.recentSentMessages.size > 0 && startingSequenceNumber < this.recentSentMessages.peek().sequence) {
          return null;
        }
        const messagesToRetransmit = new Array();
        for (const sequencedMessage of this.recentSentMessages) {
          if (sequencedMessage.sequence >= startingSequenceNumber) {
            const message = sequencedMessage.message;
            if (!(message instanceof kexMessages_1.KeyExchangeMessage || message instanceof transportMessages_1.DisconnectMessage)) {
              messagesToRetransmit.push(message);
            }
          }
        }
        return messagesToRetransmit;
      }
      async writeProtocolVersion(version, cancellation) {
        const stream = this.stream;
        if (!stream)
          throw new Error("SSH session disconnected.");
        const data = buffer_1.Buffer.from(version + "\r\n");
        await stream.write(data, cancellation);
        this.metrics.addMessageSent(data.length);
        return Promise.resolve();
      }
      async readProtocolVersion(cancellation) {
        const stream = this.stream;
        if (!stream)
          throw new Error("SSH session disconnected.");
        const buffer = buffer_1.Buffer.alloc(255);
        let lineCount = 0;
        for (let i = 0; i < buffer.length; i++) {
          const byteBuffer = await stream.read(1, cancellation);
          if (!byteBuffer) {
            break;
          }
          buffer[i] = byteBuffer[0];
          const carriageReturn = 13;
          const lineFeed = 10;
          if (i > 0 && buffer[i - 1] === carriageReturn && buffer[i] === lineFeed) {
            const line = buffer.toString("utf8", 0, i - 1);
            if (line.startsWith("SSH-")) {
              this.metrics.addMessageReceived(i + 1);
              return line;
            } else if (lineCount > 20) {
              break;
            } else {
              lineCount++;
              i = -1;
            }
          }
        }
        throw new errors_1.SshConnectionError("Failed to read the protocol version", transportMessages_1.SshDisconnectReason.protocolError);
      }
      async handleNewKeys(cancellation) {
        try {
          await this.sessionSemaphore.wait(cancellation);
          this.inboundFlow = 0;
          this.outboundFlow = 0;
          this.algorithms = this.kexService.finishKeyExchange();
        } finally {
          this.sessionSemaphore.release();
        }
      }
      /**
       * Attempts to read from the stream until the buffer is full.
       * @returns True if the read succeeded, false if the stream was disposed.
       */
      async read(buffer, cancellation) {
        const stream = this.stream;
        if (!stream)
          return false;
        let bytesRead = 0;
        do {
          let data;
          try {
            data = await stream.read(buffer.length - bytesRead, cancellation);
          } catch (e) {
            if (!(e instanceof Error))
              throw e;
            if (stream.isDisposed)
              return false;
            stream.dispose();
            this.stream = null;
            this.trace(trace_1.TraceLevel.Error, trace_1.SshTraceEventIds.streamReadError, `Error reading from stream: ${e.message}`, e);
            throw new errors_1.SshConnectionError("Error reading from stream: " + e.message, transportMessages_1.SshDisconnectReason.connectionLost);
          }
          if (!data)
            return false;
          data.copy(buffer, bytesRead);
          bytesRead += data.length;
        } while (bytesRead < buffer.length);
        return true;
      }
      /**
       * Attempts to write data to the stream.
       * @returns True if the write succeeded, false if the stream was disposed.
       */
      async write(data, cancellation) {
        const stream = this.stream;
        if (!stream)
          return false;
        try {
          await stream.write(data, cancellation);
        } catch (e) {
          if (!(e instanceof Error))
            throw e;
          if (stream.isDisposed)
            return false;
          stream.dispose();
          this.stream = null;
          this.trace(trace_1.TraceLevel.Error, trace_1.SshTraceEventIds.streamWriteError, `Error writing to stream: ${e.message}`, e);
          throw new errors_1.SshConnectionError("Error writing to stream: " + e.message, transportMessages_1.SshDisconnectReason.connectionLost);
        }
        return true;
      }
      async considerReExchange(initial, cancellation) {
        const kexService = this.kexService;
        if (!kexService)
          return;
        let kexMessage = null;
        let kexGuessMessage = null;
        if (!kexService.exchanging && (initial || this.inboundFlow + this.outboundFlow > this.config.keyRotationThreshold)) {
          [kexMessage, kexGuessMessage] = await kexService.startKeyExchange(initial);
        }
        if (kexMessage) {
          await this.sendMessage(kexMessage, cancellation);
          if (kexGuessMessage) {
            await this.sendMessage(kexGuessMessage, cancellation);
          }
        }
      }
      async computeHmac(signer, payload, seq) {
        const writer = new sshData_1.SshDataWriter(buffer_1.Buffer.alloc(4 + payload.length));
        writer.writeUInt32(seq);
        writer.write(payload);
        const result = await signer.sign(writer.toBuffer());
        return result;
      }
      async verifyHmac(verifier, payload, seq, mac) {
        const writer = new sshData_1.SshDataWriter(buffer_1.Buffer.alloc(4 + payload.length));
        writer.writeUInt32(seq);
        writer.write(payload);
        const result = await verifier.verify(writer.toBuffer(), mac);
        return result;
      }
      async readAndVerifyHmac(verifier, data, macBuffer, cancellation) {
        if (!await this.read(macBuffer, cancellation)) {
          return false;
        }
        const verified = await this.verifyHmac(verifier, data, this.inboundPacketSequence, macBuffer);
        if (!verified) {
          throw new errors_1.SshConnectionError("Invalid MAC", transportMessages_1.SshDisconnectReason.macError);
        }
        return true;
      }
      /**
       * Attemps to write one message to the stream.
       * @returns `true` if writing succeeded, `false` if the stream was disposed.
       * @throws SshConnectionException if writing to the stream failed for any other reason.
       */
      async sendMessage(message, cancellation) {
        var _a;
        const algorithms = this.algorithms;
        const compression = algorithms === null || algorithms === void 0 ? void 0 : algorithms.compressor;
        const encryption = algorithms === null || algorithms === void 0 ? void 0 : algorithms.cipher;
        const hmac = algorithms === null || algorithms === void 0 ? void 0 : algorithms.messageSigner;
        let result;
        await this.sessionSemaphore.wait(cancellation);
        try {
          const blockSize = encryption ? Math.max(8, encryption.blockLength) : 8;
          const payloadOffset = _SshProtocol.packetLengthSize + _SshProtocol.paddingLengthSize;
          this.sendWriter.position = payloadOffset;
          message.write(this.sendWriter);
          if (this.outgoingMessagesHaveReconnectInfo) {
            this.sendWriter.writeUInt64(this.lastIncomingSequence);
            if (this.outgoingMessagesHaveLatencyInfo) {
              const timeSinceLastReceivedMessage = Math.min(
                4294967295,
                // max uint32
                Math.round((this.metrics.time - this.lastIncomingTimestamp) * 1e3)
              );
              this.sendWriter.writeUInt32(timeSinceLastReceivedMessage);
            }
          }
          let payload = this.sendWriter.toBuffer().slice(payloadOffset);
          if (compression != null) {
            payload = compression.compress(payload);
          }
          const isLengthEncrypted = !((hmac === null || hmac === void 0 ? void 0 : hmac.encryptThenMac) || (hmac === null || hmac === void 0 ? void 0 : hmac.authenticatedEncryption));
          let paddingLength = blockSize - ((isLengthEncrypted ? _SshProtocol.packetLengthSize : 0) + _SshProtocol.paddingLengthSize + payload.length) % blockSize;
          if (paddingLength < 4) {
            paddingLength += blockSize;
          }
          const packetLength = _SshProtocol.paddingLengthSize + payload.length + paddingLength;
          this.sendWriter.position = 0;
          this.sendWriter.writeUInt32(packetLength);
          this.sendWriter.writeByte(paddingLength);
          if (compression != null) {
            this.sendWriter.write(payload);
          } else {
            this.sendWriter.position += payload.length;
          }
          this.sendWriter.writeRandom(paddingLength);
          payload = this.sendWriter.toBuffer();
          let mac = null;
          if ((hmac === null || hmac === void 0 ? void 0 : hmac.encryptThenMac) && encryption) {
            const packetWithoutLength = payload.slice(_SshProtocol.packetLengthSize, payload.length);
            const encryptedPacket = await encryption.transform(packetWithoutLength);
            encryptedPacket.copy(packetWithoutLength);
            mac = await this.computeHmac(hmac, payload, this.outboundPacketSequence);
          } else if (hmac === null || hmac === void 0 ? void 0 : hmac.authenticatedEncryption) {
            const packetWithoutLength = payload.slice(_SshProtocol.packetLengthSize, payload.length);
            const encryptedPacket = await encryption.transform(packetWithoutLength);
            encryptedPacket.copy(packetWithoutLength);
            mac = await hmac.sign(packetWithoutLength);
          } else {
            if (hmac) {
              mac = await this.computeHmac(hmac, payload, this.outboundPacketSequence);
            }
            if (encryption) {
              payload = await encryption.transform(payload);
            }
          }
          if (!(message instanceof connectionMessages_1.ChannelDataMessage)) {
            this.trace(trace_1.TraceLevel.Verbose, trace_1.SshTraceEventIds.sendingMessage, `Sending #${this.outboundPacketSequence} ${message}`);
          } else if (this.traceChannelData) {
            this.trace(trace_1.TraceLevel.Verbose, trace_1.SshTraceEventIds.sendingChannelData, `Sending #${this.outboundPacketSequence} ${message}`);
          }
          if (this.incomingMessagesHaveReconnectInfo) {
            const sequencedMessage = new SequencedMessage(this.outboundPacketSequence, message);
            sequencedMessage.sentTime = this.metrics.time;
            this.recentSentMessages.enqueue(sequencedMessage);
          }
          this.outboundPacketSequence++;
          this.outboundFlow += packetLength;
          if (mac) {
            const packet = buffer_1.Buffer.concat([payload, mac], payload.length + mac.length);
            result = await this.write(packet, cancellation);
          } else {
            result = await this.write(payload, cancellation);
          }
          this.metrics.addMessageSent(_SshProtocol.packetLengthSize + packetLength + ((_a = hmac === null || hmac === void 0 ? void 0 : hmac.digestLength) !== null && _a !== void 0 ? _a : 0));
        } finally {
          this.sessionSemaphore.release();
        }
        await this.considerReExchange(false, cancellation);
        return result;
      }
      /**
       * Attemps to read one message from the stream.
       * @returns The message, or `null` if the stream was disposed.
       * @throws SshConnectionError if reading from the stream failed for any other reason.
       */
      async receiveMessage(cancellation) {
        var _a;
        const algorithms = this.algorithms;
        const encryption = algorithms === null || algorithms === void 0 ? void 0 : algorithms.decipher;
        const hmac = algorithms === null || algorithms === void 0 ? void 0 : algorithms.messageVerifier;
        const compression = algorithms === null || algorithms === void 0 ? void 0 : algorithms.decompressor;
        const isLengthEncrypted = !((hmac === null || hmac === void 0 ? void 0 : hmac.encryptThenMac) || (hmac === null || hmac === void 0 ? void 0 : hmac.authenticatedEncryption));
        const firstBlockSize = !isLengthEncrypted ? _SshProtocol.packetLengthSize : encryption ? Math.max(8, encryption.blockLength) : 8;
        this.receiveWriter.position = firstBlockSize;
        let firstBlock = this.receiveWriter.toBuffer();
        if (!await this.read(firstBlock, cancellation)) {
          return null;
        }
        this.lastIncomingTimestamp = this.metrics.time;
        if (encryption && isLengthEncrypted) {
          firstBlock = await encryption.transform(firstBlock);
          this.receiveWriter.position = 0;
          this.receiveWriter.write(firstBlock);
        }
        const receiveReader = new sshData_1.SshDataReader(firstBlock);
        const packetLength = receiveReader.readUInt32();
        if (packetLength > _SshProtocol.maxPacketLength) {
          throw new errors_1.SshConnectionError("Invalid packet length.", transportMessages_1.SshDisconnectReason.protocolError);
        }
        const packetBufferSize = _SshProtocol.packetLengthSize + packetLength;
        if (packetBufferSize > firstBlockSize) {
          this.receiveWriter.skip(packetBufferSize - firstBlockSize);
        }
        if (hmac) {
          this.receiveWriter.skip(hmac.digestLength);
        }
        const receiveBuffer = this.receiveWriter.toBuffer();
        const packetBuffer = receiveBuffer.slice(0, packetBufferSize);
        const macBuffer = receiveBuffer.slice(packetBufferSize);
        let followingBlocks = packetBuffer.slice(firstBlockSize, packetBufferSize);
        if (followingBlocks.length > 0) {
          if (!await this.read(followingBlocks, cancellation)) {
            return null;
          }
          if (hmac === null || hmac === void 0 ? void 0 : hmac.encryptThenMac) {
            if (!await this.readAndVerifyHmac(hmac, packetBuffer, macBuffer, cancellation)) {
              return null;
            }
          }
          if (encryption) {
            if (hmac === null || hmac === void 0 ? void 0 : hmac.authenticatedEncryption) {
              if (!await this.read(macBuffer, cancellation)) {
                return null;
              }
              await hmac.verify(followingBlocks, macBuffer);
            }
            try {
              followingBlocks = await encryption.transform(followingBlocks);
            } catch (e) {
              if (hmac === null || hmac === void 0 ? void 0 : hmac.authenticatedEncryption) {
                throw new errors_1.SshConnectionError("Invalid MAC", transportMessages_1.SshDisconnectReason.macError);
              } else {
                throw e;
              }
            }
            this.receiveWriter.position = firstBlockSize;
            this.receiveWriter.write(followingBlocks);
          }
        }
        if (hmac && !hmac.encryptThenMac && !hmac.authenticatedEncryption) {
          if (!await this.readAndVerifyHmac(hmac, packetBuffer, macBuffer, cancellation)) {
            return null;
          }
        }
        const paddingLength = packetBuffer[_SshProtocol.packetLengthSize];
        let payload = packetBuffer.slice(_SshProtocol.packetLengthSize + _SshProtocol.paddingLengthSize, _SshProtocol.packetLengthSize + (packetLength - paddingLength));
        if (compression) {
          payload = compression.decompress(payload);
        }
        if (this.incomingMessagesHaveReconnectInfo) {
          let lastSequenceSeenByRemote;
          let remoteTimeSinceLastReceived;
          if (this.incomingMessagesHaveLatencyInfo) {
            const reader = new sshData_1.SshDataReader(payload.slice(payload.length - 12, payload.length));
            lastSequenceSeenByRemote = reader.readUInt64();
            remoteTimeSinceLastReceived = reader.readUInt32() / 1e3;
            payload = payload.slice(0, payload.length - 12);
          } else {
            const reader = new sshData_1.SshDataReader(payload.slice(payload.length - 8, payload.length));
            lastSequenceSeenByRemote = reader.readUInt64();
            remoteTimeSinceLastReceived = 0;
            payload = payload.slice(0, payload.length - 8);
          }
          while (this.recentSentMessages.size > 0) {
            const oldestSequenceMessage = this.recentSentMessages.peek();
            if (oldestSequenceMessage.sequence > lastSequenceSeenByRemote) {
              break;
            }
            if (this.stream && this.incomingMessagesHaveLatencyInfo && oldestSequenceMessage.sequence === lastSequenceSeenByRemote) {
              const timeSinceSent = this.lastIncomingTimestamp - oldestSequenceMessage.sentTime;
              const roundTripLatency = timeSinceSent - remoteTimeSinceLastReceived;
              this.metrics.updateLatency(roundTripLatency, this.trace);
            }
            this.recentSentMessages.dequeue();
          }
        }
        const messageType = payload[0];
        let message = sshMessage_1.SshMessage.create(this.config, messageType, this.messageContext, payload);
        if (!message) {
          const unimplementedMessage = new transportMessages_1.UnimplementedMessage();
          unimplementedMessage.sequenceNumber = this.inboundPacketSequence;
          unimplementedMessage.unimplementedMessageType = messageType;
          message = unimplementedMessage;
        }
        if (!(message instanceof connectionMessages_1.ChannelDataMessage)) {
          this.trace(trace_1.TraceLevel.Verbose, trace_1.SshTraceEventIds.receivingMessage, `Receiving #${this.inboundPacketSequence} ${message}`);
        } else if (this.traceChannelData) {
          this.trace(trace_1.TraceLevel.Verbose, trace_1.SshTraceEventIds.receivingChannelData, `Receiving #${this.inboundPacketSequence} ${message}`);
        }
        await this.sessionSemaphore.wait(cancellation);
        this.inboundPacketSequence++;
        this.inboundFlow += packetLength;
        this.sessionSemaphore.release();
        this.metrics.addMessageReceived(_SshProtocol.packetLengthSize + packetLength + ((_a = hmac === null || hmac === void 0 ? void 0 : hmac.digestLength) !== null && _a !== void 0 ? _a : 0));
        await this.considerReExchange(false, cancellation);
        return message;
      }
      dispose() {
        try {
          if (this.stream)
            this.stream.close().catch((e) => {
              this.trace(trace_1.TraceLevel.Error, trace_1.SshTraceEventIds.streamCloseError, `Error closing stream: ${e.message}`, e);
            });
        } catch (e) {
          if (!(e instanceof Error))
            throw e;
          this.trace(trace_1.TraceLevel.Error, trace_1.SshTraceEventIds.streamCloseError, `Error closing stream: ${e.message}`, e);
        }
        this.stream = null;
        this.metrics.updateLatency(0);
        if (this.algorithms)
          this.algorithms.dispose();
      }
    };
    exports2.SshProtocol = SshProtocol;
    SshProtocol.maxPacketLength = 1024 * 1024;
    SshProtocol.packetLengthSize = 4;
    SshProtocol.paddingLengthSize = 1;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/services/sshService.js
var require_sshService = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/services/sshService.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SshService = void 0;
    var vscode_jsonrpc_1 = require_main();
    var sshSession_1 = require_sshSession();
    var SshService = class {
      constructor(session) {
        this.session = session;
        this.disposed = false;
        this.disposedEmitter = new vscode_jsonrpc_1.Emitter();
        this.onDisposed = this.disposedEmitter.event;
        if (!(session instanceof sshSession_1.SshSession)) {
          throw new TypeError("Session is not an instance of SshSession. (This may be due to a version mismatch between SSH packages.)");
        }
      }
      get trace() {
        return this.session.trace;
      }
      raiseReportProgress(progress) {
        this.session.raiseReportProgress(progress);
      }
      dispose() {
        if (this.disposed)
          return;
        this.disposed = true;
        this.disposedEmitter.fire();
      }
      /**
       * Services that are activated via session requests must override this method to handle
       * incoming session requests.
       *
       * Implementations must set `SshRequestEventArgs.isAuthorized` or
       * `SshRequestEventArgs.responsePromise` to indicate whether the request was allowed.
       */
      async onSessionRequest(request, cancellation) {
        this.session.raiseSessionRequest(request);
      }
      /**
       * Services that are activated via channel types must override this method to handle
       * incoming requests to open a channel.
       *
       * Implementations may set `SshChannelOpeningEventArgs.failureReason` or
       * `SshChannelOpeningEventArgs.openingPromise` to block opening of the channel.
       * The default behavior allows the channel to open.
       *
       * Requests on the opened channel will not be directed to `onChannelRequest`
       * unless the service also declares activation on specific channel request(s). Otherwise,
       * an implementation of this method may add any event-handlers to the
       * `SshChannelOpeningEventArgs.channel` including a request event handler.
       */
      async onChannelOpening(request, cancellation) {
        if (!request)
          throw new TypeError("Request is required.");
        return this.session.handleChannelOpening(request, cancellation, false);
      }
      /**
       * Services that are activated via channel requests must override this method to handle
       * incoming channel requests.
       *
       * Implementations must set `SshRequestEventArgs.isAuthorized` or
       * `SshRequestEventArgs.responsePromise` to indicate whether the request was allowed.
       */
      async onChannelRequest(channel, request, cancellation) {
      }
      /**
       * Sends any message.
       */
      async sendMessage(message, cancellation) {
        await this.session.sendMessage(message, cancellation);
      }
    };
    exports2.SshService = SshService;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/events/sshChannelOpeningEventArgs.js
var require_sshChannelOpeningEventArgs = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/events/sshChannelOpeningEventArgs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SshChannelOpeningEventArgs = void 0;
    var connectionMessages_1 = require_connectionMessages();
    var vscode_jsonrpc_1 = require_main();
    var SshChannelOpeningEventArgs = class {
      constructor(request, channel, isRemoteRequest, cancellation) {
        this.request = request;
        this.channel = channel;
        this.isRemoteRequest = isRemoteRequest;
        this.failureReason = connectionMessages_1.SshChannelOpenFailureReason.none;
        this.failureDescription = null;
        if (!request)
          throw new TypeError("A channel open message is required.");
        if (!channel)
          throw new TypeError("A channel is required.");
        this.cancellationValue = cancellation !== null && cancellation !== void 0 ? cancellation : vscode_jsonrpc_1.CancellationToken.None;
      }
      /**
       * Gets a token that is cancelled if the session ends before the request handler
       * completes.
       */
      get cancellation() {
        return this.cancellationValue;
      }
      /* @internal */
      set cancellation(value) {
        this.cancellationValue = value;
      }
      toString() {
        return `${this.channel.toString()}${this.failureReason ? " " + connectionMessages_1.SshChannelOpenFailureReason[this.failureReason] : ""}`;
      }
    };
    exports2.SshChannelOpeningEventArgs = SshChannelOpeningEventArgs;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/events/sshExtendedDataEventArgs.js
var require_sshExtendedDataEventArgs = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/events/sshExtendedDataEventArgs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SshExtendedDataEventArgs = exports2.SshExtendedDataType = void 0;
    var SshExtendedDataType;
    (function(SshExtendedDataType2) {
      SshExtendedDataType2[SshExtendedDataType2["STDERR"] = 1] = "STDERR";
    })(SshExtendedDataType = exports2.SshExtendedDataType || (exports2.SshExtendedDataType = {}));
    var SshExtendedDataEventArgs = class {
      constructor(dataTypeCode, data) {
        this.dataTypeCode = dataTypeCode;
        this.data = data;
      }
      toString() {
        return `${SshExtendedDataType[this.dataTypeCode]}: ${this.data.toString()}`;
      }
    };
    exports2.SshExtendedDataEventArgs = SshExtendedDataEventArgs;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/services/connectionService.js
var require_connectionService = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/services/connectionService.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var ConnectionService_1;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConnectionService = void 0;
    var sshService_1 = require_sshService();
    var connectionMessages_1 = require_connectionMessages();
    var promiseCompletionSource_1 = require_promiseCompletionSource();
    var sshChannel_1 = require_sshChannel();
    var cancellation_1 = require_cancellation2();
    var errors_1 = require_errors();
    var sshChannelOpeningEventArgs_1 = require_sshChannelOpeningEventArgs();
    var serviceActivation_1 = require_serviceActivation();
    var trace_1 = require_trace();
    var sshExtendedDataEventArgs_1 = require_sshExtendedDataEventArgs();
    var ConnectionService = ConnectionService_1 = class ConnectionService extends sshService_1.SshService {
      constructor(session) {
        super(session);
        this.channelCounter = 0;
        this.channelMap = /* @__PURE__ */ new Map();
        this.nonAcceptedChannels = /* @__PURE__ */ new Map();
        this.pendingChannels = /* @__PURE__ */ new Map();
        this.pendingAcceptChannels = /* @__PURE__ */ new Map();
      }
      get channels() {
        return Array.from(this.channelMap.values());
      }
      close(e) {
        let channelCompletions = [...this.pendingChannels.values()].map((pc) => pc.completionSource);
        if (this.pendingAcceptChannels.size > 0) {
          channelCompletions = channelCompletions.concat([...this.pendingAcceptChannels.values()].reduce((a, b) => a.concat(b)));
        }
        for (const channel of this.channelMap.values()) {
          channel.close(e);
        }
        for (const channelCompletion of channelCompletions) {
          channelCompletion.reject(e);
        }
      }
      dispose() {
        const channels = [...this.channelMap.values()];
        let channelCompletions = [...this.pendingChannels.values()].map((pc) => pc.completionSource);
        if (this.pendingAcceptChannels.size > 0) {
          channelCompletions = channelCompletions.concat([...this.pendingAcceptChannels.values()].reduce((a, b) => a.concat(b)));
        }
        for (const channel of channels) {
          channel.dispose();
        }
        for (const channelCompletion of channelCompletions) {
          channelCompletion.reject(new errors_1.ObjectDisposedError("Session closed."));
        }
        super.dispose();
      }
      async acceptChannel(channelType, cancellation) {
        const completionSource = new promiseCompletionSource_1.PromiseCompletionSource();
        let cancellationRegistration;
        if (cancellation) {
          if (cancellation.isCancellationRequested)
            throw new cancellation_1.CancellationError();
          cancellationRegistration = cancellation.onCancellationRequested(() => {
            const list = this.pendingAcceptChannels.get(channelType);
            if (list) {
              const index = list.findIndex((item) => Object.is(item, completionSource));
              if (index >= 0) {
                list.splice(index, 1);
              }
            }
            completionSource.reject(new cancellation_1.CancellationError());
          });
        }
        let channel = null;
        channel = Array.from(this.nonAcceptedChannels.values()).find((c) => c.channelType === channelType) || null;
        if (channel) {
          this.nonAcceptedChannels.delete(channel.channelId);
        } else {
          let list = this.pendingAcceptChannels.get(channelType);
          if (!list) {
            list = [];
            this.pendingAcceptChannels.set(channelType, list);
          }
          list.push(completionSource);
        }
        try {
          return channel || await completionSource.promise;
        } finally {
          if (cancellationRegistration)
            cancellationRegistration.dispose();
        }
      }
      async openChannel(openMessage, completionSource, cancellation) {
        const channelId = ++this.channelCounter;
        openMessage.senderChannel = channelId;
        let cancellationRegistration = null;
        if (cancellation) {
          if (cancellation.isCancellationRequested)
            throw new cancellation_1.CancellationError();
          cancellationRegistration = cancellation.onCancellationRequested(() => {
            if (this.pendingChannels.delete(channelId)) {
              completionSource.reject(new cancellation_1.CancellationError());
            }
          });
        }
        this.pendingChannels.set(channelId, {
          openMessage,
          completionSource,
          cancellationRegistration
        });
        await this.session.sendMessage(openMessage);
        return channelId;
      }
      handleMessage(message, cancellation) {
        if (message instanceof connectionMessages_1.ChannelDataMessage) {
          return this.handleDataMessage(message);
        } else if (message instanceof connectionMessages_1.ChannelExtendedDataMessage) {
          return this.handleExtendedDataMessage(message);
        } else if (message instanceof connectionMessages_1.ChannelWindowAdjustMessage) {
          return this.handleAdjustWindowMessage(message);
        } else if (message instanceof connectionMessages_1.ChannelEofMessage) {
          return this.handleEofMessage(message);
        } else if (message instanceof connectionMessages_1.ChannelOpenMessage) {
          return this.handleOpenMessage(message, cancellation);
        } else if (message instanceof connectionMessages_1.ChannelCloseMessage) {
          return this.handleCloseMessage(message);
        } else if (message instanceof connectionMessages_1.ChannelOpenConfirmationMessage) {
          return this.handleOpenConfirmationMessage(message, cancellation);
        } else if (message instanceof connectionMessages_1.ChannelOpenFailureMessage) {
          return this.handleOpenFailureMessage(message);
        } else if (message instanceof connectionMessages_1.ChannelRequestMessage) {
          return this.handleRequestMessage(message, cancellation);
        } else if (message instanceof connectionMessages_1.ChannelSuccessMessage) {
          return this.handleSuccessMessage(message);
        } else if (message instanceof connectionMessages_1.ChannelFailureMessage) {
          return this.handleFailureMessage(message);
        } else {
          throw new Error(`Message not implemented: ${message}`);
        }
      }
      async handleOpenMessage(message, cancellation) {
        var _a;
        const senderChannel = message.senderChannel;
        if (!this.session.canAcceptRequests) {
          this.trace(trace_1.TraceLevel.Warning, trace_1.SshTraceEventIds.channelOpenFailed, "Channel open request blocked because the session is not yet authenticated.");
          const openFailureMessage = new connectionMessages_1.ChannelOpenFailureMessage();
          openFailureMessage.recipientChannel = senderChannel;
          openFailureMessage.reasonCode = connectionMessages_1.SshChannelOpenFailureReason.administrativelyProhibited;
          openFailureMessage.description = "Authenticate before opening channels.";
          await this.session.sendMessage(openFailureMessage, cancellation);
          return;
        } else if (!message.channelType) {
          const openFailureMessage = new connectionMessages_1.ChannelOpenFailureMessage();
          openFailureMessage.recipientChannel = senderChannel;
          openFailureMessage.reasonCode = connectionMessages_1.SshChannelOpenFailureReason.unknownChannelType;
          openFailureMessage.description = "Channel type not specified.";
          await this.session.sendMessage(openFailureMessage, cancellation);
          return;
        }
        message = message.convertTo(new connectionMessages_1.ChannelOpenMessage(), true);
        let confirmationMessage = new connectionMessages_1.ChannelOpenConfirmationMessage();
        const channelId = ++this.channelCounter;
        const channel = new sshChannel_1.SshChannel(this, message.channelType, channelId, senderChannel, message.maxWindowSize, message.maxPacketSize, message, confirmationMessage);
        let responseMessage;
        const args = new sshChannelOpeningEventArgs_1.SshChannelOpeningEventArgs(message, channel, true);
        try {
          await this.session.handleChannelOpening(args, cancellation);
          if (args.openingPromise) {
            responseMessage = await args.openingPromise;
          } else if (args.failureReason !== connectionMessages_1.SshChannelOpenFailureReason.none) {
            const failureMessage = new connectionMessages_1.ChannelOpenFailureMessage();
            failureMessage.reasonCode = args.failureReason;
            failureMessage.description = (_a = args.failureDescription) !== null && _a !== void 0 ? _a : void 0;
            responseMessage = failureMessage;
          } else {
            responseMessage = confirmationMessage;
          }
        } catch (e) {
          channel.dispose();
          throw e;
        }
        if (responseMessage instanceof connectionMessages_1.ChannelOpenFailureMessage) {
          responseMessage.recipientChannel = senderChannel;
          try {
            await this.session.sendMessage(responseMessage, cancellation);
          } finally {
            channel.dispose();
          }
          return;
        }
        if (this.session.isClosed) {
          channel.dispose();
          return;
        }
        channel.isMaxWindowSizeLocked = true;
        this.channelMap.set(channel.channelId, channel);
        confirmationMessage = responseMessage;
        confirmationMessage.recipientChannel = channel.remoteChannelId;
        confirmationMessage.senderChannel = channel.channelId;
        confirmationMessage.maxWindowSize = channel.maxWindowSize;
        confirmationMessage.maxPacketSize = channel.maxPacketSize;
        confirmationMessage.rewrite();
        channel.openConfirmationMessage = confirmationMessage;
        await this.session.sendMessage(confirmationMessage, cancellation);
        let accepted = false;
        const list = this.pendingAcceptChannels.get(channel.channelType);
        while (list && list.length > 0) {
          const acceptCompletionSource = list.shift();
          acceptCompletionSource.resolve(channel);
          accepted = true;
          break;
        }
        if (!accepted) {
          this.nonAcceptedChannels.set(channel.channelId, channel);
        }
        this.onChannelOpenCompleted(channel.channelId, channel);
        channel.enableSending();
      }
      handleCloseMessage(message) {
        const channel = this.findChannelById(message.recipientChannel);
        if (channel) {
          channel.handleClose();
        }
      }
      async handleOpenConfirmationMessage(message, cancellation) {
        var _a;
        let completionSource = null;
        let openMessage;
        const pendingChannel = this.pendingChannels.get(message.recipientChannel);
        if (pendingChannel) {
          openMessage = pendingChannel.openMessage;
          completionSource = pendingChannel.completionSource;
          if (pendingChannel.cancellationRegistration) {
            pendingChannel.cancellationRegistration.dispose();
          }
          this.pendingChannels.delete(message.recipientChannel);
        } else if (this.channelMap.has(message.recipientChannel)) {
          throw new Error("Duplicate channel ID.");
        } else {
          throw new Error("Channel confirmation was not requested.");
        }
        message = message.convertTo(new connectionMessages_1.ChannelOpenConfirmationMessage(), true);
        const channel = new sshChannel_1.SshChannel(this, openMessage.channelType || sshChannel_1.SshChannel.sessionChannelType, message.recipientChannel, message.senderChannel, message.maxWindowSize, message.maxPacketSize, openMessage, message);
        if (typeof openMessage.maxWindowSize === "number") {
          channel.maxWindowSize = openMessage.maxWindowSize;
        }
        channel.isMaxWindowSizeLocked = true;
        this.channelMap.set(channel.channelId, channel);
        const args = new sshChannelOpeningEventArgs_1.SshChannelOpeningEventArgs(openMessage, channel, false);
        await this.session.handleChannelOpening(args, cancellation);
        if (completionSource) {
          if (args.failureReason === connectionMessages_1.SshChannelOpenFailureReason.none) {
            completionSource.resolve(channel);
          } else {
            completionSource.reject(new errors_1.SshChannelError((_a = args.failureDescription) !== null && _a !== void 0 ? _a : "Channel open failure.", args.failureReason));
            return;
          }
        } else {
          this.onChannelOpenCompleted(channel.channelId, channel);
        }
        channel.enableSending();
      }
      handleOpenFailureMessage(message) {
        let completionSource = null;
        const pendingChannel = this.pendingChannels.get(message.recipientChannel);
        if (pendingChannel) {
          completionSource = pendingChannel.completionSource;
          if (pendingChannel.cancellationRegistration) {
            pendingChannel.cancellationRegistration.dispose();
          }
          this.pendingChannels.delete(message.recipientChannel);
        }
        if (completionSource != null) {
          completionSource.reject(new errors_1.SshChannelError(message.description || "Channel open rejected.", message.reasonCode));
        } else {
          this.onChannelOpenCompleted(message.recipientChannel, null);
        }
      }
      async handleRequestMessage(message, cancellation) {
        const channel = this.tryGetChannelForMessage(message);
        if (!channel)
          return;
        await channel.handleRequest(message, cancellation);
      }
      handleSuccessMessage(message) {
        const channel = this.tryGetChannelForMessage(message);
        channel === null || channel === void 0 ? void 0 : channel.handleResponse(true);
      }
      handleFailureMessage(message) {
        const channel = this.tryGetChannelForMessage(message);
        channel === null || channel === void 0 ? void 0 : channel.handleResponse(false);
      }
      handleDataMessage(message) {
        const channel = this.tryGetChannelForMessage(message);
        channel === null || channel === void 0 ? void 0 : channel.handleDataReceived(message.data);
      }
      handleExtendedDataMessage(message) {
        const channel = this.tryGetChannelForMessage(message);
        channel === null || channel === void 0 ? void 0 : channel.handleExtendedDataReceived(new sshExtendedDataEventArgs_1.SshExtendedDataEventArgs(message.dataTypeCode, message.data));
      }
      handleAdjustWindowMessage(message) {
        const channel = this.tryGetChannelForMessage(message);
        channel === null || channel === void 0 ? void 0 : channel.adjustRemoteWindow(message.bytesToAdd);
      }
      handleEofMessage(message) {
        const channel = this.findChannelById(message.recipientChannel);
        channel === null || channel === void 0 ? void 0 : channel.handleEof();
      }
      onChannelOpenCompleted(channelId, channel) {
        if (channel) {
          this.trace(trace_1.TraceLevel.Info, trace_1.SshTraceEventIds.channelOpened, `${this.session} ChannelOpenCompleted(${channel})`);
        } else {
          this.trace(trace_1.TraceLevel.Warning, trace_1.SshTraceEventIds.channelOpenFailed, `${this.session} ChannelOpenCompleted(${channelId} failed)`);
        }
      }
      /**
       * Gets the channel object based on the message `recipientChannel` property.
       * Logs a warning if the channel was not found.
       */
      tryGetChannelForMessage(channelMessage) {
        const channel = this.findChannelById(channelMessage.recipientChannel);
        if (!channel) {
          const messageString = channelMessage instanceof connectionMessages_1.ChannelDataMessage ? "channel data message" : channelMessage.toString();
          this.trace(trace_1.TraceLevel.Warning, trace_1.SshTraceEventIds.channelRequestFailed, `Invalid channel ID ${channelMessage.recipientChannel} in ${messageString}.`);
        }
        return channel;
      }
      findChannelById(id) {
        var _a;
        const channel = (_a = this.channelMap.get(id)) !== null && _a !== void 0 ? _a : null;
        return channel;
      }
      /* @internal */
      removeChannel(channel) {
        this.channelMap.delete(channel.channelId);
        this.pendingChannels.delete(channel.channelId);
      }
    };
    ConnectionService.serviceName = "ssh-connection";
    ConnectionService = ConnectionService_1 = __decorate([
      (0, serviceActivation_1.serviceActivation)({ serviceRequest: ConnectionService_1.serviceName })
    ], ConnectionService);
    exports2.ConnectionService = ConnectionService;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/messages/authenticationMessages.js
var require_authenticationMessages = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/messages/authenticationMessages.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AuthenticationSuccessMessage = exports2.AuthenticationFailureMessage = exports2.PasswordRequestMessage = exports2.PublicKeyOKMessage = exports2.AuthenticationInfoResponseMessage = exports2.AuthenticationInfoRequestMessage = exports2.PublicKeyRequestMessage = exports2.AuthenticationRequestMessage = exports2.AuthenticationMessage = void 0;
    var sshMessage_1 = require_sshMessage();
    var AuthenticationMessage = class extends sshMessage_1.SshMessage {
    };
    exports2.AuthenticationMessage = AuthenticationMessage;
    var AuthenticationRequestMessage = class extends AuthenticationMessage {
      get messageType() {
        return 50;
      }
      onRead(reader) {
        this.username = reader.readString("utf8");
        this.serviceName = reader.readString("ascii");
        this.methodName = reader.readString("ascii");
      }
      onWrite(writer) {
        writer.writeString(this.username || "", "utf8");
        writer.writeString(this.serviceName || "", "ascii");
        writer.writeString(this.validateField(this.methodName, "method name"), "ascii");
      }
      toString() {
        return super.toString() + ` (Method: ${this.methodName}, Username: ${this.username})`;
      }
    };
    exports2.AuthenticationRequestMessage = AuthenticationRequestMessage;
    var PublicKeyRequestMessage = class extends AuthenticationRequestMessage {
      constructor() {
        super();
        this.methodName = "publickey";
      }
      get hasSignature() {
        return this.signature && this.signature.length > 0 ? true : false;
      }
      onRead(reader) {
        super.onRead(reader);
        const hasSignature = reader.readBoolean();
        this.keyAlgorithmName = reader.readString("ascii");
        this.publicKey = reader.readBinary();
        if (hasSignature) {
          this.signature = reader.readBinary();
          this.payloadWithoutSignature = this.rawBytes.slice(0, this.rawBytes.length - this.signature.length - 4);
        } else {
          this.signature = void 0;
        }
      }
      onWrite(writer) {
        var _a, _b;
        super.onWrite(writer);
        if (!this.keyAlgorithmName)
          throw new Error("Key algorithm name not set.");
        if (this.methodName === "hostbased") {
          writer.writeString(this.keyAlgorithmName, "ascii");
          writer.writeBinary(this.publicKey || Buffer.alloc(0));
          writer.writeString((_a = this.clientHostname) !== null && _a !== void 0 ? _a : "", "ascii");
          writer.writeString((_b = this.clientUsername) !== null && _b !== void 0 ? _b : "", "ascii");
          if (!this.hasSignature) {
            throw new Error("A signature is required for a host-based authentcation request.");
          }
          writer.writeBinary(this.signature);
        } else {
          writer.writeBoolean(this.hasSignature);
          writer.writeString(this.keyAlgorithmName, "ascii");
          writer.writeBinary(this.publicKey || Buffer.alloc(0));
          if (this.hasSignature) {
            writer.writeBinary(this.signature);
          }
        }
      }
    };
    exports2.PublicKeyRequestMessage = PublicKeyRequestMessage;
    var AuthenticationInfoRequestMessage = class extends AuthenticationMessage {
      get messageType() {
        return 60;
      }
      onRead(reader) {
        this.name = reader.readString("utf8");
        this.instruction = reader.readString("utf8");
        this.language = reader.readString("ascii");
        this.prompts = [];
        const promptsCount = reader.readUInt32();
        const promptStrings = [];
        for (let i = 0; i < promptsCount; i++) {
          promptStrings.push(reader.readString("utf8"));
        }
        for (let i = 0; i < promptsCount; i++) {
          this.prompts.push({
            prompt: promptStrings[i],
            echo: reader.readBoolean()
          });
        }
      }
      onWrite(writer) {
        var _a, _b;
        writer.writeString(this.name || "", "utf8");
        writer.writeString(this.instruction || "", "utf8");
        writer.writeString(this.language || "", "ascii");
        const promptsCount = (_b = (_a = this.prompts) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
        writer.writeUInt32(promptsCount);
        for (let i = 0; i < promptsCount; i++) {
          writer.writeString(this.prompts[i].prompt || "", "utf8");
        }
        for (let i = 0; i < promptsCount; i++) {
          writer.writeBoolean(this.prompts[i].echo);
        }
      }
    };
    exports2.AuthenticationInfoRequestMessage = AuthenticationInfoRequestMessage;
    var AuthenticationInfoResponseMessage = class extends AuthenticationMessage {
      get messageType() {
        return 61;
      }
      onRead(reader) {
        this.responses = [];
        const responseCount = reader.readUInt32();
        for (let i = 0; i < responseCount; i++) {
          this.responses.push(reader.readString("utf8"));
        }
      }
      onWrite(writer) {
        var _a, _b;
        const responseCount = (_b = (_a = this.responses) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
        writer.writeUInt32(responseCount);
        for (let i = 0; i < responseCount; i++) {
          writer.writeString(this.responses[i] || "", "utf8");
        }
      }
    };
    exports2.AuthenticationInfoResponseMessage = AuthenticationInfoResponseMessage;
    var PublicKeyOKMessage = class extends AuthenticationMessage {
      get messageType() {
        return 60;
      }
      onRead(reader) {
        this.keyAlgorithmName = reader.readString("ascii");
        this.publicKey = reader.readBinary();
      }
      onWrite(writer) {
        if (!this.keyAlgorithmName)
          throw new Error("Key algorithm name not set.");
        if (!this.publicKey)
          throw new Error("Public key not set.");
        writer.writeString(this.keyAlgorithmName, "ascii");
        writer.writeBinary(this.publicKey);
      }
    };
    exports2.PublicKeyOKMessage = PublicKeyOKMessage;
    var PasswordRequestMessage = class extends AuthenticationRequestMessage {
      constructor() {
        super();
        this.methodName = "password";
      }
      onRead(reader) {
        super.onRead(reader);
        reader.readBoolean();
        this.password = reader.readString("utf8");
      }
      onWrite(writer) {
        super.onWrite(writer);
        writer.writeBoolean(false);
        writer.writeString(this.password || "", "utf8");
      }
    };
    exports2.PasswordRequestMessage = PasswordRequestMessage;
    var AuthenticationFailureMessage = class extends AuthenticationMessage {
      constructor() {
        super(...arguments);
        this.partialSuccess = false;
      }
      get messageType() {
        return 51;
      }
      onRead(reader) {
        this.methodNames = reader.readList("ascii");
        this.partialSuccess = reader.readBoolean();
      }
      onWrite(writer) {
        writer.writeList(this.methodNames || [], "ascii");
        writer.writeBoolean(this.partialSuccess);
      }
    };
    exports2.AuthenticationFailureMessage = AuthenticationFailureMessage;
    var AuthenticationSuccessMessage = class extends AuthenticationMessage {
      get messageType() {
        return 52;
      }
      onRead(reader) {
      }
      onWrite(writer) {
      }
    };
    exports2.AuthenticationSuccessMessage = AuthenticationSuccessMessage;
    sshMessage_1.SshMessage.index.set(50, AuthenticationRequestMessage);
    sshMessage_1.SshMessage.index.set(51, AuthenticationFailureMessage);
    sshMessage_1.SshMessage.index.set(52, AuthenticationSuccessMessage);
    sshMessage_1.SshMessage.index.set([
      60,
      "publickey"
      /* AuthenticationMethod.publicKey */
    ], PublicKeyRequestMessage);
    sshMessage_1.SshMessage.index.set([
      60,
      "keyboard-interactive"
      /* AuthenticationMethod.keyboardInteractive */
    ], AuthenticationInfoRequestMessage);
    sshMessage_1.SshMessage.index.set([
      61,
      "keyboard-interactive"
      /* AuthenticationMethod.keyboardInteractive */
    ], AuthenticationInfoResponseMessage);
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/events/sshAuthenticatingEventArgs.js
var require_sshAuthenticatingEventArgs = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/events/sshAuthenticatingEventArgs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SshAuthenticatingEventArgs = exports2.SshAuthenticationType = void 0;
    var vscode_jsonrpc_1 = require_main();
    var SshAuthenticationType;
    (function(SshAuthenticationType2) {
      SshAuthenticationType2[SshAuthenticationType2["clientNone"] = 0] = "clientNone";
      SshAuthenticationType2[SshAuthenticationType2["clientHostBased"] = 1] = "clientHostBased";
      SshAuthenticationType2[SshAuthenticationType2["clientPassword"] = 2] = "clientPassword";
      SshAuthenticationType2[SshAuthenticationType2["clientPublicKeyQuery"] = 3] = "clientPublicKeyQuery";
      SshAuthenticationType2[SshAuthenticationType2["clientPublicKey"] = 4] = "clientPublicKey";
      SshAuthenticationType2[SshAuthenticationType2["clientInteractive"] = 5] = "clientInteractive";
      SshAuthenticationType2[SshAuthenticationType2["serverPublicKey"] = 10] = "serverPublicKey";
    })(SshAuthenticationType = exports2.SshAuthenticationType || (exports2.SshAuthenticationType = {}));
    var SshAuthenticatingEventArgs = class {
      constructor(authenticationType, { username, password, publicKey, clientHostname, clientUsername, infoRequest, infoResponse }, cancellation) {
        this.authenticationType = authenticationType;
        this.infoRequest = null;
        this.infoResponse = null;
        const validate = ({ usernameRequired, passwordRequired, publicKeyRequired, clientHostnameRequired, clientUsernameRequired }) => {
          if (typeof username === "string" !== !!usernameRequired)
            return false;
          if (typeof password === "string" !== !!passwordRequired)
            return false;
          if (!!publicKey !== !!publicKeyRequired)
            return false;
          if (typeof clientHostname === "string" !== !!clientHostnameRequired)
            return false;
          if (typeof clientUsername === "string" !== !!clientUsernameRequired)
            return false;
          return true;
        };
        let valid;
        switch (authenticationType) {
          case SshAuthenticationType.clientNone:
            valid = validate({ usernameRequired: true });
            break;
          case SshAuthenticationType.clientHostBased:
            valid = validate({
              usernameRequired: true,
              publicKeyRequired: true,
              clientHostnameRequired: true,
              clientUsernameRequired: true
            });
            break;
          case SshAuthenticationType.clientPassword:
            valid = validate({ usernameRequired: true, passwordRequired: true });
            break;
          case SshAuthenticationType.clientPublicKeyQuery:
          case SshAuthenticationType.clientPublicKey:
            valid = validate({ usernameRequired: true, publicKeyRequired: true });
            break;
          case SshAuthenticationType.serverPublicKey:
            valid = validate({ publicKeyRequired: true });
            break;
          case SshAuthenticationType.clientInteractive:
            valid = true;
            break;
          default:
            throw new Error(`Invalid authentication type: ${authenticationType}`);
        }
        if (!valid) {
          throw new Error(`Invalid arguments for authentication type: ${authenticationType}`);
        }
        this.username = username !== null && username !== void 0 ? username : null;
        this.password = password !== null && password !== void 0 ? password : null;
        this.publicKey = publicKey !== null && publicKey !== void 0 ? publicKey : null;
        this.clientHostname = clientHostname !== null && clientHostname !== void 0 ? clientHostname : null;
        this.clientUsername = clientUsername !== null && clientUsername !== void 0 ? clientUsername : null;
        this.infoRequest = infoRequest !== null && infoRequest !== void 0 ? infoRequest : null;
        this.infoResponse = infoResponse !== null && infoResponse !== void 0 ? infoResponse : null;
        this.cancellationValue = cancellation !== null && cancellation !== void 0 ? cancellation : vscode_jsonrpc_1.CancellationToken.None;
      }
      /**
       * Gets a token that is cancelled if the session ends before the authentication handler
       * completes.
       */
      get cancellation() {
        return this.cancellationValue;
      }
      /* @internal */
      set cancellation(value) {
        this.cancellationValue = value;
      }
      toString() {
        if (this.infoRequest) {
          return `Info request: ${this.infoRequest.name}`;
        } else if (this.infoResponse) {
          return `"${this.username}" info response`;
        } else if (this.password) {
          return `${this.username ? '"' + this.username + '" ' : ""}[password]`;
        } else if (this.publicKey) {
          return `${this.username ? '"' + this.username + '" ' : ""}[${this.publicKey.keyAlgorithmName}]`;
        } else {
          return `"${this.username}"`;
        }
      }
    };
    exports2.SshAuthenticatingEventArgs = SshAuthenticatingEventArgs;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/services/authenticationService.js
var require_authenticationService = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/services/authenticationService.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var AuthenticationService_1;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AuthenticationService = void 0;
    var sshService_1 = require_sshService();
    var authenticationMessages_1 = require_authenticationMessages();
    var vscode_jsonrpc_1 = require_main();
    var sshData_1 = require_sshData();
    var transportMessages_1 = require_transportMessages();
    var sshAuthenticatingEventArgs_1 = require_sshAuthenticatingEventArgs();
    var connectionService_1 = require_connectionService();
    var serviceActivation_1 = require_serviceActivation();
    var queue_1 = require_queue();
    var trace_1 = require_trace();
    var errors_1 = require_errors();
    var AuthenticationService = AuthenticationService_1 = class AuthenticationService extends sshService_1.SshService {
      constructor(session) {
        var _a;
        super(session);
        this.currentRequestMessage = null;
        this.authenticationFailureCount = 0;
        this.disposeCancellationSource = new vscode_jsonrpc_1.CancellationTokenSource();
        const algorithmName = (_a = session.algorithms) === null || _a === void 0 ? void 0 : _a.publicKeyAlgorithmName;
        if (!algorithmName) {
          throw new Error("Algorithms not initialized.");
        }
        this.publicKeyAlgorithmName = algorithmName;
      }
      handleMessage(message, cancellation) {
        if (message instanceof authenticationMessages_1.AuthenticationSuccessMessage) {
          return this.handleSuccessMessage(message);
        } else if (message instanceof authenticationMessages_1.AuthenticationFailureMessage) {
          return this.handleFailureMessage(message);
        } else if (message instanceof authenticationMessages_1.AuthenticationRequestMessage) {
          return this.handleAuthenticationRequestMessage(message, cancellation);
        } else if (message instanceof authenticationMessages_1.AuthenticationInfoRequestMessage) {
          return this.handleInfoRequestMessage(message, cancellation);
        } else if (message instanceof authenticationMessages_1.AuthenticationInfoResponseMessage) {
          return this.handleInfoResponseMessage(message, cancellation);
        } else if (message instanceof authenticationMessages_1.PublicKeyOKMessage) {
        } else {
        }
      }
      async handleAuthenticationRequestMessage(message, cancellation) {
        this.trace(trace_1.TraceLevel.Info, trace_1.SshTraceEventIds.sessionAuthenticating, `Authentication request: ${message.methodName}`);
        let methodName = message.methodName;
        if (!this.session.config.authenticationMethods.includes(methodName)) {
          methodName = null;
        }
        if (methodName === "publickey" || methodName === "hostbased") {
          const publicKeymessage = message.convertTo(new authenticationMessages_1.PublicKeyRequestMessage());
          this.setCurrentRequest(publicKeymessage);
          return this.handlePublicKeyRequestMessage(publicKeymessage, cancellation);
        } else if (methodName === "password") {
          const passwordMessage = message.convertTo(new authenticationMessages_1.PasswordRequestMessage());
          this.setCurrentRequest(passwordMessage);
          return this.handlePasswordRequestMessage(passwordMessage, cancellation);
        } else if (methodName === "keyboard-interactive") {
          this.setCurrentRequest(message);
          return this.beginInteractiveAuthentication(message, cancellation);
        } else if (methodName === "none") {
          this.setCurrentRequest(message);
          return this.handleAuthenticating(new sshAuthenticatingEventArgs_1.SshAuthenticatingEventArgs(sshAuthenticatingEventArgs_1.SshAuthenticationType.clientNone, {
            username: message.username
          }), cancellation);
        } else {
          this.setCurrentRequest(null);
          const failureMessage = new authenticationMessages_1.AuthenticationFailureMessage();
          failureMessage.methodNames = [
            "publickey",
            "password",
            "hostbased"
          ];
          await this.session.sendMessage(failureMessage, cancellation);
        }
      }
      setCurrentRequest(message) {
        var _a;
        this.currentRequestMessage = message;
        const protocol = this.session.protocol;
        if (protocol) {
          protocol.messageContext = (_a = message === null || message === void 0 ? void 0 : message.methodName) !== null && _a !== void 0 ? _a : null;
        }
      }
      async handlePublicKeyRequestMessage(message, cancellation) {
        var _a, _b, _c;
        const publicKeyAlg = this.session.config.getPublicKeyAlgorithm(message.keyAlgorithmName);
        if (!publicKeyAlg) {
          const failureMessage = new authenticationMessages_1.AuthenticationFailureMessage();
          failureMessage.methodNames = [
            "publickey",
            "password"
          ];
          await this.session.sendMessage(failureMessage, cancellation);
          return;
        }
        const publicKey = publicKeyAlg.createKeyPair();
        await publicKey.setPublicKeyBytes(message.publicKey);
        let args;
        if (message.methodName === "hostbased") {
          args = new sshAuthenticatingEventArgs_1.SshAuthenticatingEventArgs(sshAuthenticatingEventArgs_1.SshAuthenticationType.clientHostBased, {
            username: (_a = message.username) !== null && _a !== void 0 ? _a : "",
            publicKey,
            clientHostname: message.clientHostname,
            clientUsername: message.clientUsername
          });
        } else if (!message.hasSignature) {
          args = new sshAuthenticatingEventArgs_1.SshAuthenticatingEventArgs(sshAuthenticatingEventArgs_1.SshAuthenticationType.clientPublicKeyQuery, {
            username: (_b = message.username) !== null && _b !== void 0 ? _b : "",
            publicKey
          });
        } else {
          const signature = publicKeyAlg.readSignatureData(message.signature);
          const sessionId = this.session.sessionId;
          if (sessionId == null) {
            throw new Error("Session ID not initialized.");
          }
          const writer = new sshData_1.SshDataWriter(Buffer.alloc(sessionId.length + message.payloadWithoutSignature.length + 20));
          writer.writeBinary(sessionId);
          writer.write(message.payloadWithoutSignature);
          const signedData = writer.toBuffer();
          const verifier = publicKeyAlg.createVerifier(publicKey);
          const verified = await verifier.verify(signedData, signature);
          if (!verified) {
            await this.handleAuthenticationFailure("Public key authentication failed: invalid signature.", cancellation);
          }
          args = new sshAuthenticatingEventArgs_1.SshAuthenticatingEventArgs(sshAuthenticatingEventArgs_1.SshAuthenticationType.clientPublicKey, {
            username: (_c = message.username) !== null && _c !== void 0 ? _c : "",
            publicKey
          });
        }
        await this.handleAuthenticating(args, cancellation);
      }
      async handlePasswordRequestMessage(message, cancellation) {
        var _a, _b;
        const args = new sshAuthenticatingEventArgs_1.SshAuthenticatingEventArgs(sshAuthenticatingEventArgs_1.SshAuthenticationType.clientPassword, {
          username: (_a = message.username) !== null && _a !== void 0 ? _a : "",
          password: (_b = message.password) !== null && _b !== void 0 ? _b : ""
        });
        await this.handleAuthenticating(args, cancellation);
      }
      async beginInteractiveAuthentication(message, cancellation) {
        const args = new sshAuthenticatingEventArgs_1.SshAuthenticatingEventArgs(sshAuthenticatingEventArgs_1.SshAuthenticationType.clientInteractive, {
          username: message.username
        });
        await this.handleAuthenticating(args, cancellation);
      }
      async handleInfoRequestMessage(message, cancellation) {
        const args = new sshAuthenticatingEventArgs_1.SshAuthenticatingEventArgs(sshAuthenticatingEventArgs_1.SshAuthenticationType.clientInteractive, {
          infoRequest: message
        });
        await this.handleAuthenticating(args, cancellation);
      }
      async handleInfoResponseMessage(message, cancellation) {
        var _a;
        const args = new sshAuthenticatingEventArgs_1.SshAuthenticatingEventArgs(sshAuthenticatingEventArgs_1.SshAuthenticationType.clientInteractive, {
          username: (_a = this.currentRequestMessage) === null || _a === void 0 ? void 0 : _a.username,
          infoResponse: message
        });
        await this.handleAuthenticating(args, cancellation);
      }
      async handleAuthenticating(args, cancellation) {
        var _a;
        if (!this.currentRequestMessage) {
          throw new errors_1.SshConnectionError("No current authentication request.", transportMessages_1.SshDisconnectReason.protocolError);
        }
        args.cancellation = this.disposeCancellationSource.token;
        let authenticatedPrincipal = null;
        try {
          authenticatedPrincipal = await this.session.raiseAuthenticatingEvent(args);
        } catch (e) {
          if (!(e instanceof Error))
            throw e;
          this.trace(trace_1.TraceLevel.Error, trace_1.SshTraceEventIds.authenticationError, `Error while authenticating client: ${e.message}`, e);
          authenticatedPrincipal = null;
        }
        if (authenticatedPrincipal) {
          if (args.authenticationType === sshAuthenticatingEventArgs_1.SshAuthenticationType.clientPublicKeyQuery) {
            const publicKeyRequest = this.currentRequestMessage;
            const okMessage = new authenticationMessages_1.PublicKeyOKMessage();
            okMessage.keyAlgorithmName = publicKeyRequest.keyAlgorithmName;
            okMessage.publicKey = publicKeyRequest.publicKey;
            this.setCurrentRequest(null);
            await this.session.sendMessage(okMessage, cancellation);
          } else {
            this.session.principal = authenticatedPrincipal;
            const serviceName = this.currentRequestMessage.serviceName;
            if (serviceName) {
              this.session.activateService(serviceName);
            }
            this.trace(trace_1.TraceLevel.Info, trace_1.SshTraceEventIds.sessionAuthenticated, `${sshAuthenticatingEventArgs_1.SshAuthenticationType[args.authenticationType]} authentication succeeded.`);
            this.setCurrentRequest(null);
            await this.session.sendMessage(new authenticationMessages_1.AuthenticationSuccessMessage(), cancellation);
            (_a = this.session) === null || _a === void 0 ? void 0 : _a.handleClientAuthenticated();
          }
        } else if (args.authenticationType === sshAuthenticatingEventArgs_1.SshAuthenticationType.clientInteractive && !this.session.isClientSession && args.infoRequest) {
          await this.sendMessage(args.infoRequest, cancellation);
        } else if (args.authenticationType === sshAuthenticatingEventArgs_1.SshAuthenticationType.clientInteractive && this.session.isClientSession && args.infoResponse) {
          await this.sendMessage(args.infoResponse, cancellation);
        } else {
          this.setCurrentRequest(null);
          await this.handleAuthenticationFailure(`${sshAuthenticatingEventArgs_1.SshAuthenticationType[args.authenticationType]} authentication failed.`);
        }
      }
      async handleAuthenticationFailure(message, cancellation) {
        this.authenticationFailureCount++;
        this.trace(trace_1.TraceLevel.Warning, trace_1.SshTraceEventIds.clientAuthenticationFailed, message);
        const failureMessage = new authenticationMessages_1.AuthenticationFailureMessage();
        failureMessage.methodNames = this.session.config.authenticationMethods;
        await this.session.sendMessage(failureMessage, cancellation);
        if (this.authenticationFailureCount >= this.session.config.maxClientAuthenticationAttempts) {
          await this.session.close(transportMessages_1.SshDisconnectReason.noMoreAuthMethodsAvailable, "Authentication failed.");
        }
      }
      async authenticateClient(credentials, cancellation) {
        var _a, _b, _c, _d;
        this.clientAuthenticationMethods = new queue_1.Queue();
        const configuredMethods = this.session.config.authenticationMethods;
        if (configuredMethods.includes(
          "publickey"
          /* AuthenticationMethod.publicKey */
        )) {
          for (const publicKey of (_a = credentials.publicKeys) !== null && _a !== void 0 ? _a : []) {
            if (!publicKey)
              continue;
            const username = (_b = credentials.username) !== null && _b !== void 0 ? _b : "";
            let privateKey = publicKey;
            const privateKeyProvider = credentials.privateKeyProvider;
            this.clientAuthenticationMethods.enqueue({
              method: "publickey",
              handler: async (cancellation2) => {
                if (!privateKey.hasPrivateKey) {
                  if (privateKeyProvider == null) {
                    throw new Error("A private key provider is required.");
                  }
                  privateKey = await privateKeyProvider(publicKey, cancellation2 !== null && cancellation2 !== void 0 ? cancellation2 : vscode_jsonrpc_1.CancellationToken.None);
                }
                if (privateKey) {
                  await this.requestPublicKeyAuthentication(username, privateKey, cancellation2);
                } else {
                  await this.session.close(transportMessages_1.SshDisconnectReason.authCancelledByUser);
                }
              }
            });
          }
        }
        if (configuredMethods.includes(
          "password"
          /* AuthenticationMethod.password */
        )) {
          const passwordCredentialProvider = credentials.passwordProvider;
          if (passwordCredentialProvider) {
            this.clientAuthenticationMethods.enqueue({
              method: "password",
              handler: async (cancellation2) => {
                var _a2;
                const passwordCredentialPromise = passwordCredentialProvider(cancellation2 !== null && cancellation2 !== void 0 ? cancellation2 : vscode_jsonrpc_1.CancellationToken.None);
                const passwordCredential = passwordCredentialPromise ? await passwordCredentialPromise : null;
                if (passwordCredential) {
                  await this.requestPasswordAuthentication((_a2 = passwordCredential[0]) !== null && _a2 !== void 0 ? _a2 : "", passwordCredential[1], cancellation2);
                } else {
                  await this.session.close(transportMessages_1.SshDisconnectReason.authCancelledByUser);
                }
              }
            });
          } else if (credentials.password) {
            const username = (_c = credentials.username) !== null && _c !== void 0 ? _c : "";
            const password = credentials.password;
            this.clientAuthenticationMethods.enqueue({
              method: "password",
              handler: async (cancellation2) => {
                await this.requestPasswordAuthentication(username, password, cancellation2);
              }
            });
          }
        }
        if (this.clientAuthenticationMethods.size === 0) {
          const username = (_d = credentials.username) !== null && _d !== void 0 ? _d : "";
          if (configuredMethods.includes(
            "none"
            /* AuthenticationMethod.none */
          )) {
            this.clientAuthenticationMethods.enqueue({
              method: "none",
              handler: async (cancellation2) => {
                await this.requestUsernameAuthentication(username, cancellation2);
              }
            });
          }
          if (configuredMethods.includes(
            "keyboard-interactive"
            /* AuthenticationMethod.keyboardInteractive */
          )) {
            this.clientAuthenticationMethods.enqueue({
              method: "keyboard-interactive",
              handler: async (cancellation2) => {
                await this.requestInteractiveAuthentication(username, cancellation2);
              }
            });
          }
          if (this.clientAuthenticationMethods.size === 0) {
            throw new Error("Could not prepare request for authentication method(s): " + configuredMethods.join(", ") + ". Supply client credentials or enable none or interactive authentication methods.");
          }
        }
        this.session.activateService(connectionService_1.ConnectionService);
        const firstAuthMethod = this.clientAuthenticationMethods.dequeue();
        await firstAuthMethod.handler(cancellation);
      }
      async requestUsernameAuthentication(username, cancellation) {
        const authMessage = new authenticationMessages_1.AuthenticationRequestMessage();
        authMessage.serviceName = connectionService_1.ConnectionService.serviceName;
        authMessage.methodName = "none";
        authMessage.username = username;
        this.setCurrentRequest(authMessage);
        await this.session.sendMessage(authMessage, cancellation);
      }
      async requestPublicKeyAuthentication(username, key, cancellation) {
        const algorithm = this.session.config.publicKeyAlgorithms.find((a) => (a === null || a === void 0 ? void 0 : a.keyAlgorithmName) === key.keyAlgorithmName);
        if (!algorithm) {
          throw new Error(`Public key algorithm '${key.keyAlgorithmName}' is not in session config.`);
        }
        const authMessage = new authenticationMessages_1.PublicKeyRequestMessage();
        authMessage.serviceName = connectionService_1.ConnectionService.serviceName;
        authMessage.username = username;
        authMessage.keyAlgorithmName = algorithm.name;
        authMessage.publicKey = await key.getPublicKeyBytes(algorithm.name);
        authMessage.signature = await this.createAuthenticationSignature(authMessage, algorithm, key);
        this.setCurrentRequest(authMessage);
        await this.session.sendMessage(authMessage, cancellation);
      }
      async requestPasswordAuthentication(username, password, cancellation) {
        const authMessage = new authenticationMessages_1.PasswordRequestMessage();
        authMessage.serviceName = connectionService_1.ConnectionService.serviceName;
        authMessage.username = username;
        authMessage.password = password;
        this.setCurrentRequest(authMessage);
        await this.session.sendMessage(authMessage, cancellation);
      }
      async requestInteractiveAuthentication(username, cancellation) {
        const authMessage = new authenticationMessages_1.AuthenticationRequestMessage();
        authMessage.serviceName = connectionService_1.ConnectionService.serviceName;
        authMessage.methodName = "keyboard-interactive";
        authMessage.username = username;
        this.setCurrentRequest(authMessage);
        await this.session.sendMessage(authMessage, cancellation);
      }
      async handleFailureMessage(message) {
        var _a, _b;
        this.setCurrentRequest(null);
        while ((_a = this.clientAuthenticationMethods) === null || _a === void 0 ? void 0 : _a.size) {
          const nextAuthMethod = this.clientAuthenticationMethods.dequeue();
          if ((_b = message.methodNames) === null || _b === void 0 ? void 0 : _b.includes(nextAuthMethod.method)) {
            await nextAuthMethod.handler(this.disposeCancellationSource.token);
            return;
          }
        }
        this.session.onAuthenticationComplete(false);
      }
      handleSuccessMessage(message) {
        this.setCurrentRequest(null);
        this.session.onAuthenticationComplete(true);
      }
      async createAuthenticationSignature(requestMessage, algorithm, key) {
        const sessionId = this.session.sessionId;
        if (sessionId == null) {
          throw new Error("Session ID not initialized.");
        }
        const writer = new sshData_1.SshDataWriter(Buffer.alloc(requestMessage.publicKey.length + (requestMessage.username || "").length + 400));
        writer.writeBinary(sessionId);
        writer.writeByte(requestMessage.messageType);
        writer.writeString(requestMessage.username || "", "utf8");
        writer.writeString(requestMessage.serviceName || "", "ascii");
        writer.writeString("publickey", "ascii");
        writer.writeBoolean(true);
        writer.writeString(requestMessage.keyAlgorithmName, "ascii");
        writer.writeBinary(requestMessage.publicKey);
        const signer = algorithm.createSigner(key);
        const signature = await signer.sign(writer.toBuffer());
        return algorithm.createSignatureData(signature);
      }
      dispose() {
        try {
          this.disposeCancellationSource.cancel();
          this.disposeCancellationSource.dispose();
        } catch (_a) {
        }
        super.dispose();
      }
    };
    AuthenticationService.serviceName = "ssh-userauth";
    AuthenticationService = AuthenticationService_1 = __decorate([
      (0, serviceActivation_1.serviceActivation)({ serviceRequest: AuthenticationService_1.serviceName })
    ], AuthenticationService);
    exports2.AuthenticationService = AuthenticationService;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/metrics/sessionMetrics.js
var require_sessionMetrics = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/metrics/sessionMetrics.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SessionMetrics = void 0;
    var vscode_jsonrpc_1 = require_main();
    var trace_1 = require_trace();
    var SessionMetrics = class {
      /* @internal */
      constructor() {
        this.startTime = 0;
        this.messagesSentCount = 0;
        this.messagesReceivedCount = 0;
        this.bytesSentSum = 0;
        this.bytesReceivedSum = 0;
        this.reconnectionsCount = 0;
        this.currentLatency = 0;
        this.minLatency = 0;
        this.maxLatency = 0;
        this.latencySum = 0;
        this.latencyCount = 0;
        this.messageSentEmitter = new vscode_jsonrpc_1.Emitter();
        this.onMessageSent = this.messageSentEmitter.event;
        this.messageReceivedEmitter = new vscode_jsonrpc_1.Emitter();
        this.onMessageReceived = this.messageReceivedEmitter.event;
        this.latencyUpdatedEmitter = new vscode_jsonrpc_1.Emitter();
        this.onLatencyUpdated = this.latencyUpdatedEmitter.event;
        this.sessionClosedEmitter = new vscode_jsonrpc_1.Emitter();
        this.onSessionClosed = this.sessionClosedEmitter.event;
        if (typeof performance === "object" && typeof performance.now === "function") {
          Object.defineProperty(this, "time", { get: this.browserTime });
        } else if (typeof process === "object" && typeof process.hrtime === "function") {
          Object.defineProperty(this, "time", { get: this.nodejsTime });
        }
        this.startTime = this.time;
      }
      /**
       * Gets the current stopwatch value in milliseconds (possibly including fractional milliseconds),
       * used for measuring latency.
       */
      /* @internal */
      get time() {
        return Date.now() - this.startTime;
      }
      browserTime() {
        return performance.now() - this.startTime;
      }
      nodejsTime() {
        const [s, ns] = process.hrtime();
        return s * 1e3 + ns / 1e6 - this.startTime;
      }
      /**
       * Gets the total cumulative number of messages sent for the duration of the session,
       * including all channels and non-channel protocol messages.
       */
      get messagesSent() {
        return this.messagesSentCount;
      }
      /**
       * Gets the total cumulative number of messages received for the duration of the session,
       * including all channels and non-channel protocol messages.
       */
      get messagesReceived() {
        return this.messagesReceivedCount;
      }
      /**
       * Gets the total cumulative number of bytes sent for the duration of the session,
       * including all channels and non-channel protocol messages, and including message
       * framing, padding, and MAC bytes.
       */
      get bytesSent() {
        return this.bytesSentSum;
      }
      /**
       * Gets the total cumulative number of bytes received for the duration of the session,
       * including all channels and non-channel protocol messages, and including message
       * framing, padding, and MAC bytes.
       */
      get bytesReceived() {
        return this.bytesReceivedSum;
      }
      /**
       * Gets the number of times the session has reconnected.
       * </summary>
       * <remarks>
       * Reconnection requires both sides to support the
       * <see cref="SshProtocolExtensionNames.SessionReconnect" /> protocol extension.
       */
      get reconnections() {
        return this.reconnectionsCount;
      }
      /**
       * Gets the average measured round-trip connection latency between client and server
       * over the duration of the session, in milliseconds.
       * </summary>
       * <remarks>
       * Latency measurement requires both sides to support the
       * <see cref="SshProtocolExtensionNames.SessionLatency" /> protocol extension.
       * If not supported, this Sum will be 0.
       */
      get latencyAverageMs() {
        return this.latencyCount === 0 ? 0 : this.latencySum / this.latencyCount;
      }
      /**
       * Gets the minimum measured round-trip connection latency between client and server
       * over the duration of the session, in milliseconds.
       * </summary>
       * <remarks>
       * Latency measurement requires both sides to support the
       * <see cref="SshProtocolExtensionNames.SessionLatency" /> protocol extension.
       * If not supported, this Sum will be 0.
       */
      get latencyMinMs() {
        return this.minLatency;
      }
      /**
       * Gets the maximum measured round-trip connection latency between client and server
       * over the duration of the session, in milliseconds.
       * </summary>
       * <remarks>
       * Latency measurement requires both sides to support the
       * <see cref="SshProtocolExtensionNames.SessionLatency" /> protocol extension.
       * If not supported, this Sum will be 0.
       */
      get latencyMaxMs() {
        return this.maxLatency;
      }
      /**
       * Gets the most recent measurement of round-trip connection latency between client and
       * server, in milliseconds.
       * </summary>
       * <remarks>
       * Latency measurement requires both sides to support the
       * <see cref="SshProtocolExtensionNames.SessionLatency" /> protocol extension.
       * If not supported or the session is not currently connected, this Sum will be 0.
       */
      get latencyCurrentMs() {
        return this.currentLatency;
      }
      /* @internal */
      addMessageSent(size) {
        this.messagesSentCount++;
        this.bytesSentSum += size;
        this.messageSentEmitter.fire({ time: this.time, size });
      }
      /* @internal */
      addMessageReceived(size) {
        this.messagesReceivedCount++;
        this.bytesReceivedSum += size;
        this.messageReceivedEmitter.fire({ time: this.time, size });
      }
      /* @internal */
      addReconnection() {
        this.reconnectionsCount++;
      }
      /* @internal */
      updateLatency(latencyMs, trace) {
        if (latencyMs < 0) {
          if (trace) {
            trace(trace_1.TraceLevel.Warning, trace_1.SshTraceEventIds.metricsError, `Measured latency was negative: ${latencyMs} us`);
          }
          return;
        }
        this.currentLatency = latencyMs;
        if (latencyMs === 0) {
          return;
        }
        if (this.minLatency === 0 || latencyMs < this.minLatency) {
          this.minLatency = latencyMs;
        }
        if (this.maxLatency === 0 || latencyMs > this.maxLatency) {
          this.maxLatency = latencyMs;
        }
        this.latencySum += latencyMs;
        this.latencyCount++;
        this.latencyUpdatedEmitter.fire({ time: this.time, latency: latencyMs });
      }
      /* @internal */
      close() {
        this.currentLatency = 0;
        this.sessionClosedEmitter.fire();
      }
      toString() {
        let s = `Messages S/R: ${this.messagesSent} / ${this.messagesReceived}; Bytes S/R: ${this.bytesSent} / ${this.bytesReceived}; Reconnections: ${this.reconnections}; `;
        const precision = this.minLatency >= 10 ? 1 : this.minLatency >= 1 ? 10 : 100;
        if (this.maxLatency > 0) {
          const min = Math.round(this.minLatency * precision) / precision;
          const avg = Math.round(this.latencySum / this.latencyCount * precision) / precision;
          const max = Math.round(this.maxLatency * precision) / precision;
          s += `Latency Min-Avg-Max: ${min} - ${avg} - ${max} ms; `;
        }
        if (this.currentLatency > 0) {
          const current = Math.round(this.currentLatency * precision) / precision;
          s += `Current Latency: ${current} ms; `;
        }
        return s;
      }
    };
    exports2.SessionMetrics = SessionMetrics;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/events/sshSessionClosedEventArgs.js
var require_sshSessionClosedEventArgs = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/events/sshSessionClosedEventArgs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SshSessionClosedEventArgs = void 0;
    var transportMessages_1 = require_transportMessages();
    var SshSessionClosedEventArgs = class {
      constructor(reason, message, error) {
        this.reason = reason;
        this.message = message;
        this.error = error;
        if (!message)
          throw new TypeError("A disconnect message is required.");
      }
      toString() {
        return `${transportMessages_1.SshDisconnectReason[this.reason]}: ${this.message}`;
      }
    };
    exports2.SshSessionClosedEventArgs = SshSessionClosedEventArgs;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/progress.js
var require_progress = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/progress.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Progress = void 0;
    var Progress;
    (function(Progress2) {
      Progress2["OpeningClientConnectionToRelay"] = "OpeningClientConnectionToRelay";
      Progress2["OpenedClientConnectionToRelay"] = "OpenedClientConnectionToRelay";
      Progress2["OpeningHostConnectionToRelay"] = "OpeningHostConnectionToRelay";
      Progress2["OpenedHostConnectionToRelay"] = "OpenedHostConnectionToRelay";
      Progress2["OpeningSshSessionConnection"] = "OpeningSshSessionConnection";
      Progress2["OpenedSshSessionConnection"] = "OpenedSshSessionConnection";
      Progress2["StartingProtocolVersionExchange"] = "StartingProtocolVersionExchange";
      Progress2["CompletedProtocolVersionExchange"] = "CompletedProtocolVersionExchange";
      Progress2["StartingKeyExchange"] = "StartingKeyExchange";
      Progress2["CompletedKeyExchange"] = "CompletedKeyExchange";
      Progress2["StartingSessionAuthentication"] = "StartingSessionAuthentication";
      Progress2["CompletedSessionAuthentication"] = "CompletedSessionAuthentication";
    })(Progress = exports2.Progress || (exports2.Progress = {}));
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/events/sshReportProgressEventArgs.js
var require_sshReportProgressEventArgs = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/events/sshReportProgressEventArgs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SshReportProgressEventArgs = void 0;
    var SshReportProgressEventArgs = class {
      constructor(progress, sessionNumber) {
        this.progress = progress;
        this.sessionNumber = sessionNumber;
      }
      toString() {
        return `Progress: ${this.progress}` + this.sessionNumber ? ` Session number: ${this.sessionNumber}` : "";
      }
    };
    exports2.SshReportProgressEventArgs = SshReportProgressEventArgs;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/sshSession.js
var require_sshSession = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/sshSession.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SshSession = void 0;
    var trace_1 = require_trace();
    var buffer_1 = require("buffer");
    var vscode_jsonrpc_1 = require_main();
    var sshSessionConfiguration_1 = require_sshSessionConfiguration();
    var sshChannel_1 = require_sshChannel();
    var sshVersionInfo_1 = require_sshVersionInfo();
    var sshProtocol_1 = require_sshProtocol();
    var keyExchangeService_1 = require_keyExchangeService();
    var serviceActivation_1 = require_serviceActivation();
    var connectionService_1 = require_connectionService();
    var authenticationService_1 = require_authenticationService();
    var sshMessage_1 = require_sshMessage();
    var kexMessages_1 = require_kexMessages();
    var connectionMessages_1 = require_connectionMessages();
    var authenticationMessages_1 = require_authenticationMessages();
    var transportMessages_1 = require_transportMessages();
    var sessionMetrics_1 = require_sessionMetrics();
    var promiseCompletionSource_1 = require_promiseCompletionSource();
    var sshSessionClosedEventArgs_1 = require_sshSessionClosedEventArgs();
    var sshRequestEventArgs_1 = require_sshRequestEventArgs();
    var sshAlgorithms_1 = require_sshAlgorithms();
    var cancellation_1 = require_cancellation2();
    var errors_1 = require_errors();
    var semaphore_1 = require_semaphore();
    var pipeExtensions_1 = require_pipeExtensions();
    var queue_1 = require_queue();
    var progress_1 = require_progress();
    var sshReportProgressEventArgs_1 = require_sshReportProgressEventArgs();
    var sessionCounter = 0;
    var SshSession = class _SshSession {
      get algorithms() {
        return this.protocol ? this.protocol.algorithms : null;
      }
      /**
       * Gets an object containing claims about the server or client on the
       * other end of the session, or `null` if the session is not authenticated.
       *
       * This property is initially `null` for an unauthenticated session. On
       * successful authentication, the session Authenticating event handler
       * provides a Task that returns a principal that is stored here.
       */
      get principal() {
        return this.principalValue;
      }
      /* @internal */
      set principal(value) {
        this.principalValue = value;
      }
      constructor(config, isClientSession) {
        this.config = config;
        this.remoteVersion = null;
        this.activatedServices = /* @__PURE__ */ new Map();
        this.connectionService = null;
        this.requestHandlers = new queue_1.Queue();
        this.blockedMessages = [];
        this.blockedMessagesSemaphore = new semaphore_1.Semaphore(1);
        this.connected = false;
        this.disposed = false;
        this.keepAliveResponseReceived = false;
        this.keepAliveFailureCount = 0;
        this.keepAliveSuccessCount = 0;
        this.metrics = new sessionMetrics_1.SessionMetrics();
        this.reconnecting = false;
        this.sessionId = null;
        this.principalValue = null;
        this.authenticatingEmitter = new vscode_jsonrpc_1.Emitter();
        this.onAuthenticating = this.authenticatingEmitter.event;
        this.closedEmitter = new vscode_jsonrpc_1.Emitter();
        this.onClosed = this.closedEmitter.event;
        this.disconnectedEmitter = new vscode_jsonrpc_1.Emitter();
        this.onDisconnected = this.disconnectedEmitter.event;
        this.serviceActivatedEmitter = new vscode_jsonrpc_1.Emitter();
        this.onServiceActivated = this.serviceActivatedEmitter.event;
        this.channelOpeningEmitter = new vscode_jsonrpc_1.Emitter();
        this.onChannelOpening = this.channelOpeningEmitter.event;
        this.requestEmitter = new vscode_jsonrpc_1.Emitter();
        this.onRequest = this.requestEmitter.event;
        this.reportProgressEmitter = new vscode_jsonrpc_1.Emitter();
        this.onReportProgress = this.reportProgressEmitter.event;
        this.keepAliveFailedEmitter = new vscode_jsonrpc_1.Emitter();
        this.onKeepAliveFailed = this.keepAliveFailedEmitter.event;
        this.keepAliveSucceededEmitter = new vscode_jsonrpc_1.Emitter();
        this.onKeepAliveSucceeded = this.keepAliveSucceededEmitter.event;
        this.trace = (level, eventId, msg, err) => {
        };
        this.isClientSession = isClientSession;
        this.sessionNumber = ++sessionCounter;
        if (!config)
          throw new TypeError("Session configuration is required.");
        if (!config.keyExchangeAlgorithms.find((a) => !!a)) {
          if (config.encryptionAlgorithms.length > 0 && config.encryptionAlgorithms.indexOf(null) < 0) {
            throw new Error("Encryption requires a key-exchange algorithm to be configured.");
          } else if (config.hmacAlgorithms.length > 0 && config.hmacAlgorithms.indexOf(null) < 0) {
            throw new Error("HMAC requires a key-exchange algorithm to be configured.");
          } else if (config.publicKeyAlgorithms.length > 0 && config.publicKeyAlgorithms.indexOf(null) < 0) {
            throw new Error("Host authentication requires a key-exchange algorithm to be configured.");
          }
          this.kexService = null;
          this.activateService(connectionService_1.ConnectionService);
        } else {
          this.kexService = new keyExchangeService_1.KeyExchangeService(this);
        }
        config.onConfigurationChanged(() => {
          const protocol = this.protocol;
          if (protocol) {
            protocol.traceChannelData = config.traceChannelData;
          }
          if (this.connected && !this.disposed) {
            this.startKeepAliveTimer();
          }
        });
      }
      get isConnected() {
        return this.connected;
      }
      get isClosed() {
        return this.disposed;
      }
      get services() {
        return [...this.activatedServices.values()];
      }
      get channels() {
        var _a, _b;
        return (_b = (_a = this.connectionService) === null || _a === void 0 ? void 0 : _a.channels) !== null && _b !== void 0 ? _b : [];
      }
      get protocolExtensions() {
        var _a;
        return ((_a = this.protocol) === null || _a === void 0 ? void 0 : _a.extensions) || null;
      }
      /**
       * Gets an activated service instance by type.
       *
       * @returns The service instance, or `null` if the service has not been activated.
       */
      getService(serviceType) {
        const service = this.activatedServices.get(serviceType);
        return service ? service : null;
      }
      /* @internal */
      activateService(serviceTypeOrName) {
        let serviceType;
        if (typeof serviceTypeOrName === "function") {
          serviceType = serviceTypeOrName;
        } else {
          const serviceName = serviceTypeOrName;
          serviceType = (0, serviceActivation_1.findService)(this.config.services, (a) => a.serviceRequest === serviceName);
          if (!serviceType) {
            return null;
          }
        }
        let activatedService = this.activatedServices.get(serviceType);
        if (!activatedService) {
          if (!this.config.services.has(serviceType)) {
            throw new Error(`Service type not configured: ${serviceType.name}`);
          }
          const serviceConfig = this.config.services.get(serviceType);
          activatedService = new serviceType(this, serviceConfig);
          if (serviceType === connectionService_1.ConnectionService) {
            this.connectionService = activatedService;
          }
          this.activatedServices.set(serviceType, activatedService);
          this.serviceActivatedEmitter.fire(activatedService);
        }
        return activatedService;
      }
      async connect(stream, cancellation) {
        if (!stream)
          throw new TypeError("A session stream is required.");
        if (this.disposed)
          throw new errors_1.ObjectDisposedError(this);
        if (!this.connectPromise) {
          this.connectPromise = this.doConnect(stream, cancellation);
        }
        await this.connectPromise;
      }
      async doConnect(stream, cancellation) {
        this.trace(trace_1.TraceLevel.Info, trace_1.SshTraceEventIds.sessionConnecting, `${this} ${this.reconnecting ? "re" : ""}connecting...`);
        this.raiseReportProgress(progress_1.Progress.OpeningSshSessionConnection);
        this.protocol = new sshProtocol_1.SshProtocol(stream, this.config, this.metrics, this.trace);
        this.protocol.kexService = this.kexService;
        this.raiseReportProgress(progress_1.Progress.StartingProtocolVersionExchange);
        await this.exchangeVersions(cancellation);
        if (this.kexService) {
          await this.encrypt(cancellation);
        } else {
          await this.sendMessage(kexMessages_1.KeyExchangeInitMessage.none, cancellation);
          await (0, cancellation_1.withCancellation)(this.versionExchangePromise, cancellation);
          this.raiseReportProgress(progress_1.Progress.CompletedProtocolVersionExchange);
          this.connected = true;
        }
        this.processMessages().catch((e) => {
          this.trace(trace_1.TraceLevel.Error, trace_1.SshTraceEventIds.unknownError, `Unhandled error processing messages: ${e.message}`, e);
        });
        this.startKeepAliveTimer();
        this.raiseReportProgress(progress_1.Progress.OpenedSshSessionConnection);
      }
      async exchangeVersions(cancellation) {
        const writePromise = this.protocol.writeProtocolVersion(_SshSession.localVersion.toString(), cancellation);
        const readPromise = this.protocol.readProtocolVersion(cancellation);
        this.versionExchangePromise = readPromise.then(async (remoteVersion) => {
          this.trace(trace_1.TraceLevel.Info, trace_1.SshTraceEventIds.protocolVersion, `Local version: ${_SshSession.localVersion}, remote version: ${remoteVersion}`);
          let errorMessage;
          const remoteVersionInfo = sshVersionInfo_1.SshVersionInfo.tryParse(remoteVersion);
          if (remoteVersionInfo) {
            this.remoteVersion = remoteVersionInfo;
            if (remoteVersionInfo.protocolVersion === "2.0") {
              return;
            }
            errorMessage = `Remote SSH version ${this.remoteVersion} is not supported. This library only supports SSH v2.0.`;
          } else {
            errorMessage = `Could not parse remote SSH version ${remoteVersion}`;
          }
          await this.close(transportMessages_1.SshDisconnectReason.protocolVersionNotSupported, errorMessage, new Error(errorMessage));
        });
        await writePromise;
      }
      async encrypt(cancellation) {
        var _a, _b;
        const protocol = this.protocol;
        if (!protocol)
          throw new errors_1.ObjectDisposedError(this);
        await protocol.considerReExchange(true, cancellation);
        await (0, cancellation_1.withCancellation)(this.versionExchangePromise, cancellation);
        this.raiseReportProgress(progress_1.Progress.CompletedProtocolVersionExchange);
        this.connected = true;
        this.raiseReportProgress(progress_1.Progress.StartingKeyExchange);
        let message = null;
        while (!this.isClosed && !((_a = this.protocol) === null || _a === void 0 ? void 0 : _a.algorithms) && !(message instanceof transportMessages_1.DisconnectMessage)) {
          message = await protocol.receiveMessage(cancellation);
          if (!message) {
            break;
          }
          await this.handleMessage(message, cancellation);
        }
        this.raiseReportProgress(progress_1.Progress.CompletedKeyExchange);
        if (!((_b = this.protocol) === null || _b === void 0 ? void 0 : _b.algorithms)) {
          throw new errors_1.SshConnectionError("Session closed while encrypting.", transportMessages_1.SshDisconnectReason.connectionLost);
        } else if (this.protocol.algorithms.cipher) {
          this.trace(trace_1.TraceLevel.Info, trace_1.SshTraceEventIds.sessionEncrypted, `${this} encrypted.`);
        }
      }
      /* @internal */
      async processMessages() {
        var _a;
        this.connected = true;
        while (!this.disposed) {
          const protocol = this.protocol;
          if (!protocol) {
            break;
          }
          let message = null;
          try {
            message = await protocol.receiveMessage();
          } catch (e) {
            if (!(e instanceof Error))
              throw e;
            let reason = transportMessages_1.SshDisconnectReason.protocolError;
            if (e instanceof errors_1.SshConnectionError) {
              reason = (_a = e.reason) !== null && _a !== void 0 ? _a : reason;
            } else {
              this.trace(trace_1.TraceLevel.Error, trace_1.SshTraceEventIds.receiveMessageFailed, `Error receiving message: ${e.message}`, e);
            }
            await this.close(reason, e.message, e);
          }
          if (!message) {
            await this.close(transportMessages_1.SshDisconnectReason.connectionLost, "Connection lost.");
            break;
          }
          let messageSuccess = false;
          try {
            await this.handleMessage(message);
            messageSuccess = true;
          } catch (e) {
            if (!(e instanceof Error))
              throw e;
            this.trace(trace_1.TraceLevel.Error, trace_1.SshTraceEventIds.handleMessageFailed, `Error handling ${message}: ${e.message}`, e);
            await this.close(transportMessages_1.SshDisconnectReason.protocolError, e.message, e);
          }
          if (messageSuccess) {
            this.keepAliveResponseReceived = true;
            this.startKeepAliveTimer();
          }
        }
        this.connected = false;
      }
      /**
       * Checks whether the session is in a state that allows requests, such as session requests
       * and open-channel requests.
       *
       * A session with disabled crypto (no key-exchange service) always allows requests. A
       * session with enabled crypto does not allow requests until the first key-exchange has
       * completed (algorithms are negotiated). If the negotiated algorithms enabled encryption,
       * then the session must be authenticated (have a principal) before allowing requests.
       */
      /* @internal */
      get canAcceptRequests() {
        var _a;
        return !this.kexService || !!((_a = this.protocol) === null || _a === void 0 ? void 0 : _a.algorithms) && (!this.protocol.algorithms.cipher || !!this.principal);
      }
      async sendMessage(message, cancellation) {
        var _a, _b;
        if (!message)
          throw new TypeError("Message expected.");
        if (cancellation && cancellation.isCancellationRequested)
          throw new cancellation_1.CancellationError();
        const protocol = this.protocol;
        if (!protocol || this.disposed) {
          throw new errors_1.ObjectDisposedError(this);
        }
        if (this.kexService && this.kexService.exchanging && message.messageType > 4 && (message.messageType < 20 || message.messageType > 49)) {
          this.blockedMessages.push(message);
          return;
        }
        await this.blockedMessagesSemaphore.wait(cancellation);
        let result;
        try {
          result = await protocol.sendMessage(message, cancellation);
          this.blockedMessagesSemaphore.release();
        } catch (e) {
          this.blockedMessagesSemaphore.release();
          if (e instanceof errors_1.SshConnectionError) {
            const ce = e;
            if (ce.reason === transportMessages_1.SshDisconnectReason.connectionLost && ((_a = this.protocolExtensions) === null || _a === void 0 ? void 0 : _a.has(sshSessionConfiguration_1.SshProtocolExtensionNames.sessionReconnect))) {
              return;
            }
          }
          if (!(e instanceof Error))
            throw e;
          this.trace(trace_1.TraceLevel.Error, trace_1.SshTraceEventIds.sendMessageFailed, `Error sending ${message}: ${e.message}`, e);
          throw e;
        }
        if (!result) {
          if (!((_b = this.protocolExtensions) === null || _b === void 0 ? void 0 : _b.has(sshSessionConfiguration_1.SshProtocolExtensionNames.sessionReconnect))) {
            throw new errors_1.SshConnectionError("Session disconnected.", transportMessages_1.SshDisconnectReason.connectionLost);
          }
        }
      }
      /**
       * Handles an incoming message. Can be overridden by subclasses to handle additional
       * message types that are registered via `SshSessionConfiguration.messages`.
       */
      handleMessage(message, cancellation) {
        var _a;
        if (message instanceof connectionMessages_1.ConnectionMessage && this.connectionService) {
          return this.connectionService.handleMessage(message, cancellation);
        } else if (message instanceof kexMessages_1.NewKeysMessage) {
          return this.handleNewKeysMessage(message, cancellation);
        } else if (message instanceof kexMessages_1.KeyExchangeMessage) {
          return this.handleKeyExchangeMessage(message, cancellation);
        } else if (message instanceof authenticationMessages_1.AuthenticationMessage) {
          return (_a = this.getService(authenticationService_1.AuthenticationService)) === null || _a === void 0 ? void 0 : _a.handleMessage(message, cancellation);
        } else if (message instanceof transportMessages_1.ServiceRequestMessage) {
          return this.handleServiceRequestMessage(message, cancellation);
        } else if (message instanceof transportMessages_1.ServiceAcceptMessage) {
          return this.handleServiceAcceptMessage(message, cancellation);
        } else if (message instanceof transportMessages_1.SessionRequestMessage) {
          return this.handleRequestMessage(message, cancellation);
        } else if (message instanceof transportMessages_1.SessionRequestSuccessMessage) {
          return this.handleRequestSuccessMessage(message);
        } else if (message instanceof transportMessages_1.SessionRequestFailureMessage) {
          return this.handleRequestFailureMessage(message);
        } else if (message instanceof transportMessages_1.ExtensionInfoMessage) {
          return this.handleExtensionInfoMessage(message, cancellation);
        } else if (message instanceof transportMessages_1.DisconnectMessage) {
          return this.handleDisconnectMessage(message);
        } else if (message instanceof transportMessages_1.UnimplementedMessage) {
          return this.handleUnimplementedMessage(message, cancellation);
        } else if (message instanceof transportMessages_1.DebugMessage) {
          return this.handleDebugMessage(message);
        } else if (message instanceof transportMessages_1.IgnoreMessage) {
          return;
        } else if (message instanceof sshMessage_1.SshMessage) {
          throw new Error(`Unhandled message type: ${message.constructor.name}`);
        } else {
          throw new TypeError("Message argument was " + (message ? "invalid type." : "null."));
        }
      }
      /* @internal */
      async handleRequestMessage(message, cancellation) {
        var _a;
        let result = false;
        let response = null;
        if (message.requestType === "initial-channel-request@microsoft.com" && this.config.protocolExtensions.includes(sshSessionConfiguration_1.SshProtocolExtensionNames.openChannelRequest)) {
          const sessionChannelRequest = message.convertTo(new transportMessages_1.SessionChannelRequestMessage());
          const remoteChannelId = sessionChannelRequest.senderChannel;
          const channel = this.channels.find((c) => c.remoteChannelId === remoteChannelId);
          if (channel && sessionChannelRequest.request) {
            sessionChannelRequest.request.wantReply = false;
            result = await channel.handleRequest(sessionChannelRequest.request, cancellation);
          }
        } else if (message.requestType === "enable-session-reconnect@microsoft.com" && ((_a = this.config.protocolExtensions) === null || _a === void 0 ? void 0 : _a.includes(sshSessionConfiguration_1.SshProtocolExtensionNames.sessionReconnect))) {
          if (!this.protocol.incomingMessagesHaveReconnectInfo) {
            this.protocol.incomingMessagesHaveReconnectInfo = true;
            this.protocol.incomingMessagesHaveLatencyInfo = this.protocol.extensions.has(sshSessionConfiguration_1.SshProtocolExtensionNames.sessionLatency);
            result = true;
          }
        } else if (message.requestType === "keepalive@openssh.com") {
          this.trace(trace_1.TraceLevel.Verbose, trace_1.SshTraceEventIds.keepAliveRequestReceived, `${this} Keep-alive request received`);
          result = true;
        } else if (!this.canAcceptRequests) {
          this.trace(trace_1.TraceLevel.Warning, trace_1.SshTraceEventIds.sessionRequestFailed, "Session request blocked because the session is not yet authenticated.");
          result = false;
        } else {
          const args = new sshRequestEventArgs_1.SshRequestEventArgs(message.requestType || "", message, this.principal, cancellation);
          const serviceType = (0, serviceActivation_1.findService)(this.config.services, (a) => a.sessionRequest === message.requestType);
          if (serviceType) {
            const service = this.activateService(serviceType);
            await service.onSessionRequest(args, cancellation);
          } else {
            this.raiseSessionRequest(args);
          }
          if (args.responsePromise) {
            response = await args.responsePromise;
            result = response instanceof transportMessages_1.SessionRequestSuccessMessage;
          } else {
            result = args.isAuthorized || false;
          }
        }
        if (message.wantReply) {
          if (result) {
            if (!(response instanceof transportMessages_1.SessionRequestSuccessMessage)) {
              response = new transportMessages_1.SessionRequestSuccessMessage();
            }
          } else {
            if (!(response instanceof transportMessages_1.SessionRequestFailureMessage)) {
              response = new transportMessages_1.SessionRequestFailureMessage();
            }
          }
          await this.sendMessage(response, cancellation);
        }
      }
      /* @internal */
      raiseReportProgress(progress) {
        const args = new sshReportProgressEventArgs_1.SshReportProgressEventArgs(progress, this.sessionNumber);
        this.reportProgressEmitter.fire(args);
      }
      /* @internal */
      raiseSessionRequest(args) {
        this.requestEmitter.fire(args);
      }
      /* @internal */
      async handleServiceRequestMessage(message, cancellation) {
      }
      /* @internal */
      async handleServiceAcceptMessage(message, cancellation) {
      }
      async handleKeyExchangeMessage(message, cancellation) {
        if (this.kexService) {
          await this.kexService.handleMessage(message, cancellation);
        } else if (!(message instanceof kexMessages_1.KeyExchangeInitMessage && message.allowsNone)) {
          await this.close(transportMessages_1.SshDisconnectReason.keyExchangeFailed, "Encryption is disabled.");
        }
      }
      /* @internal */
      async handleNewKeysMessage(message, cancellation) {
        var _a;
        try {
          await this.blockedMessagesSemaphore.wait(cancellation);
          await this.protocol.handleNewKeys(cancellation);
          if ((_a = this.algorithms) === null || _a === void 0 ? void 0 : _a.isExtensionInfoRequested) {
            await this.sendExtensionInfo(cancellation);
          }
          try {
            while (this.blockedMessages.length > 0) {
              const blockedMessage = this.blockedMessages.shift();
              if (!this.protocol)
                throw new errors_1.ObjectDisposedError(this);
              await this.protocol.sendMessage(blockedMessage, cancellation);
            }
          } catch (e) {
            if (!(e instanceof Error))
              throw e;
            await this.close(transportMessages_1.SshDisconnectReason.protocolError, void 0, e);
          }
        } finally {
          this.blockedMessagesSemaphore.release();
        }
      }
      async handleUnimplementedMessage(message, cancellation) {
        if (message.unimplementedMessageType !== void 0) {
          await this.sendMessage(message, cancellation);
        } else {
        }
      }
      handleDebugMessage(message) {
        if (message.message) {
          this.trace(message.alwaysDisplay ? trace_1.TraceLevel.Info : trace_1.TraceLevel.Verbose, trace_1.SshTraceEventIds.debugMessage, message.message);
        }
      }
      startKeepAliveTimer() {
        if (this.keepAliveTimer) {
          clearTimeout(this.keepAliveTimer);
          this.keepAliveTimer = void 0;
        }
        const timeoutInSeconds = this.config.keepAliveTimeoutInSeconds;
        if (!timeoutInSeconds || timeoutInSeconds <= 0 || this.disposed || !this.connected) {
          return;
        }
        this.keepAliveTimer = setTimeout(async () => {
          try {
            await this.onKeepAliveTimeout();
          } catch (error) {
            this.trace(trace_1.TraceLevel.Error, trace_1.SshTraceEventIds.unknownError, `Error in keep-alive timeout: ${error instanceof Error ? error.message : error}`, error instanceof Error ? error : void 0);
          }
        }, timeoutInSeconds * 1e3);
      }
      async onKeepAliveTimeout() {
        if (this.disposed || !this.connected) {
          if (this.keepAliveTimer) {
            clearTimeout(this.keepAliveTimer);
            this.keepAliveTimer = void 0;
          }
          return;
        }
        if (!this.canAcceptRequests) {
          this.startKeepAliveTimer();
          return;
        }
        if (!this.keepAliveResponseReceived) {
          this.keepAliveSuccessCount = 0;
          this.keepAliveFailureCount++;
          this.trace(trace_1.TraceLevel.Warning, trace_1.SshTraceEventIds.keepAliveResponseNotReceived, `${this} Keep-alive response not received (failure #${this.keepAliveFailureCount})`);
          this.keepAliveFailedEmitter.fire(this.keepAliveFailureCount);
        } else {
          this.keepAliveFailureCount = 0;
          this.keepAliveSuccessCount++;
          this.keepAliveSucceededEmitter.fire(this.keepAliveSuccessCount);
        }
        this.keepAliveResponseReceived = false;
        try {
          const request = new transportMessages_1.SessionRequestMessage();
          request.requestType = "keepalive@openssh.com";
          request.wantReply = true;
          await this.sendMessage(request);
        } catch (error) {
          this.keepAliveSuccessCount = 0;
          this.keepAliveFailureCount++;
          this.keepAliveFailedEmitter.fire(this.keepAliveFailureCount);
        }
        if (!this.disposed && this.connected) {
          this.startKeepAliveTimer();
        }
      }
      /* @internal */
      async raiseAuthenticatingEvent(args) {
        this.trace(trace_1.TraceLevel.Info, trace_1.SshTraceEventIds.sessionAuthenticating, `${this} Authenticating(${args})`);
        this.raiseReportProgress(progress_1.Progress.StartingSessionAuthentication);
        this.authenticatingEmitter.fire(args);
        let authPromise = args.authenticationPromise;
        if (!authPromise) {
          authPromise = Promise.resolve(null);
        }
        const principal = await authPromise;
        this.raiseReportProgress(progress_1.Progress.CompletedSessionAuthentication);
        return principal;
      }
      /**
       * Sends a session request and waits for a response.
       *
       * Note if `wantReply` is `false`, this method returns `true` immediately after sending
       * the request, without waiting for a response.
       *
       * @returns The authorization status of the response; if `false`, the other side denied the
       * request.
       */
      async request(request, cancellation) {
        if (!request)
          throw new TypeError("Request is required.");
        if (!request.wantReply) {
          await this.sendMessage(request, cancellation);
          return true;
        }
        const response = await this.requestResponse(request, transportMessages_1.SessionRequestSuccessMessage, transportMessages_1.SessionRequestFailureMessage, cancellation);
        return response instanceof transportMessages_1.SessionRequestSuccessMessage;
      }
      /**
       * Sends a session request and waits for a specific type of success or failure message.
       *
       * @returns The success or failure response message.
       */
      async requestResponse(request, successType, failureType, cancellation) {
        if (!request)
          throw new TypeError("Request is required.");
        if (!successType)
          throw new TypeError("Success response type is required.");
        if (!failureType)
          throw new TypeError("Failure response type is required.");
        request.wantReply = true;
        const requestHandler = (err, result) => {
          var _a, _b;
          if (err) {
            requestCompletionSource.reject(err);
          } else if (requestHandler.isCancelled) {
            return;
          } else if (result instanceof transportMessages_1.SessionRequestFailureMessage) {
            const failure = (_a = result === null || result === void 0 ? void 0 : result.convertTo(new failureType(), true)) !== null && _a !== void 0 ? _a : null;
            requestCompletionSource.resolve(failure);
          } else if (result instanceof transportMessages_1.SessionRequestSuccessMessage) {
            const success = (_b = result === null || result === void 0 ? void 0 : result.convertTo(new successType(), true)) !== null && _b !== void 0 ? _b : null;
            requestCompletionSource.resolve(success);
          } else {
            requestCompletionSource.reject(new Error("Unknown response message type."));
          }
        };
        const requestCompletionSource = new promiseCompletionSource_1.PromiseCompletionSource();
        if (cancellation) {
          if (cancellation.isCancellationRequested)
            throw new cancellation_1.CancellationError();
          cancellation.onCancellationRequested(() => {
            requestHandler.isCancelled = true;
            requestCompletionSource.reject(new cancellation_1.CancellationError());
          });
        }
        this.requestHandlers.enqueue(requestHandler);
        await this.sendMessage(request, cancellation);
        return await requestCompletionSource.promise;
      }
      handleRequestSuccessMessage(message) {
        this.invokeRequestHandler(message, void 0, void 0);
      }
      handleRequestFailureMessage(message) {
        this.invokeRequestHandler(void 0, message, void 0);
      }
      invokeRequestHandler(success, failure, error) {
        let requestHandler;
        while (requestHandler = this.requestHandlers.dequeue()) {
          requestHandler(error, success !== null && success !== void 0 ? success : failure);
          if (!error) {
            break;
          }
        }
      }
      async acceptChannel(channelTypeOrCancellation, cancellation) {
        const channelType = typeof channelTypeOrCancellation === "string" ? channelTypeOrCancellation : void 0;
        if (!cancellation && typeof channelTypeOrCancellation === "object")
          cancellation = channelTypeOrCancellation;
        this.activateService(connectionService_1.ConnectionService);
        const acceptPromise = this.connectionService.acceptChannel(channelType || sshChannel_1.SshChannel.sessionChannelType, cancellation);
        return await acceptPromise;
      }
      async openChannel(channelTypeOrOpenMessageOrCancellation, initialRequestOrCancellation, cancellation) {
        let openMessage;
        if (typeof channelTypeOrOpenMessageOrCancellation === "string" || channelTypeOrOpenMessageOrCancellation === null) {
          openMessage = new connectionMessages_1.ChannelOpenMessage();
          openMessage.channelType = channelTypeOrOpenMessageOrCancellation !== null && channelTypeOrOpenMessageOrCancellation !== void 0 ? channelTypeOrOpenMessageOrCancellation : sshChannel_1.SshChannel.sessionChannelType;
        } else if (channelTypeOrOpenMessageOrCancellation instanceof connectionMessages_1.ChannelOpenMessage) {
          openMessage = channelTypeOrOpenMessageOrCancellation;
        } else {
          openMessage = new connectionMessages_1.ChannelOpenMessage();
          openMessage.channelType = sshChannel_1.SshChannel.sessionChannelType;
          cancellation = channelTypeOrOpenMessageOrCancellation;
        }
        if (initialRequestOrCancellation instanceof connectionMessages_1.ChannelRequestMessage) {
          return await this.openChannelWithInitialRequest(openMessage, initialRequestOrCancellation, cancellation);
        } else if (!cancellation && initialRequestOrCancellation !== null) {
          cancellation = initialRequestOrCancellation;
        }
        this.activateService(connectionService_1.ConnectionService);
        const completionSource = new promiseCompletionSource_1.PromiseCompletionSource();
        await this.connectionService.openChannel(openMessage, completionSource, cancellation);
        return await completionSource.promise;
      }
      async openChannelWithInitialRequest(openMessage, initialRequest, cancellation) {
        var _a;
        this.activateService(connectionService_1.ConnectionService);
        const completionSource = new promiseCompletionSource_1.PromiseCompletionSource();
        const channelId = await this.connectionService.openChannel(openMessage, completionSource, cancellation);
        if (cancellation) {
          if (cancellation.isCancellationRequested)
            throw new cancellation_1.CancellationError();
          cancellation.onCancellationRequested(() => completionSource.reject(new cancellation_1.CancellationError()));
        }
        let channel;
        let requestResult;
        const isExtensionSupported = this.config.protocolExtensions.includes(sshSessionConfiguration_1.SshProtocolExtensionNames.openChannelRequest) && ((_a = this.protocolExtensions) === null || _a === void 0 ? void 0 : _a.has(sshSessionConfiguration_1.SshProtocolExtensionNames.openChannelRequest));
        if (isExtensionSupported === false) {
          channel = await completionSource.promise;
          requestResult = await channel.request(initialRequest, cancellation);
        } else {
          const wantReply = initialRequest.wantReply || isExtensionSupported === void 0;
          const sessionRequest = new transportMessages_1.SessionChannelRequestMessage();
          sessionRequest.requestType = "initial-channel-request@microsoft.com";
          sessionRequest.senderChannel = channelId;
          sessionRequest.request = initialRequest;
          sessionRequest.wantReply = wantReply;
          const requestPromise = this.request(sessionRequest, cancellation);
          channel = await completionSource.promise;
          if (!wantReply) {
            requestResult = true;
          } else {
            requestResult = await requestPromise;
            if (!requestResult && isExtensionSupported === void 0) {
              requestResult = await channel.request(initialRequest);
            }
          }
        }
        if (!requestResult) {
          await channel.close();
          throw new Error("The initial channel request was denied.");
        }
        return channel;
      }
      /* @internal */
      async handleChannelOpening(args, cancellation, resolveService = true) {
        if (resolveService) {
          const serviceType = (0, serviceActivation_1.findService)(this.config.services, (a) => a.channelType === args.channel.channelType && !a.channelRequest);
          if (serviceType) {
            const service = this.activateService(serviceType);
            await service.onChannelOpening(args, cancellation);
            return;
          }
        }
        args.cancellation = cancellation !== null && cancellation !== void 0 ? cancellation : vscode_jsonrpc_1.CancellationToken.None;
        this.channelOpeningEmitter.fire(args);
      }
      /* @internal */
      async sendExtensionInfo(cancellation) {
        if (!this.protocol)
          return;
        const message = new transportMessages_1.ExtensionInfoMessage();
        message.extensionInfo = {};
        for (const extensionName of this.config.protocolExtensions) {
          if (extensionName === sshSessionConfiguration_1.SshProtocolExtensionNames.serverSignatureAlgorithms) {
            const publicKeyAlgorithms = Array.from(new Set((0, sshAlgorithms_1.algorithmNames)(this.config.publicKeyAlgorithms))).join(",");
            message.extensionInfo[extensionName] = publicKeyAlgorithms;
          } else {
            message.extensionInfo[extensionName] = "";
          }
        }
        await this.protocol.sendMessage(message, cancellation);
      }
      async handleExtensionInfoMessage(message, cancellation) {
        if (!this.protocol) {
          return;
        }
        this.protocol.extensions = /* @__PURE__ */ new Map();
        const proposedExtensions = message.extensionInfo;
        if (!proposedExtensions) {
          return;
        }
        for (const extensionName of this.config.protocolExtensions) {
          const proposedExtension = message.extensionInfo[extensionName];
          if (typeof proposedExtension === "string") {
            this.protocol.extensions.set(extensionName, proposedExtension);
          }
        }
        if (this.protocol.extensions.has(sshSessionConfiguration_1.SshProtocolExtensionNames.sessionReconnect)) {
          await this.enableReconnect(cancellation);
        }
      }
      async close(reason, message, error) {
        var _a, _b, _c;
        if (this.disposed || !this.connected) {
          return;
        }
        this.connected = false;
        this.trace(trace_1.TraceLevel.Info, trace_1.SshTraceEventIds.sessionClosing, `${this} Close(${transportMessages_1.SshDisconnectReason[reason]}, "${message || ""}")`);
        if (reason !== transportMessages_1.SshDisconnectReason.connectionLost) {
          try {
            const disconnectMessage = new transportMessages_1.DisconnectMessage();
            disconnectMessage.reasonCode = reason;
            disconnectMessage.description = message || "";
            await ((_a = this.protocol) === null || _a === void 0 ? void 0 : _a.sendMessage(disconnectMessage));
          } catch (e) {
          }
        } else if (this.handleDisconnected()) {
          (_b = this.protocol) === null || _b === void 0 ? void 0 : _b.dispose();
          this.trace(trace_1.TraceLevel.Info, trace_1.SshTraceEventIds.sessionDisconnected, `${this} disconnected.`);
          this.disconnectedEmitter.fire();
          return;
        }
        this.disposed = true;
        this.closedError = error;
        error = error !== null && error !== void 0 ? error : new errors_1.SshConnectionError(message, reason);
        if (error) {
          (_c = this.connectionService) === null || _c === void 0 ? void 0 : _c.close(error);
        }
        this.closedEmitter.fire(new sshSessionClosedEventArgs_1.SshSessionClosedEventArgs(reason, message || "Disconnected.", error));
        this.dispose();
      }
      /* @internal */
      handleDisconnected() {
        var _a, _b;
        this.connectPromise = void 0;
        (_a = this.kexService) === null || _a === void 0 ? void 0 : _a.abortKeyExchange();
        if (!((_b = this.protocolExtensions) === null || _b === void 0 ? void 0 : _b.has(sshSessionConfiguration_1.SshProtocolExtensionNames.sessionReconnect))) {
          return false;
        }
        return true;
      }
      async handleDisconnectMessage(message) {
        var _a;
        const description = message.description || "Received disconnect message.";
        await this.close((_a = message.reasonCode) !== null && _a !== void 0 ? _a : transportMessages_1.SshDisconnectReason.none, description);
      }
      dispose(error) {
        var _a, _b;
        const closedError = error !== null && error !== void 0 ? error : this.closedError instanceof errors_1.SshConnectionError ? this.closedError : new errors_1.SshConnectionError(this.constructor.name + " disposed.");
        if (!this.disposed) {
          this.trace(trace_1.TraceLevel.Info, trace_1.SshTraceEventIds.sessionClosing, `${this} disposed.`);
          this.disposed = true;
          if (this.keepAliveTimer) {
            clearTimeout(this.keepAliveTimer);
            this.keepAliveTimer = void 0;
          }
          this.closedEmitter.fire(new sshSessionClosedEventArgs_1.SshSessionClosedEventArgs(transportMessages_1.SshDisconnectReason.none, closedError.message, closedError));
        }
        this.invokeRequestHandler(void 0, void 0, closedError);
        this.metrics.close();
        (_a = this.connectionService) === null || _a === void 0 ? void 0 : _a.dispose();
        for (const service of this.activatedServices.values()) {
          if (service !== this.connectionService) {
            service.dispose();
          }
        }
        this.activatedServices.clear();
        (_b = this.protocol) === null || _b === void 0 ? void 0 : _b.dispose();
        this.protocol = void 0;
      }
      /* @internal */
      async enableReconnect(cancellation) {
        var _a;
        try {
          await this.blockedMessagesSemaphore.wait();
          if ((_a = this.kexService) === null || _a === void 0 ? void 0 : _a.exchanging) {
            this.trace(trace_1.TraceLevel.Error, trace_1.SshTraceEventIds.sessionReconnectInitFailed, "Failed to initialize session reconnect because a key-exchange was in-progress.");
          } else {
            const enableReconnectMessage = new transportMessages_1.SessionRequestMessage("enable-session-reconnect@microsoft.com", false);
            await this.protocol.sendMessage(enableReconnectMessage, cancellation);
            if (this.protocol) {
              this.protocol.outgoingMessagesHaveReconnectInfo = true;
              this.protocol.outgoingMessagesHaveLatencyInfo = this.protocol.extensions.has(sshSessionConfiguration_1.SshProtocolExtensionNames.sessionLatency);
            }
          }
          this.blockedMessagesSemaphore.release();
        } catch (e) {
          this.blockedMessagesSemaphore.release();
          if (e instanceof Error) {
            await this.close(transportMessages_1.SshDisconnectReason.protocolError, void 0, e);
          }
          throw e;
        }
      }
      /* @internal */
      async createReconnectToken(previousSessionId, newSessionId) {
        const reconnectToken = await this.algorithms.signer.sign(buffer_1.Buffer.concat([previousSessionId, newSessionId]));
        return reconnectToken;
      }
      /* @internal */
      async verifyReconnectToken(previousSessionId, newSessionId, reconnectToken) {
        const result = await this.algorithms.verifier.verify(buffer_1.Buffer.concat([previousSessionId, newSessionId]), reconnectToken);
        return result;
      }
      /**
       * Pipes one SSH session into another, relaying all data between them.
       *
       * Any new channels opened from the remote side of either session will be piped into a
       * new channel in the other session. Any channels opened before connecting the session pipe,
       * or any channels opened from the local side, will not be piped.
       *
       * @param toSession Session to which the current session will be connected via the pipe.
       * @returns A promise that resolves when the sessions are closed.
       */
      pipe(toSession) {
        return pipeExtensions_1.PipeExtensions.pipeSession(this, toSession);
      }
      toString() {
        return this.constructor.name;
      }
    };
    exports2.SshSession = SshSession;
    SshSession.localVersion = sshVersionInfo_1.SshVersionInfo.getLocalVersion();
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/sshSessionAlgorithms.js
var require_sshSessionAlgorithms = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/sshSessionAlgorithms.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SshSessionAlgorithms = void 0;
    var SshSessionAlgorithms = class {
      dispose() {
        if (this.cipher)
          this.cipher.dispose();
        if (this.decipher)
          this.decipher.dispose();
        if (this.signer)
          this.signer.dispose();
        if (this.verifier)
          this.verifier.dispose();
      }
    };
    exports2.SshSessionAlgorithms = SshSessionAlgorithms;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/services/keyExchangeService.js
var require_keyExchangeService = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/services/keyExchangeService.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var KeyExchangeService_1;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.KeyExchangeService = void 0;
    var buffer_1 = require("buffer");
    var sshSession_1 = require_sshSession();
    var sshService_1 = require_sshService();
    var bigInt_1 = require_bigInt();
    var kexMessages_1 = require_kexMessages();
    var sshAlgorithms_1 = require_sshAlgorithms();
    var sshData_1 = require_sshData();
    var errors_1 = require_errors();
    var transportMessages_1 = require_transportMessages();
    var sshSessionAlgorithms_1 = require_sshSessionAlgorithms();
    var vscode_jsonrpc_1 = require_main();
    var connectionService_1 = require_connectionService();
    var serviceActivation_1 = require_serviceActivation();
    var trace_1 = require_trace();
    var ExchangeContext = class {
    };
    var serverExtensionInfoSignal = "ext-info-s";
    var clientExtensionInfoSignal = "ext-info-c";
    var KeyExchangeService = KeyExchangeService_1 = class KeyExchangeService extends sshService_1.SshService {
      constructor(session) {
        super(session);
        this.isInitialExchange = false;
        this.exchangeContext = null;
      }
      get exchanging() {
        return !!this.exchangeContext;
      }
      async startKeyExchange(isInitialExchange) {
        this.isInitialExchange = isInitialExchange;
        this.exchangeContext = new ExchangeContext();
        const kexInitMessage = this.createKeyExchangeInitMessage();
        let kexGuessMessage = null;
        if (this.session.isClientSession) {
          if (isInitialExchange && this.session.config.enableKeyExchangeGuess) {
            kexGuessMessage = await this.createKeyExchangeGuessMessage();
            kexInitMessage.firstKexPacketFollows = !!kexGuessMessage;
          }
          this.exchangeContext.clientKexInitPayload = kexInitMessage.toBuffer();
        } else {
          this.exchangeContext.serverKexInitPayload = kexInitMessage.toBuffer();
        }
        return [kexInitMessage, kexGuessMessage];
      }
      finishKeyExchange() {
        var _a;
        if (!this.exchangeContext) {
          throw new errors_1.SshConnectionError("Key exchange not started.", transportMessages_1.SshDisconnectReason.protocolError);
        }
        const newAlgorithms = this.exchangeContext.newAlgorithms;
        if (!newAlgorithms) {
          throw new errors_1.SshConnectionError("Key exchange not completed.", transportMessages_1.SshDisconnectReason.protocolError);
        }
        newAlgorithms.isExtensionInfoRequested = (_a = this.exchangeContext) === null || _a === void 0 ? void 0 : _a.isExtensionInfoRequested;
        this.exchangeContext = null;
        return newAlgorithms;
      }
      abortKeyExchange() {
        this.exchangeContext = null;
      }
      createKeyExchangeInitMessage() {
        const extinfo = this.session.isClientSession ? clientExtensionInfoSignal : serverExtensionInfoSignal;
        const config = this.session.config;
        const message = new kexMessages_1.KeyExchangeInitMessage();
        message.keyExchangeAlgorithms = (0, sshAlgorithms_1.algorithmNames)(config.keyExchangeAlgorithms).concat(extinfo);
        message.serverHostKeyAlgorithms = this.getPublicKeyAlgorithms();
        message.encryptionAlgorithmsClientToServer = message.encryptionAlgorithmsServerToClient = (0, sshAlgorithms_1.algorithmNames)(config.encryptionAlgorithms);
        message.macAlgorithmsClientToServer = message.macAlgorithmsServerToClient = (0, sshAlgorithms_1.algorithmNames)(config.hmacAlgorithms);
        message.compressionAlgorithmsClientToServer = message.compressionAlgorithmsServerToClient = (0, sshAlgorithms_1.algorithmNames)(config.compressionAlgorithms);
        message.languagesClientToServer = [""];
        message.languagesServerToClient = [""];
        message.firstKexPacketFollows = false;
        message.reserved = 0;
        return message;
      }
      /**
       * Gets the list of public key algorithms that the current session can support.
       * For a server session the list is filtered based on the available private keys.
       */
      getPublicKeyAlgorithms() {
        var _a, _b;
        let publicKeyAlgorithms = [...this.session.config.publicKeyAlgorithms];
        if (publicKeyAlgorithms.length > 1 && !this.session.isClientSession) {
          const privateKeyAlgorithms = (_b = (_a = this.session.credentials) === null || _a === void 0 ? void 0 : _a.publicKeys) === null || _b === void 0 ? void 0 : _b.map((k) => k.keyAlgorithmName);
          if (privateKeyAlgorithms) {
            publicKeyAlgorithms = publicKeyAlgorithms.filter((a) => a && privateKeyAlgorithms.includes(a.keyAlgorithmName));
          }
        }
        const publicKeyAlgorithmNames = (0, sshAlgorithms_1.algorithmNames)(publicKeyAlgorithms);
        return publicKeyAlgorithmNames;
      }
      async createKeyExchangeGuessMessage() {
        if (!this.exchangeContext) {
          throw new Error("Key exchange was not started.");
        }
        const kexAlgorithm = this.session.config.keyExchangeAlgorithms[0];
        if (!kexAlgorithm) {
          return null;
        }
        this.exchangeContext.keyExchange = kexAlgorithm.name;
        this.exchangeContext.exchange = kexAlgorithm.createKeyExchange();
        this.exchangeContext.exchangeValue = await this.exchangeContext.exchange.startKeyExchange();
        const guess = new kexMessages_1.KeyExchangeDhInitMessage();
        guess.e = this.exchangeContext.exchangeValue;
        return guess;
      }
      handleMessage(message, cancellation) {
        if (message instanceof kexMessages_1.KeyExchangeInitMessage) {
          return this.handleInitMessage(message, cancellation);
        } else if (message instanceof kexMessages_1.KeyExchangeDhInitMessage) {
          return this.handleDhInitMessage(message, cancellation);
        } else if (message instanceof kexMessages_1.KeyExchangeDhReplyMessage) {
          return this.handleDhReplyMessage(message, cancellation);
        } else {
          throw new Error(`Message not implemented: ${message}`);
        }
      }
      async handleInitMessage(message, cancellation) {
        var _a, _b, _c, _d;
        if (!this.exchangeContext) {
          throw new Error("Key exchange was not started.");
        }
        const config = this.session.config;
        this.exchangeContext.keyExchange = this.chooseAlgorithm("KeyExchange", (0, sshAlgorithms_1.algorithmNames)(config.keyExchangeAlgorithms), message.keyExchangeAlgorithms);
        if (this.exchangeContext.keyExchange === "none") {
          this.trace(trace_1.TraceLevel.Info, trace_1.SshTraceEventIds.algorithmNegotiation, "Client and server negotiated no security. Cancelling key-exchange.");
          this.session.activateService(connectionService_1.ConnectionService);
          this.exchangeContext.newAlgorithms = new sshSessionAlgorithms_1.SshSessionAlgorithms();
          await this.session.handleNewKeysMessage(new kexMessages_1.NewKeysMessage(), cancellation);
          return;
        }
        this.exchangeContext.publicKey = this.chooseAlgorithm("PublicKey", this.getPublicKeyAlgorithms(), message.serverHostKeyAlgorithms);
        this.exchangeContext.clientEncryption = this.chooseAlgorithm("ClientEncryption", (0, sshAlgorithms_1.algorithmNames)(config.encryptionAlgorithms), message.encryptionAlgorithmsClientToServer);
        this.exchangeContext.serverEncryption = this.chooseAlgorithm("ServerEncryption", (0, sshAlgorithms_1.algorithmNames)(config.encryptionAlgorithms), message.encryptionAlgorithmsServerToClient);
        this.exchangeContext.clientHmac = this.chooseAlgorithm("ClientHmac", (0, sshAlgorithms_1.algorithmNames)(config.hmacAlgorithms), message.macAlgorithmsClientToServer);
        this.exchangeContext.serverHmac = this.chooseAlgorithm("ServerHmac", (0, sshAlgorithms_1.algorithmNames)(config.hmacAlgorithms), message.macAlgorithmsServerToClient);
        this.exchangeContext.clientCompression = this.chooseAlgorithm("ClientCompression", (0, sshAlgorithms_1.algorithmNames)(config.compressionAlgorithms), message.compressionAlgorithmsClientToServer);
        this.exchangeContext.serverCompression = this.chooseAlgorithm("ServerCompression", (0, sshAlgorithms_1.algorithmNames)(config.compressionAlgorithms), message.compressionAlgorithmsServerToClient);
        if (this.session.isClientSession) {
          this.exchangeContext.serverKexInitPayload = message.toBuffer();
          const alreadySentGuess = !!this.exchangeContext.exchangeValue;
          const negotiatedKexAlgorithmIsPreferred = this.exchangeContext.keyExchange === ((_a = config.keyExchangeAlgorithms[0]) === null || _a === void 0 ? void 0 : _a.name);
          if (!alreadySentGuess || !negotiatedKexAlgorithmIsPreferred) {
            const kexAlgorithm = config.getKeyExchangeAlgorithm(this.exchangeContext.keyExchange);
            this.exchangeContext.exchange = kexAlgorithm.createKeyExchange();
            this.exchangeContext.exchangeValue = await this.exchangeContext.exchange.startKeyExchange();
            const reply = new kexMessages_1.KeyExchangeDhInitMessage();
            reply.e = this.exchangeContext.exchangeValue;
            await this.session.sendMessage(reply, cancellation);
          } else {
            this.trace(trace_1.TraceLevel.Verbose, trace_1.SshTraceEventIds.algorithmNegotiation, "Already sent correct guess for key-exchange init.");
          }
          this.exchangeContext.isExtensionInfoRequested = this.isInitialExchange && ((_b = message.keyExchangeAlgorithms) === null || _b === void 0 ? void 0 : _b.includes(serverExtensionInfoSignal));
        } else {
          if (message.firstKexPacketFollows) {
            const negotiatedKexAlgorithmIsPreferred = this.exchangeContext.keyExchange === ((_c = message.keyExchangeAlgorithms) === null || _c === void 0 ? void 0 : _c[0]);
            const guessResult = negotiatedKexAlgorithmIsPreferred ? "correct" : "incorrect";
            this.trace(trace_1.TraceLevel.Verbose, trace_1.SshTraceEventIds.algorithmNegotiation, `Client's KeyExchange guess was ${guessResult}.`);
            this.exchangeContext.discardGuessedInit = !negotiatedKexAlgorithmIsPreferred;
          }
          this.exchangeContext.clientKexInitPayload = message.toBuffer();
          this.exchangeContext.isExtensionInfoRequested = this.isInitialExchange && ((_d = message.keyExchangeAlgorithms) === null || _d === void 0 ? void 0 : _d.includes(clientExtensionInfoSignal));
        }
      }
      async handleDhInitMessage(message, cancellation) {
        var _a, _b, _c, _d, _e;
        if (this.session.isClientSession) {
          return;
        }
        const serverSession = this.session;
        if (!this.exchangeContext || !this.exchangeContext.keyExchange || !this.exchangeContext.publicKey) {
          throw new errors_1.SshConnectionError("Key exchange not started.", transportMessages_1.SshDisconnectReason.protocolError);
        }
        if (this.exchangeContext.discardGuessedInit) {
          this.exchangeContext.discardGuessedInit = false;
          return;
        }
        const kexAlg = this.session.config.getKeyExchangeAlgorithm(this.exchangeContext.keyExchange);
        if (!kexAlg) {
          throw new errors_1.SshConnectionError("Key exchange not supported for algorithm: " + this.exchangeContext.keyExchange, transportMessages_1.SshDisconnectReason.keyExchangeFailed);
        }
        const publicKeyAlg = this.session.config.getPublicKeyAlgorithm(this.exchangeContext.publicKey);
        if (!publicKeyAlg) {
          throw new errors_1.SshConnectionError("Public key algorithm not supported: " + this.exchangeContext.publicKey, transportMessages_1.SshDisconnectReason.keyExchangeFailed);
        }
        let privateKey = null;
        if ((_a = serverSession.credentials) === null || _a === void 0 ? void 0 : _a.publicKeys) {
          const publicKey = serverSession.credentials.publicKeys.find((k) => k.keyAlgorithmName === publicKeyAlg.keyAlgorithmName);
          privateKey = publicKey !== null && publicKey !== void 0 ? publicKey : null;
          if ((privateKey === null || privateKey === void 0 ? void 0 : privateKey.hasPrivateKey) === false) {
            if (!serverSession.credentials.privateKeyProvider) {
              throw new Error("A private key provider is required.");
            }
            privateKey = await serverSession.credentials.privateKeyProvider(publicKey, cancellation !== null && cancellation !== void 0 ? cancellation : vscode_jsonrpc_1.CancellationToken.None);
          }
        }
        if (privateKey == null) {
          throw new errors_1.SshConnectionError("Private key not found for algorithm: " + this.exchangeContext.publicKey, transportMessages_1.SshDisconnectReason.keyExchangeFailed);
        }
        const clientEncryption = this.session.config.getEncryptionAlgorithm(this.exchangeContext.clientEncryption);
        const serverEncryption = this.session.config.getEncryptionAlgorithm(this.exchangeContext.serverEncryption);
        const serverHmac = this.session.config.getHmacAlgorithm(this.exchangeContext.serverHmac);
        const clientHmac = this.session.config.getHmacAlgorithm(this.exchangeContext.clientHmac);
        const keyExchange = kexAlg.createKeyExchange();
        const clientExchangeValue = message.e || buffer_1.Buffer.alloc(0);
        const serverExchangeValue = await keyExchange.startKeyExchange();
        const sharedSecret = await keyExchange.decryptKeyExchange(clientExchangeValue);
        const hostKeyAndCerts = await privateKey.getPublicKeyBytes(publicKeyAlg.name);
        if (!hostKeyAndCerts) {
          throw new errors_1.SshConnectionError("Public key not set.", transportMessages_1.SshDisconnectReason.keyExchangeFailed);
        }
        const exchangeHash = await this.computeExchangeHash(keyExchange, hostKeyAndCerts, clientExchangeValue, serverExchangeValue, sharedSecret);
        if (!this.session.sessionId) {
          this.session.sessionId = exchangeHash;
        }
        const [clientCipherIV, serverCipherIV, clientCipherKey, serverCipherKey, clientHmacKey, serverHmacKey] = await this.computeKeys(keyExchange, sharedSecret, exchangeHash, clientEncryption, serverEncryption, clientHmac, serverHmac);
        const cipher = (_b = await (serverEncryption === null || serverEncryption === void 0 ? void 0 : serverEncryption.createCipher(true, serverCipherKey, serverCipherIV))) !== null && _b !== void 0 ? _b : null;
        const decipher = (_c = await (clientEncryption === null || clientEncryption === void 0 ? void 0 : clientEncryption.createCipher(false, clientCipherKey, clientCipherIV))) !== null && _c !== void 0 ? _c : null;
        const signer = (_d = await (serverHmac === null || serverHmac === void 0 ? void 0 : serverHmac.createSigner(serverHmacKey))) !== null && _d !== void 0 ? _d : null;
        const verifier = (_e = await (clientHmac === null || clientHmac === void 0 ? void 0 : clientHmac.createVerifier(clientHmacKey))) !== null && _e !== void 0 ? _e : null;
        const algorithms = new sshSessionAlgorithms_1.SshSessionAlgorithms();
        algorithms.publicKeyAlgorithmName = this.exchangeContext.publicKey;
        algorithms.cipher = cipher;
        algorithms.decipher = decipher;
        algorithms.signer = signer;
        algorithms.verifier = verifier;
        algorithms.messageSigner = (cipher === null || cipher === void 0 ? void 0 : cipher.authenticatedEncryption) ? cipher : signer;
        algorithms.messageVerifier = (decipher === null || decipher === void 0 ? void 0 : decipher.authenticatedEncryption) ? decipher : verifier;
        algorithms.compressor = this.session.config.getCompressionAlgorithm(this.exchangeContext.serverCompression);
        algorithms.decompressor = this.session.config.getCompressionAlgorithm(this.exchangeContext.clientCompression);
        this.exchangeContext.newAlgorithms = algorithms;
        if (clientCipherIV)
          clientCipherIV.fill(0);
        if (clientCipherKey)
          clientCipherKey.fill(0);
        if (clientHmacKey)
          clientHmacKey.fill(0);
        if (serverCipherIV)
          serverCipherIV.fill(0);
        if (serverCipherKey)
          serverCipherKey.fill(0);
        if (serverHmacKey)
          serverHmacKey.fill(0);
        const exchangeSigner = publicKeyAlg.createSigner(privateKey);
        let signature = await exchangeSigner.sign(exchangeHash);
        signature = publicKeyAlg.createSignatureData(signature);
        const reply = new kexMessages_1.KeyExchangeDhReplyMessage();
        reply.hostKey = hostKeyAndCerts;
        reply.f = serverExchangeValue;
        reply.signature = signature;
        await this.session.sendMessage(reply, cancellation);
        await this.session.sendMessage(new kexMessages_1.NewKeysMessage(), cancellation);
      }
      async handleDhReplyMessage(message, cancellation) {
        var _a, _b, _c, _d;
        if (!this.session.isClientSession) {
          return;
        }
        if (!this.exchangeContext) {
          throw new errors_1.SshConnectionError("Key exchange was not started.", transportMessages_1.SshDisconnectReason.protocolError);
        }
        const config = this.session.config;
        const keyExchange = this.exchangeContext.exchange;
        const publicKeyAlgorithmName = this.exchangeContext.publicKey;
        const publicKeyAlg = config.getPublicKeyAlgorithm(publicKeyAlgorithmName);
        const clientEncryption = config.getEncryptionAlgorithm(this.exchangeContext.clientEncryption);
        const serverEncryption = config.getEncryptionAlgorithm(this.exchangeContext.serverEncryption);
        const serverHmac = config.getHmacAlgorithm(this.exchangeContext.serverHmac);
        const clientHmac = config.getHmacAlgorithm(this.exchangeContext.clientHmac);
        const clientExchangeValue = this.exchangeContext.exchangeValue;
        const serverExchangeValue = message.f;
        if (!keyExchange || !clientExchangeValue) {
          throw new errors_1.SshConnectionError("Failed to initialize crypto after key exchange.", transportMessages_1.SshDisconnectReason.keyExchangeFailed);
        }
        this.hostKey = publicKeyAlg.createKeyPair();
        await this.hostKey.setPublicKeyBytes(message.hostKey);
        const sharedSecret = await keyExchange.decryptKeyExchange(serverExchangeValue);
        const hostKeyAndCerts = message.hostKey;
        const exchangeHash = await this.computeExchangeHash(keyExchange, hostKeyAndCerts, clientExchangeValue, serverExchangeValue, sharedSecret);
        const signature = publicKeyAlg.readSignatureData(message.signature);
        const exchangeVerifier = publicKeyAlg.createVerifier(this.hostKey);
        let verified;
        try {
          verified = await exchangeVerifier.verify(exchangeHash, signature);
        } catch (e) {
          if (!(e instanceof Error))
            throw e;
          this.trace(trace_1.TraceLevel.Error, trace_1.SshTraceEventIds.serverAuthenticationFailed, `Server public key verification error: ${e.message}`, e);
          throw new errors_1.SshConnectionError(`Server public key verification failed: ${e.message}`, transportMessages_1.SshDisconnectReason.hostKeyNotVerifiable);
        }
        if (verified) {
          this.trace(trace_1.TraceLevel.Verbose, trace_1.SshTraceEventIds.sessionAuthenticated, "Server public key verification succeeded.");
        } else {
          this.trace(trace_1.TraceLevel.Warning, trace_1.SshTraceEventIds.serverAuthenticationFailed, "Server public key verification failed.");
          throw new errors_1.SshConnectionError("Server public key verification failed.", transportMessages_1.SshDisconnectReason.hostKeyNotVerifiable);
        }
        if (this.session.sessionId == null) {
          this.session.sessionId = exchangeHash;
        }
        const [clientCipherIV, serverCipherIV, clientCipherKey, serverCipherKey, clientHmacKey, serverHmacKey] = await this.computeKeys(keyExchange, sharedSecret, exchangeHash, clientEncryption, serverEncryption, clientHmac, serverHmac);
        const cipher = (_a = await (clientEncryption === null || clientEncryption === void 0 ? void 0 : clientEncryption.createCipher(true, clientCipherKey, clientCipherIV))) !== null && _a !== void 0 ? _a : null;
        const decipher = (_b = await (serverEncryption === null || serverEncryption === void 0 ? void 0 : serverEncryption.createCipher(false, serverCipherKey, serverCipherIV))) !== null && _b !== void 0 ? _b : null;
        const signer = (_c = await (clientHmac === null || clientHmac === void 0 ? void 0 : clientHmac.createSigner(clientHmacKey))) !== null && _c !== void 0 ? _c : null;
        const verifier = (_d = await (serverHmac === null || serverHmac === void 0 ? void 0 : serverHmac.createVerifier(serverHmacKey))) !== null && _d !== void 0 ? _d : null;
        const algorithms = new sshSessionAlgorithms_1.SshSessionAlgorithms();
        algorithms.publicKeyAlgorithmName = publicKeyAlgorithmName;
        algorithms.cipher = cipher;
        algorithms.decipher = decipher;
        algorithms.signer = signer;
        algorithms.verifier = verifier;
        algorithms.messageSigner = (cipher === null || cipher === void 0 ? void 0 : cipher.authenticatedEncryption) ? cipher : signer;
        algorithms.messageVerifier = (decipher === null || decipher === void 0 ? void 0 : decipher.authenticatedEncryption) ? decipher : verifier;
        algorithms.compressor = config.getCompressionAlgorithm(this.exchangeContext.clientCompression);
        algorithms.decompressor = config.getCompressionAlgorithm(this.exchangeContext.serverCompression);
        this.exchangeContext.newAlgorithms = algorithms;
        if (clientCipherIV)
          clientCipherIV.fill(0);
        if (clientCipherKey)
          clientCipherKey.fill(0);
        if (clientHmacKey)
          clientHmacKey.fill(0);
        if (serverCipherIV)
          serverCipherIV.fill(0);
        if (serverCipherKey)
          serverCipherKey.fill(0);
        if (serverHmacKey)
          serverHmacKey.fill(0);
        await this.session.sendMessage(new kexMessages_1.NewKeysMessage(), cancellation);
      }
      chooseAlgorithm(label, localAlgorithms, remoteAlgorithms) {
        let serverAlgorithms;
        let clientAlgorithms;
        if (this.session.isClientSession) {
          serverAlgorithms = remoteAlgorithms || [];
          clientAlgorithms = localAlgorithms;
        } else {
          serverAlgorithms = localAlgorithms;
          clientAlgorithms = remoteAlgorithms || [];
        }
        const negotiationDetail = `${label} negotiation: Server (${serverAlgorithms.join(", ")}) Client (${clientAlgorithms.join(", ")})`;
        for (const client of clientAlgorithms) {
          for (const server of serverAlgorithms) {
            if (server === client) {
              const result = server;
              this.trace(trace_1.TraceLevel.Info, trace_1.SshTraceEventIds.algorithmNegotiation, `${negotiationDetail} => ${result}`);
              return result;
            }
          }
        }
        throw new Error(`Failed ${negotiationDetail}`);
      }
      async computeExchangeHash(kex, hostKeyAndCerts, clientExchangeValue, serverExchangeValue, sharedSecret) {
        if (!this.session.remoteVersion) {
          throw new Error("Key exchange not completed.");
        }
        const writer = new sshData_1.SshDataWriter(buffer_1.Buffer.alloc(2048));
        if (this.session.isClientSession) {
          writer.writeString(sshSession_1.SshSession.localVersion.toString(), "ascii");
          writer.writeString(this.session.remoteVersion.toString(), "ascii");
        } else {
          writer.writeString(this.session.remoteVersion.toString(), "ascii");
          writer.writeString(sshSession_1.SshSession.localVersion.toString(), "ascii");
        }
        writer.writeBinary(this.exchangeContext.clientKexInitPayload);
        writer.writeBinary(this.exchangeContext.serverKexInitPayload);
        writer.writeBinary(hostKeyAndCerts);
        writer.writeBigInt(bigInt_1.BigInt.fromBytes(clientExchangeValue, { unsigned: true }));
        writer.writeBigInt(bigInt_1.BigInt.fromBytes(serverExchangeValue, { unsigned: true }));
        writer.writeBigInt(bigInt_1.BigInt.fromBytes(sharedSecret, { unsigned: true }));
        const hash = await kex.sign(writer.toBuffer());
        return hash;
      }
      async computeKeys(keyExchange, sharedSecret, exchangeHash, clientEncryption, serverEncryption, clientHmac, serverHmac) {
        var _a, _b;
        const writer = new sshData_1.SshDataWriter(buffer_1.Buffer.alloc(4 + sharedSecret.length + exchangeHash.length + Math.max(1 + ((_b = (_a = this.session.sessionId) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0), keyExchange.digestLength)));
        writer.writeBinary(sharedSecret);
        writer.write(exchangeHash);
        const offset = writer.position;
        const clientCipherIV = clientEncryption && await this.computeKey(keyExchange, writer, offset, clientEncryption.blockLength, "A");
        const serverCipherIV = serverEncryption && await this.computeKey(keyExchange, writer, offset, serverEncryption.blockLength, "B");
        const clientCipherKey = clientEncryption && await this.computeKey(keyExchange, writer, offset, clientEncryption.keyLength, "C");
        const serverCipherKey = serverEncryption && await this.computeKey(keyExchange, writer, offset, serverEncryption.keyLength, "D");
        const clientHmacKey = clientHmac && await this.computeKey(keyExchange, writer, offset, clientHmac.keyLength, "E");
        const serverHmacKey = serverHmac && await this.computeKey(keyExchange, writer, offset, serverHmac.keyLength, "F");
        return [
          clientCipherIV,
          serverCipherIV,
          clientCipherKey,
          serverCipherKey,
          clientHmacKey,
          serverHmacKey
        ];
      }
      async computeKey(keyExchange, writer, writerOffset, blockSize, letter) {
        const keyBuffer = buffer_1.Buffer.alloc(blockSize);
        let keyBufferIndex = 0;
        let currentHashLength = 0;
        let currentHash = null;
        if (!this.session.sessionId) {
          throw new Error("Session ID not set.");
        }
        while (keyBufferIndex < blockSize) {
          writer.position = writerOffset;
          if (!currentHash) {
            writer.writeByte(letter.charCodeAt(0));
            writer.write(this.session.sessionId);
          } else {
            writer.write(currentHash);
          }
          currentHash = await keyExchange.sign(writer.toBuffer());
          currentHashLength = Math.min(currentHash.length, blockSize - keyBufferIndex);
          currentHash.copy(keyBuffer, keyBufferIndex);
          keyBufferIndex += currentHashLength;
        }
        if (currentHash) {
          currentHash.fill(0);
        }
        return keyBuffer;
      }
    };
    KeyExchangeService.serviceName = "ssh-keyexchange";
    KeyExchangeService = KeyExchangeService_1 = __decorate([
      (0, serviceActivation_1.serviceActivation)({ serviceRequest: KeyExchangeService_1.serviceName })
    ], KeyExchangeService);
    exports2.KeyExchangeService = KeyExchangeService;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/sshSessionConfiguration.js
var require_sshSessionConfiguration = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/sshSessionConfiguration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SshSessionConfiguration = exports2.SshProtocolExtensionNames = void 0;
    var vscode_jsonrpc_1 = require_main();
    var sshAlgorithms_1 = require_sshAlgorithms();
    var keyExchangeService_1 = require_keyExchangeService();
    var connectionService_1 = require_connectionService();
    var authenticationService_1 = require_authenticationService();
    var sshMessage_1 = require_sshMessage();
    var SshProtocolExtensionNames;
    (function(SshProtocolExtensionNames2) {
      SshProtocolExtensionNames2["serverSignatureAlgorithms"] = "server-sig-algs";
      SshProtocolExtensionNames2["openChannelRequest"] = "open-channel-request@microsoft.com";
      SshProtocolExtensionNames2["sessionReconnect"] = "session-reconnect@microsoft.com";
      SshProtocolExtensionNames2["sessionLatency"] = "session-latency@microsoft.com";
    })(SshProtocolExtensionNames = exports2.SshProtocolExtensionNames || (exports2.SshProtocolExtensionNames = {}));
    var SshSessionConfiguration = class {
      constructor(useSecurity = true) {
        this.protocolExtensions = [];
        this.services = /* @__PURE__ */ new Map();
        this.authenticationMethods = [];
        this.messages = /* @__PURE__ */ new Map();
        this.contextualMessages = /* @__PURE__ */ new Map();
        this.keyExchangeAlgorithms = [];
        this.publicKeyAlgorithms = [];
        this.encryptionAlgorithms = [];
        this.hmacAlgorithms = [];
        this.compressionAlgorithms = [];
        this.traceChannelDataValue = false;
        this.configurationChangedEmitter = new vscode_jsonrpc_1.Emitter();
        this.onConfigurationChanged = this.configurationChangedEmitter.event;
        this.maxClientAuthenticationAttempts = 5;
        this.enableKeyExchangeGuess = false;
        this.keepAliveTimeoutInSecondsValue = 0;
        this.keyRotationThreshold = 512 * 1024 * 1024;
        this.protocolExtensions.push(SshProtocolExtensionNames.serverSignatureAlgorithms);
        this.protocolExtensions.push(SshProtocolExtensionNames.openChannelRequest);
        this.services.set(keyExchangeService_1.KeyExchangeService, null);
        this.services.set(connectionService_1.ConnectionService, null);
        this.services.set(authenticationService_1.AuthenticationService, null);
        this.authenticationMethods.push(
          "none",
          "password",
          "publickey",
          "keyboard-interactive"
          /* AuthenticationMethod.keyboardInteractive */
        );
        for (const [messageKey, messageType] of sshMessage_1.SshMessage.index) {
          if (typeof messageKey === "number") {
            this.messages.set(messageKey, messageType);
          } else {
            const [messageNumber, messageContext] = messageKey;
            let contextMessageTypes = this.contextualMessages.get(messageContext);
            if (!contextMessageTypes) {
              contextMessageTypes = /* @__PURE__ */ new Map();
              this.contextualMessages.set(messageContext, contextMessageTypes);
            }
            contextMessageTypes.set(messageNumber, messageType);
          }
        }
        if (useSecurity) {
          this.keyExchangeAlgorithms.push(sshAlgorithms_1.SshAlgorithms.keyExchange.ecdhNistp384Sha384);
          this.keyExchangeAlgorithms.push(sshAlgorithms_1.SshAlgorithms.keyExchange.ecdhNistp256Sha256);
          this.keyExchangeAlgorithms.push(sshAlgorithms_1.SshAlgorithms.keyExchange.dhGroup16Sha512);
          this.keyExchangeAlgorithms.push(sshAlgorithms_1.SshAlgorithms.keyExchange.dhGroup14Sha256);
          this.publicKeyAlgorithms.push(sshAlgorithms_1.SshAlgorithms.publicKey.rsaWithSha512);
          this.publicKeyAlgorithms.push(sshAlgorithms_1.SshAlgorithms.publicKey.rsaWithSha256);
          this.publicKeyAlgorithms.push(sshAlgorithms_1.SshAlgorithms.publicKey.ecdsaSha2Nistp384);
          this.publicKeyAlgorithms.push(sshAlgorithms_1.SshAlgorithms.publicKey.ecdsaSha2Nistp256);
          this.encryptionAlgorithms.push(sshAlgorithms_1.SshAlgorithms.encryption.aes256Gcm);
          this.encryptionAlgorithms.push(sshAlgorithms_1.SshAlgorithms.encryption.aes256Ctr);
          this.hmacAlgorithms.push(sshAlgorithms_1.SshAlgorithms.hmac.hmacSha512Etm);
          this.hmacAlgorithms.push(sshAlgorithms_1.SshAlgorithms.hmac.hmacSha256Etm);
          this.hmacAlgorithms.push(sshAlgorithms_1.SshAlgorithms.hmac.hmacSha512);
          this.hmacAlgorithms.push(sshAlgorithms_1.SshAlgorithms.hmac.hmacSha256);
        } else {
          this.keyExchangeAlgorithms.push(sshAlgorithms_1.SshAlgorithms.keyExchange.none);
          this.publicKeyAlgorithms.push(sshAlgorithms_1.SshAlgorithms.publicKey.none);
          this.encryptionAlgorithms.push(sshAlgorithms_1.SshAlgorithms.encryption.none);
          this.hmacAlgorithms.push(sshAlgorithms_1.SshAlgorithms.hmac.none);
        }
        this.compressionAlgorithms.push(sshAlgorithms_1.SshAlgorithms.compression.none);
      }
      /**
       * Adds a service to the configuration.
       */
      addService(serviceType, serviceConfig) {
        if (this.services.has(serviceType)) {
          throw new Error("Duplicate service entry.");
        }
        this.services.set(serviceType, serviceConfig);
      }
      getKeyExchangeAlgorithm(name) {
        return this.getAlgorithm(name, this.keyExchangeAlgorithms);
      }
      getPublicKeyAlgorithm(name) {
        return this.getAlgorithm(name, this.publicKeyAlgorithms);
      }
      getEncryptionAlgorithm(name) {
        return this.getAlgorithm(name, this.encryptionAlgorithms);
      }
      getHmacAlgorithm(name) {
        return this.getAlgorithm(name, this.hmacAlgorithms);
      }
      getCompressionAlgorithm(name) {
        return this.getAlgorithm(name, this.compressionAlgorithms);
      }
      getAlgorithm(name, collection) {
        const algorithm = collection.find((a) => a ? a.name === name : false);
        if (!algorithm) {
          if (name === "none") {
            return null;
          }
          throw new Error("Algorithm not found: " + name);
        }
        return algorithm;
      }
      get traceChannelData() {
        return this.traceChannelDataValue;
      }
      /**
       * Enables tracing of all channel data messages.
       *
       * Unlike other configuration, this option may be adjusted any time while the session
       * is active. Channel data tracing produces a large volume of trace events, so it is
       * primarily meant only for debugging.
       */
      set traceChannelData(value) {
        if (value !== this.traceChannelDataValue) {
          this.traceChannelDataValue = value;
          this.configurationChangedEmitter.fire();
        }
      }
      get keepAliveTimeoutInSeconds() {
        return this.keepAliveTimeoutInSecondsValue;
      }
      set keepAliveTimeoutInSeconds(value) {
        if (this.keepAliveTimeoutInSecondsValue !== value) {
          this.keepAliveTimeoutInSecondsValue = value;
          this.configurationChangedEmitter.fire();
        }
      }
    };
    exports2.SshSessionConfiguration = SshSessionConfiguration;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/sshClientSession.js
var require_sshClientSession = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/sshClientSession.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SshClientSession = void 0;
    var sshSession_1 = require_sshSession();
    var transportMessages_1 = require_transportMessages();
    var sshAuthenticatingEventArgs_1 = require_sshAuthenticatingEventArgs();
    var promiseCompletionSource_1 = require_promiseCompletionSource();
    var cancellation_1 = require_cancellation2();
    var sshSessionConfiguration_1 = require_sshSessionConfiguration();
    var authenticationService_1 = require_authenticationService();
    var connectionService_1 = require_connectionService();
    var errors_1 = require_errors();
    var trace_1 = require_trace();
    var SshClientSession = class extends sshSession_1.SshSession {
      constructor(config) {
        super(config, true);
        this.serviceRequests = /* @__PURE__ */ new Map();
        this.clientAuthCompletion = null;
      }
      /**
       * Attempts to authenticate both the server and client.
       *
       * This method must be called only after encrypting the session. It is equivalent
       * to calling both `authenticateServer()` and `authenticateClient()` and waiting on
       * both results.
       *
       * @returns `true` if authentication succeeded, `false` if it failed.
       */
      async authenticate(clientCredentials, cancellation) {
        const serverAuthenticated = await this.authenticateServer(cancellation);
        if (!serverAuthenticated) {
          return false;
        }
        const clientAuthenticated = await this.authenticateClient(clientCredentials, cancellation);
        if (!clientAuthenticated) {
          return false;
        }
        return true;
      }
      /**
       * Triggers server authentication by invoking the `authenticating` event with
       * the verified server host key.
       *
       * This method must be called only after encrypting the session. It does not wait for any
       * further message exchange with the server, since the server host key would have already
       * been obtained during the key-exchange.
       *
       * @returns `true` if authentication succeeded, `false` if it failed.
       */
      async authenticateServer(cancellation) {
        if (!(this.kexService && this.kexService.hostKey)) {
          throw new Error("Encrypt the session before authenticating.");
        }
        try {
          this.principal = await this.raiseAuthenticatingEvent(new sshAuthenticatingEventArgs_1.SshAuthenticatingEventArgs(sshAuthenticatingEventArgs_1.SshAuthenticationType.serverPublicKey, {
            publicKey: this.kexService.hostKey
          }, cancellation));
        } catch (e) {
          if (!(e instanceof Error))
            throw e;
          this.trace(trace_1.TraceLevel.Error, trace_1.SshTraceEventIds.authenticationError, `Error while authenticating server: ${e.message}`, e);
          throw e;
        }
        if (!this.principal) {
          await this.close(transportMessages_1.SshDisconnectReason.hostKeyNotVerifiable, "Server authentication failed.");
          this.trace(trace_1.TraceLevel.Warning, trace_1.SshTraceEventIds.serverAuthenticationFailed, `${this} server authentication failed.`);
          return false;
        }
        this.trace(trace_1.TraceLevel.Info, trace_1.SshTraceEventIds.sessionAuthenticated, `${this} server authenticated.`);
        return true;
      }
      /* @internal */
      authenticateClient(credentials, callbackOrCancellation, cancellation) {
        if (!credentials) {
          throw new TypeError("A credentials object is required.");
        }
        if (typeof callbackOrCancellation === "function") {
          return this.authenticateClientWithCompletion(credentials, callbackOrCancellation, cancellation);
        } else {
          return new Promise((resolve3, reject) => this.authenticateClientWithCompletion(credentials, (err, result) => {
            if (err)
              reject(err);
            else
              resolve3(result);
          }, callbackOrCancellation));
        }
      }
      async authenticateClientWithCompletion(credentials, callback2, cancellation) {
        this.clientAuthCompletion = new promiseCompletionSource_1.PromiseCompletionSource();
        this.clientAuthCompletion.promise.then((result) => callback2(void 0, result), (err) => callback2(err));
        if (cancellation) {
          if (cancellation.isCancellationRequested)
            throw new cancellation_1.CancellationError();
          cancellation.onCancellationRequested((e) => {
            if (this.clientAuthCompletion) {
              this.clientAuthCompletion.reject(new cancellation_1.CancellationError());
            }
          });
        }
        let authService = this.getService(authenticationService_1.AuthenticationService);
        if (!authService) {
          const serviceRequestMessage = new transportMessages_1.ServiceRequestMessage();
          serviceRequestMessage.serviceName = authenticationService_1.AuthenticationService.serviceName;
          await this.sendMessage(serviceRequestMessage, cancellation);
          authService = this.activateService(authenticationService_1.AuthenticationService);
        }
        await authService.authenticateClient(credentials, cancellation);
      }
      /* @internal */
      onAuthenticationComplete(success) {
        if (success) {
          this.trace(trace_1.TraceLevel.Info, trace_1.SshTraceEventIds.sessionAuthenticated, `${this} client authenticated.`);
        } else {
          this.trace(trace_1.TraceLevel.Warning, trace_1.SshTraceEventIds.clientAuthenticationFailed, `${this} client authentication failed.`);
        }
        if (this.clientAuthCompletion) {
          this.clientAuthCompletion.resolve(success);
          this.clientAuthCompletion = null;
        }
      }
      /**
       * Sends a request for a service and waits for a response.
       *
       * @param serviceName Name of the service to be requested.
       * @param cancellation Optional cancellation token.
       * @returns A promise that resolves when the service request has been accepted.
       *
       * If the server does not accept the service request, it will disconnect the session.
       */
      async requestService(serviceName, cancellation) {
        let sendRequest = false;
        let completion = this.serviceRequests.get(serviceName);
        if (!completion) {
          completion = new promiseCompletionSource_1.PromiseCompletionSource();
          this.serviceRequests.set(serviceName, completion);
          sendRequest = true;
        }
        if (sendRequest) {
          const requestMessage = new transportMessages_1.ServiceRequestMessage();
          requestMessage.serviceName = serviceName;
          await this.sendMessage(requestMessage, cancellation);
        }
        await completion.promise;
      }
      /* @internal */
      async handleServiceAcceptMessage(message, cancellation) {
        const completion = this.serviceRequests.get(message.serviceName);
        completion === null || completion === void 0 ? void 0 : completion.resolve(true);
      }
      async openChannel(channelTypeOrOpenMessageOrCancellation, initialRequestOrCancellation, cancellation) {
        if (!this.connectionService) {
          const serviceRequestMessage = new transportMessages_1.ServiceRequestMessage();
          serviceRequestMessage.serviceName = connectionService_1.ConnectionService.serviceName;
          await this.sendMessage(serviceRequestMessage, cancellation);
        }
        return await super.openChannel(channelTypeOrOpenMessageOrCancellation, initialRequestOrCancellation, cancellation);
      }
      /* @internal */
      handleDisconnected() {
        if (this.reconnecting) {
          this.reconnecting = false;
          return false;
        }
        return super.handleDisconnected();
      }
      /**
       * Call instead of `connect()` to reconnect to a prior session instead of connecting
       * a new session.
       * @param stream A new stream that has just (re-) connected to the server.
       * @param cancellation Optional cancellation token.
       * @returns True if reconnect succeeded, false if the server declined the reconnect
       * request or reconnect session validation failed. In the case of a false return value,
       * retrying is unlikely to succeed.
       * @throws {SshConnectionError} There was a problem connecting to or communicating with
       * the server; retrying may still succeed if connectivity is restored.
       * @throws {SshReconnectError} Reconnect failed for some reason other than a communication
       * issue: see the `failureReason` property of the error. Retrying is unlikely to succeed,
       * unless the specific error condition can be addressed.
       */
      async reconnect(stream, cancellation) {
        this.trace(trace_1.TraceLevel.Verbose, trace_1.SshTraceEventIds.clientSessionReconnecting, "Attempting to reconnect...");
        if (this.isClosed) {
          throw new errors_1.ObjectDisposedError(this);
        } else if (this.isConnected) {
          throw new Error("Already connected.");
        }
        if (!this.protocol) {
          throw new Error("The session was never previously connected.");
        }
        if (this.reconnecting) {
          throw new Error("Already reconnecting.");
        }
        this.reconnecting = true;
        try {
          await this.reconnectInternal(stream, cancellation);
        } finally {
          this.reconnecting = false;
        }
      }
      async reconnectInternal(stream, cancellation) {
        var _a, _b, _c, _d, _e, _f;
        const previousSessionId = this.sessionId;
        const previousProtocolInstance = this.protocol;
        const previousHostKey = (_a = this.kexService) === null || _a === void 0 ? void 0 : _a.hostKey;
        if (!previousSessionId || !previousProtocolInstance || !this.kexService || !previousHostKey || !((_b = previousProtocolInstance.extensions) === null || _b === void 0 ? void 0 : _b.has(sshSessionConfiguration_1.SshProtocolExtensionNames.sessionReconnect))) {
          throw new Error("Reconnect was not enabled for this session.");
        }
        let newSessionId;
        try {
          this.sessionId = null;
          await this.connect(stream, cancellation);
          if (!this.sessionId || !this.algorithms || !this.algorithms.signer) {
            throw new Error("Session is not encrypted.");
          }
          const newHostKey = this.kexService.hostKey;
          const newHostPublicKey = !newHostKey ? null : await newHostKey.getPublicKeyBytes();
          const previousHostPublicKey = await previousHostKey.getPublicKeyBytes();
          if (!newHostPublicKey || !previousHostPublicKey || !newHostPublicKey.equals(previousHostPublicKey)) {
            const message = "The server host key is different.";
            this.trace(trace_1.TraceLevel.Error, trace_1.SshTraceEventIds.clientSessionReconnectFailed, `Reconnection failed: ${message}`);
            throw new errors_1.SshReconnectError(message, transportMessages_1.SshReconnectFailureReason.differentServerHostKey);
          }
          newSessionId = this.sessionId;
        } catch (e) {
          this.protocol = previousProtocolInstance;
          super.handleDisconnected();
          throw e;
        } finally {
          this.sessionId = previousSessionId;
          this.kexService.hostKey = previousHostKey;
        }
        const reconnectToken = await this.createReconnectToken(previousSessionId, newSessionId);
        const reconnectRequest = new transportMessages_1.SessionReconnectRequestMessage();
        reconnectRequest.requestType = "session-reconnect@microsoft.com";
        reconnectRequest.clientReconnectToken = reconnectToken;
        reconnectRequest.lastReceivedSequenceNumber = previousProtocolInstance.lastIncomingSequence;
        reconnectRequest.wantReply = true;
        const response = await this.requestResponse(reconnectRequest, transportMessages_1.SessionReconnectResponseMessage, transportMessages_1.SessionReconnectFailureMessage, cancellation);
        if (response instanceof transportMessages_1.SessionReconnectFailureMessage) {
          const reason = (_c = response.reasonCode) !== null && _c !== void 0 ? _c : transportMessages_1.SshReconnectFailureReason.unknownServerFailure;
          const message = (_d = response.description) !== null && _d !== void 0 ? _d : "The server rejected the reconnect request.";
          this.trace(trace_1.TraceLevel.Error, trace_1.SshTraceEventIds.clientSessionReconnectFailed, `Reconnection failed: ${message}`);
          this.protocol = previousProtocolInstance;
          throw new errors_1.SshReconnectError(message, reason);
        }
        if (!this.verifyReconnectToken(previousSessionId, newSessionId, (_e = response.serverReconnectToken) !== null && _e !== void 0 ? _e : Buffer.alloc(0))) {
          const message = "The reconnect token provided by the server was invalid.";
          this.trace(trace_1.TraceLevel.Error, trace_1.SshTraceEventIds.clientSessionReconnectFailed, `Reconnection failed: ${message}`);
          throw new errors_1.SshReconnectError(message, transportMessages_1.SshReconnectFailureReason.invalidServerReconnectToken);
        }
        this.trace(trace_1.TraceLevel.Info, trace_1.SshTraceEventIds.clientSessionReconnecting, "Reconnect request was accepted by the server.");
        const messagesToResend = previousProtocolInstance.getSentMessages(((_f = response.lastReceivedSequenceNumber) !== null && _f !== void 0 ? _f : 0) + 1);
        if (!messagesToResend) {
          const message = "Client is unable to re-send messages requested by the server.";
          this.trace(trace_1.TraceLevel.Error, trace_1.SshTraceEventIds.clientSessionReconnectFailed, `Reconnection failed: ${message}`);
          throw new errors_1.SshReconnectError(message, transportMessages_1.SshReconnectFailureReason.clientDroppedMessages);
        }
        let count = 0;
        for (const message of messagesToResend) {
          await this.sendMessage(message, cancellation);
          count++;
        }
        previousProtocolInstance.dispose();
        this.metrics.addReconnection();
        this.trace(trace_1.TraceLevel.Info, trace_1.SshTraceEventIds.clientSessionReconnecting, `${this} reconnected. Re-sent ${count} dropped messages.`);
      }
      dispose() {
        if (this.clientAuthCompletion) {
          this.clientAuthCompletion.reject(new errors_1.ObjectDisposedError(this));
        }
        super.dispose();
      }
    };
    exports2.SshClientSession = SshClientSession;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/sshServerSession.js
var require_sshServerSession = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/sshServerSession.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SshServerSession = void 0;
    var sshSession_1 = require_sshSession();
    var vscode_jsonrpc_1 = require_main();
    var transportMessages_1 = require_transportMessages();
    var errors_1 = require_errors();
    var sshSessionConfiguration_1 = require_sshSessionConfiguration();
    var trace_1 = require_trace();
    var SshServerSession = class extends sshSession_1.SshSession {
      constructor(config, reconnectableSessions) {
        super(config, false);
        this.clientAuthenticatedEmitter = new vscode_jsonrpc_1.Emitter();
        this.onClientAuthenticated = this.clientAuthenticatedEmitter.event;
        this.reconnectedEmitter = new vscode_jsonrpc_1.Emitter();
        this.onReconnected = this.reconnectedEmitter.event;
        this.credentials = { publicKeys: [] };
        const enableReconnect = config.protocolExtensions.includes(sshSessionConfiguration_1.SshProtocolExtensionNames.sessionReconnect);
        if (enableReconnect && !reconnectableSessions) {
          throw new Error("When reconnect is enabled, server sessions require a reference to a shared collection to track reconnectable sessions.");
        } else if (!enableReconnect && reconnectableSessions) {
          throw new Error("When reconnect is not enabled, the reconnectable sessions collection is not applicable.");
        }
        this.reconnectableSessions = reconnectableSessions;
      }
      /* @internal */
      async handleServiceRequestMessage(message, cancellation) {
        const service = this.activateService(message.serviceName);
        if (service) {
          const acceptMessage = new transportMessages_1.ServiceAcceptMessage();
          acceptMessage.serviceName = message.serviceName;
          await this.sendMessage(acceptMessage, cancellation);
        } else {
          throw new errors_1.SshConnectionError(`Service "${message.serviceName}" not available.`, transportMessages_1.SshDisconnectReason.serviceNotAvailable);
        }
      }
      /* @internal */
      async handleRequestMessage(message, cancellation) {
        var _a;
        if (message.requestType === "session-reconnect@microsoft.com" && ((_a = this.config.protocolExtensions) === null || _a === void 0 ? void 0 : _a.includes(sshSessionConfiguration_1.SshProtocolExtensionNames.sessionReconnect))) {
          const reconnectRequest = message.convertTo(new transportMessages_1.SessionReconnectRequestMessage());
          await this.reconnect(reconnectRequest, cancellation);
          return;
        }
        await super.handleRequestMessage(message, cancellation);
      }
      /* @internal */
      handleClientAuthenticated() {
        this.clientAuthenticatedEmitter.fire();
      }
      /* @internal */
      async enableReconnect(cancellation) {
        await super.enableReconnect(cancellation);
        if (!this.reconnectableSessions.includes(this)) {
          this.reconnectableSessions.push(this);
        }
      }
      /* @internal */
      handleDisconnected() {
        if (this.reconnecting) {
          return true;
        }
        return super.handleDisconnected();
      }
      /**
       * Attempts to reconnect the client to a disconnected server session.
       *
       * If reconnection is successful, the current server session is disposed because the client
       * gets reconnected to a different server session.
       */
      /* @internal */
      async reconnect(reconnectRequest, cancellation) {
        var _a, _b, _c;
        if (!this.reconnectableSessions) {
          throw new Error("Disconnected sessions collection should have been initialized when reconnect is enabled.");
        }
        let reconnectSession;
        for (const reconnectableSession of this.reconnectableSessions) {
          if (reconnectableSession !== this && await this.verifyReconnectToken(reconnectableSession.sessionId, this.sessionId, (_a = reconnectRequest.clientReconnectToken) !== null && _a !== void 0 ? _a : Buffer.alloc(0))) {
            reconnectSession = reconnectableSession;
            this.reconnectableSessions.splice(this.reconnectableSessions.indexOf(reconnectSession), 1);
            break;
          }
        }
        if (!reconnectSession || reconnectSession.isClosed) {
          const message = "Requested reconnect session was not found or the reconnect token provided by the client was invalid.";
          this.trace(trace_1.TraceLevel.Error, trace_1.SshTraceEventIds.serverSessionReconnectFailed, `Reconnect failed: ${message}`);
          const failure = new transportMessages_1.SessionReconnectFailureMessage();
          failure.reasonCode = transportMessages_1.SshReconnectFailureReason.sessionNotFound;
          failure.description = message;
          await this.sendMessage(failure, cancellation);
          return;
        }
        const messagesToResend = reconnectSession.protocol.getSentMessages(((_b = reconnectRequest.lastReceivedSequenceNumber) !== null && _b !== void 0 ? _b : 0) + 1);
        if (!messagesToResend) {
          this.reconnectableSessions.push(reconnectSession);
          const message = "Server is unable to re-send messages requested by the client.";
          this.trace(trace_1.TraceLevel.Error, trace_1.SshTraceEventIds.serverSessionReconnectFailed, `Reconnect failed: ${message}`);
          const failure = new transportMessages_1.SessionReconnectFailureMessage();
          failure.reasonCode = transportMessages_1.SshReconnectFailureReason.serverDroppedMessages;
          failure.description = message;
          await this.sendMessage(failure, cancellation);
          return;
        }
        const responseMessage = new transportMessages_1.SessionReconnectResponseMessage();
        responseMessage.serverReconnectToken = await this.createReconnectToken(reconnectSession.sessionId, this.sessionId);
        responseMessage.lastReceivedSequenceNumber = reconnectSession.protocol.lastIncomingSequence;
        await this.sendMessage(responseMessage, cancellation);
        try {
          reconnectSession.reconnecting = true;
          (_c = reconnectSession.protocol) === null || _c === void 0 ? void 0 : _c.dispose();
          while (reconnectSession.isConnected) {
            await new Promise((resolve3) => setTimeout(() => resolve3(), 5));
          }
          reconnectSession.protocol = this.protocol;
          reconnectSession.protocol.kexService = reconnectSession.kexService;
          this.protocol = void 0;
          for (const message of messagesToResend) {
            await reconnectSession.sendMessage(message, cancellation);
          }
          this.dispose(new errors_1.SshConnectionError("Reconnected.", transportMessages_1.SshDisconnectReason.none));
        } finally {
          reconnectSession.reconnecting = false;
        }
        this.reconnectableSessions.push(reconnectSession);
        reconnectSession.metrics.addReconnection();
        reconnectSession.processMessages().catch((e) => {
          this.trace(trace_1.TraceLevel.Error, trace_1.SshTraceEventIds.unknownError, `Unhandled error processing messages: ${e.message}`, e);
        });
        this.trace(trace_1.TraceLevel.Info, trace_1.SshTraceEventIds.serverSessionReconnecting, `${reconnectSession} reconnected. Re-sent ${messagesToResend.length} dropped messages.`);
        reconnectSession.reconnectedEmitter.fire();
      }
      dispose(error) {
        if (this.reconnectableSessions) {
          const index = this.reconnectableSessions.indexOf(this);
          if (index >= 0) {
            this.reconnectableSessions.splice(index, 1);
          }
        }
        super.dispose(error);
      }
    };
    exports2.SshServerSession = SshServerSession;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/sshStream.js
var require_sshStream = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/sshStream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SshStream = void 0;
    var promiseCompletionSource_1 = require_promiseCompletionSource();
    var stream_1 = require("stream");
    var SshStream = class extends stream_1.Duplex {
      constructor(channel) {
        let readPaused = null;
        super({
          async write(chunk, encoding, cb) {
            let error;
            try {
              let buffer;
              if (typeof chunk === "string") {
                buffer = Buffer.from(chunk, encoding);
              } else if (chunk instanceof Buffer || chunk instanceof Uint8Array) {
                buffer = chunk;
              } else {
                throw new Error("Unsupported chunk type: " + typeof chunk);
              }
              await channel.send(buffer);
            } catch (e) {
              if (!(e instanceof Error))
                throw e;
              error = e;
            }
            if (cb) {
              cb(error);
            }
          },
          async writev(chunks, cb) {
            let error;
            try {
              if (chunks.length === 1) {
                return this.write(chunks[0].chunk, chunks[0].encoding, cb);
              } else {
                let BufferReduce = function(accumulator, chunk) {
                  if (chunk.chunk instanceof Buffer || chunk.chunk instanceof Uint8Array) {
                    return accumulator + chunk.chunk.length;
                  } else {
                    throw new Error("Unsupported chunk type: " + typeof chunk.chunk);
                  }
                };
                const totalLength = chunks.reduce(BufferReduce, 0);
                const singleBuffer = Buffer.alloc(totalLength);
                let singleBufferIndex = 0;
                for (let i = 0; i < chunks.length; i++) {
                  chunks[i].chunk.copy(singleBuffer, singleBufferIndex);
                  singleBufferIndex += chunks[i].chunk.length;
                }
                await channel.send(singleBuffer);
              }
            } catch (e) {
              if (!(e instanceof Error))
                throw e;
              error = e;
            }
            if (cb) {
              cb(error);
            }
          },
          async final(cb) {
            let error;
            try {
              await channel.close();
            } catch (e) {
              if (!(e instanceof Error))
                throw e;
              error = e;
            }
            if (cb) {
              cb(error);
            }
          },
          read() {
            if (readPaused) {
              readPaused.resolve();
              readPaused = null;
            }
          }
        });
        channel.onDataReceived(async (data) => {
          const buffer = Buffer.alloc(data.length);
          data.copy(buffer);
          const result = this.push(buffer);
          if (!result) {
            if (!readPaused) {
              readPaused = new promiseCompletionSource_1.PromiseCompletionSource();
            }
            await readPaused.promise;
          }
          channel.adjustWindow(buffer.length);
        });
        channel.onClosed(() => {
          this.push(null);
        });
        this.channel = channel;
      }
      /**
       * Destroys the stream and closes the underlying SSH channel.
       */
      destroy(error) {
        void this.channel.close().catch();
        super.destroy(error);
        return this;
      }
      toString() {
        return `SshStream(Channel Type: ${this.channel.channelType}, Id: ${this.channel.channelId}, RemoteId: ${this.channel.remoteChannelId})`;
      }
    };
    exports2.SshStream = SshStream;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/streams.js
var require_streams = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/streams.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WebSocketStream = exports2.NodeStream = exports2.BaseStream = void 0;
    var buffer_1 = require("buffer");
    var vscode_jsonrpc_1 = require_main();
    var cancellation_1 = require_cancellation2();
    var errors_1 = require_errors();
    function handleCancellation(reject, cancellation) {
      if (cancellation) {
        if (cancellation.isCancellationRequested) {
          reject(new cancellation_1.CancellationError());
        } else {
          cancellation.onCancellationRequested(() => {
            reject(new cancellation_1.CancellationError());
          });
        }
      }
    }
    var BaseStream = class {
      constructor() {
        this.incomingData = [];
        this.pendingReads = [];
        this.error = null;
        this.disposed = false;
        this.closedEmitter = new vscode_jsonrpc_1.Emitter();
        this.closed = this.closedEmitter.event;
      }
      onData(data) {
        while (this.pendingReads.length > 0) {
          const read = this.pendingReads.shift();
          if (read.count >= data.length) {
            read.resolve(data);
            return;
          } else {
            const readData = data.slice(0, read.count);
            data = data.slice(read.count);
            read.resolve(readData);
          }
        }
        this.incomingData.push(data);
      }
      onEnd() {
        while (this.pendingReads.length > 0) {
          const read = this.pendingReads.shift();
          read.resolve(null);
        }
        this.incomingData.push(buffer_1.Buffer.alloc(0));
      }
      onError(error) {
        if (!this.error) {
          this.error = error;
        }
        while (this.pendingReads.length > 0) {
          const read = this.pendingReads.shift();
          read.reject(error);
        }
      }
      async read(count, cancellation) {
        if (this.disposed)
          throw new errors_1.ObjectDisposedError(this);
        if (this.incomingData.length > 0) {
          let data = this.incomingData[0];
          if (data.length === 0) {
            return null;
          } else if (count >= data.length) {
            this.incomingData.shift();
          } else {
            this.incomingData[0] = data.slice(count);
            data = data.slice(0, count);
          }
          return data;
        } else if (this.error) {
          throw this.error;
        } else {
          return await new Promise((resolve3, reject) => {
            if (cancellation) {
              if (cancellation.isCancellationRequested) {
                reject(new cancellation_1.CancellationError());
                return;
              }
              cancellation.onCancellationRequested(() => {
                for (let i = 0; i < this.pendingReads.length; i++) {
                  if (Object.is(cancellation, this.pendingReads[i].cancellation)) {
                    const read = this.pendingReads.splice(i--, 1)[0];
                    read.reject(new cancellation_1.CancellationError());
                  }
                }
              });
            }
            this.pendingReads.push({ count, resolve: resolve3, reject, cancellation });
          });
        }
      }
      dispose() {
        if (!this.disposed) {
          this.disposed = true;
          const error = new errors_1.ObjectDisposedError(this);
          this.onError(error);
          this.fireOnClose(error);
        }
      }
      fireOnClose(error) {
        this.closedEmitter.fire({ error });
      }
      get isDisposed() {
        return this.disposed;
      }
    };
    exports2.BaseStream = BaseStream;
    var NodeStream = class extends BaseStream {
      constructor(duplexOrReadStream, writeStream) {
        super();
        if (!duplexOrReadStream)
          throw new TypeError("Duplex or Readable/Writable stream are required.");
        this.readStream = duplexOrReadStream;
        this.writeStream = writeStream || duplexOrReadStream;
        this.readStream.on("data", this.onData.bind(this));
        this.readStream.on("end", this.onEnd.bind(this));
        this.readStream.on("error", this.onError.bind(this));
        this.readStream.on("close", () => {
          this.onEnd();
          this.fireOnClose();
        });
      }
      async write(data, cancellation) {
        if (!data)
          throw new TypeError("Data is required.");
        if (this.disposed)
          throw new errors_1.ObjectDisposedError(this);
        return new Promise((resolve3, reject) => {
          handleCancellation(reject, cancellation);
          this.writeStream.write(data, (err) => {
            if (!err) {
              resolve3();
            } else {
              reject(err);
            }
          });
        });
      }
      async close(error, cancellation) {
        if (this.disposed)
          throw new errors_1.ObjectDisposedError(this);
        await new Promise((resolve3, reject) => {
          handleCancellation(reject, cancellation);
          this.writeStream.end(resolve3);
        });
        this.disposed = true;
        this.onError(error || new errors_1.ObjectDisposedError(this));
        this.closedEmitter.fire({ error });
      }
      dispose() {
        if (!this.disposed) {
          const error = new errors_1.ObjectDisposedError(this);
          this.readStream.destroy(error);
          this.writeStream.destroy(error);
        }
        super.dispose();
      }
    };
    exports2.NodeStream = NodeStream;
    var WebSocketStream = class extends BaseStream {
      constructor(websocket) {
        super();
        this.websocket = websocket;
        if (!websocket)
          throw new TypeError("WebSocket is required.");
        if (typeof websocket.binaryType === "string" && websocket.binaryType !== "arraybuffer") {
          throw new Error("WebSocket must use arraybuffer binary type.");
        }
        websocket.onmessage = (e) => {
          this.onData(buffer_1.Buffer.from(e.data));
        };
        websocket.onclose = (e) => {
          if (e.wasClean) {
            this.onEnd();
          } else {
            const error = new Error(e.reason);
            error.code = e.code;
            this.onError(error);
          }
        };
      }
      get protocol() {
        return this.websocket.protocol;
      }
      async write(data, cancellation) {
        if (!data)
          throw new TypeError("Data is required.");
        if (this.disposed)
          throw new errors_1.ObjectDisposedError(this);
        if ("readyState" in this.websocket) {
          if (this.websocket.readyState === 2 || this.websocket.readyState === 3) {
            throw new DOMException("WebSocket is already in CLOSING or CLOSED state.", "InvalidStateError");
          }
        }
        this.websocket.send(data);
      }
      async close(error, cancellation) {
        if (this.disposed)
          throw new errors_1.ObjectDisposedError(this);
        if (!error) {
          this.websocket.close();
        } else {
          const code = typeof error.code === "number" ? error.code : void 0;
          this.websocket.close(code, error.message);
        }
        this.disposed = true;
        this.closedEmitter.fire({ error });
        this.onError(error || new Error("Stream closed."));
      }
      dispose() {
        if (!this.disposed) {
          this.websocket.close();
        }
        super.dispose();
      }
    };
    exports2.WebSocketStream = WebSocketStream;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/sshRpcMessageStream.js
var require_sshRpcMessageStream = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/sshRpcMessageStream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SshRpcMessageStream = void 0;
    var rpc = require_main();
    var buffer_1 = require("buffer");
    var sshData_1 = require_sshData();
    var contentLengthHeaderPrefix = "Content-Length: ";
    var headersSeparator = "\r\n\r\n";
    var SshRpcMessageReader = class {
      constructor(channel) {
        this.channel = channel;
        this.errorEmitter = new rpc.Emitter();
        this.closeEmitter = new rpc.Emitter();
        this.partialMessageEmitter = new rpc.Emitter();
        this.callback = null;
        this.messageBuffer = new sshData_1.SshDataWriter(buffer_1.Buffer.alloc(1024));
        this.headersLength = null;
        this.messageLength = null;
        this.onError = this.errorEmitter.event;
        this.onClose = this.closeEmitter.event;
        this.onPartialMessage = this.partialMessageEmitter.event;
        this.eventRegistration = this.channel.onDataReceived(this.onDataReceived.bind(this));
        this.channel.onClosed((e) => {
          if (e.error) {
            this.errorEmitter.fire(e.error);
          }
          this.closeEmitter.fire();
        });
      }
      listen(callback2) {
        this.callback = callback2;
        return rpc.Disposable.create(() => {
          this.callback = null;
        });
      }
      dispose() {
        if (this.eventRegistration) {
          this.eventRegistration.dispose();
        }
      }
      onDataReceived(data) {
        this.messageBuffer.write(data);
        this.channel.adjustWindow(data.length);
        data = this.messageBuffer.toBuffer();
        if (this.messageLength === null) {
          const headersEnd = data.indexOf(headersSeparator);
          if (headersEnd < 0) {
            return;
          }
          const headers = data.slice(0, headersEnd).toString();
          if (!headers.startsWith(contentLengthHeaderPrefix)) {
            throw new Error(`Message does not start with JSON-RPC headers.
${headers}`);
          }
          this.headersLength = headersEnd + headersSeparator.length;
          this.messageLength = parseInt(headers.substr(contentLengthHeaderPrefix.length, headersEnd - contentLengthHeaderPrefix.length), 10);
        }
        const position = this.messageBuffer.position;
        const totalLength = this.headersLength + this.messageLength;
        if (position >= totalLength) {
          if (this.callback) {
            const messageJson = data.slice(this.headersLength, totalLength).toString();
            let message;
            try {
              message = JSON.parse(messageJson);
            } catch (e) {
              if (!(e instanceof Error))
                throw e;
              throw new Error(`Failed to parse JSON-RPC message: ${e.message}
${messageJson}`);
            }
            this.callback(message);
          }
          this.messageLength = null;
          this.messageBuffer.position = 0;
          if (position > totalLength) {
            this.onDataReceived(data.slice(totalLength));
          }
        }
      }
    };
    var SshRpcMessageWriter = class {
      constructor(channel) {
        this.channel = channel;
        this.errorEmitter = new rpc.Emitter();
        this.closeEmitter = new rpc.Emitter();
        this.onError = this.errorEmitter.event;
        this.onClose = this.closeEmitter.event;
        this.channel.onClosed((e) => {
          if (e.error) {
            this.errorEmitter.fire([
              e.error,
              e.errorMessage && { jsonrpc: e.errorMessage } || void 0,
              e.exitStatus
            ]);
          }
          this.closeEmitter.fire();
        });
      }
      write(message) {
        const messageJson = JSON.stringify(message);
        const messageData = buffer_1.Buffer.from(messageJson);
        const headerData = buffer_1.Buffer.from(contentLengthHeaderPrefix + messageData.length + headersSeparator);
        const data = buffer_1.Buffer.alloc(headerData.length + messageData.length);
        headerData.copy(data, 0);
        messageData.copy(data, headerData.length);
        return this.channel.send(data).catch((e) => {
          this.errorEmitter.fire([e, void 0, void 0]);
        });
      }
      end() {
      }
      dispose() {
      }
    };
    var SshRpcMessageStream = class {
      constructor(channel) {
        this.reader = new SshRpcMessageReader(channel);
        this.writer = new SshRpcMessageWriter(channel);
      }
    };
    exports2.SshRpcMessageStream = SshRpcMessageStream;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/metrics/sessionContour.js
var require_sessionContour = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/metrics/sessionContour.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SessionContour = void 0;
    var errors_1 = require_errors();
    var queue_1 = require_queue();
    var semaphore_1 = require_semaphore();
    var SessionContour = class _SessionContour {
      /**
       * Creates a new instance of the `SessionContour` class.
       *
       * @param maxIntervals Maximum number of metric intervals to record,
       * defaults to 256. Must be a power of two.
       */
      constructor(maxIntervals = 256) {
        this.intervalMs = _SessionContour.initialInterval;
        this.count = 0;
        this.updateQueue = new queue_1.Queue();
        this.updateSemaphore = new semaphore_1.Semaphore(0);
        this.disposed = false;
        if (maxIntervals < 2 || (maxIntervals & maxIntervals - 1) !== 0) {
          throw new Error("Contour intervals must be a power of two.");
        }
        this.maxIntervals = maxIntervals;
        this.intervalBytesSent = new Array(maxIntervals);
        this.intervalBytesReceived = new Array(maxIntervals);
        this.intervalLatencyMin = new Array(maxIntervals);
        this.intervalLatencyMax = new Array(maxIntervals);
        this.intervalLatencySum = new Array(maxIntervals);
        this.intervalLatencyCount = new Array(maxIntervals);
        this.intervalLatencyAvg = new Array(maxIntervals);
        this.intervalBytesSent.fill(0);
        this.intervalBytesReceived.fill(0);
        this.intervalLatencyMin.fill(0);
        this.intervalLatencyMax.fill(0);
        this.intervalLatencySum.fill(0);
        this.intervalLatencyCount.fill(0);
        this.intervalLatencyAvg.fill(0);
      }
      /**
       * Gets the current number of contour intervals with recorded metrics. This is always
       * less than `maxIntervals`.
       */
      get intervalCount() {
        return this.count;
      }
      /**
       * Gets the current time span of each contour interval, in milliseconds. This interval time
       * span is doubled as necesary such that the entire duration of the session is always covered
       * by fewer intervals than the maximum.
       */
      get interval() {
        return this.intervalMs;
      }
      /**
       * Gets the total number of bytes sent for each interval during the session,
       * including all channels and non-channel protocol messages, and including message
       * framing, padding, and MAC bytes. The number of values is equal to `intervalCount`.
       */
      get bytesSent() {
        return this.intervalBytesSent.slice(0, this.count);
      }
      /**
       * Gets the total number of bytes received for each interval during the session,
       * including all channels and non-channel protocol messages, and including message
       * framing, padding, and MAC bytes. The number of values is equal to `intervalCount`.
       */
      get bytesReceived() {
        return this.intervalBytesReceived.slice(0, this.count);
      }
      /**
       * Gets the minimum recorded round-trip connection latency between client and server for
       * each interval during the session. The number of values is equal to `intervalCount`.
       */
      get latencyMinMs() {
        return this.intervalLatencyMin.slice(0, this.count);
      }
      /**
       * Gets the maximum recorded round-trip connection latency between client and server for
       * each interval during the session. The number of values is equal to `intervalCount`.
       */
      get latencyMaxMs() {
        return this.intervalLatencyMax.slice(0, this.count);
      }
      /**
       * Gets the average recorded round-trip connection latency between client and server for
       * each interval during the session. The number of values is equal to `intervalCount`.
       */
      get latencyAverageMs() {
        return this.intervalLatencyAvg.slice(0, this.count);
      }
      onMessageSent(e) {
        this.updateQueue.enqueue({
          time: e.time,
          bytesSent: e.size
        });
        this.updateSemaphore.tryRelease();
      }
      onMessageReceived(e) {
        this.updateQueue.enqueue({
          time: e.time,
          bytesReceived: e.size
        });
        this.updateSemaphore.tryRelease();
      }
      onLatencyUpdated(e) {
        this.updateQueue.enqueue(e);
        this.updateSemaphore.tryRelease();
      }
      onSessionClosed() {
        this.updateSemaphore.tryRelease();
      }
      /**
       * Starts collecting session metrics, and processes the metrics in a backgroud loop until
       * cancelled or until the session is closed or the `SessionContour` instance is disposed.
       */
      async collectMetrics(sessionMetrics, cancellation) {
        if (!sessionMetrics)
          throw new TypeError("A session metrics object is required.");
        if (this.disposed)
          throw new errors_1.ObjectDisposedError(this);
        const eventRegistrations = [];
        eventRegistrations.push(sessionMetrics.onMessageSent(this.onMessageSent.bind(this)));
        eventRegistrations.push(sessionMetrics.onMessageReceived(this.onMessageReceived.bind(this)));
        eventRegistrations.push(sessionMetrics.onLatencyUpdated(this.onLatencyUpdated.bind(this)));
        eventRegistrations.push(sessionMetrics.onSessionClosed(this.onSessionClosed.bind(this)));
        try {
          while (!(cancellation === null || cancellation === void 0 ? void 0 : cancellation.isCancellationRequested)) {
            try {
              await this.updateSemaphore.wait(cancellation);
            } catch (e) {
              break;
            }
            const update = this.updateQueue.dequeue();
            if (!update) {
              break;
            }
            const intervalIndex = this.updateInterval(update.time);
            if (update.bytesSent) {
              this.intervalBytesSent[intervalIndex] += update.bytesSent;
            }
            if (update.bytesReceived) {
              this.intervalBytesReceived[intervalIndex] += update.bytesReceived;
            }
            const latency = update.latency;
            if (latency) {
              if (!this.intervalLatencyMin[intervalIndex] || latency < this.intervalLatencyMin[intervalIndex]) {
                this.intervalLatencyMin[intervalIndex] = latency;
              }
              if (!this.intervalLatencyMax[intervalIndex] || latency > this.intervalLatencyMax[intervalIndex]) {
                this.intervalLatencyMax[intervalIndex] = latency;
              }
              this.intervalLatencySum[intervalIndex] += latency;
              this.intervalLatencyCount[intervalIndex]++;
              this.intervalLatencyAvg[intervalIndex] = this.intervalLatencySum[intervalIndex] / this.intervalLatencyCount[intervalIndex];
            }
          }
          if (this.disposed) {
            this.updateSemaphore.dispose();
          }
        } finally {
          for (const eventRegistration of eventRegistrations) {
            eventRegistration.dispose();
          }
        }
      }
      updateInterval(time) {
        let intervalIndex = Math.floor(time / this.intervalMs);
        if (intervalIndex >= this.intervalCount) {
          while (intervalIndex >= this.maxIntervals) {
            this.expandIntervals();
            intervalIndex = Math.floor(time / this.intervalMs);
          }
          this.count = intervalIndex + 1;
        }
        return intervalIndex;
      }
      expandIntervals() {
        const combineLatency = (a, b, f) => a === 0 ? b : b === 0 ? a : f(a, b);
        const halfMaxIntervals = this.maxIntervals / 2;
        for (let i = 0; i < halfMaxIntervals; i++) {
          const iA = 2 * i;
          const iB = 2 * i + 1;
          this.intervalBytesSent[i] = this.intervalBytesSent[iA] + this.intervalBytesSent[iB];
          this.intervalBytesReceived[i] = this.intervalBytesReceived[iA] + this.intervalBytesReceived[iB];
          this.intervalLatencyMin[i] = combineLatency(this.intervalLatencyMin[iA], this.intervalLatencyMin[iB], Math.min);
          this.intervalLatencyMax[i] = combineLatency(this.intervalLatencyMax[iA], this.intervalLatencyMax[iB], Math.max);
          this.intervalLatencySum[i] = this.intervalLatencySum[iA] + this.intervalLatencySum[iB];
          const countSum = this.intervalLatencyCount[iA] + this.intervalLatencyCount[iB];
          this.intervalLatencyCount[i] = countSum;
          this.intervalLatencyAvg[i] = countSum === 0 ? 0 : this.intervalLatencySum[i] / this.intervalLatencyCount[i];
        }
        this.intervalBytesSent.fill(0, halfMaxIntervals, this.maxIntervals);
        this.intervalBytesReceived.fill(0, halfMaxIntervals, this.maxIntervals);
        this.intervalLatencyMin.fill(0, halfMaxIntervals, this.maxIntervals);
        this.intervalLatencyMax.fill(0, halfMaxIntervals, this.maxIntervals);
        this.intervalLatencySum.fill(0, halfMaxIntervals, this.maxIntervals);
        this.intervalLatencyCount.fill(0, halfMaxIntervals, this.maxIntervals);
        this.intervalLatencyAvg.fill(0, halfMaxIntervals, this.maxIntervals);
        this.intervalMs *= 2;
      }
      dispose() {
        this.disposed = true;
        this.updateSemaphore.tryRelease();
      }
      /**
       * Serializes the session contour into a compact form suitable for recording in
       * logs or telemetry.
       *
       * This compact serialization format uses one byte per metric per interval, so there is
       * some loss of precision, but generally not so much that it affects a visualization. A
       * scale factor for each metric is automatically determined and included in the serialized
       * header. The size of the serialized encoded data will be a little under 7 bytes per
       * interval. With the default interval maximum (256), that comes out to less than 1.75 KB.
       *
       * Use the code in `SessionContour.kql` to decode and chart this output in
       * Azure Data Explorer.
       */
      export() {
        const getScale = (values) => Math.max(0, Math.ceil(Math.log2(Math.max(...values) / 255)));
        const applyReverseScale = (value, scale) => Math.round(value / Math.pow(2, scale));
        const bytes = Buffer.alloc(3 + (2 + this.intervalCount) * 5);
        const version = 1;
        const timeScale = Math.log2(this.interval / _SessionContour.initialInterval);
        bytes[0] = version;
        bytes[1] = 5;
        bytes[2] = timeScale;
        bytes[3] = getScale(this.latencyMinMs);
        bytes[4] = getScale(this.latencyMaxMs);
        bytes[5] = getScale(this.latencyAverageMs);
        bytes[6] = getScale(this.bytesSent);
        bytes[7] = getScale(this.bytesReceived);
        bytes[8] = SessionMetric.latencyMin;
        bytes[9] = SessionMetric.latencyMax;
        bytes[10] = SessionMetric.latencyAverage;
        bytes[11] = SessionMetric.bytesSent;
        bytes[12] = SessionMetric.bytesReceived;
        for (let i = 0; i < this.intervalCount; i++) {
          const offset = 13 + 5 * i;
          bytes[offset + 0] = applyReverseScale(this.intervalLatencyMin[i], bytes[3]);
          bytes[offset + 1] = applyReverseScale(this.intervalLatencyMax[i], bytes[4]);
          bytes[offset + 2] = applyReverseScale(this.intervalLatencyAvg[i], bytes[5]);
          bytes[offset + 3] = applyReverseScale(this.intervalBytesSent[i], bytes[6]);
          bytes[offset + 4] = applyReverseScale(this.intervalBytesReceived[i], bytes[7]);
        }
        return bytes.toString("base64");
      }
      /**
       * Deserializes a session contour that was previously exported.
       *
       * Due to loss in precision, some values in the deserialized contour will not exactly match
       * the original, but they will be close.
       */
      static import(contourBase64) {
        const bytes = Buffer.from(contourBase64, "base64");
        if (bytes.length < 3) {
          throw new Error("Invalid session contour string.");
        }
        const version = bytes[0];
        const metricsPerInterval = bytes[1];
        const timeScale = bytes[2];
        if (version !== 1) {
          throw new Error(`Unsupported session contour version: ${version}`);
        }
        const intervalCount = (bytes.length - 3) / metricsPerInterval - 2;
        if (intervalCount < 1 || bytes.length !== 3 + metricsPerInterval * (intervalCount + 2)) {
          throw new Error("Incomplete session contour string.");
        }
        const maxIntervals = Math.pow(2, Math.ceil(Math.log2(intervalCount)));
        const sessionContour = new _SessionContour(maxIntervals);
        sessionContour.intervalMs = Math.pow(2, timeScale) * _SessionContour.initialInterval;
        sessionContour.count = intervalCount;
        const scales = new Array(metricsPerInterval);
        for (let m = 0; m < metricsPerInterval; m++) {
          scales[m] = Math.pow(2, bytes[3 + m]);
        }
        const ids = new Array(metricsPerInterval);
        for (let m = 0; m < metricsPerInterval; m++) {
          ids[m] = bytes[3 + metricsPerInterval + m];
        }
        for (let i = 0; i < intervalCount; i++) {
          const offset = 3 + (2 + i) * metricsPerInterval;
          for (let m = 0; m < metricsPerInterval; m++) {
            switch (ids[m]) {
              case SessionMetric.latencyMin:
                sessionContour.intervalLatencyMin[i] = bytes[offset + m] * scales[m];
                break;
              case SessionMetric.latencyMax:
                sessionContour.intervalLatencyMax[i] = bytes[offset + m] * scales[m];
                break;
              case SessionMetric.latencyAverage:
                sessionContour.intervalLatencyAvg[i] = sessionContour.intervalLatencySum[i] = bytes[offset + m] * scales[m];
                sessionContour.intervalLatencyCount[i] = bytes[offset + m] === 0 ? 0 : 1;
                break;
              case SessionMetric.bytesSent:
                sessionContour.intervalBytesSent[i] = bytes[offset + m] * scales[m];
                break;
              case SessionMetric.bytesReceived:
                sessionContour.intervalBytesReceived[i] = bytes[offset + m] * scales[m];
                break;
              default:
                break;
            }
          }
        }
        return sessionContour;
      }
    };
    exports2.SessionContour = SessionContour;
    SessionContour.initialInterval = 1e3;
    var SessionMetric;
    (function(SessionMetric2) {
      SessionMetric2[SessionMetric2["none"] = 0] = "none";
      SessionMetric2[SessionMetric2["latencyMin"] = 1] = "latencyMin";
      SessionMetric2[SessionMetric2["latencyMax"] = 2] = "latencyMax";
      SessionMetric2[SessionMetric2["latencyAverage"] = 3] = "latencyAverage";
      SessionMetric2[SessionMetric2["bytesSent"] = 11] = "bytesSent";
      SessionMetric2[SessionMetric2["bytesReceived"] = 12] = "bytesReceived";
    })(SessionMetric || (SessionMetric = {}));
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/multiChannelStream.js
var require_multiChannelStream = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/multiChannelStream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MultiChannelStream = void 0;
    var vscode_jsonrpc_1 = require_main();
    var sshChannel_1 = require_sshChannel();
    var sshStream_1 = require_sshStream();
    var sshSession_1 = require_sshSession();
    var sshSessionConfiguration_1 = require_sshSessionConfiguration();
    var transportMessages_1 = require_transportMessages();
    var trace_1 = require_trace();
    var connectionMessages_1 = require_connectionMessages();
    var sshReportProgressEventArgs_1 = require_sshReportProgressEventArgs();
    var MultiChannelStream = class {
      /**
       * Creates a new multi-channel stream over an underlying transport stream.
       * @param transportStream Stream that is used to multiplex all the channels.
       */
      constructor(transportStream) {
        this.transportStream = transportStream;
        this.disposed = false;
        this.disposables = [];
        this.reportProgressEmitter = new vscode_jsonrpc_1.Emitter();
        this.onReportProgress = this.reportProgressEmitter.event;
        this.channelMaxWindowSize = sshChannel_1.SshChannel.defaultMaxWindowSize;
        this.closedEmitter = new vscode_jsonrpc_1.Emitter();
        this.onClosed = this.closedEmitter.event;
        this.channelOpeningEmitter = new vscode_jsonrpc_1.Emitter();
        this.onChannelOpening = this.channelOpeningEmitter.event;
        if (!transportStream)
          throw new TypeError("transportStream is required.");
        const noSecurityConfig = new sshSessionConfiguration_1.SshSessionConfiguration(false);
        this.session = new sshSession_1.SshSession(noSecurityConfig);
        this.session.onReportProgress((args) => this.raiseReportProgress(args.progress, args.sessionNumber), this, this.disposables);
        this.session.onClosed(this.onSessionClosed, this, this.disposables);
        this.session.onChannelOpening(this.onSessionChannelOpening, this, this.disposables);
      }
      get trace() {
        return this.session.trace;
      }
      set trace(trace) {
        this.session.trace = trace;
      }
      raiseReportProgress(progress, sessionNumber) {
        const args = new sshReportProgressEventArgs_1.SshReportProgressEventArgs(progress, sessionNumber);
        this.reportProgressEmitter.fire(args);
      }
      get isClosed() {
        return this.disposed || this.session.isClosed;
      }
      /**
       * Initiates the SSH session over the transport stream by exchanging initial messages with the
       * remote peer. Waits for the protocol version exchange and key exchange. Additional message
       * processing is kicked off as a background promise chain.
       * @param cancellation optional cancellation token.
       */
      async connect(cancellation) {
        await this.session.connect(this.transportStream, cancellation);
      }
      /**
       * Asynchronously waits for the other side to open a channel.
       * @param channelType optional channel type
       * @param cancellation optional cancellation token.
       */
      async acceptChannel(channelType, cancellation) {
        await this.session.connect(this.transportStream, cancellation);
        const channel = await this.session.acceptChannel(channelType, cancellation);
        return channel;
      }
      /**
       * Asynchronously waits for the other side to open a channel.
       * @param channelType optional channel type
       * @param cancellation optional cancellation token.
       */
      async acceptStream(channelType, cancellation) {
        return this.createStream(await this.acceptChannel(channelType, cancellation));
      }
      /**
       * Opens a channel and asynchronously waits for the other side to accept it.
       * @param channelType optional channel type
       * @param cancellation optional cancellation token.
       */
      async openChannel(channelType, cancellation) {
        await this.session.connect(this.transportStream, cancellation);
        const openMessage = new connectionMessages_1.ChannelOpenMessage();
        openMessage.channelType = channelType !== null && channelType !== void 0 ? channelType : sshChannel_1.SshChannel.sessionChannelType;
        openMessage.maxWindowSize = this.channelMaxWindowSize;
        const channel = await this.session.openChannel(openMessage, null, cancellation);
        return channel;
      }
      /**
       * Opens a channel and asynchronously waits for the other side to accept it.
       * @param channelType optional channel type
       * @param cancellation optional cancellation token.
       */
      async openStream(channelType, cancellation) {
        return this.createStream(await this.openChannel(channelType, cancellation));
      }
      /**
       * Creates a stream instance for a channel. May be overridden to create a `SshStream` subclass.
       */
      createStream(channel) {
        return new sshStream_1.SshStream(channel);
      }
      /**
       * Connects, waits until the session closes or `cancellation` is cancelled, and then disposes the
       * session and the transport stream.
       * @param cancellation optional cancellation token.
       */
      async connectAndRunUntilClosed(cancellation) {
        const disposables = [];
        const sessionClosedPromise = new Promise((resolve3, reject) => {
          cancellation === null || cancellation === void 0 ? void 0 : cancellation.onCancellationRequested(reject, null, disposables);
          this.session.onClosed(resolve3, null, disposables);
        });
        try {
          await this.connect(cancellation);
          await sessionClosedPromise;
        } finally {
          disposables.forEach((d) => d.dispose());
          await this.close();
        }
      }
      dispose() {
        if (!this.disposed) {
          this.disposed = true;
          this.session.dispose();
          this.unsubscribe();
          try {
            if (this.transportStream)
              this.transportStream.close().catch((e) => {
                this.trace(trace_1.TraceLevel.Error, trace_1.SshTraceEventIds.streamCloseError, `Error closing transport stream: ${e.message}`, e);
              });
          } catch (e) {
            if (!(e instanceof Error))
              throw e;
            this.trace(trace_1.TraceLevel.Error, trace_1.SshTraceEventIds.streamCloseError, `Error closing transport stream: ${e.message}`, e);
          }
        }
      }
      async close() {
        if (!this.disposed) {
          this.disposed = true;
          await this.session.close(transportMessages_1.SshDisconnectReason.none, "SshSession disposed");
          this.session.dispose();
          this.unsubscribe();
          await this.transportStream.close();
        }
      }
      onSessionClosed(e) {
        this.unsubscribe();
        this.closedEmitter.fire(e);
      }
      onSessionChannelOpening(e) {
        if (e.isRemoteRequest) {
          e.channel.maxWindowSize = this.channelMaxWindowSize;
        }
        this.channelOpeningEmitter.fire(e);
      }
      unsubscribe() {
        this.disposables.forEach((d) => d.dispose());
        this.disposables = [];
      }
    };
    exports2.MultiChannelStream = MultiChannelStream;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/secureStream.js
var require_secureStream = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/secureStream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SecureStream = void 0;
    var vscode_jsonrpc_1 = require_main();
    var streams_1 = require_streams();
    var sshStream_1 = require_sshStream();
    var sshSessionConfiguration_1 = require_sshSessionConfiguration();
    var transportMessages_1 = require_transportMessages();
    var trace_1 = require_trace();
    var sshClientSession_1 = require_sshClientSession();
    var sshServerSession_1 = require_sshServerSession();
    var errors_1 = require_errors();
    var stream_1 = require("stream");
    var promiseCompletionSource_1 = require_promiseCompletionSource();
    var SecureStream = class extends stream_1.Duplex {
      /**
       * Creates a new encrypted and authenticated stream over an underlying transport stream.
       * @param transportStream Stream that is used to multiplex all the channels.
       * @param credentials Client or server credentials for authenticating the secure connection.
       * @param reconnectableSessions Optional parameter that enables the stream to be reconnected
       * with a new transport stream after a temporary disconnection. For a stream client it is
       * a boolean value; for a stream server it must be an array.
       */
      constructor(transportStream, credentials, reconnectableSessions) {
        super({
          write(chunk, encoding, cb) {
            this.connectCompletion.promise.then((stream) => {
              if (!stream) {
                cb(new errors_1.ObjectDisposedError("SecureStream"));
              } else {
                stream._write(chunk, encoding, cb);
              }
            }, cb);
          },
          writev(chunks, cb) {
            this.connectCompletion.promise.then((stream) => {
              if (!stream) {
                cb(new errors_1.ObjectDisposedError("SecureStream"));
              } else {
                stream._writev(chunks, cb);
              }
            }, cb);
          },
          final(cb) {
            this.connectCompletion.promise.then((stream) => {
              if (!stream) {
                cb(new errors_1.ObjectDisposedError("SecureStream"));
              } else {
                stream._final(cb);
              }
            }, cb);
          },
          read(size) {
            this.connectCompletion.promise.then((stream) => {
              if (!stream) {
                this.push(null);
              } else {
                stream._read(size);
              }
            }, (e) => {
            });
          }
        });
        this.transportStream = transportStream;
        this.clientCredentials = null;
        this.serverCredentials = null;
        this.connectCompletion = new promiseCompletionSource_1.PromiseCompletionSource();
        this.disposed = false;
        this.disposables = [];
        this.disconnectedEmitter = new vscode_jsonrpc_1.Emitter();
        this.onDisconnected = this.disconnectedEmitter.event;
        this.closedEmitter = new vscode_jsonrpc_1.Emitter();
        this.onClosed = this.closedEmitter.event;
        if (!transportStream)
          throw new TypeError("A transport stream is required.");
        if (!credentials)
          throw new TypeError("Client or server credentials are required.");
        const sessionConfig = new sshSessionConfiguration_1.SshSessionConfiguration(true);
        if (reconnectableSessions) {
          sessionConfig.protocolExtensions.push(sshSessionConfiguration_1.SshProtocolExtensionNames.sessionReconnect);
        }
        if ("username" in credentials) {
          if (typeof reconnectableSessions !== "undefined" && typeof reconnectableSessions !== "boolean") {
            throw new TypeError("SecureStream client reconnectable sessions must be a boolean.");
          }
          this.clientCredentials = credentials;
          this.session = new sshClientSession_1.SshClientSession(sessionConfig);
        } else if (credentials.publicKeys) {
          if (typeof reconnectableSessions !== "undefined" && !Array.isArray(reconnectableSessions)) {
            throw new TypeError("SecureStream server reconnectable sessions must be an array.");
          }
          this.serverCredentials = credentials;
          this.session = new sshServerSession_1.SshServerSession(sessionConfig, reconnectableSessions);
        } else {
          throw new TypeError("Client or server credentials are required.");
        }
        this.session.onDisconnected(this.onSessionDisconnected, this, this.disposables);
        this.session.onClosed(this.onSessionClosed, this, this.disposables);
      }
      get trace() {
        return this.session.trace;
      }
      set trace(trace) {
        this.session.trace = trace;
      }
      get isClosed() {
        return this.disposed || this.session.isClosed;
      }
      onAuthenticating(listener, thisArgs, disposables) {
        return this.session.onAuthenticating(listener, thisArgs, disposables);
      }
      /**
       * Initiates the SSH session over the transport stream by exchanging initial messages with the
       * remote peer. Waits for the protocol version exchange and key exchange. Additional message
       * processing is kicked off as a background promise chain.
       * @param cancellation optional cancellation token.
       */
      async connect(cancellation) {
        let sessionConnected = false;
        try {
          if (this.serverCredentials) {
            const serverSession = this.session;
            serverSession.credentials = this.serverCredentials;
          }
          let stream = this.transportStream;
          if (stream instanceof stream_1.Duplex) {
            stream = new streams_1.NodeStream(stream);
          }
          await this.session.connect(stream, cancellation);
          sessionConnected = true;
          let channel = null;
          if (this.clientCredentials) {
            const clientSession = this.session;
            if (!await clientSession.authenticateServer(cancellation)) {
              throw new errors_1.SshConnectionError("Server authentication failed.", transportMessages_1.SshDisconnectReason.hostKeyNotVerifiable);
            }
            if (!await clientSession.authenticateClient(this.clientCredentials, cancellation)) {
              throw new errors_1.SshConnectionError("Client authentication failed.", transportMessages_1.SshDisconnectReason.noMoreAuthMethodsAvailable);
            }
            channel = await this.session.openChannel(cancellation);
          } else {
            channel = await this.session.acceptChannel(cancellation);
          }
          this.stream = this.createStream(channel);
          this.stream.on("data", (data) => this.emit("data", data));
          this.stream.on("end", () => this.emit("end"));
          this.stream.on("close", () => this.emit("close"));
          this.stream.on("error", () => this.emit("error"));
          channel.onClosed(() => this.dispose());
          this.connectCompletion.resolve(this.stream);
        } catch (e) {
          if (!(e instanceof Error))
            throw e;
          if (e instanceof errors_1.ObjectDisposedError && this.session.isClosed) {
            this.connectCompletion.resolve(null);
          } else {
            let disconnectReason = e instanceof errors_1.SshConnectionError ? e.reason : void 0;
            disconnectReason !== null && disconnectReason !== void 0 ? disconnectReason : disconnectReason = transportMessages_1.SshDisconnectReason.protocolError;
            await this.session.close(disconnectReason, e.message, e);
            this.connectCompletion.reject(e);
            throw e;
          }
        }
      }
      /**
       * Re-initiates the SSH session over a NEW transport stream by exchanging initial messages
       * with the remote server. Waits for the secure reconnect handshake to complete. Additional
       * message processing is kicked off as a background task chain.
       *
       * Applies only to a secure stream client. (The secure stream server handles reconnections
       * automatically during the session handshake.)
       */
      async reconnect(transportStream, cancellation) {
        if (!(this.session instanceof sshClientSession_1.SshClientSession)) {
          throw new Error("Cannot reconnect SecureStream server.");
        }
        if (!transportStream)
          throw new TypeError("A transport stream is required.");
        this.transportStream = transportStream;
        let stream = this.transportStream;
        if (stream instanceof stream_1.Duplex) {
          stream = new streams_1.NodeStream(stream);
        }
        await this.session.reconnect(stream, cancellation);
      }
      /**
       * Creates a stream instance for a channel. May be overridden to create a `SshStream` subclass.
       */
      createStream(channel) {
        return new sshStream_1.SshStream(channel);
      }
      dispose() {
        if (!this.disposed) {
          const sessionWasConnected = this.session.isConnected || this.session.isClosed;
          this.disposed = true;
          this.session.dispose();
          this.unsubscribe();
          try {
            if (!sessionWasConnected && this.transportStream) {
              if (this.transportStream instanceof stream_1.Duplex) {
                this.transportStream.end();
                this.transportStream.destroy();
              } else {
                this.transportStream.close().catch((e) => {
                  this.trace(trace_1.TraceLevel.Error, trace_1.SshTraceEventIds.streamCloseError, `Error closing transport stream: ${e.message}`, e);
                });
              }
            }
          } catch (e) {
            if (!(e instanceof Error))
              throw e;
            this.trace(trace_1.TraceLevel.Error, trace_1.SshTraceEventIds.streamCloseError, `Error closing transport stream: ${e.message}`, e);
          }
        }
      }
      async close() {
        if (!this.disposed) {
          this.disposed = true;
          await this.session.close(transportMessages_1.SshDisconnectReason.none, this.session.constructor.name + " disposed.");
          this.session.dispose();
          this.unsubscribe();
          if (this.transportStream instanceof stream_1.Duplex) {
            await new Promise((resolve3) => {
              this.transportStream.end(resolve3);
            });
          } else {
            await this.transportStream.close();
          }
        }
      }
      onSessionDisconnected() {
        this.disconnectedEmitter.fire();
      }
      onSessionClosed(e) {
        this.unsubscribe();
        this.closedEmitter.fire(e);
      }
      unsubscribe() {
        this.disposables.forEach((d) => d.dispose());
        this.disposables = [];
      }
    };
    exports2.SecureStream = SecureStream;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/index.js
var require_dev_tunnels_ssh = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CommandRequestMessage = exports2.ChannelRequestType = exports2.ChannelRequestMessage = exports2.ChannelOpenConfirmationMessage = exports2.ChannelOpenMessage = exports2.ChannelOpenFailureMessage = exports2.ChannelMessage = exports2.SshChannelOpenFailureReason = exports2.SessionChannelRequestMessage = exports2.ServiceAcceptMessage = exports2.ServiceRequestMessage = exports2.SshReconnectFailureReason = exports2.SshDisconnectReason = exports2.SessionRequestFailureMessage = exports2.SessionRequestSuccessMessage = exports2.DebugMessage = exports2.SessionRequestMessage = exports2.PasswordRequestMessage = exports2.PublicKeyOKMessage = exports2.PublicKeyRequestMessage = exports2.AuthenticationInfoResponseMessage = exports2.AuthenticationInfoRequestMessage = exports2.AuthenticationFailureMessage = exports2.AuthenticationSuccessMessage = exports2.AuthenticationRequestMessage = exports2.AuthenticationMessage = exports2.SshMessage = exports2.SshExtendedDataEventArgs = exports2.SshExtendedDataType = exports2.SshChannelClosedEventArgs = exports2.SshSessionClosedEventArgs = exports2.SshChannelOpeningEventArgs = exports2.SshReportProgressEventArgs = exports2.SshRequestEventArgs = exports2.SshAuthenticatingEventArgs = exports2.SshAuthenticationType = exports2.serviceActivation = exports2.SshService = exports2.SshRpcMessageStream = exports2.WebSocketStream = exports2.NodeStream = exports2.BaseStream = exports2.SshStream = exports2.SshChannel = exports2.SshServerSession = exports2.SshClientSession = exports2.SshSession = exports2.SshVersionInfo = exports2.SshProtocolExtensionNames = exports2.SshSessionConfiguration = void 0;
    exports2.Progress = exports2.SshTraceEventIds = exports2.TraceLevel = exports2.SecureStream = exports2.MultiChannelStream = exports2.SessionContour = exports2.ChannelMetrics = exports2.SessionMetrics = exports2.Queue = exports2.Semaphore = exports2.PromiseCompletionSource = exports2.CancellationError = exports2.CancellationTokenSource = exports2.CancellationToken = exports2.ObjectDisposedError = exports2.SshReconnectError = exports2.SshConnectionError = exports2.SshChannelError = exports2.BigInt = exports2.DerWriter = exports2.DerReader = exports2.formatBuffer = exports2.SshDataWriter = exports2.SshDataReader = exports2.ECDsa = exports2.Rsa = exports2.Encryption = exports2.HmacAlgorithm = exports2.EncryptionAlgorithm = exports2.PublicKeyAlgorithm = exports2.KeyExchangeAlgorithm = exports2.SshAlgorithms = void 0;
    var sshSessionConfiguration_1 = require_sshSessionConfiguration();
    Object.defineProperty(exports2, "SshSessionConfiguration", { enumerable: true, get: function() {
      return sshSessionConfiguration_1.SshSessionConfiguration;
    } });
    Object.defineProperty(exports2, "SshProtocolExtensionNames", { enumerable: true, get: function() {
      return sshSessionConfiguration_1.SshProtocolExtensionNames;
    } });
    var sshVersionInfo_1 = require_sshVersionInfo();
    Object.defineProperty(exports2, "SshVersionInfo", { enumerable: true, get: function() {
      return sshVersionInfo_1.SshVersionInfo;
    } });
    var sshSession_1 = require_sshSession();
    Object.defineProperty(exports2, "SshSession", { enumerable: true, get: function() {
      return sshSession_1.SshSession;
    } });
    var sshClientSession_1 = require_sshClientSession();
    Object.defineProperty(exports2, "SshClientSession", { enumerable: true, get: function() {
      return sshClientSession_1.SshClientSession;
    } });
    var sshServerSession_1 = require_sshServerSession();
    Object.defineProperty(exports2, "SshServerSession", { enumerable: true, get: function() {
      return sshServerSession_1.SshServerSession;
    } });
    var sshChannel_1 = require_sshChannel();
    Object.defineProperty(exports2, "SshChannel", { enumerable: true, get: function() {
      return sshChannel_1.SshChannel;
    } });
    var sshStream_1 = require_sshStream();
    Object.defineProperty(exports2, "SshStream", { enumerable: true, get: function() {
      return sshStream_1.SshStream;
    } });
    var streams_1 = require_streams();
    Object.defineProperty(exports2, "BaseStream", { enumerable: true, get: function() {
      return streams_1.BaseStream;
    } });
    Object.defineProperty(exports2, "NodeStream", { enumerable: true, get: function() {
      return streams_1.NodeStream;
    } });
    Object.defineProperty(exports2, "WebSocketStream", { enumerable: true, get: function() {
      return streams_1.WebSocketStream;
    } });
    var sshRpcMessageStream_1 = require_sshRpcMessageStream();
    Object.defineProperty(exports2, "SshRpcMessageStream", { enumerable: true, get: function() {
      return sshRpcMessageStream_1.SshRpcMessageStream;
    } });
    var sshService_1 = require_sshService();
    Object.defineProperty(exports2, "SshService", { enumerable: true, get: function() {
      return sshService_1.SshService;
    } });
    var serviceActivation_1 = require_serviceActivation();
    Object.defineProperty(exports2, "serviceActivation", { enumerable: true, get: function() {
      return serviceActivation_1.serviceActivation;
    } });
    var sshAuthenticatingEventArgs_1 = require_sshAuthenticatingEventArgs();
    Object.defineProperty(exports2, "SshAuthenticationType", { enumerable: true, get: function() {
      return sshAuthenticatingEventArgs_1.SshAuthenticationType;
    } });
    Object.defineProperty(exports2, "SshAuthenticatingEventArgs", { enumerable: true, get: function() {
      return sshAuthenticatingEventArgs_1.SshAuthenticatingEventArgs;
    } });
    var sshRequestEventArgs_1 = require_sshRequestEventArgs();
    Object.defineProperty(exports2, "SshRequestEventArgs", { enumerable: true, get: function() {
      return sshRequestEventArgs_1.SshRequestEventArgs;
    } });
    var sshReportProgressEventArgs_1 = require_sshReportProgressEventArgs();
    Object.defineProperty(exports2, "SshReportProgressEventArgs", { enumerable: true, get: function() {
      return sshReportProgressEventArgs_1.SshReportProgressEventArgs;
    } });
    var sshChannelOpeningEventArgs_1 = require_sshChannelOpeningEventArgs();
    Object.defineProperty(exports2, "SshChannelOpeningEventArgs", { enumerable: true, get: function() {
      return sshChannelOpeningEventArgs_1.SshChannelOpeningEventArgs;
    } });
    var sshSessionClosedEventArgs_1 = require_sshSessionClosedEventArgs();
    Object.defineProperty(exports2, "SshSessionClosedEventArgs", { enumerable: true, get: function() {
      return sshSessionClosedEventArgs_1.SshSessionClosedEventArgs;
    } });
    var sshChannelClosedEventArgs_1 = require_sshChannelClosedEventArgs();
    Object.defineProperty(exports2, "SshChannelClosedEventArgs", { enumerable: true, get: function() {
      return sshChannelClosedEventArgs_1.SshChannelClosedEventArgs;
    } });
    var sshExtendedDataEventArgs_1 = require_sshExtendedDataEventArgs();
    Object.defineProperty(exports2, "SshExtendedDataType", { enumerable: true, get: function() {
      return sshExtendedDataEventArgs_1.SshExtendedDataType;
    } });
    Object.defineProperty(exports2, "SshExtendedDataEventArgs", { enumerable: true, get: function() {
      return sshExtendedDataEventArgs_1.SshExtendedDataEventArgs;
    } });
    var sshMessage_1 = require_sshMessage();
    Object.defineProperty(exports2, "SshMessage", { enumerable: true, get: function() {
      return sshMessage_1.SshMessage;
    } });
    var authenticationMessages_1 = require_authenticationMessages();
    Object.defineProperty(exports2, "AuthenticationMessage", { enumerable: true, get: function() {
      return authenticationMessages_1.AuthenticationMessage;
    } });
    Object.defineProperty(exports2, "AuthenticationRequestMessage", { enumerable: true, get: function() {
      return authenticationMessages_1.AuthenticationRequestMessage;
    } });
    Object.defineProperty(exports2, "AuthenticationSuccessMessage", { enumerable: true, get: function() {
      return authenticationMessages_1.AuthenticationSuccessMessage;
    } });
    Object.defineProperty(exports2, "AuthenticationFailureMessage", { enumerable: true, get: function() {
      return authenticationMessages_1.AuthenticationFailureMessage;
    } });
    Object.defineProperty(exports2, "AuthenticationInfoRequestMessage", { enumerable: true, get: function() {
      return authenticationMessages_1.AuthenticationInfoRequestMessage;
    } });
    Object.defineProperty(exports2, "AuthenticationInfoResponseMessage", { enumerable: true, get: function() {
      return authenticationMessages_1.AuthenticationInfoResponseMessage;
    } });
    Object.defineProperty(exports2, "PublicKeyRequestMessage", { enumerable: true, get: function() {
      return authenticationMessages_1.PublicKeyRequestMessage;
    } });
    Object.defineProperty(exports2, "PublicKeyOKMessage", { enumerable: true, get: function() {
      return authenticationMessages_1.PublicKeyOKMessage;
    } });
    Object.defineProperty(exports2, "PasswordRequestMessage", { enumerable: true, get: function() {
      return authenticationMessages_1.PasswordRequestMessage;
    } });
    var transportMessages_1 = require_transportMessages();
    Object.defineProperty(exports2, "SessionRequestMessage", { enumerable: true, get: function() {
      return transportMessages_1.SessionRequestMessage;
    } });
    Object.defineProperty(exports2, "DebugMessage", { enumerable: true, get: function() {
      return transportMessages_1.DebugMessage;
    } });
    Object.defineProperty(exports2, "SessionRequestSuccessMessage", { enumerable: true, get: function() {
      return transportMessages_1.SessionRequestSuccessMessage;
    } });
    Object.defineProperty(exports2, "SessionRequestFailureMessage", { enumerable: true, get: function() {
      return transportMessages_1.SessionRequestFailureMessage;
    } });
    Object.defineProperty(exports2, "SshDisconnectReason", { enumerable: true, get: function() {
      return transportMessages_1.SshDisconnectReason;
    } });
    Object.defineProperty(exports2, "SshReconnectFailureReason", { enumerable: true, get: function() {
      return transportMessages_1.SshReconnectFailureReason;
    } });
    Object.defineProperty(exports2, "ServiceRequestMessage", { enumerable: true, get: function() {
      return transportMessages_1.ServiceRequestMessage;
    } });
    Object.defineProperty(exports2, "ServiceAcceptMessage", { enumerable: true, get: function() {
      return transportMessages_1.ServiceAcceptMessage;
    } });
    Object.defineProperty(exports2, "SessionChannelRequestMessage", { enumerable: true, get: function() {
      return transportMessages_1.SessionChannelRequestMessage;
    } });
    var connectionMessages_1 = require_connectionMessages();
    Object.defineProperty(exports2, "SshChannelOpenFailureReason", { enumerable: true, get: function() {
      return connectionMessages_1.SshChannelOpenFailureReason;
    } });
    Object.defineProperty(exports2, "ChannelMessage", { enumerable: true, get: function() {
      return connectionMessages_1.ChannelMessage;
    } });
    Object.defineProperty(exports2, "ChannelOpenFailureMessage", { enumerable: true, get: function() {
      return connectionMessages_1.ChannelOpenFailureMessage;
    } });
    Object.defineProperty(exports2, "ChannelOpenMessage", { enumerable: true, get: function() {
      return connectionMessages_1.ChannelOpenMessage;
    } });
    Object.defineProperty(exports2, "ChannelOpenConfirmationMessage", { enumerable: true, get: function() {
      return connectionMessages_1.ChannelOpenConfirmationMessage;
    } });
    Object.defineProperty(exports2, "ChannelRequestMessage", { enumerable: true, get: function() {
      return connectionMessages_1.ChannelRequestMessage;
    } });
    Object.defineProperty(exports2, "ChannelRequestType", { enumerable: true, get: function() {
      return connectionMessages_1.ChannelRequestType;
    } });
    Object.defineProperty(exports2, "CommandRequestMessage", { enumerable: true, get: function() {
      return connectionMessages_1.CommandRequestMessage;
    } });
    var sshAlgorithms_1 = require_sshAlgorithms();
    Object.defineProperty(exports2, "SshAlgorithms", { enumerable: true, get: function() {
      return sshAlgorithms_1.SshAlgorithms;
    } });
    Object.defineProperty(exports2, "KeyExchangeAlgorithm", { enumerable: true, get: function() {
      return sshAlgorithms_1.KeyExchangeAlgorithm;
    } });
    Object.defineProperty(exports2, "PublicKeyAlgorithm", { enumerable: true, get: function() {
      return sshAlgorithms_1.PublicKeyAlgorithm;
    } });
    Object.defineProperty(exports2, "EncryptionAlgorithm", { enumerable: true, get: function() {
      return sshAlgorithms_1.EncryptionAlgorithm;
    } });
    Object.defineProperty(exports2, "HmacAlgorithm", { enumerable: true, get: function() {
      return sshAlgorithms_1.HmacAlgorithm;
    } });
    Object.defineProperty(exports2, "Encryption", { enumerable: true, get: function() {
      return sshAlgorithms_1.Encryption;
    } });
    Object.defineProperty(exports2, "Rsa", { enumerable: true, get: function() {
      return sshAlgorithms_1.Rsa;
    } });
    Object.defineProperty(exports2, "ECDsa", { enumerable: true, get: function() {
      return sshAlgorithms_1.ECDsa;
    } });
    var sshData_1 = require_sshData();
    Object.defineProperty(exports2, "SshDataReader", { enumerable: true, get: function() {
      return sshData_1.SshDataReader;
    } });
    Object.defineProperty(exports2, "SshDataWriter", { enumerable: true, get: function() {
      return sshData_1.SshDataWriter;
    } });
    Object.defineProperty(exports2, "formatBuffer", { enumerable: true, get: function() {
      return sshData_1.formatBuffer;
    } });
    var derData_1 = require_derData();
    Object.defineProperty(exports2, "DerReader", { enumerable: true, get: function() {
      return derData_1.DerReader;
    } });
    Object.defineProperty(exports2, "DerWriter", { enumerable: true, get: function() {
      return derData_1.DerWriter;
    } });
    var bigInt_1 = require_bigInt();
    Object.defineProperty(exports2, "BigInt", { enumerable: true, get: function() {
      return bigInt_1.BigInt;
    } });
    var errors_1 = require_errors();
    Object.defineProperty(exports2, "SshChannelError", { enumerable: true, get: function() {
      return errors_1.SshChannelError;
    } });
    Object.defineProperty(exports2, "SshConnectionError", { enumerable: true, get: function() {
      return errors_1.SshConnectionError;
    } });
    Object.defineProperty(exports2, "SshReconnectError", { enumerable: true, get: function() {
      return errors_1.SshReconnectError;
    } });
    Object.defineProperty(exports2, "ObjectDisposedError", { enumerable: true, get: function() {
      return errors_1.ObjectDisposedError;
    } });
    var cancellation_1 = require_cancellation2();
    Object.defineProperty(exports2, "CancellationToken", { enumerable: true, get: function() {
      return cancellation_1.CancellationToken;
    } });
    Object.defineProperty(exports2, "CancellationTokenSource", { enumerable: true, get: function() {
      return cancellation_1.CancellationTokenSource;
    } });
    Object.defineProperty(exports2, "CancellationError", { enumerable: true, get: function() {
      return cancellation_1.CancellationError;
    } });
    var promiseCompletionSource_1 = require_promiseCompletionSource();
    Object.defineProperty(exports2, "PromiseCompletionSource", { enumerable: true, get: function() {
      return promiseCompletionSource_1.PromiseCompletionSource;
    } });
    var semaphore_1 = require_semaphore();
    Object.defineProperty(exports2, "Semaphore", { enumerable: true, get: function() {
      return semaphore_1.Semaphore;
    } });
    var queue_1 = require_queue();
    Object.defineProperty(exports2, "Queue", { enumerable: true, get: function() {
      return queue_1.Queue;
    } });
    var sessionMetrics_1 = require_sessionMetrics();
    Object.defineProperty(exports2, "SessionMetrics", { enumerable: true, get: function() {
      return sessionMetrics_1.SessionMetrics;
    } });
    var channelMetrics_1 = require_channelMetrics();
    Object.defineProperty(exports2, "ChannelMetrics", { enumerable: true, get: function() {
      return channelMetrics_1.ChannelMetrics;
    } });
    var sessionContour_1 = require_sessionContour();
    Object.defineProperty(exports2, "SessionContour", { enumerable: true, get: function() {
      return sessionContour_1.SessionContour;
    } });
    var multiChannelStream_1 = require_multiChannelStream();
    Object.defineProperty(exports2, "MultiChannelStream", { enumerable: true, get: function() {
      return multiChannelStream_1.MultiChannelStream;
    } });
    var secureStream_1 = require_secureStream();
    Object.defineProperty(exports2, "SecureStream", { enumerable: true, get: function() {
      return secureStream_1.SecureStream;
    } });
    var trace_1 = require_trace();
    Object.defineProperty(exports2, "TraceLevel", { enumerable: true, get: function() {
      return trace_1.TraceLevel;
    } });
    Object.defineProperty(exports2, "SshTraceEventIds", { enumerable: true, get: function() {
      return trace_1.SshTraceEventIds;
    } });
    var progress_1 = require_progress();
    Object.defineProperty(exports2, "Progress", { enumerable: true, get: function() {
      return progress_1.Progress;
    } });
  }
});

// ../../node_modules/@microsoft/dev-tunnels-contracts/tunnelAccessScopes.js
var require_tunnelAccessScopes = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-contracts/tunnelAccessScopes.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TunnelAccessScopes = void 0;
    var TunnelAccessScopes2;
    (function(TunnelAccessScopes3) {
      TunnelAccessScopes3["Create"] = "create";
      TunnelAccessScopes3["Manage"] = "manage";
      TunnelAccessScopes3["ManagePorts"] = "manage:ports";
      TunnelAccessScopes3["Host"] = "host";
      TunnelAccessScopes3["Inspect"] = "inspect";
      TunnelAccessScopes3["Connect"] = "connect";
    })(TunnelAccessScopes2 = exports2.TunnelAccessScopes || (exports2.TunnelAccessScopes = {}));
  }
});

// ../../node_modules/@microsoft/dev-tunnels-contracts/tunnelAccessControlStatics.js
var require_tunnelAccessControlStatics = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-contracts/tunnelAccessControlStatics.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateScopes = void 0;
    var tunnelAccessScopes_1 = require_tunnelAccessScopes();
    var allScopes = [
      tunnelAccessScopes_1.TunnelAccessScopes.Manage,
      tunnelAccessScopes_1.TunnelAccessScopes.ManagePorts,
      tunnelAccessScopes_1.TunnelAccessScopes.Host,
      tunnelAccessScopes_1.TunnelAccessScopes.Inspect,
      tunnelAccessScopes_1.TunnelAccessScopes.Connect
    ];
    function validateScopes(scopes, validScopes, allowMultiple) {
      if (!Array.isArray(scopes)) {
        throw new TypeError("A scopes array was expected.");
      }
      if (allowMultiple) {
        scopes = scopes.map((s) => s.split(" ")).reduce((a, b) => a.concat(b), []);
      }
      scopes.forEach((scope) => {
        if (!scope) {
          throw new Error("Tunnel access scopes include a null/empty item.");
        } else if (!allScopes.includes(scope)) {
          throw new Error("Invalid tunnel access scope: " + scope);
        }
      });
      if (Array.isArray(validScopes)) {
        scopes.forEach((scope) => {
          if (!validScopes.includes(scope)) {
            throw new Error("Tunnel access scope is invalid for current request: scope");
          }
        });
      }
    }
    exports2.validateScopes = validateScopes;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-contracts/tunnelAccessControl.js
var require_tunnelAccessControl = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-contracts/tunnelAccessControl.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TunnelAccessControl = void 0;
    var tunnelAccessControlStatics_1 = require_tunnelAccessControlStatics();
    exports2.TunnelAccessControl = {
      validateScopes: tunnelAccessControlStatics_1.validateScopes
    };
  }
});

// ../../node_modules/@microsoft/dev-tunnels-contracts/tunnelAccessControlEntry.js
var require_tunnelAccessControlEntry = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-contracts/tunnelAccessControlEntry.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TunnelAccessControlEntry = void 0;
    var TunnelAccessControlEntry;
    (function(TunnelAccessControlEntry2) {
      let Providers;
      (function(Providers2) {
        Providers2["Microsoft"] = "microsoft";
        Providers2["GitHub"] = "github";
        Providers2["Ssh"] = "ssh";
        Providers2["IPv4"] = "ipv4";
        Providers2["IPv6"] = "ipv6";
        Providers2["ServiceTag"] = "service-tag";
      })(Providers = TunnelAccessControlEntry2.Providers || (TunnelAccessControlEntry2.Providers = {}));
    })(TunnelAccessControlEntry = exports2.TunnelAccessControlEntry || (exports2.TunnelAccessControlEntry = {}));
  }
});

// ../../node_modules/@microsoft/dev-tunnels-contracts/tunnelAccessControlEntryType.js
var require_tunnelAccessControlEntryType = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-contracts/tunnelAccessControlEntryType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TunnelAccessControlEntryType = void 0;
    var TunnelAccessControlEntryType;
    (function(TunnelAccessControlEntryType2) {
      TunnelAccessControlEntryType2["None"] = "None";
      TunnelAccessControlEntryType2["Anonymous"] = "Anonymous";
      TunnelAccessControlEntryType2["Users"] = "Users";
      TunnelAccessControlEntryType2["Groups"] = "Groups";
      TunnelAccessControlEntryType2["Organizations"] = "Organizations";
      TunnelAccessControlEntryType2["Repositories"] = "Repositories";
      TunnelAccessControlEntryType2["PublicKeys"] = "PublicKeys";
      TunnelAccessControlEntryType2["IPAddressRanges"] = "IPAddressRanges";
    })(TunnelAccessControlEntryType = exports2.TunnelAccessControlEntryType || (exports2.TunnelAccessControlEntryType = {}));
  }
});

// ../../node_modules/@microsoft/dev-tunnels-contracts/tunnelConnectionMode.js
var require_tunnelConnectionMode = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-contracts/tunnelConnectionMode.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TunnelConnectionMode = void 0;
    var TunnelConnectionMode;
    (function(TunnelConnectionMode2) {
      TunnelConnectionMode2["LocalNetwork"] = "LocalNetwork";
      TunnelConnectionMode2["TunnelRelay"] = "TunnelRelay";
    })(TunnelConnectionMode = exports2.TunnelConnectionMode || (exports2.TunnelConnectionMode = {}));
  }
});

// ../../node_modules/@microsoft/dev-tunnels-contracts/tunnelEndpointStatics.js
var require_tunnelEndpointStatics = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-contracts/tunnelEndpointStatics.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getPortSshCommand = exports2.getPortUri = void 0;
    var tunnelEndpoint_1 = require_tunnelEndpoint();
    function getPortUri(endpoint, portNumber) {
      if (!endpoint) {
        throw new TypeError("A tunnel endpoint is required.");
      }
      if (typeof portNumber !== "number" && !endpoint.tunnelUri) {
        return endpoint.tunnelUri;
      }
      if (typeof portNumber !== "number" || !endpoint.portUriFormat) {
        return void 0;
      }
      return endpoint.portUriFormat.replace(tunnelEndpoint_1.portToken, portNumber.toString());
    }
    exports2.getPortUri = getPortUri;
    function getPortSshCommand(endpoint, portNumber) {
      if (!endpoint) {
        throw new TypeError("A tunnel endpoint is required.");
      }
      if (typeof portNumber !== "number" && !endpoint.tunnelSshCommand) {
        return endpoint.tunnelSshCommand;
      }
      if (typeof portNumber !== "number" || !endpoint.portSshCommandFormat) {
        return void 0;
      }
      return endpoint.portSshCommandFormat.replace(tunnelEndpoint_1.portToken, portNumber.toString());
    }
    exports2.getPortSshCommand = getPortSshCommand;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-contracts/tunnelEndpoint.js
var require_tunnelEndpoint = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-contracts/tunnelEndpoint.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TunnelEndpoint = exports2.portToken = void 0;
    exports2.portToken = "{port}";
    var tunnelEndpointStatics_1 = require_tunnelEndpointStatics();
    exports2.TunnelEndpoint = {
      portToken: exports2.portToken,
      getPortUri: tunnelEndpointStatics_1.getPortUri,
      getPortSshCommand: tunnelEndpointStatics_1.getPortSshCommand
    };
  }
});

// ../../node_modules/@microsoft/dev-tunnels-contracts/tunnelEvent.js
var require_tunnelEvent = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-contracts/tunnelEvent.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TunnelEvent = exports2.error = exports2.warning = exports2.info = void 0;
    exports2.info = "info";
    exports2.warning = "warning";
    exports2.error = "error";
    exports2.TunnelEvent = {
      info: exports2.info,
      warning: exports2.warning,
      error: exports2.error
    };
  }
});

// ../../node_modules/@microsoft/dev-tunnels-contracts/tunnelHeaderNames.js
var require_tunnelHeaderNames = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-contracts/tunnelHeaderNames.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TunnelHeaderNames = void 0;
    var TunnelHeaderNames;
    (function(TunnelHeaderNames2) {
      TunnelHeaderNames2["XTunnelAuthorization"] = "X-Tunnel-Authorization";
      TunnelHeaderNames2["XRequestID"] = "X-Request-ID";
      TunnelHeaderNames2["XGithubSshKey"] = "X-Github-Ssh-Key";
      TunnelHeaderNames2["XTunnelSkipAntiPhishingPage"] = "X-Tunnel-Skip-AntiPhishing-Page";
    })(TunnelHeaderNames = exports2.TunnelHeaderNames || (exports2.TunnelHeaderNames = {}));
  }
});

// ../../node_modules/@microsoft/dev-tunnels-contracts/tunnelProtocol.js
var require_tunnelProtocol = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-contracts/tunnelProtocol.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TunnelProtocol = void 0;
    var TunnelProtocol;
    (function(TunnelProtocol2) {
      TunnelProtocol2["Auto"] = "auto";
      TunnelProtocol2["Tcp"] = "tcp";
      TunnelProtocol2["Udp"] = "udp";
      TunnelProtocol2["Ssh"] = "ssh";
      TunnelProtocol2["Rdp"] = "rdp";
      TunnelProtocol2["Http"] = "http";
      TunnelProtocol2["Https"] = "https";
    })(TunnelProtocol = exports2.TunnelProtocol || (exports2.TunnelProtocol = {}));
  }
});

// ../../node_modules/@microsoft/dev-tunnels-contracts/tunnelServicePropertiesStatics.js
var require_tunnelServicePropertiesStatics = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-contracts/tunnelServicePropertiesStatics.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.environment = exports2.development = exports2.staging = exports2.production = void 0;
    var tunnelServiceProperties_1 = require_tunnelServiceProperties();
    exports2.production = {
      serviceUri: `https://${tunnelServiceProperties_1.prodDnsName}/`,
      serviceAppId: tunnelServiceProperties_1.prodFirstPartyAppId,
      serviceInternalAppId: tunnelServiceProperties_1.prodThirdPartyAppId,
      gitHubAppClientId: tunnelServiceProperties_1.prodGitHubAppClientId
    };
    exports2.staging = {
      serviceUri: `https://${tunnelServiceProperties_1.ppeDnsName}/`,
      serviceAppId: tunnelServiceProperties_1.ppeFirstPartyAppId,
      serviceInternalAppId: tunnelServiceProperties_1.ppeThirdPartyAppId,
      gitHubAppClientId: tunnelServiceProperties_1.nonProdGitHubAppClientId
    };
    exports2.development = {
      serviceUri: `https://${tunnelServiceProperties_1.devDnsName}/`,
      serviceAppId: tunnelServiceProperties_1.devFirstPartyAppId,
      serviceInternalAppId: tunnelServiceProperties_1.devThirdPartyAppId,
      gitHubAppClientId: tunnelServiceProperties_1.nonProdGitHubAppClientId
    };
    function environment(environmentName) {
      if (!environmentName) {
        throw new Error(`Invalid argument: ${environmentName}`);
      }
      switch (environmentName.toLowerCase()) {
        case "prod":
        case "production":
          return exports2.production;
        case "ppe":
        case "preprod":
          return exports2.staging;
        case "dev":
        case "development":
          return exports2.development;
        default:
          throw new Error(`Invalid service environment: ${environmentName}`);
      }
    }
    exports2.environment = environment;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-contracts/tunnelServiceProperties.js
var require_tunnelServiceProperties = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-contracts/tunnelServiceProperties.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TunnelServiceProperties = exports2.nonProdGitHubAppClientId = exports2.prodGitHubAppClientId = exports2.devThirdPartyAppId = exports2.ppeThirdPartyAppId = exports2.prodThirdPartyAppId = exports2.devFirstPartyAppId = exports2.ppeFirstPartyAppId = exports2.prodFirstPartyAppId = exports2.devDnsName = exports2.ppeDnsName = exports2.prodDnsName = void 0;
    exports2.prodDnsName = "global.rel.tunnels.api.visualstudio.com";
    exports2.ppeDnsName = "global.rel.tunnels.ppe.api.visualstudio.com";
    exports2.devDnsName = "global.ci.tunnels.dev.api.visualstudio.com";
    exports2.prodFirstPartyAppId = "46da2f7e-b5ef-422a-88d4-2a7f9de6a0b2";
    exports2.ppeFirstPartyAppId = "54c45752-bacd-424a-b928-652f3eca2b18";
    exports2.devFirstPartyAppId = "9c63851a-ba2b-40a5-94bd-890be43b9284";
    exports2.prodThirdPartyAppId = "ce65d243-a913-4cae-a7dd-cb52e9f77647";
    exports2.ppeThirdPartyAppId = "544167a6-f431-4518-aac6-2fd50071928e";
    exports2.devThirdPartyAppId = "a118c979-0249-44bb-8f95-eb0457127aeb";
    exports2.prodGitHubAppClientId = "Iv1.e7b89e013f801f03";
    exports2.nonProdGitHubAppClientId = "Iv1.b231c327f1eaa229";
    var tunnelServicePropertiesStatics_1 = require_tunnelServicePropertiesStatics();
    exports2.TunnelServiceProperties = {
      production: tunnelServicePropertiesStatics_1.production,
      staging: tunnelServicePropertiesStatics_1.staging,
      development: tunnelServicePropertiesStatics_1.development,
      environment: tunnelServicePropertiesStatics_1.environment
    };
  }
});

// ../../node_modules/@microsoft/dev-tunnels-contracts/tunnelConstraints.js
var require_tunnelConstraints = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-contracts/tunnelConstraints.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TunnelConstraints = void 0;
    var TunnelConstraints;
    (function(TunnelConstraints2) {
      TunnelConstraints2.clusterIdMinLength = 3;
      TunnelConstraints2.clusterIdMaxLength = 12;
      TunnelConstraints2.oldTunnelIdLength = 8;
      TunnelConstraints2.newTunnelIdMinLength = 3;
      TunnelConstraints2.newTunnelIdMaxLength = 60;
      TunnelConstraints2.tunnelAliasLength = 8;
      TunnelConstraints2.tunnelNameMinLength = 3;
      TunnelConstraints2.tunnelNameMaxLength = 60;
      TunnelConstraints2.descriptionMaxLength = 400;
      TunnelConstraints2.eventDetailsMaxLength = 4e3;
      TunnelConstraints2.maxEventProperties = 100;
      TunnelConstraints2.eventPropertyValueMaxLength = 4e3;
      TunnelConstraints2.labelMinLength = 1;
      TunnelConstraints2.labelMaxLength = 50;
      TunnelConstraints2.maxLabels = 100;
      TunnelConstraints2.tunnelDomainMinLength = 4;
      TunnelConstraints2.tunnelDomainMaxLength = 180;
      TunnelConstraints2.tunnelMaxPorts = 1e3;
      TunnelConstraints2.accessControlMaxEntries = 40;
      TunnelConstraints2.accessControlMaxSubjects = 100;
      TunnelConstraints2.accessControlSubjectMaxLength = 200;
      TunnelConstraints2.accessControlSubjectNameMaxLength = 200;
      TunnelConstraints2.accessControlMaxScopes = 10;
      TunnelConstraints2.eventNamePattern = "^[a-z0-9_]{3,80}$";
      TunnelConstraints2.eventSeverityPattern = "^(info)|(warning)|(error)$";
      TunnelConstraints2.eventPropertyNamePattern = "^[a-zA-Z0-9_.]{3,200}$";
      TunnelConstraints2.clusterIdPattern = "^(([a-z]{3,4}[0-9]{1,3})|asse|aue|brs|euw|use)$";
      TunnelConstraints2.clusterIdRegex = new RegExp(TunnelConstraints2.clusterIdPattern);
      TunnelConstraints2.clusterIdPrefixRegex = new RegExp(TunnelConstraints2.clusterIdPattern.replace("$", "\\."));
      TunnelConstraints2.oldTunnelIdChars = "0123456789bcdfghjklmnpqrstvwxz";
      TunnelConstraints2.oldTunnelIdPattern = "[" + TunnelConstraints2.oldTunnelIdChars + "]{8}";
      TunnelConstraints2.oldTunnelIdRegex = new RegExp(TunnelConstraints2.oldTunnelIdPattern);
      TunnelConstraints2.newTunnelIdChars = "0123456789abcdefghijklmnopqrstuvwxyz-";
      TunnelConstraints2.newTunnelIdPattern = "[a-z0-9][a-z0-9-]{1,58}[a-z0-9]";
      TunnelConstraints2.newTunnelIdRegex = new RegExp(TunnelConstraints2.newTunnelIdPattern);
      TunnelConstraints2.tunnelAliasChars = "0123456789bcdfghjklmnpqrstvwxz";
      TunnelConstraints2.tunnelAliasPattern = "[" + TunnelConstraints2.tunnelAliasChars + "]{3,60}";
      TunnelConstraints2.tunnelAliasRegex = new RegExp(TunnelConstraints2.tunnelAliasPattern);
      TunnelConstraints2.tunnelNamePattern = "([a-z0-9][a-z0-9-]{1,58}[a-z0-9])|(^$)";
      TunnelConstraints2.tunnelNameRegex = new RegExp(TunnelConstraints2.tunnelNamePattern);
      TunnelConstraints2.labelPattern = "[\\w-=]{1,50}";
      TunnelConstraints2.labelRegex = new RegExp(TunnelConstraints2.labelPattern);
      TunnelConstraints2.tunnelDomainPattern = "[0-9a-z][0-9a-z-.]{1,158}[0-9a-z]|(^$)";
      TunnelConstraints2.tunnelDomainRegex = new RegExp(TunnelConstraints2.tunnelDomainPattern);
      TunnelConstraints2.accessControlSubjectPattern = "[0-9a-zA-Z-._:/@]{0,200}";
      TunnelConstraints2.accessControlSubjectRegex = new RegExp(TunnelConstraints2.accessControlSubjectPattern);
      TunnelConstraints2.accessControlSubjectNamePattern = `[ \\w\\d-.,/'"_@()<>]{0,200}`;
      TunnelConstraints2.accessControlSubjectNameRegex = new RegExp(TunnelConstraints2.accessControlSubjectNamePattern);
    })(TunnelConstraints = exports2.TunnelConstraints || (exports2.TunnelConstraints = {}));
  }
});

// ../../node_modules/@microsoft/dev-tunnels-contracts/tunnelProgress.js
var require_tunnelProgress = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-contracts/tunnelProgress.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TunnelProgress = void 0;
    var TunnelProgress;
    (function(TunnelProgress2) {
      TunnelProgress2["StartingRefreshPorts"] = "StartingRefreshPorts";
      TunnelProgress2["CompletedRefreshPorts"] = "CompletedRefreshPorts";
      TunnelProgress2["StartingRequestUri"] = "StartingRequestUri";
      TunnelProgress2["StartingRequestConfig"] = "StartingRequestConfig";
      TunnelProgress2["StartingSendTunnelRequest"] = "StartingSendTunnelRequest";
      TunnelProgress2["CompletedSendTunnelRequest"] = "CompletedSendTunnelRequest";
      TunnelProgress2["StartingCreateTunnelPort"] = "StartingCreateTunnelPort";
      TunnelProgress2["CompletedCreateTunnelPort"] = "CompletedCreateTunnelPort";
      TunnelProgress2["StartingGetTunnelPort"] = "StartingGetTunnelPort";
      TunnelProgress2["CompletedGetTunnelPort"] = "CompletedGetTunnelPort";
    })(TunnelProgress = exports2.TunnelProgress || (exports2.TunnelProgress = {}));
  }
});

// ../../node_modules/@microsoft/dev-tunnels-contracts/index.js
var require_dev_tunnels_contracts = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-contracts/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TunnelProgress = exports2.TunnelConstraints = exports2.TunnelServiceProperties = exports2.TunnelProtocol = exports2.TunnelHeaderNames = exports2.TunnelEvent = exports2.TunnelEndpoint = exports2.TunnelConnectionMode = exports2.TunnelAccessScopes = exports2.TunnelAccessControlEntryType = exports2.TunnelAccessControlEntry = exports2.TunnelAccessControl = void 0;
    var tunnelAccessControl_1 = require_tunnelAccessControl();
    Object.defineProperty(exports2, "TunnelAccessControl", { enumerable: true, get: function() {
      return tunnelAccessControl_1.TunnelAccessControl;
    } });
    var tunnelAccessControlEntry_1 = require_tunnelAccessControlEntry();
    Object.defineProperty(exports2, "TunnelAccessControlEntry", { enumerable: true, get: function() {
      return tunnelAccessControlEntry_1.TunnelAccessControlEntry;
    } });
    var tunnelAccessControlEntryType_1 = require_tunnelAccessControlEntryType();
    Object.defineProperty(exports2, "TunnelAccessControlEntryType", { enumerable: true, get: function() {
      return tunnelAccessControlEntryType_1.TunnelAccessControlEntryType;
    } });
    var tunnelAccessScopes_1 = require_tunnelAccessScopes();
    Object.defineProperty(exports2, "TunnelAccessScopes", { enumerable: true, get: function() {
      return tunnelAccessScopes_1.TunnelAccessScopes;
    } });
    var tunnelConnectionMode_1 = require_tunnelConnectionMode();
    Object.defineProperty(exports2, "TunnelConnectionMode", { enumerable: true, get: function() {
      return tunnelConnectionMode_1.TunnelConnectionMode;
    } });
    var tunnelEndpoint_1 = require_tunnelEndpoint();
    Object.defineProperty(exports2, "TunnelEndpoint", { enumerable: true, get: function() {
      return tunnelEndpoint_1.TunnelEndpoint;
    } });
    var tunnelEvent_1 = require_tunnelEvent();
    Object.defineProperty(exports2, "TunnelEvent", { enumerable: true, get: function() {
      return tunnelEvent_1.TunnelEvent;
    } });
    var tunnelHeaderNames_1 = require_tunnelHeaderNames();
    Object.defineProperty(exports2, "TunnelHeaderNames", { enumerable: true, get: function() {
      return tunnelHeaderNames_1.TunnelHeaderNames;
    } });
    var tunnelProtocol_1 = require_tunnelProtocol();
    Object.defineProperty(exports2, "TunnelProtocol", { enumerable: true, get: function() {
      return tunnelProtocol_1.TunnelProtocol;
    } });
    var tunnelServiceProperties_1 = require_tunnelServiceProperties();
    Object.defineProperty(exports2, "TunnelServiceProperties", { enumerable: true, get: function() {
      return tunnelServiceProperties_1.TunnelServiceProperties;
    } });
    var tunnelConstraints_1 = require_tunnelConstraints();
    Object.defineProperty(exports2, "TunnelConstraints", { enumerable: true, get: function() {
      return tunnelConstraints_1.TunnelConstraints;
    } });
    var tunnelProgress_1 = require_tunnelProgress();
    Object.defineProperty(exports2, "TunnelProgress", { enumerable: true, get: function() {
      return tunnelProgress_1.TunnelProgress;
    } });
  }
});

// ../../node_modules/@microsoft/dev-tunnels-management/tunnelManagementClient.js
var require_tunnelManagementClient = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-management/tunnelManagementClient.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TunnelAuthenticationSchemes = void 0;
    var TunnelAuthenticationSchemes = class {
    };
    exports2.TunnelAuthenticationSchemes = TunnelAuthenticationSchemes;
    TunnelAuthenticationSchemes.aad = "aad";
    TunnelAuthenticationSchemes.github = "github";
    TunnelAuthenticationSchemes.tunnel = "tunnel";
  }
});

// ../../node_modules/@microsoft/dev-tunnels-management/tunnelAccessTokenProperties.js
var require_tunnelAccessTokenProperties = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-management/tunnelAccessTokenProperties.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TunnelAccessTokenProperties = void 0;
    var TunnelAccessTokenProperties = class _TunnelAccessTokenProperties {
      constructor(clusterId, tunnelId, tunnelPorts, scopes, issuer, expiration) {
        this.clusterId = clusterId;
        this.tunnelId = tunnelId;
        this.tunnelPorts = tunnelPorts;
        this.scopes = scopes;
        this.issuer = issuer;
        this.expiration = expiration;
      }
      toString() {
        let s = "";
        if (this.tunnelId) {
          s += "tunnel=";
          s += this.tunnelId;
          if (this.clusterId) {
            s += ".";
            s += this.clusterId;
          }
        }
        if (this.tunnelPorts && this.tunnelPorts.length > 0) {
          if (s.length > 0)
            s += ", ";
          if (this.tunnelPorts.length === 1) {
            s += `port=${this.tunnelPorts[0]}`;
          } else {
            s += `ports=[${this.tunnelPorts.join(", ")}]`;
          }
        }
        if (this.scopes) {
          if (s.length > 0)
            s += ", ";
          s += `scopes=[${this.scopes.join(", ")}]`;
        }
        if (this.issuer) {
          if (s.length > 0)
            s += ", ";
          s += "issuer=";
          s += this.issuer;
        }
        if (this.expiration) {
          if (s.length > 0)
            s += ", ";
          s += `expiration=${this.expiration.toString().replace(".000Z", "Z")}`;
        }
        return s;
      }
      /**
       * Checks if the tunnel access token expiration claim is in the past.
       * Note: uses client's system time for the validation.
       * (Does not throw if the token is an invalid format.)
       */
      static validateTokenExpiration(token) {
        const t = _TunnelAccessTokenProperties.tryParse(token);
        if (t === null || t === void 0 ? void 0 : t.expiration) {
          if (t.expiration < /* @__PURE__ */ new Date()) {
            throw new Error("The access token is expired: " + t);
          }
        }
      }
      /**
       * Attempts to parse a tunnel access token (JWT). This does NOT validate the token
       * signature or any claims.
       */
      static tryParse(token) {
        if (typeof token !== "string")
          throw new TypeError("Token string expected.");
        const tokenParts = token.split(".");
        if (tokenParts.length !== 3) {
          return null;
        }
        const tokenBodyJson = _TunnelAccessTokenProperties.base64UrlDecode(tokenParts[1]);
        if (!tokenBodyJson) {
          return null;
        }
        try {
          const tokenJson = JSON.parse(tokenBodyJson);
          const clusterId = tokenJson.clusterId;
          const tunnelId = tokenJson.tunnelId;
          const ports = tokenJson.tunnelPorts;
          const scp = tokenJson.scp;
          const iss = tokenJson.iss;
          const exp = tokenJson.exp;
          return new _TunnelAccessTokenProperties(clusterId, tunnelId, typeof ports === "number" ? [ports] : ports, scp === null || scp === void 0 ? void 0 : scp.split(" "), iss, typeof exp === "number" ? new Date(exp * 1e3) : void 0);
        } catch (_a) {
          return null;
        }
      }
      /**
       * Gets the tunnal access token trace string.
       * 'none' if null or undefined, parsed token info if can be parsed, or 'token' if cannot be parsed.
       */
      static getTokenTrace(token) {
        var _a, _b;
        return !token ? "none" : (_b = (_a = _TunnelAccessTokenProperties.tryParse(token)) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : "token";
      }
      /**
       * Gets a tunnel access token that matches any of the provided access token scopes.
       * @param tunnel The tunnel to get the access tokens from.
       * @param accessTokenScopes What scopes the token needs to have.
       * @returns Tunnel access token if found; otherwise, undefined.
       */
      static getTunnelAccessToken(tunnel, accessTokenScopes) {
        if (!(tunnel === null || tunnel === void 0 ? void 0 : tunnel.accessTokens) || !accessTokenScopes) {
          return;
        }
        if (!Array.isArray(accessTokenScopes)) {
          accessTokenScopes = [accessTokenScopes];
        }
        for (const scope of accessTokenScopes) {
          for (const [key, accessToken] of Object.entries(tunnel.accessTokens)) {
            if (accessToken && key.split(" ").includes(scope)) {
              return accessToken;
            }
          }
        }
      }
      static base64UrlDecode(encodedString) {
        encodedString = encodedString.replace("-", "+");
        while (encodedString.length % 4 !== 0) {
          encodedString += "=";
        }
        try {
          const result = atob(encodedString);
          return result;
        } catch (_a) {
          return null;
        }
      }
    };
    exports2.TunnelAccessTokenProperties = TunnelAccessTokenProperties;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-management/package.json
var require_package2 = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-management/package.json"(exports2, module2) {
    module2.exports = {
      name: "@microsoft/dev-tunnels-management",
      version: "1.3.6",
      description: "Tunnels library for Visual Studio tools",
      keywords: [
        "Tunnels"
      ],
      author: "Microsoft",
      license: "MIT",
      dependencies: {
        buffer: "^5.2.1",
        debug: "^4.1.1",
        "vscode-jsonrpc": "^4.0.0",
        "@microsoft/dev-tunnels-contracts": "^1.3.6",
        axios: "^1.8.4"
      },
      main: "./index.js"
    };
  }
});

// ../../node_modules/@microsoft/dev-tunnels-management/version.js
var require_version = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-management/version.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.tunnelSdkUserAgent = void 0;
    var packageJson = require_package2();
    var packageVersion = packageJson.version;
    exports2.tunnelSdkUserAgent = `Dev-Tunnels-Service-TypeScript-SDK/${packageVersion}`;
  }
});

// ../../node_modules/delayed-stream/lib/delayed_stream.js
var require_delayed_stream = __commonJS({
  "../../node_modules/delayed-stream/lib/delayed_stream.js"(exports2, module2) {
    "use strict";
    var Stream = require("stream").Stream;
    var util = require("util");
    module2.exports = DelayedStream;
    function DelayedStream() {
      this.source = null;
      this.dataSize = 0;
      this.maxDataSize = 1024 * 1024;
      this.pauseStream = true;
      this._maxDataSizeExceeded = false;
      this._released = false;
      this._bufferedEvents = [];
    }
    util.inherits(DelayedStream, Stream);
    DelayedStream.create = function(source, options) {
      var delayedStream = new this();
      options = options || {};
      for (var option in options) {
        delayedStream[option] = options[option];
      }
      delayedStream.source = source;
      var realEmit = source.emit;
      source.emit = function() {
        delayedStream._handleEmit(arguments);
        return realEmit.apply(source, arguments);
      };
      source.on("error", function() {
      });
      if (delayedStream.pauseStream) {
        source.pause();
      }
      return delayedStream;
    };
    Object.defineProperty(DelayedStream.prototype, "readable", {
      configurable: true,
      enumerable: true,
      get: function() {
        return this.source.readable;
      }
    });
    DelayedStream.prototype.setEncoding = function() {
      return this.source.setEncoding.apply(this.source, arguments);
    };
    DelayedStream.prototype.resume = function() {
      if (!this._released) {
        this.release();
      }
      this.source.resume();
    };
    DelayedStream.prototype.pause = function() {
      this.source.pause();
    };
    DelayedStream.prototype.release = function() {
      this._released = true;
      this._bufferedEvents.forEach(function(args) {
        this.emit.apply(this, args);
      }.bind(this));
      this._bufferedEvents = [];
    };
    DelayedStream.prototype.pipe = function() {
      var r = Stream.prototype.pipe.apply(this, arguments);
      this.resume();
      return r;
    };
    DelayedStream.prototype._handleEmit = function(args) {
      if (this._released) {
        this.emit.apply(this, args);
        return;
      }
      if (args[0] === "data") {
        this.dataSize += args[1].length;
        this._checkIfMaxDataSizeExceeded();
      }
      this._bufferedEvents.push(args);
    };
    DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
      if (this._maxDataSizeExceeded) {
        return;
      }
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
      this._maxDataSizeExceeded = true;
      var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
      this.emit("error", new Error(message));
    };
  }
});

// ../../node_modules/combined-stream/lib/combined_stream.js
var require_combined_stream = __commonJS({
  "../../node_modules/combined-stream/lib/combined_stream.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var Stream = require("stream").Stream;
    var DelayedStream = require_delayed_stream();
    module2.exports = CombinedStream;
    function CombinedStream() {
      this.writable = false;
      this.readable = true;
      this.dataSize = 0;
      this.maxDataSize = 2 * 1024 * 1024;
      this.pauseStreams = true;
      this._released = false;
      this._streams = [];
      this._currentStream = null;
      this._insideLoop = false;
      this._pendingNext = false;
    }
    util.inherits(CombinedStream, Stream);
    CombinedStream.create = function(options) {
      var combinedStream = new this();
      options = options || {};
      for (var option in options) {
        combinedStream[option] = options[option];
      }
      return combinedStream;
    };
    CombinedStream.isStreamLike = function(stream) {
      return typeof stream !== "function" && typeof stream !== "string" && typeof stream !== "boolean" && typeof stream !== "number" && !Buffer.isBuffer(stream);
    };
    CombinedStream.prototype.append = function(stream) {
      var isStreamLike = CombinedStream.isStreamLike(stream);
      if (isStreamLike) {
        if (!(stream instanceof DelayedStream)) {
          var newStream = DelayedStream.create(stream, {
            maxDataSize: Infinity,
            pauseStream: this.pauseStreams
          });
          stream.on("data", this._checkDataSize.bind(this));
          stream = newStream;
        }
        this._handleErrors(stream);
        if (this.pauseStreams) {
          stream.pause();
        }
      }
      this._streams.push(stream);
      return this;
    };
    CombinedStream.prototype.pipe = function(dest, options) {
      Stream.prototype.pipe.call(this, dest, options);
      this.resume();
      return dest;
    };
    CombinedStream.prototype._getNext = function() {
      this._currentStream = null;
      if (this._insideLoop) {
        this._pendingNext = true;
        return;
      }
      this._insideLoop = true;
      try {
        do {
          this._pendingNext = false;
          this._realGetNext();
        } while (this._pendingNext);
      } finally {
        this._insideLoop = false;
      }
    };
    CombinedStream.prototype._realGetNext = function() {
      var stream = this._streams.shift();
      if (typeof stream == "undefined") {
        this.end();
        return;
      }
      if (typeof stream !== "function") {
        this._pipeNext(stream);
        return;
      }
      var getStream = stream;
      getStream(function(stream2) {
        var isStreamLike = CombinedStream.isStreamLike(stream2);
        if (isStreamLike) {
          stream2.on("data", this._checkDataSize.bind(this));
          this._handleErrors(stream2);
        }
        this._pipeNext(stream2);
      }.bind(this));
    };
    CombinedStream.prototype._pipeNext = function(stream) {
      this._currentStream = stream;
      var isStreamLike = CombinedStream.isStreamLike(stream);
      if (isStreamLike) {
        stream.on("end", this._getNext.bind(this));
        stream.pipe(this, { end: false });
        return;
      }
      var value = stream;
      this.write(value);
      this._getNext();
    };
    CombinedStream.prototype._handleErrors = function(stream) {
      var self2 = this;
      stream.on("error", function(err) {
        self2._emitError(err);
      });
    };
    CombinedStream.prototype.write = function(data) {
      this.emit("data", data);
    };
    CombinedStream.prototype.pause = function() {
      if (!this.pauseStreams) {
        return;
      }
      if (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == "function") this._currentStream.pause();
      this.emit("pause");
    };
    CombinedStream.prototype.resume = function() {
      if (!this._released) {
        this._released = true;
        this.writable = true;
        this._getNext();
      }
      if (this.pauseStreams && this._currentStream && typeof this._currentStream.resume == "function") this._currentStream.resume();
      this.emit("resume");
    };
    CombinedStream.prototype.end = function() {
      this._reset();
      this.emit("end");
    };
    CombinedStream.prototype.destroy = function() {
      this._reset();
      this.emit("close");
    };
    CombinedStream.prototype._reset = function() {
      this.writable = false;
      this._streams = [];
      this._currentStream = null;
    };
    CombinedStream.prototype._checkDataSize = function() {
      this._updateDataSize();
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
      var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
      this._emitError(new Error(message));
    };
    CombinedStream.prototype._updateDataSize = function() {
      this.dataSize = 0;
      var self2 = this;
      this._streams.forEach(function(stream) {
        if (!stream.dataSize) {
          return;
        }
        self2.dataSize += stream.dataSize;
      });
      if (this._currentStream && this._currentStream.dataSize) {
        this.dataSize += this._currentStream.dataSize;
      }
    };
    CombinedStream.prototype._emitError = function(err) {
      this._reset();
      this.emit("error", err);
    };
  }
});

// ../../node_modules/mime-db/db.json
var require_db = __commonJS({
  "../../node_modules/mime-db/db.json"(exports2, module2) {
    module2.exports = {
      "application/1d-interleaved-parityfec": {
        source: "iana"
      },
      "application/3gpdash-qoe-report+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/3gpp-ims+xml": {
        source: "iana",
        compressible: true
      },
      "application/3gpphal+json": {
        source: "iana",
        compressible: true
      },
      "application/3gpphalforms+json": {
        source: "iana",
        compressible: true
      },
      "application/a2l": {
        source: "iana"
      },
      "application/ace+cbor": {
        source: "iana"
      },
      "application/activemessage": {
        source: "iana"
      },
      "application/activity+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-directory+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcost+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcostparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointprop+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointpropparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-error+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamcontrol+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamparams+json": {
        source: "iana",
        compressible: true
      },
      "application/aml": {
        source: "iana"
      },
      "application/andrew-inset": {
        source: "iana",
        extensions: ["ez"]
      },
      "application/applefile": {
        source: "iana"
      },
      "application/applixware": {
        source: "apache",
        extensions: ["aw"]
      },
      "application/at+jwt": {
        source: "iana"
      },
      "application/atf": {
        source: "iana"
      },
      "application/atfx": {
        source: "iana"
      },
      "application/atom+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atom"]
      },
      "application/atomcat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomcat"]
      },
      "application/atomdeleted+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomdeleted"]
      },
      "application/atomicmail": {
        source: "iana"
      },
      "application/atomsvc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomsvc"]
      },
      "application/atsc-dwd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dwd"]
      },
      "application/atsc-dynamic-event-message": {
        source: "iana"
      },
      "application/atsc-held+xml": {
        source: "iana",
        compressible: true,
        extensions: ["held"]
      },
      "application/atsc-rdt+json": {
        source: "iana",
        compressible: true
      },
      "application/atsc-rsat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsat"]
      },
      "application/atxml": {
        source: "iana"
      },
      "application/auth-policy+xml": {
        source: "iana",
        compressible: true
      },
      "application/bacnet-xdd+zip": {
        source: "iana",
        compressible: false
      },
      "application/batch-smtp": {
        source: "iana"
      },
      "application/bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/beep+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/calendar+json": {
        source: "iana",
        compressible: true
      },
      "application/calendar+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xcs"]
      },
      "application/call-completion": {
        source: "iana"
      },
      "application/cals-1840": {
        source: "iana"
      },
      "application/captive+json": {
        source: "iana",
        compressible: true
      },
      "application/cbor": {
        source: "iana"
      },
      "application/cbor-seq": {
        source: "iana"
      },
      "application/cccex": {
        source: "iana"
      },
      "application/ccmp+xml": {
        source: "iana",
        compressible: true
      },
      "application/ccxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ccxml"]
      },
      "application/cdfx+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdfx"]
      },
      "application/cdmi-capability": {
        source: "iana",
        extensions: ["cdmia"]
      },
      "application/cdmi-container": {
        source: "iana",
        extensions: ["cdmic"]
      },
      "application/cdmi-domain": {
        source: "iana",
        extensions: ["cdmid"]
      },
      "application/cdmi-object": {
        source: "iana",
        extensions: ["cdmio"]
      },
      "application/cdmi-queue": {
        source: "iana",
        extensions: ["cdmiq"]
      },
      "application/cdni": {
        source: "iana"
      },
      "application/cea": {
        source: "iana"
      },
      "application/cea-2018+xml": {
        source: "iana",
        compressible: true
      },
      "application/cellml+xml": {
        source: "iana",
        compressible: true
      },
      "application/cfw": {
        source: "iana"
      },
      "application/city+json": {
        source: "iana",
        compressible: true
      },
      "application/clr": {
        source: "iana"
      },
      "application/clue+xml": {
        source: "iana",
        compressible: true
      },
      "application/clue_info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cms": {
        source: "iana"
      },
      "application/cnrp+xml": {
        source: "iana",
        compressible: true
      },
      "application/coap-group+json": {
        source: "iana",
        compressible: true
      },
      "application/coap-payload": {
        source: "iana"
      },
      "application/commonground": {
        source: "iana"
      },
      "application/conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cose": {
        source: "iana"
      },
      "application/cose-key": {
        source: "iana"
      },
      "application/cose-key-set": {
        source: "iana"
      },
      "application/cpl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cpl"]
      },
      "application/csrattrs": {
        source: "iana"
      },
      "application/csta+xml": {
        source: "iana",
        compressible: true
      },
      "application/cstadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/csvm+json": {
        source: "iana",
        compressible: true
      },
      "application/cu-seeme": {
        source: "apache",
        extensions: ["cu"]
      },
      "application/cwt": {
        source: "iana"
      },
      "application/cybercash": {
        source: "iana"
      },
      "application/dart": {
        compressible: true
      },
      "application/dash+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpd"]
      },
      "application/dash-patch+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpp"]
      },
      "application/dashdelta": {
        source: "iana"
      },
      "application/davmount+xml": {
        source: "iana",
        compressible: true,
        extensions: ["davmount"]
      },
      "application/dca-rft": {
        source: "iana"
      },
      "application/dcd": {
        source: "iana"
      },
      "application/dec-dx": {
        source: "iana"
      },
      "application/dialog-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/dicom": {
        source: "iana"
      },
      "application/dicom+json": {
        source: "iana",
        compressible: true
      },
      "application/dicom+xml": {
        source: "iana",
        compressible: true
      },
      "application/dii": {
        source: "iana"
      },
      "application/dit": {
        source: "iana"
      },
      "application/dns": {
        source: "iana"
      },
      "application/dns+json": {
        source: "iana",
        compressible: true
      },
      "application/dns-message": {
        source: "iana"
      },
      "application/docbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dbk"]
      },
      "application/dots+cbor": {
        source: "iana"
      },
      "application/dskpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/dssc+der": {
        source: "iana",
        extensions: ["dssc"]
      },
      "application/dssc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdssc"]
      },
      "application/dvcs": {
        source: "iana"
      },
      "application/ecmascript": {
        source: "iana",
        compressible: true,
        extensions: ["es", "ecma"]
      },
      "application/edi-consent": {
        source: "iana"
      },
      "application/edi-x12": {
        source: "iana",
        compressible: false
      },
      "application/edifact": {
        source: "iana",
        compressible: false
      },
      "application/efi": {
        source: "iana"
      },
      "application/elm+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/elm+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.cap+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/emergencycalldata.comment+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.control+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.deviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.ecall.msd": {
        source: "iana"
      },
      "application/emergencycalldata.providerinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.serviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.subscriberinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.veds+xml": {
        source: "iana",
        compressible: true
      },
      "application/emma+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emma"]
      },
      "application/emotionml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emotionml"]
      },
      "application/encaprtp": {
        source: "iana"
      },
      "application/epp+xml": {
        source: "iana",
        compressible: true
      },
      "application/epub+zip": {
        source: "iana",
        compressible: false,
        extensions: ["epub"]
      },
      "application/eshop": {
        source: "iana"
      },
      "application/exi": {
        source: "iana",
        extensions: ["exi"]
      },
      "application/expect-ct-report+json": {
        source: "iana",
        compressible: true
      },
      "application/express": {
        source: "iana",
        extensions: ["exp"]
      },
      "application/fastinfoset": {
        source: "iana"
      },
      "application/fastsoap": {
        source: "iana"
      },
      "application/fdt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fdt"]
      },
      "application/fhir+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fhir+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fido.trusted-apps+json": {
        compressible: true
      },
      "application/fits": {
        source: "iana"
      },
      "application/flexfec": {
        source: "iana"
      },
      "application/font-sfnt": {
        source: "iana"
      },
      "application/font-tdpfr": {
        source: "iana",
        extensions: ["pfr"]
      },
      "application/font-woff": {
        source: "iana",
        compressible: false
      },
      "application/framework-attributes+xml": {
        source: "iana",
        compressible: true
      },
      "application/geo+json": {
        source: "iana",
        compressible: true,
        extensions: ["geojson"]
      },
      "application/geo+json-seq": {
        source: "iana"
      },
      "application/geopackage+sqlite3": {
        source: "iana"
      },
      "application/geoxacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/gltf-buffer": {
        source: "iana"
      },
      "application/gml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["gml"]
      },
      "application/gpx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["gpx"]
      },
      "application/gxf": {
        source: "apache",
        extensions: ["gxf"]
      },
      "application/gzip": {
        source: "iana",
        compressible: false,
        extensions: ["gz"]
      },
      "application/h224": {
        source: "iana"
      },
      "application/held+xml": {
        source: "iana",
        compressible: true
      },
      "application/hjson": {
        extensions: ["hjson"]
      },
      "application/http": {
        source: "iana"
      },
      "application/hyperstudio": {
        source: "iana",
        extensions: ["stk"]
      },
      "application/ibe-key-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pkg-reply+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pp-data": {
        source: "iana"
      },
      "application/iges": {
        source: "iana"
      },
      "application/im-iscomposing+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/index": {
        source: "iana"
      },
      "application/index.cmd": {
        source: "iana"
      },
      "application/index.obj": {
        source: "iana"
      },
      "application/index.response": {
        source: "iana"
      },
      "application/index.vnd": {
        source: "iana"
      },
      "application/inkml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ink", "inkml"]
      },
      "application/iotp": {
        source: "iana"
      },
      "application/ipfix": {
        source: "iana",
        extensions: ["ipfix"]
      },
      "application/ipp": {
        source: "iana"
      },
      "application/isup": {
        source: "iana"
      },
      "application/its+xml": {
        source: "iana",
        compressible: true,
        extensions: ["its"]
      },
      "application/java-archive": {
        source: "apache",
        compressible: false,
        extensions: ["jar", "war", "ear"]
      },
      "application/java-serialized-object": {
        source: "apache",
        compressible: false,
        extensions: ["ser"]
      },
      "application/java-vm": {
        source: "apache",
        compressible: false,
        extensions: ["class"]
      },
      "application/javascript": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["js", "mjs"]
      },
      "application/jf2feed+json": {
        source: "iana",
        compressible: true
      },
      "application/jose": {
        source: "iana"
      },
      "application/jose+json": {
        source: "iana",
        compressible: true
      },
      "application/jrd+json": {
        source: "iana",
        compressible: true
      },
      "application/jscalendar+json": {
        source: "iana",
        compressible: true
      },
      "application/json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["json", "map"]
      },
      "application/json-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/json-seq": {
        source: "iana"
      },
      "application/json5": {
        extensions: ["json5"]
      },
      "application/jsonml+json": {
        source: "apache",
        compressible: true,
        extensions: ["jsonml"]
      },
      "application/jwk+json": {
        source: "iana",
        compressible: true
      },
      "application/jwk-set+json": {
        source: "iana",
        compressible: true
      },
      "application/jwt": {
        source: "iana"
      },
      "application/kpml-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/kpml-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/ld+json": {
        source: "iana",
        compressible: true,
        extensions: ["jsonld"]
      },
      "application/lgr+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lgr"]
      },
      "application/link-format": {
        source: "iana"
      },
      "application/load-control+xml": {
        source: "iana",
        compressible: true
      },
      "application/lost+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lostxml"]
      },
      "application/lostsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/lpf+zip": {
        source: "iana",
        compressible: false
      },
      "application/lxf": {
        source: "iana"
      },
      "application/mac-binhex40": {
        source: "iana",
        extensions: ["hqx"]
      },
      "application/mac-compactpro": {
        source: "apache",
        extensions: ["cpt"]
      },
      "application/macwriteii": {
        source: "iana"
      },
      "application/mads+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mads"]
      },
      "application/manifest+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["webmanifest"]
      },
      "application/marc": {
        source: "iana",
        extensions: ["mrc"]
      },
      "application/marcxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mrcx"]
      },
      "application/mathematica": {
        source: "iana",
        extensions: ["ma", "nb", "mb"]
      },
      "application/mathml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mathml"]
      },
      "application/mathml-content+xml": {
        source: "iana",
        compressible: true
      },
      "application/mathml-presentation+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-associated-procedure-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-deregister+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-envelope+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-protection-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-reception-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-schedule+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-user-service-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbox": {
        source: "iana",
        extensions: ["mbox"]
      },
      "application/media-policy-dataset+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpf"]
      },
      "application/media_control+xml": {
        source: "iana",
        compressible: true
      },
      "application/mediaservercontrol+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mscml"]
      },
      "application/merge-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/metalink+xml": {
        source: "apache",
        compressible: true,
        extensions: ["metalink"]
      },
      "application/metalink4+xml": {
        source: "iana",
        compressible: true,
        extensions: ["meta4"]
      },
      "application/mets+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mets"]
      },
      "application/mf4": {
        source: "iana"
      },
      "application/mikey": {
        source: "iana"
      },
      "application/mipc": {
        source: "iana"
      },
      "application/missing-blocks+cbor-seq": {
        source: "iana"
      },
      "application/mmt-aei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["maei"]
      },
      "application/mmt-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musd"]
      },
      "application/mods+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mods"]
      },
      "application/moss-keys": {
        source: "iana"
      },
      "application/moss-signature": {
        source: "iana"
      },
      "application/mosskey-data": {
        source: "iana"
      },
      "application/mosskey-request": {
        source: "iana"
      },
      "application/mp21": {
        source: "iana",
        extensions: ["m21", "mp21"]
      },
      "application/mp4": {
        source: "iana",
        extensions: ["mp4s", "m4p"]
      },
      "application/mpeg4-generic": {
        source: "iana"
      },
      "application/mpeg4-iod": {
        source: "iana"
      },
      "application/mpeg4-iod-xmt": {
        source: "iana"
      },
      "application/mrb-consumer+xml": {
        source: "iana",
        compressible: true
      },
      "application/mrb-publish+xml": {
        source: "iana",
        compressible: true
      },
      "application/msc-ivr+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msc-mixer+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msword": {
        source: "iana",
        compressible: false,
        extensions: ["doc", "dot"]
      },
      "application/mud+json": {
        source: "iana",
        compressible: true
      },
      "application/multipart-core": {
        source: "iana"
      },
      "application/mxf": {
        source: "iana",
        extensions: ["mxf"]
      },
      "application/n-quads": {
        source: "iana",
        extensions: ["nq"]
      },
      "application/n-triples": {
        source: "iana",
        extensions: ["nt"]
      },
      "application/nasdata": {
        source: "iana"
      },
      "application/news-checkgroups": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-groupinfo": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-transmission": {
        source: "iana"
      },
      "application/nlsml+xml": {
        source: "iana",
        compressible: true
      },
      "application/node": {
        source: "iana",
        extensions: ["cjs"]
      },
      "application/nss": {
        source: "iana"
      },
      "application/oauth-authz-req+jwt": {
        source: "iana"
      },
      "application/oblivious-dns-message": {
        source: "iana"
      },
      "application/ocsp-request": {
        source: "iana"
      },
      "application/ocsp-response": {
        source: "iana"
      },
      "application/octet-stream": {
        source: "iana",
        compressible: false,
        extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
      },
      "application/oda": {
        source: "iana",
        extensions: ["oda"]
      },
      "application/odm+xml": {
        source: "iana",
        compressible: true
      },
      "application/odx": {
        source: "iana"
      },
      "application/oebps-package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["opf"]
      },
      "application/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogx"]
      },
      "application/omdoc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["omdoc"]
      },
      "application/onenote": {
        source: "apache",
        extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
      },
      "application/opc-nodeset+xml": {
        source: "iana",
        compressible: true
      },
      "application/oscore": {
        source: "iana"
      },
      "application/oxps": {
        source: "iana",
        extensions: ["oxps"]
      },
      "application/p21": {
        source: "iana"
      },
      "application/p21+zip": {
        source: "iana",
        compressible: false
      },
      "application/p2p-overlay+xml": {
        source: "iana",
        compressible: true,
        extensions: ["relo"]
      },
      "application/parityfec": {
        source: "iana"
      },
      "application/passport": {
        source: "iana"
      },
      "application/patch-ops-error+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xer"]
      },
      "application/pdf": {
        source: "iana",
        compressible: false,
        extensions: ["pdf"]
      },
      "application/pdx": {
        source: "iana"
      },
      "application/pem-certificate-chain": {
        source: "iana"
      },
      "application/pgp-encrypted": {
        source: "iana",
        compressible: false,
        extensions: ["pgp"]
      },
      "application/pgp-keys": {
        source: "iana",
        extensions: ["asc"]
      },
      "application/pgp-signature": {
        source: "iana",
        extensions: ["asc", "sig"]
      },
      "application/pics-rules": {
        source: "apache",
        extensions: ["prf"]
      },
      "application/pidf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pidf-diff+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pkcs10": {
        source: "iana",
        extensions: ["p10"]
      },
      "application/pkcs12": {
        source: "iana"
      },
      "application/pkcs7-mime": {
        source: "iana",
        extensions: ["p7m", "p7c"]
      },
      "application/pkcs7-signature": {
        source: "iana",
        extensions: ["p7s"]
      },
      "application/pkcs8": {
        source: "iana",
        extensions: ["p8"]
      },
      "application/pkcs8-encrypted": {
        source: "iana"
      },
      "application/pkix-attr-cert": {
        source: "iana",
        extensions: ["ac"]
      },
      "application/pkix-cert": {
        source: "iana",
        extensions: ["cer"]
      },
      "application/pkix-crl": {
        source: "iana",
        extensions: ["crl"]
      },
      "application/pkix-pkipath": {
        source: "iana",
        extensions: ["pkipath"]
      },
      "application/pkixcmp": {
        source: "iana",
        extensions: ["pki"]
      },
      "application/pls+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pls"]
      },
      "application/poc-settings+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/postscript": {
        source: "iana",
        compressible: true,
        extensions: ["ai", "eps", "ps"]
      },
      "application/ppsp-tracker+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+xml": {
        source: "iana",
        compressible: true
      },
      "application/provenance+xml": {
        source: "iana",
        compressible: true,
        extensions: ["provx"]
      },
      "application/prs.alvestrand.titrax-sheet": {
        source: "iana"
      },
      "application/prs.cww": {
        source: "iana",
        extensions: ["cww"]
      },
      "application/prs.cyn": {
        source: "iana",
        charset: "7-BIT"
      },
      "application/prs.hpub+zip": {
        source: "iana",
        compressible: false
      },
      "application/prs.nprend": {
        source: "iana"
      },
      "application/prs.plucker": {
        source: "iana"
      },
      "application/prs.rdf-xml-crypt": {
        source: "iana"
      },
      "application/prs.xsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/pskc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pskcxml"]
      },
      "application/pvd+json": {
        source: "iana",
        compressible: true
      },
      "application/qsig": {
        source: "iana"
      },
      "application/raml+yaml": {
        compressible: true,
        extensions: ["raml"]
      },
      "application/raptorfec": {
        source: "iana"
      },
      "application/rdap+json": {
        source: "iana",
        compressible: true
      },
      "application/rdf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rdf", "owl"]
      },
      "application/reginfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rif"]
      },
      "application/relax-ng-compact-syntax": {
        source: "iana",
        extensions: ["rnc"]
      },
      "application/remote-printing": {
        source: "iana"
      },
      "application/reputon+json": {
        source: "iana",
        compressible: true
      },
      "application/resource-lists+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rl"]
      },
      "application/resource-lists-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rld"]
      },
      "application/rfc+xml": {
        source: "iana",
        compressible: true
      },
      "application/riscos": {
        source: "iana"
      },
      "application/rlmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/rls-services+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rs"]
      },
      "application/route-apd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rapd"]
      },
      "application/route-s-tsid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sls"]
      },
      "application/route-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rusd"]
      },
      "application/rpki-ghostbusters": {
        source: "iana",
        extensions: ["gbr"]
      },
      "application/rpki-manifest": {
        source: "iana",
        extensions: ["mft"]
      },
      "application/rpki-publication": {
        source: "iana"
      },
      "application/rpki-roa": {
        source: "iana",
        extensions: ["roa"]
      },
      "application/rpki-updown": {
        source: "iana"
      },
      "application/rsd+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rsd"]
      },
      "application/rss+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rss"]
      },
      "application/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "application/rtploopback": {
        source: "iana"
      },
      "application/rtx": {
        source: "iana"
      },
      "application/samlassertion+xml": {
        source: "iana",
        compressible: true
      },
      "application/samlmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/sarif+json": {
        source: "iana",
        compressible: true
      },
      "application/sarif-external-properties+json": {
        source: "iana",
        compressible: true
      },
      "application/sbe": {
        source: "iana"
      },
      "application/sbml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sbml"]
      },
      "application/scaip+xml": {
        source: "iana",
        compressible: true
      },
      "application/scim+json": {
        source: "iana",
        compressible: true
      },
      "application/scvp-cv-request": {
        source: "iana",
        extensions: ["scq"]
      },
      "application/scvp-cv-response": {
        source: "iana",
        extensions: ["scs"]
      },
      "application/scvp-vp-request": {
        source: "iana",
        extensions: ["spq"]
      },
      "application/scvp-vp-response": {
        source: "iana",
        extensions: ["spp"]
      },
      "application/sdp": {
        source: "iana",
        extensions: ["sdp"]
      },
      "application/secevent+jwt": {
        source: "iana"
      },
      "application/senml+cbor": {
        source: "iana"
      },
      "application/senml+json": {
        source: "iana",
        compressible: true
      },
      "application/senml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["senmlx"]
      },
      "application/senml-etch+cbor": {
        source: "iana"
      },
      "application/senml-etch+json": {
        source: "iana",
        compressible: true
      },
      "application/senml-exi": {
        source: "iana"
      },
      "application/sensml+cbor": {
        source: "iana"
      },
      "application/sensml+json": {
        source: "iana",
        compressible: true
      },
      "application/sensml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sensmlx"]
      },
      "application/sensml-exi": {
        source: "iana"
      },
      "application/sep+xml": {
        source: "iana",
        compressible: true
      },
      "application/sep-exi": {
        source: "iana"
      },
      "application/session-info": {
        source: "iana"
      },
      "application/set-payment": {
        source: "iana"
      },
      "application/set-payment-initiation": {
        source: "iana",
        extensions: ["setpay"]
      },
      "application/set-registration": {
        source: "iana"
      },
      "application/set-registration-initiation": {
        source: "iana",
        extensions: ["setreg"]
      },
      "application/sgml": {
        source: "iana"
      },
      "application/sgml-open-catalog": {
        source: "iana"
      },
      "application/shf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["shf"]
      },
      "application/sieve": {
        source: "iana",
        extensions: ["siv", "sieve"]
      },
      "application/simple-filter+xml": {
        source: "iana",
        compressible: true
      },
      "application/simple-message-summary": {
        source: "iana"
      },
      "application/simplesymbolcontainer": {
        source: "iana"
      },
      "application/sipc": {
        source: "iana"
      },
      "application/slate": {
        source: "iana"
      },
      "application/smil": {
        source: "iana"
      },
      "application/smil+xml": {
        source: "iana",
        compressible: true,
        extensions: ["smi", "smil"]
      },
      "application/smpte336m": {
        source: "iana"
      },
      "application/soap+fastinfoset": {
        source: "iana"
      },
      "application/soap+xml": {
        source: "iana",
        compressible: true
      },
      "application/sparql-query": {
        source: "iana",
        extensions: ["rq"]
      },
      "application/sparql-results+xml": {
        source: "iana",
        compressible: true,
        extensions: ["srx"]
      },
      "application/spdx+json": {
        source: "iana",
        compressible: true
      },
      "application/spirits-event+xml": {
        source: "iana",
        compressible: true
      },
      "application/sql": {
        source: "iana"
      },
      "application/srgs": {
        source: "iana",
        extensions: ["gram"]
      },
      "application/srgs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["grxml"]
      },
      "application/sru+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sru"]
      },
      "application/ssdl+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ssdl"]
      },
      "application/ssml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ssml"]
      },
      "application/stix+json": {
        source: "iana",
        compressible: true
      },
      "application/swid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["swidtag"]
      },
      "application/tamp-apex-update": {
        source: "iana"
      },
      "application/tamp-apex-update-confirm": {
        source: "iana"
      },
      "application/tamp-community-update": {
        source: "iana"
      },
      "application/tamp-community-update-confirm": {
        source: "iana"
      },
      "application/tamp-error": {
        source: "iana"
      },
      "application/tamp-sequence-adjust": {
        source: "iana"
      },
      "application/tamp-sequence-adjust-confirm": {
        source: "iana"
      },
      "application/tamp-status-query": {
        source: "iana"
      },
      "application/tamp-status-response": {
        source: "iana"
      },
      "application/tamp-update": {
        source: "iana"
      },
      "application/tamp-update-confirm": {
        source: "iana"
      },
      "application/tar": {
        compressible: true
      },
      "application/taxii+json": {
        source: "iana",
        compressible: true
      },
      "application/td+json": {
        source: "iana",
        compressible: true
      },
      "application/tei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tei", "teicorpus"]
      },
      "application/tetra_isi": {
        source: "iana"
      },
      "application/thraud+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tfi"]
      },
      "application/timestamp-query": {
        source: "iana"
      },
      "application/timestamp-reply": {
        source: "iana"
      },
      "application/timestamped-data": {
        source: "iana",
        extensions: ["tsd"]
      },
      "application/tlsrpt+gzip": {
        source: "iana"
      },
      "application/tlsrpt+json": {
        source: "iana",
        compressible: true
      },
      "application/tnauthlist": {
        source: "iana"
      },
      "application/token-introspection+jwt": {
        source: "iana"
      },
      "application/toml": {
        compressible: true,
        extensions: ["toml"]
      },
      "application/trickle-ice-sdpfrag": {
        source: "iana"
      },
      "application/trig": {
        source: "iana",
        extensions: ["trig"]
      },
      "application/ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ttml"]
      },
      "application/tve-trigger": {
        source: "iana"
      },
      "application/tzif": {
        source: "iana"
      },
      "application/tzif-leap": {
        source: "iana"
      },
      "application/ubjson": {
        compressible: false,
        extensions: ["ubj"]
      },
      "application/ulpfec": {
        source: "iana"
      },
      "application/urc-grpsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/urc-ressheet+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsheet"]
      },
      "application/urc-targetdesc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["td"]
      },
      "application/urc-uisocketdesc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vcard+json": {
        source: "iana",
        compressible: true
      },
      "application/vcard+xml": {
        source: "iana",
        compressible: true
      },
      "application/vemmi": {
        source: "iana"
      },
      "application/vividence.scriptfile": {
        source: "apache"
      },
      "application/vnd.1000minds.decision-model+xml": {
        source: "iana",
        compressible: true,
        extensions: ["1km"]
      },
      "application/vnd.3gpp-prose+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-prose-pc3ch+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-v2x-local-service-information": {
        source: "iana"
      },
      "application/vnd.3gpp.5gnas": {
        source: "iana"
      },
      "application/vnd.3gpp.access-transfer-events+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.bsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gmop+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gtpc": {
        source: "iana"
      },
      "application/vnd.3gpp.interworking-data": {
        source: "iana"
      },
      "application/vnd.3gpp.lpp": {
        source: "iana"
      },
      "application/vnd.3gpp.mc-signalling-ear": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-payload": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-signalling": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-floor-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-signed+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-init-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-transmission-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mid-call+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ngap": {
        source: "iana"
      },
      "application/vnd.3gpp.pfcp": {
        source: "iana"
      },
      "application/vnd.3gpp.pic-bw-large": {
        source: "iana",
        extensions: ["plb"]
      },
      "application/vnd.3gpp.pic-bw-small": {
        source: "iana",
        extensions: ["psb"]
      },
      "application/vnd.3gpp.pic-bw-var": {
        source: "iana",
        extensions: ["pvb"]
      },
      "application/vnd.3gpp.s1ap": {
        source: "iana"
      },
      "application/vnd.3gpp.sms": {
        source: "iana"
      },
      "application/vnd.3gpp.sms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-ext+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.state-and-event-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ussd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.bcmcsinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.sms": {
        source: "iana"
      },
      "application/vnd.3gpp2.tcap": {
        source: "iana",
        extensions: ["tcap"]
      },
      "application/vnd.3lightssoftware.imagescal": {
        source: "iana"
      },
      "application/vnd.3m.post-it-notes": {
        source: "iana",
        extensions: ["pwn"]
      },
      "application/vnd.accpac.simply.aso": {
        source: "iana",
        extensions: ["aso"]
      },
      "application/vnd.accpac.simply.imp": {
        source: "iana",
        extensions: ["imp"]
      },
      "application/vnd.acucobol": {
        source: "iana",
        extensions: ["acu"]
      },
      "application/vnd.acucorp": {
        source: "iana",
        extensions: ["atc", "acutc"]
      },
      "application/vnd.adobe.air-application-installer-package+zip": {
        source: "apache",
        compressible: false,
        extensions: ["air"]
      },
      "application/vnd.adobe.flash.movie": {
        source: "iana"
      },
      "application/vnd.adobe.formscentral.fcdt": {
        source: "iana",
        extensions: ["fcdt"]
      },
      "application/vnd.adobe.fxp": {
        source: "iana",
        extensions: ["fxp", "fxpl"]
      },
      "application/vnd.adobe.partial-upload": {
        source: "iana"
      },
      "application/vnd.adobe.xdp+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdp"]
      },
      "application/vnd.adobe.xfdf": {
        source: "iana",
        extensions: ["xfdf"]
      },
      "application/vnd.aether.imp": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata-pagedef": {
        source: "iana"
      },
      "application/vnd.afpc.cmoca-cmresource": {
        source: "iana"
      },
      "application/vnd.afpc.foca-charset": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codedfont": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codepage": {
        source: "iana"
      },
      "application/vnd.afpc.modca": {
        source: "iana"
      },
      "application/vnd.afpc.modca-cmtable": {
        source: "iana"
      },
      "application/vnd.afpc.modca-formdef": {
        source: "iana"
      },
      "application/vnd.afpc.modca-mediummap": {
        source: "iana"
      },
      "application/vnd.afpc.modca-objectcontainer": {
        source: "iana"
      },
      "application/vnd.afpc.modca-overlay": {
        source: "iana"
      },
      "application/vnd.afpc.modca-pagesegment": {
        source: "iana"
      },
      "application/vnd.age": {
        source: "iana",
        extensions: ["age"]
      },
      "application/vnd.ah-barcode": {
        source: "iana"
      },
      "application/vnd.ahead.space": {
        source: "iana",
        extensions: ["ahead"]
      },
      "application/vnd.airzip.filesecure.azf": {
        source: "iana",
        extensions: ["azf"]
      },
      "application/vnd.airzip.filesecure.azs": {
        source: "iana",
        extensions: ["azs"]
      },
      "application/vnd.amadeus+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.amazon.ebook": {
        source: "apache",
        extensions: ["azw"]
      },
      "application/vnd.amazon.mobi8-ebook": {
        source: "iana"
      },
      "application/vnd.americandynamics.acc": {
        source: "iana",
        extensions: ["acc"]
      },
      "application/vnd.amiga.ami": {
        source: "iana",
        extensions: ["ami"]
      },
      "application/vnd.amundsen.maze+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.android.ota": {
        source: "iana"
      },
      "application/vnd.android.package-archive": {
        source: "apache",
        compressible: false,
        extensions: ["apk"]
      },
      "application/vnd.anki": {
        source: "iana"
      },
      "application/vnd.anser-web-certificate-issue-initiation": {
        source: "iana",
        extensions: ["cii"]
      },
      "application/vnd.anser-web-funds-transfer-initiation": {
        source: "apache",
        extensions: ["fti"]
      },
      "application/vnd.antix.game-component": {
        source: "iana",
        extensions: ["atx"]
      },
      "application/vnd.apache.arrow.file": {
        source: "iana"
      },
      "application/vnd.apache.arrow.stream": {
        source: "iana"
      },
      "application/vnd.apache.thrift.binary": {
        source: "iana"
      },
      "application/vnd.apache.thrift.compact": {
        source: "iana"
      },
      "application/vnd.apache.thrift.json": {
        source: "iana"
      },
      "application/vnd.api+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.aplextor.warrp+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apothekende.reservation+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apple.installer+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpkg"]
      },
      "application/vnd.apple.keynote": {
        source: "iana",
        extensions: ["key"]
      },
      "application/vnd.apple.mpegurl": {
        source: "iana",
        extensions: ["m3u8"]
      },
      "application/vnd.apple.numbers": {
        source: "iana",
        extensions: ["numbers"]
      },
      "application/vnd.apple.pages": {
        source: "iana",
        extensions: ["pages"]
      },
      "application/vnd.apple.pkpass": {
        compressible: false,
        extensions: ["pkpass"]
      },
      "application/vnd.arastra.swi": {
        source: "iana"
      },
      "application/vnd.aristanetworks.swi": {
        source: "iana",
        extensions: ["swi"]
      },
      "application/vnd.artisan+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.artsquare": {
        source: "iana"
      },
      "application/vnd.astraea-software.iota": {
        source: "iana",
        extensions: ["iota"]
      },
      "application/vnd.audiograph": {
        source: "iana",
        extensions: ["aep"]
      },
      "application/vnd.autopackage": {
        source: "iana"
      },
      "application/vnd.avalon+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.avistar+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.balsamiq.bmml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["bmml"]
      },
      "application/vnd.balsamiq.bmpr": {
        source: "iana"
      },
      "application/vnd.banana-accounting": {
        source: "iana"
      },
      "application/vnd.bbf.usp.error": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bekitzur-stech+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bint.med-content": {
        source: "iana"
      },
      "application/vnd.biopax.rdf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.blink-idb-value-wrapper": {
        source: "iana"
      },
      "application/vnd.blueice.multipass": {
        source: "iana",
        extensions: ["mpm"]
      },
      "application/vnd.bluetooth.ep.oob": {
        source: "iana"
      },
      "application/vnd.bluetooth.le.oob": {
        source: "iana"
      },
      "application/vnd.bmi": {
        source: "iana",
        extensions: ["bmi"]
      },
      "application/vnd.bpf": {
        source: "iana"
      },
      "application/vnd.bpf3": {
        source: "iana"
      },
      "application/vnd.businessobjects": {
        source: "iana",
        extensions: ["rep"]
      },
      "application/vnd.byu.uapi+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cab-jscript": {
        source: "iana"
      },
      "application/vnd.canon-cpdl": {
        source: "iana"
      },
      "application/vnd.canon-lips": {
        source: "iana"
      },
      "application/vnd.capasystems-pg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cendio.thinlinc.clientconf": {
        source: "iana"
      },
      "application/vnd.century-systems.tcp_stream": {
        source: "iana"
      },
      "application/vnd.chemdraw+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdxml"]
      },
      "application/vnd.chess-pgn": {
        source: "iana"
      },
      "application/vnd.chipnuts.karaoke-mmd": {
        source: "iana",
        extensions: ["mmd"]
      },
      "application/vnd.ciedi": {
        source: "iana"
      },
      "application/vnd.cinderella": {
        source: "iana",
        extensions: ["cdy"]
      },
      "application/vnd.cirpack.isdn-ext": {
        source: "iana"
      },
      "application/vnd.citationstyles.style+xml": {
        source: "iana",
        compressible: true,
        extensions: ["csl"]
      },
      "application/vnd.claymore": {
        source: "iana",
        extensions: ["cla"]
      },
      "application/vnd.cloanto.rp9": {
        source: "iana",
        extensions: ["rp9"]
      },
      "application/vnd.clonk.c4group": {
        source: "iana",
        extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
      },
      "application/vnd.cluetrust.cartomobile-config": {
        source: "iana",
        extensions: ["c11amc"]
      },
      "application/vnd.cluetrust.cartomobile-config-pkg": {
        source: "iana",
        extensions: ["c11amz"]
      },
      "application/vnd.coffeescript": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet-template": {
        source: "iana"
      },
      "application/vnd.collection+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.doc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.next+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.comicbook+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.comicbook-rar": {
        source: "iana"
      },
      "application/vnd.commerce-battelle": {
        source: "iana"
      },
      "application/vnd.commonspace": {
        source: "iana",
        extensions: ["csp"]
      },
      "application/vnd.contact.cmsg": {
        source: "iana",
        extensions: ["cdbcmsg"]
      },
      "application/vnd.coreos.ignition+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cosmocaller": {
        source: "iana",
        extensions: ["cmc"]
      },
      "application/vnd.crick.clicker": {
        source: "iana",
        extensions: ["clkx"]
      },
      "application/vnd.crick.clicker.keyboard": {
        source: "iana",
        extensions: ["clkk"]
      },
      "application/vnd.crick.clicker.palette": {
        source: "iana",
        extensions: ["clkp"]
      },
      "application/vnd.crick.clicker.template": {
        source: "iana",
        extensions: ["clkt"]
      },
      "application/vnd.crick.clicker.wordbank": {
        source: "iana",
        extensions: ["clkw"]
      },
      "application/vnd.criticaltools.wbs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wbs"]
      },
      "application/vnd.cryptii.pipe+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.crypto-shade-file": {
        source: "iana"
      },
      "application/vnd.cryptomator.encrypted": {
        source: "iana"
      },
      "application/vnd.cryptomator.vault": {
        source: "iana"
      },
      "application/vnd.ctc-posml": {
        source: "iana",
        extensions: ["pml"]
      },
      "application/vnd.ctct.ws+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cups-pdf": {
        source: "iana"
      },
      "application/vnd.cups-postscript": {
        source: "iana"
      },
      "application/vnd.cups-ppd": {
        source: "iana",
        extensions: ["ppd"]
      },
      "application/vnd.cups-raster": {
        source: "iana"
      },
      "application/vnd.cups-raw": {
        source: "iana"
      },
      "application/vnd.curl": {
        source: "iana"
      },
      "application/vnd.curl.car": {
        source: "apache",
        extensions: ["car"]
      },
      "application/vnd.curl.pcurl": {
        source: "apache",
        extensions: ["pcurl"]
      },
      "application/vnd.cyan.dean.root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cybank": {
        source: "iana"
      },
      "application/vnd.cyclonedx+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cyclonedx+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.d2l.coursepackage1p0+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.d3m-dataset": {
        source: "iana"
      },
      "application/vnd.d3m-problem": {
        source: "iana"
      },
      "application/vnd.dart": {
        source: "iana",
        compressible: true,
        extensions: ["dart"]
      },
      "application/vnd.data-vision.rdz": {
        source: "iana",
        extensions: ["rdz"]
      },
      "application/vnd.datapackage+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dataresource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dbf": {
        source: "iana",
        extensions: ["dbf"]
      },
      "application/vnd.debian.binary-package": {
        source: "iana"
      },
      "application/vnd.dece.data": {
        source: "iana",
        extensions: ["uvf", "uvvf", "uvd", "uvvd"]
      },
      "application/vnd.dece.ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uvt", "uvvt"]
      },
      "application/vnd.dece.unspecified": {
        source: "iana",
        extensions: ["uvx", "uvvx"]
      },
      "application/vnd.dece.zip": {
        source: "iana",
        extensions: ["uvz", "uvvz"]
      },
      "application/vnd.denovo.fcselayout-link": {
        source: "iana",
        extensions: ["fe_launch"]
      },
      "application/vnd.desmume.movie": {
        source: "iana"
      },
      "application/vnd.dir-bi.plate-dl-nosuffix": {
        source: "iana"
      },
      "application/vnd.dm.delegation+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dna": {
        source: "iana",
        extensions: ["dna"]
      },
      "application/vnd.document+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dolby.mlp": {
        source: "apache",
        extensions: ["mlp"]
      },
      "application/vnd.dolby.mobile.1": {
        source: "iana"
      },
      "application/vnd.dolby.mobile.2": {
        source: "iana"
      },
      "application/vnd.doremir.scorecloud-binary-document": {
        source: "iana"
      },
      "application/vnd.dpgraph": {
        source: "iana",
        extensions: ["dpg"]
      },
      "application/vnd.dreamfactory": {
        source: "iana",
        extensions: ["dfac"]
      },
      "application/vnd.drive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ds-keypoint": {
        source: "apache",
        extensions: ["kpxx"]
      },
      "application/vnd.dtg.local": {
        source: "iana"
      },
      "application/vnd.dtg.local.flash": {
        source: "iana"
      },
      "application/vnd.dtg.local.html": {
        source: "iana"
      },
      "application/vnd.dvb.ait": {
        source: "iana",
        extensions: ["ait"]
      },
      "application/vnd.dvb.dvbisl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.dvbj": {
        source: "iana"
      },
      "application/vnd.dvb.esgcontainer": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcdftnotifaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess2": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgpdd": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcroaming": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-base": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-enhancement": {
        source: "iana"
      },
      "application/vnd.dvb.notif-aggregate-root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-container+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-generic+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-msglist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-init+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.pfr": {
        source: "iana"
      },
      "application/vnd.dvb.service": {
        source: "iana",
        extensions: ["svc"]
      },
      "application/vnd.dxr": {
        source: "iana"
      },
      "application/vnd.dynageo": {
        source: "iana",
        extensions: ["geo"]
      },
      "application/vnd.dzr": {
        source: "iana"
      },
      "application/vnd.easykaraoke.cdgdownload": {
        source: "iana"
      },
      "application/vnd.ecdis-update": {
        source: "iana"
      },
      "application/vnd.ecip.rlp": {
        source: "iana"
      },
      "application/vnd.eclipse.ditto+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ecowin.chart": {
        source: "iana",
        extensions: ["mag"]
      },
      "application/vnd.ecowin.filerequest": {
        source: "iana"
      },
      "application/vnd.ecowin.fileupdate": {
        source: "iana"
      },
      "application/vnd.ecowin.series": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesrequest": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesupdate": {
        source: "iana"
      },
      "application/vnd.efi.img": {
        source: "iana"
      },
      "application/vnd.efi.iso": {
        source: "iana"
      },
      "application/vnd.emclient.accessrequest+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.enliven": {
        source: "iana",
        extensions: ["nml"]
      },
      "application/vnd.enphase.envoy": {
        source: "iana"
      },
      "application/vnd.eprints.data+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.epson.esf": {
        source: "iana",
        extensions: ["esf"]
      },
      "application/vnd.epson.msf": {
        source: "iana",
        extensions: ["msf"]
      },
      "application/vnd.epson.quickanime": {
        source: "iana",
        extensions: ["qam"]
      },
      "application/vnd.epson.salt": {
        source: "iana",
        extensions: ["slt"]
      },
      "application/vnd.epson.ssf": {
        source: "iana",
        extensions: ["ssf"]
      },
      "application/vnd.ericsson.quickcall": {
        source: "iana"
      },
      "application/vnd.espass-espass+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.eszigno3+xml": {
        source: "iana",
        compressible: true,
        extensions: ["es3", "et3"]
      },
      "application/vnd.etsi.aoc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.asic-e+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.asic-s+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.cug+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvcommand+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-bc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-cod+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-npvr+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvservice+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mcid+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mheg5": {
        source: "iana"
      },
      "application/vnd.etsi.overload-control-policy-dataset+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.pstn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.sci+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.simservs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.timestamp-token": {
        source: "iana"
      },
      "application/vnd.etsi.tsl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.tsl.der": {
        source: "iana"
      },
      "application/vnd.eu.kasparian.car+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.eudora.data": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.profile": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.settings": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.theme": {
        source: "iana"
      },
      "application/vnd.exstream-empower+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.exstream-package": {
        source: "iana"
      },
      "application/vnd.ezpix-album": {
        source: "iana",
        extensions: ["ez2"]
      },
      "application/vnd.ezpix-package": {
        source: "iana",
        extensions: ["ez3"]
      },
      "application/vnd.f-secure.mobile": {
        source: "iana"
      },
      "application/vnd.familysearch.gedcom+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.fastcopy-disk-image": {
        source: "iana"
      },
      "application/vnd.fdf": {
        source: "iana",
        extensions: ["fdf"]
      },
      "application/vnd.fdsn.mseed": {
        source: "iana",
        extensions: ["mseed"]
      },
      "application/vnd.fdsn.seed": {
        source: "iana",
        extensions: ["seed", "dataless"]
      },
      "application/vnd.ffsns": {
        source: "iana"
      },
      "application/vnd.ficlab.flb+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.filmit.zfc": {
        source: "iana"
      },
      "application/vnd.fints": {
        source: "iana"
      },
      "application/vnd.firemonkeys.cloudcell": {
        source: "iana"
      },
      "application/vnd.flographit": {
        source: "iana",
        extensions: ["gph"]
      },
      "application/vnd.fluxtime.clip": {
        source: "iana",
        extensions: ["ftc"]
      },
      "application/vnd.font-fontforge-sfd": {
        source: "iana"
      },
      "application/vnd.framemaker": {
        source: "iana",
        extensions: ["fm", "frame", "maker", "book"]
      },
      "application/vnd.frogans.fnc": {
        source: "iana",
        extensions: ["fnc"]
      },
      "application/vnd.frogans.ltf": {
        source: "iana",
        extensions: ["ltf"]
      },
      "application/vnd.fsc.weblaunch": {
        source: "iana",
        extensions: ["fsc"]
      },
      "application/vnd.fujifilm.fb.docuworks": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.binder": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.jfi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fujitsu.oasys": {
        source: "iana",
        extensions: ["oas"]
      },
      "application/vnd.fujitsu.oasys2": {
        source: "iana",
        extensions: ["oa2"]
      },
      "application/vnd.fujitsu.oasys3": {
        source: "iana",
        extensions: ["oa3"]
      },
      "application/vnd.fujitsu.oasysgp": {
        source: "iana",
        extensions: ["fg5"]
      },
      "application/vnd.fujitsu.oasysprs": {
        source: "iana",
        extensions: ["bh2"]
      },
      "application/vnd.fujixerox.art-ex": {
        source: "iana"
      },
      "application/vnd.fujixerox.art4": {
        source: "iana"
      },
      "application/vnd.fujixerox.ddd": {
        source: "iana",
        extensions: ["ddd"]
      },
      "application/vnd.fujixerox.docuworks": {
        source: "iana",
        extensions: ["xdw"]
      },
      "application/vnd.fujixerox.docuworks.binder": {
        source: "iana",
        extensions: ["xbd"]
      },
      "application/vnd.fujixerox.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujixerox.hbpl": {
        source: "iana"
      },
      "application/vnd.fut-misnet": {
        source: "iana"
      },
      "application/vnd.futoin+cbor": {
        source: "iana"
      },
      "application/vnd.futoin+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fuzzysheet": {
        source: "iana",
        extensions: ["fzs"]
      },
      "application/vnd.genomatix.tuxedo": {
        source: "iana",
        extensions: ["txd"]
      },
      "application/vnd.gentics.grd+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geo+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geocube+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geogebra.file": {
        source: "iana",
        extensions: ["ggb"]
      },
      "application/vnd.geogebra.slides": {
        source: "iana"
      },
      "application/vnd.geogebra.tool": {
        source: "iana",
        extensions: ["ggt"]
      },
      "application/vnd.geometry-explorer": {
        source: "iana",
        extensions: ["gex", "gre"]
      },
      "application/vnd.geonext": {
        source: "iana",
        extensions: ["gxt"]
      },
      "application/vnd.geoplan": {
        source: "iana",
        extensions: ["g2w"]
      },
      "application/vnd.geospace": {
        source: "iana",
        extensions: ["g3w"]
      },
      "application/vnd.gerber": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt-response": {
        source: "iana"
      },
      "application/vnd.gmx": {
        source: "iana",
        extensions: ["gmx"]
      },
      "application/vnd.google-apps.document": {
        compressible: false,
        extensions: ["gdoc"]
      },
      "application/vnd.google-apps.presentation": {
        compressible: false,
        extensions: ["gslides"]
      },
      "application/vnd.google-apps.spreadsheet": {
        compressible: false,
        extensions: ["gsheet"]
      },
      "application/vnd.google-earth.kml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["kml"]
      },
      "application/vnd.google-earth.kmz": {
        source: "iana",
        compressible: false,
        extensions: ["kmz"]
      },
      "application/vnd.gov.sk.e-form+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.gov.sk.e-form+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.gov.sk.xmldatacontainer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.grafeq": {
        source: "iana",
        extensions: ["gqf", "gqs"]
      },
      "application/vnd.gridmp": {
        source: "iana"
      },
      "application/vnd.groove-account": {
        source: "iana",
        extensions: ["gac"]
      },
      "application/vnd.groove-help": {
        source: "iana",
        extensions: ["ghf"]
      },
      "application/vnd.groove-identity-message": {
        source: "iana",
        extensions: ["gim"]
      },
      "application/vnd.groove-injector": {
        source: "iana",
        extensions: ["grv"]
      },
      "application/vnd.groove-tool-message": {
        source: "iana",
        extensions: ["gtm"]
      },
      "application/vnd.groove-tool-template": {
        source: "iana",
        extensions: ["tpl"]
      },
      "application/vnd.groove-vcard": {
        source: "iana",
        extensions: ["vcg"]
      },
      "application/vnd.hal+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hal+xml": {
        source: "iana",
        compressible: true,
        extensions: ["hal"]
      },
      "application/vnd.handheld-entertainment+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zmm"]
      },
      "application/vnd.hbci": {
        source: "iana",
        extensions: ["hbci"]
      },
      "application/vnd.hc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hcl-bireports": {
        source: "iana"
      },
      "application/vnd.hdt": {
        source: "iana"
      },
      "application/vnd.heroku+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hhe.lesson-player": {
        source: "iana",
        extensions: ["les"]
      },
      "application/vnd.hl7cda+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hl7v2+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hp-hpgl": {
        source: "iana",
        extensions: ["hpgl"]
      },
      "application/vnd.hp-hpid": {
        source: "iana",
        extensions: ["hpid"]
      },
      "application/vnd.hp-hps": {
        source: "iana",
        extensions: ["hps"]
      },
      "application/vnd.hp-jlyt": {
        source: "iana",
        extensions: ["jlt"]
      },
      "application/vnd.hp-pcl": {
        source: "iana",
        extensions: ["pcl"]
      },
      "application/vnd.hp-pclxl": {
        source: "iana",
        extensions: ["pclxl"]
      },
      "application/vnd.httphone": {
        source: "iana"
      },
      "application/vnd.hydrostatix.sof-data": {
        source: "iana",
        extensions: ["sfd-hdstx"]
      },
      "application/vnd.hyper+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyper-item+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyperdrive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hzn-3d-crossword": {
        source: "iana"
      },
      "application/vnd.ibm.afplinedata": {
        source: "iana"
      },
      "application/vnd.ibm.electronic-media": {
        source: "iana"
      },
      "application/vnd.ibm.minipay": {
        source: "iana",
        extensions: ["mpy"]
      },
      "application/vnd.ibm.modcap": {
        source: "iana",
        extensions: ["afp", "listafp", "list3820"]
      },
      "application/vnd.ibm.rights-management": {
        source: "iana",
        extensions: ["irm"]
      },
      "application/vnd.ibm.secure-container": {
        source: "iana",
        extensions: ["sc"]
      },
      "application/vnd.iccprofile": {
        source: "iana",
        extensions: ["icc", "icm"]
      },
      "application/vnd.ieee.1905": {
        source: "iana"
      },
      "application/vnd.igloader": {
        source: "iana",
        extensions: ["igl"]
      },
      "application/vnd.imagemeter.folder+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.imagemeter.image+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.immervision-ivp": {
        source: "iana",
        extensions: ["ivp"]
      },
      "application/vnd.immervision-ivu": {
        source: "iana",
        extensions: ["ivu"]
      },
      "application/vnd.ims.imsccv1p1": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p2": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p3": {
        source: "iana"
      },
      "application/vnd.ims.lis.v2.result+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy.id+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings.simple+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informedcontrol.rms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informix-visionary": {
        source: "iana"
      },
      "application/vnd.infotech.project": {
        source: "iana"
      },
      "application/vnd.infotech.project+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.innopath.wamp.notification": {
        source: "iana"
      },
      "application/vnd.insors.igm": {
        source: "iana",
        extensions: ["igm"]
      },
      "application/vnd.intercon.formnet": {
        source: "iana",
        extensions: ["xpw", "xpx"]
      },
      "application/vnd.intergeo": {
        source: "iana",
        extensions: ["i2g"]
      },
      "application/vnd.intertrust.digibox": {
        source: "iana"
      },
      "application/vnd.intertrust.nncp": {
        source: "iana"
      },
      "application/vnd.intu.qbo": {
        source: "iana",
        extensions: ["qbo"]
      },
      "application/vnd.intu.qfx": {
        source: "iana",
        extensions: ["qfx"]
      },
      "application/vnd.iptc.g2.catalogitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.conceptitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.knowledgeitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.packageitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.planningitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ipunplugged.rcprofile": {
        source: "iana",
        extensions: ["rcprofile"]
      },
      "application/vnd.irepository.package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["irp"]
      },
      "application/vnd.is-xpr": {
        source: "iana",
        extensions: ["xpr"]
      },
      "application/vnd.isac.fcs": {
        source: "iana",
        extensions: ["fcs"]
      },
      "application/vnd.iso11783-10+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.jam": {
        source: "iana",
        extensions: ["jam"]
      },
      "application/vnd.japannet-directory-service": {
        source: "iana"
      },
      "application/vnd.japannet-jpnstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-payment-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-registration": {
        source: "iana"
      },
      "application/vnd.japannet-registration-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-setstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-verification": {
        source: "iana"
      },
      "application/vnd.japannet-verification-wakeup": {
        source: "iana"
      },
      "application/vnd.jcp.javame.midlet-rms": {
        source: "iana",
        extensions: ["rms"]
      },
      "application/vnd.jisp": {
        source: "iana",
        extensions: ["jisp"]
      },
      "application/vnd.joost.joda-archive": {
        source: "iana",
        extensions: ["joda"]
      },
      "application/vnd.jsk.isdn-ngn": {
        source: "iana"
      },
      "application/vnd.kahootz": {
        source: "iana",
        extensions: ["ktz", "ktr"]
      },
      "application/vnd.kde.karbon": {
        source: "iana",
        extensions: ["karbon"]
      },
      "application/vnd.kde.kchart": {
        source: "iana",
        extensions: ["chrt"]
      },
      "application/vnd.kde.kformula": {
        source: "iana",
        extensions: ["kfo"]
      },
      "application/vnd.kde.kivio": {
        source: "iana",
        extensions: ["flw"]
      },
      "application/vnd.kde.kontour": {
        source: "iana",
        extensions: ["kon"]
      },
      "application/vnd.kde.kpresenter": {
        source: "iana",
        extensions: ["kpr", "kpt"]
      },
      "application/vnd.kde.kspread": {
        source: "iana",
        extensions: ["ksp"]
      },
      "application/vnd.kde.kword": {
        source: "iana",
        extensions: ["kwd", "kwt"]
      },
      "application/vnd.kenameaapp": {
        source: "iana",
        extensions: ["htke"]
      },
      "application/vnd.kidspiration": {
        source: "iana",
        extensions: ["kia"]
      },
      "application/vnd.kinar": {
        source: "iana",
        extensions: ["kne", "knp"]
      },
      "application/vnd.koan": {
        source: "iana",
        extensions: ["skp", "skd", "skt", "skm"]
      },
      "application/vnd.kodak-descriptor": {
        source: "iana",
        extensions: ["sse"]
      },
      "application/vnd.las": {
        source: "iana"
      },
      "application/vnd.las.las+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.las.las+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lasxml"]
      },
      "application/vnd.laszip": {
        source: "iana"
      },
      "application/vnd.leap+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.liberty-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.llamagraphics.life-balance.desktop": {
        source: "iana",
        extensions: ["lbd"]
      },
      "application/vnd.llamagraphics.life-balance.exchange+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lbe"]
      },
      "application/vnd.logipipe.circuit+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.loom": {
        source: "iana"
      },
      "application/vnd.lotus-1-2-3": {
        source: "iana",
        extensions: ["123"]
      },
      "application/vnd.lotus-approach": {
        source: "iana",
        extensions: ["apr"]
      },
      "application/vnd.lotus-freelance": {
        source: "iana",
        extensions: ["pre"]
      },
      "application/vnd.lotus-notes": {
        source: "iana",
        extensions: ["nsf"]
      },
      "application/vnd.lotus-organizer": {
        source: "iana",
        extensions: ["org"]
      },
      "application/vnd.lotus-screencam": {
        source: "iana",
        extensions: ["scm"]
      },
      "application/vnd.lotus-wordpro": {
        source: "iana",
        extensions: ["lwp"]
      },
      "application/vnd.macports.portpkg": {
        source: "iana",
        extensions: ["portpkg"]
      },
      "application/vnd.mapbox-vector-tile": {
        source: "iana",
        extensions: ["mvt"]
      },
      "application/vnd.marlin.drm.actiontoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.conftoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.license+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.mdcf": {
        source: "iana"
      },
      "application/vnd.mason+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.maxar.archive.3tz+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.maxmind.maxmind-db": {
        source: "iana"
      },
      "application/vnd.mcd": {
        source: "iana",
        extensions: ["mcd"]
      },
      "application/vnd.medcalcdata": {
        source: "iana",
        extensions: ["mc1"]
      },
      "application/vnd.mediastation.cdkey": {
        source: "iana",
        extensions: ["cdkey"]
      },
      "application/vnd.meridian-slingshot": {
        source: "iana"
      },
      "application/vnd.mfer": {
        source: "iana",
        extensions: ["mwf"]
      },
      "application/vnd.mfmp": {
        source: "iana",
        extensions: ["mfm"]
      },
      "application/vnd.micro+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.micrografx.flo": {
        source: "iana",
        extensions: ["flo"]
      },
      "application/vnd.micrografx.igx": {
        source: "iana",
        extensions: ["igx"]
      },
      "application/vnd.microsoft.portable-executable": {
        source: "iana"
      },
      "application/vnd.microsoft.windows.thumbnail-cache": {
        source: "iana"
      },
      "application/vnd.miele+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.mif": {
        source: "iana",
        extensions: ["mif"]
      },
      "application/vnd.minisoft-hp3000-save": {
        source: "iana"
      },
      "application/vnd.mitsubishi.misty-guard.trustweb": {
        source: "iana"
      },
      "application/vnd.mobius.daf": {
        source: "iana",
        extensions: ["daf"]
      },
      "application/vnd.mobius.dis": {
        source: "iana",
        extensions: ["dis"]
      },
      "application/vnd.mobius.mbk": {
        source: "iana",
        extensions: ["mbk"]
      },
      "application/vnd.mobius.mqy": {
        source: "iana",
        extensions: ["mqy"]
      },
      "application/vnd.mobius.msl": {
        source: "iana",
        extensions: ["msl"]
      },
      "application/vnd.mobius.plc": {
        source: "iana",
        extensions: ["plc"]
      },
      "application/vnd.mobius.txf": {
        source: "iana",
        extensions: ["txf"]
      },
      "application/vnd.mophun.application": {
        source: "iana",
        extensions: ["mpn"]
      },
      "application/vnd.mophun.certificate": {
        source: "iana",
        extensions: ["mpc"]
      },
      "application/vnd.motorola.flexsuite": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.adsi": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.fis": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.gotap": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.kmr": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.ttc": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.wem": {
        source: "iana"
      },
      "application/vnd.motorola.iprm": {
        source: "iana"
      },
      "application/vnd.mozilla.xul+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xul"]
      },
      "application/vnd.ms-3mfdocument": {
        source: "iana"
      },
      "application/vnd.ms-artgalry": {
        source: "iana",
        extensions: ["cil"]
      },
      "application/vnd.ms-asf": {
        source: "iana"
      },
      "application/vnd.ms-cab-compressed": {
        source: "iana",
        extensions: ["cab"]
      },
      "application/vnd.ms-color.iccprofile": {
        source: "apache"
      },
      "application/vnd.ms-excel": {
        source: "iana",
        compressible: false,
        extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
      },
      "application/vnd.ms-excel.addin.macroenabled.12": {
        source: "iana",
        extensions: ["xlam"]
      },
      "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
        source: "iana",
        extensions: ["xlsb"]
      },
      "application/vnd.ms-excel.sheet.macroenabled.12": {
        source: "iana",
        extensions: ["xlsm"]
      },
      "application/vnd.ms-excel.template.macroenabled.12": {
        source: "iana",
        extensions: ["xltm"]
      },
      "application/vnd.ms-fontobject": {
        source: "iana",
        compressible: true,
        extensions: ["eot"]
      },
      "application/vnd.ms-htmlhelp": {
        source: "iana",
        extensions: ["chm"]
      },
      "application/vnd.ms-ims": {
        source: "iana",
        extensions: ["ims"]
      },
      "application/vnd.ms-lrm": {
        source: "iana",
        extensions: ["lrm"]
      },
      "application/vnd.ms-office.activex+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-officetheme": {
        source: "iana",
        extensions: ["thmx"]
      },
      "application/vnd.ms-opentype": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-outlook": {
        compressible: false,
        extensions: ["msg"]
      },
      "application/vnd.ms-package.obfuscated-opentype": {
        source: "apache"
      },
      "application/vnd.ms-pki.seccat": {
        source: "apache",
        extensions: ["cat"]
      },
      "application/vnd.ms-pki.stl": {
        source: "apache",
        extensions: ["stl"]
      },
      "application/vnd.ms-playready.initiator+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-powerpoint": {
        source: "iana",
        compressible: false,
        extensions: ["ppt", "pps", "pot"]
      },
      "application/vnd.ms-powerpoint.addin.macroenabled.12": {
        source: "iana",
        extensions: ["ppam"]
      },
      "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
        source: "iana",
        extensions: ["pptm"]
      },
      "application/vnd.ms-powerpoint.slide.macroenabled.12": {
        source: "iana",
        extensions: ["sldm"]
      },
      "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
        source: "iana",
        extensions: ["ppsm"]
      },
      "application/vnd.ms-powerpoint.template.macroenabled.12": {
        source: "iana",
        extensions: ["potm"]
      },
      "application/vnd.ms-printdevicecapabilities+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-printing.printticket+xml": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-printschematicket+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-project": {
        source: "iana",
        extensions: ["mpp", "mpt"]
      },
      "application/vnd.ms-tnef": {
        source: "iana"
      },
      "application/vnd.ms-windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.nwprinting.oob": {
        source: "iana"
      },
      "application/vnd.ms-windows.printerpairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.wsd.oob": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-resp": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-resp": {
        source: "iana"
      },
      "application/vnd.ms-word.document.macroenabled.12": {
        source: "iana",
        extensions: ["docm"]
      },
      "application/vnd.ms-word.template.macroenabled.12": {
        source: "iana",
        extensions: ["dotm"]
      },
      "application/vnd.ms-works": {
        source: "iana",
        extensions: ["wps", "wks", "wcm", "wdb"]
      },
      "application/vnd.ms-wpl": {
        source: "iana",
        extensions: ["wpl"]
      },
      "application/vnd.ms-xpsdocument": {
        source: "iana",
        compressible: false,
        extensions: ["xps"]
      },
      "application/vnd.msa-disk-image": {
        source: "iana"
      },
      "application/vnd.mseq": {
        source: "iana",
        extensions: ["mseq"]
      },
      "application/vnd.msign": {
        source: "iana"
      },
      "application/vnd.multiad.creator": {
        source: "iana"
      },
      "application/vnd.multiad.creator.cif": {
        source: "iana"
      },
      "application/vnd.music-niff": {
        source: "iana"
      },
      "application/vnd.musician": {
        source: "iana",
        extensions: ["mus"]
      },
      "application/vnd.muvee.style": {
        source: "iana",
        extensions: ["msty"]
      },
      "application/vnd.mynfc": {
        source: "iana",
        extensions: ["taglet"]
      },
      "application/vnd.nacamar.ybrid+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ncd.control": {
        source: "iana"
      },
      "application/vnd.ncd.reference": {
        source: "iana"
      },
      "application/vnd.nearst.inv+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nebumind.line": {
        source: "iana"
      },
      "application/vnd.nervana": {
        source: "iana"
      },
      "application/vnd.netfpx": {
        source: "iana"
      },
      "application/vnd.neurolanguage.nlu": {
        source: "iana",
        extensions: ["nlu"]
      },
      "application/vnd.nimn": {
        source: "iana"
      },
      "application/vnd.nintendo.nitro.rom": {
        source: "iana"
      },
      "application/vnd.nintendo.snes.rom": {
        source: "iana"
      },
      "application/vnd.nitf": {
        source: "iana",
        extensions: ["ntf", "nitf"]
      },
      "application/vnd.noblenet-directory": {
        source: "iana",
        extensions: ["nnd"]
      },
      "application/vnd.noblenet-sealer": {
        source: "iana",
        extensions: ["nns"]
      },
      "application/vnd.noblenet-web": {
        source: "iana",
        extensions: ["nnw"]
      },
      "application/vnd.nokia.catalogs": {
        source: "iana"
      },
      "application/vnd.nokia.conml+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.conml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.iptv.config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.isds-radio-presets": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.landmarkcollection+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.n-gage.ac+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ac"]
      },
      "application/vnd.nokia.n-gage.data": {
        source: "iana",
        extensions: ["ngdat"]
      },
      "application/vnd.nokia.n-gage.symbian.install": {
        source: "iana",
        extensions: ["n-gage"]
      },
      "application/vnd.nokia.ncd": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.radio-preset": {
        source: "iana",
        extensions: ["rpst"]
      },
      "application/vnd.nokia.radio-presets": {
        source: "iana",
        extensions: ["rpss"]
      },
      "application/vnd.novadigm.edm": {
        source: "iana",
        extensions: ["edm"]
      },
      "application/vnd.novadigm.edx": {
        source: "iana",
        extensions: ["edx"]
      },
      "application/vnd.novadigm.ext": {
        source: "iana",
        extensions: ["ext"]
      },
      "application/vnd.ntt-local.content-share": {
        source: "iana"
      },
      "application/vnd.ntt-local.file-transfer": {
        source: "iana"
      },
      "application/vnd.ntt-local.ogw_remote-access": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_remote": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_tcp_stream": {
        source: "iana"
      },
      "application/vnd.oasis.opendocument.chart": {
        source: "iana",
        extensions: ["odc"]
      },
      "application/vnd.oasis.opendocument.chart-template": {
        source: "iana",
        extensions: ["otc"]
      },
      "application/vnd.oasis.opendocument.database": {
        source: "iana",
        extensions: ["odb"]
      },
      "application/vnd.oasis.opendocument.formula": {
        source: "iana",
        extensions: ["odf"]
      },
      "application/vnd.oasis.opendocument.formula-template": {
        source: "iana",
        extensions: ["odft"]
      },
      "application/vnd.oasis.opendocument.graphics": {
        source: "iana",
        compressible: false,
        extensions: ["odg"]
      },
      "application/vnd.oasis.opendocument.graphics-template": {
        source: "iana",
        extensions: ["otg"]
      },
      "application/vnd.oasis.opendocument.image": {
        source: "iana",
        extensions: ["odi"]
      },
      "application/vnd.oasis.opendocument.image-template": {
        source: "iana",
        extensions: ["oti"]
      },
      "application/vnd.oasis.opendocument.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["odp"]
      },
      "application/vnd.oasis.opendocument.presentation-template": {
        source: "iana",
        extensions: ["otp"]
      },
      "application/vnd.oasis.opendocument.spreadsheet": {
        source: "iana",
        compressible: false,
        extensions: ["ods"]
      },
      "application/vnd.oasis.opendocument.spreadsheet-template": {
        source: "iana",
        extensions: ["ots"]
      },
      "application/vnd.oasis.opendocument.text": {
        source: "iana",
        compressible: false,
        extensions: ["odt"]
      },
      "application/vnd.oasis.opendocument.text-master": {
        source: "iana",
        extensions: ["odm"]
      },
      "application/vnd.oasis.opendocument.text-template": {
        source: "iana",
        extensions: ["ott"]
      },
      "application/vnd.oasis.opendocument.text-web": {
        source: "iana",
        extensions: ["oth"]
      },
      "application/vnd.obn": {
        source: "iana"
      },
      "application/vnd.ocf+cbor": {
        source: "iana"
      },
      "application/vnd.oci.image.manifest.v1+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oftn.l10n+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessdownload+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessstreaming+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.cspg-hexbinary": {
        source: "iana"
      },
      "application/vnd.oipf.dae.svg+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.dae.xhtml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.mippvcontrolmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.pae.gem": {
        source: "iana"
      },
      "application/vnd.oipf.spdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.spdlist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.ueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.userprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.olpc-sugar": {
        source: "iana",
        extensions: ["xo"]
      },
      "application/vnd.oma-scws-config": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-request": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-response": {
        source: "iana"
      },
      "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.drm-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.imd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.ltkm": {
        source: "iana"
      },
      "application/vnd.oma.bcast.notification+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.provisioningtrigger": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgboot": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgdd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sgdu": {
        source: "iana"
      },
      "application/vnd.oma.bcast.simple-symbol-container": {
        source: "iana"
      },
      "application/vnd.oma.bcast.smartcard-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sprov+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.stkm": {
        source: "iana"
      },
      "application/vnd.oma.cab-address-book+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-feature-handler+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-pcc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-subs-invite+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-user-prefs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.dcd": {
        source: "iana"
      },
      "application/vnd.oma.dcdc": {
        source: "iana"
      },
      "application/vnd.oma.dd2+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dd2"]
      },
      "application/vnd.oma.drm.risd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.group-usage-list+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+cbor": {
        source: "iana"
      },
      "application/vnd.oma.lwm2m+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+tlv": {
        source: "iana"
      },
      "application/vnd.oma.pal+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.detailed-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.final-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.groups+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.invocation-descriptor+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.optimized-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.push": {
        source: "iana"
      },
      "application/vnd.oma.scidm.messages+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.xcap-directory+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.omads-email+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-file+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-folder+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omaloc-supl-init": {
        source: "iana"
      },
      "application/vnd.onepager": {
        source: "iana"
      },
      "application/vnd.onepagertamp": {
        source: "iana"
      },
      "application/vnd.onepagertamx": {
        source: "iana"
      },
      "application/vnd.onepagertat": {
        source: "iana"
      },
      "application/vnd.onepagertatp": {
        source: "iana"
      },
      "application/vnd.onepagertatx": {
        source: "iana"
      },
      "application/vnd.openblox.game+xml": {
        source: "iana",
        compressible: true,
        extensions: ["obgx"]
      },
      "application/vnd.openblox.game-binary": {
        source: "iana"
      },
      "application/vnd.openeye.oeb": {
        source: "iana"
      },
      "application/vnd.openofficeorg.extension": {
        source: "apache",
        extensions: ["oxt"]
      },
      "application/vnd.openstreetmap.data+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osm"]
      },
      "application/vnd.opentimestamps.ots": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawing+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["pptx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide": {
        source: "iana",
        extensions: ["sldx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
        source: "iana",
        extensions: ["ppsx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template": {
        source: "iana",
        extensions: ["potx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
        source: "iana",
        compressible: false,
        extensions: ["xlsx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
        source: "iana",
        extensions: ["xltx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.theme+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.vmldrawing": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
        source: "iana",
        compressible: false,
        extensions: ["docx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
        source: "iana",
        extensions: ["dotx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.core-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.relationships+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oracle.resource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.orange.indata": {
        source: "iana"
      },
      "application/vnd.osa.netdeploy": {
        source: "iana"
      },
      "application/vnd.osgeo.mapguide.package": {
        source: "iana",
        extensions: ["mgp"]
      },
      "application/vnd.osgi.bundle": {
        source: "iana"
      },
      "application/vnd.osgi.dp": {
        source: "iana",
        extensions: ["dp"]
      },
      "application/vnd.osgi.subsystem": {
        source: "iana",
        extensions: ["esa"]
      },
      "application/vnd.otps.ct-kip+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oxli.countgraph": {
        source: "iana"
      },
      "application/vnd.pagerduty+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.palm": {
        source: "iana",
        extensions: ["pdb", "pqa", "oprc"]
      },
      "application/vnd.panoply": {
        source: "iana"
      },
      "application/vnd.paos.xml": {
        source: "iana"
      },
      "application/vnd.patentdive": {
        source: "iana"
      },
      "application/vnd.patientecommsdoc": {
        source: "iana"
      },
      "application/vnd.pawaafile": {
        source: "iana",
        extensions: ["paw"]
      },
      "application/vnd.pcos": {
        source: "iana"
      },
      "application/vnd.pg.format": {
        source: "iana",
        extensions: ["str"]
      },
      "application/vnd.pg.osasli": {
        source: "iana",
        extensions: ["ei6"]
      },
      "application/vnd.piaccess.application-licence": {
        source: "iana"
      },
      "application/vnd.picsel": {
        source: "iana",
        extensions: ["efif"]
      },
      "application/vnd.pmi.widget": {
        source: "iana",
        extensions: ["wg"]
      },
      "application/vnd.poc.group-advertisement+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.pocketlearn": {
        source: "iana",
        extensions: ["plf"]
      },
      "application/vnd.powerbuilder6": {
        source: "iana",
        extensions: ["pbd"]
      },
      "application/vnd.powerbuilder6-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder7": {
        source: "iana"
      },
      "application/vnd.powerbuilder7-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder75": {
        source: "iana"
      },
      "application/vnd.powerbuilder75-s": {
        source: "iana"
      },
      "application/vnd.preminet": {
        source: "iana"
      },
      "application/vnd.previewsystems.box": {
        source: "iana",
        extensions: ["box"]
      },
      "application/vnd.proteus.magazine": {
        source: "iana",
        extensions: ["mgz"]
      },
      "application/vnd.psfs": {
        source: "iana"
      },
      "application/vnd.publishare-delta-tree": {
        source: "iana",
        extensions: ["qps"]
      },
      "application/vnd.pvi.ptid1": {
        source: "iana",
        extensions: ["ptid"]
      },
      "application/vnd.pwg-multiplexed": {
        source: "iana"
      },
      "application/vnd.pwg-xhtml-print+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.qualcomm.brew-app-res": {
        source: "iana"
      },
      "application/vnd.quarantainenet": {
        source: "iana"
      },
      "application/vnd.quark.quarkxpress": {
        source: "iana",
        extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
      },
      "application/vnd.quobject-quoxdocument": {
        source: "iana"
      },
      "application/vnd.radisys.moml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-stream+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-base+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-detect+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-group+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-speech+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-transform+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rainstor.data": {
        source: "iana"
      },
      "application/vnd.rapid": {
        source: "iana"
      },
      "application/vnd.rar": {
        source: "iana",
        extensions: ["rar"]
      },
      "application/vnd.realvnc.bed": {
        source: "iana",
        extensions: ["bed"]
      },
      "application/vnd.recordare.musicxml": {
        source: "iana",
        extensions: ["mxl"]
      },
      "application/vnd.recordare.musicxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musicxml"]
      },
      "application/vnd.renlearn.rlprint": {
        source: "iana"
      },
      "application/vnd.resilient.logic": {
        source: "iana"
      },
      "application/vnd.restful+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rig.cryptonote": {
        source: "iana",
        extensions: ["cryptonote"]
      },
      "application/vnd.rim.cod": {
        source: "apache",
        extensions: ["cod"]
      },
      "application/vnd.rn-realmedia": {
        source: "apache",
        extensions: ["rm"]
      },
      "application/vnd.rn-realmedia-vbr": {
        source: "apache",
        extensions: ["rmvb"]
      },
      "application/vnd.route66.link66+xml": {
        source: "iana",
        compressible: true,
        extensions: ["link66"]
      },
      "application/vnd.rs-274x": {
        source: "iana"
      },
      "application/vnd.ruckus.download": {
        source: "iana"
      },
      "application/vnd.s3sms": {
        source: "iana"
      },
      "application/vnd.sailingtracker.track": {
        source: "iana",
        extensions: ["st"]
      },
      "application/vnd.sar": {
        source: "iana"
      },
      "application/vnd.sbm.cid": {
        source: "iana"
      },
      "application/vnd.sbm.mid2": {
        source: "iana"
      },
      "application/vnd.scribus": {
        source: "iana"
      },
      "application/vnd.sealed.3df": {
        source: "iana"
      },
      "application/vnd.sealed.csf": {
        source: "iana"
      },
      "application/vnd.sealed.doc": {
        source: "iana"
      },
      "application/vnd.sealed.eml": {
        source: "iana"
      },
      "application/vnd.sealed.mht": {
        source: "iana"
      },
      "application/vnd.sealed.net": {
        source: "iana"
      },
      "application/vnd.sealed.ppt": {
        source: "iana"
      },
      "application/vnd.sealed.tiff": {
        source: "iana"
      },
      "application/vnd.sealed.xls": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.html": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.pdf": {
        source: "iana"
      },
      "application/vnd.seemail": {
        source: "iana",
        extensions: ["see"]
      },
      "application/vnd.seis+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.sema": {
        source: "iana",
        extensions: ["sema"]
      },
      "application/vnd.semd": {
        source: "iana",
        extensions: ["semd"]
      },
      "application/vnd.semf": {
        source: "iana",
        extensions: ["semf"]
      },
      "application/vnd.shade-save-file": {
        source: "iana"
      },
      "application/vnd.shana.informed.formdata": {
        source: "iana",
        extensions: ["ifm"]
      },
      "application/vnd.shana.informed.formtemplate": {
        source: "iana",
        extensions: ["itp"]
      },
      "application/vnd.shana.informed.interchange": {
        source: "iana",
        extensions: ["iif"]
      },
      "application/vnd.shana.informed.package": {
        source: "iana",
        extensions: ["ipk"]
      },
      "application/vnd.shootproof+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shopkick+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shp": {
        source: "iana"
      },
      "application/vnd.shx": {
        source: "iana"
      },
      "application/vnd.sigrok.session": {
        source: "iana"
      },
      "application/vnd.simtech-mindmapper": {
        source: "iana",
        extensions: ["twd", "twds"]
      },
      "application/vnd.siren+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.smaf": {
        source: "iana",
        extensions: ["mmf"]
      },
      "application/vnd.smart.notebook": {
        source: "iana"
      },
      "application/vnd.smart.teacher": {
        source: "iana",
        extensions: ["teacher"]
      },
      "application/vnd.snesdev-page-table": {
        source: "iana"
      },
      "application/vnd.software602.filler.form+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fo"]
      },
      "application/vnd.software602.filler.form-xml-zip": {
        source: "iana"
      },
      "application/vnd.solent.sdkm+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sdkm", "sdkd"]
      },
      "application/vnd.spotfire.dxp": {
        source: "iana",
        extensions: ["dxp"]
      },
      "application/vnd.spotfire.sfs": {
        source: "iana",
        extensions: ["sfs"]
      },
      "application/vnd.sqlite3": {
        source: "iana"
      },
      "application/vnd.sss-cod": {
        source: "iana"
      },
      "application/vnd.sss-dtf": {
        source: "iana"
      },
      "application/vnd.sss-ntf": {
        source: "iana"
      },
      "application/vnd.stardivision.calc": {
        source: "apache",
        extensions: ["sdc"]
      },
      "application/vnd.stardivision.draw": {
        source: "apache",
        extensions: ["sda"]
      },
      "application/vnd.stardivision.impress": {
        source: "apache",
        extensions: ["sdd"]
      },
      "application/vnd.stardivision.math": {
        source: "apache",
        extensions: ["smf"]
      },
      "application/vnd.stardivision.writer": {
        source: "apache",
        extensions: ["sdw", "vor"]
      },
      "application/vnd.stardivision.writer-global": {
        source: "apache",
        extensions: ["sgl"]
      },
      "application/vnd.stepmania.package": {
        source: "iana",
        extensions: ["smzip"]
      },
      "application/vnd.stepmania.stepchart": {
        source: "iana",
        extensions: ["sm"]
      },
      "application/vnd.street-stream": {
        source: "iana"
      },
      "application/vnd.sun.wadl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wadl"]
      },
      "application/vnd.sun.xml.calc": {
        source: "apache",
        extensions: ["sxc"]
      },
      "application/vnd.sun.xml.calc.template": {
        source: "apache",
        extensions: ["stc"]
      },
      "application/vnd.sun.xml.draw": {
        source: "apache",
        extensions: ["sxd"]
      },
      "application/vnd.sun.xml.draw.template": {
        source: "apache",
        extensions: ["std"]
      },
      "application/vnd.sun.xml.impress": {
        source: "apache",
        extensions: ["sxi"]
      },
      "application/vnd.sun.xml.impress.template": {
        source: "apache",
        extensions: ["sti"]
      },
      "application/vnd.sun.xml.math": {
        source: "apache",
        extensions: ["sxm"]
      },
      "application/vnd.sun.xml.writer": {
        source: "apache",
        extensions: ["sxw"]
      },
      "application/vnd.sun.xml.writer.global": {
        source: "apache",
        extensions: ["sxg"]
      },
      "application/vnd.sun.xml.writer.template": {
        source: "apache",
        extensions: ["stw"]
      },
      "application/vnd.sus-calendar": {
        source: "iana",
        extensions: ["sus", "susp"]
      },
      "application/vnd.svd": {
        source: "iana",
        extensions: ["svd"]
      },
      "application/vnd.swiftview-ics": {
        source: "iana"
      },
      "application/vnd.sycle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.syft+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.symbian.install": {
        source: "apache",
        extensions: ["sis", "sisx"]
      },
      "application/vnd.syncml+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xsm"]
      },
      "application/vnd.syncml.dm+wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["bdm"]
      },
      "application/vnd.syncml.dm+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xdm"]
      },
      "application/vnd.syncml.dm.notification": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["ddf"]
      },
      "application/vnd.syncml.dmtnds+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmtnds+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.syncml.ds.notification": {
        source: "iana"
      },
      "application/vnd.tableschema+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tao.intent-module-archive": {
        source: "iana",
        extensions: ["tao"]
      },
      "application/vnd.tcpdump.pcap": {
        source: "iana",
        extensions: ["pcap", "cap", "dmp"]
      },
      "application/vnd.think-cell.ppttc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tmd.mediaflex.api+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tml": {
        source: "iana"
      },
      "application/vnd.tmobile-livetv": {
        source: "iana",
        extensions: ["tmo"]
      },
      "application/vnd.tri.onesource": {
        source: "iana"
      },
      "application/vnd.trid.tpt": {
        source: "iana",
        extensions: ["tpt"]
      },
      "application/vnd.triscape.mxs": {
        source: "iana",
        extensions: ["mxs"]
      },
      "application/vnd.trueapp": {
        source: "iana",
        extensions: ["tra"]
      },
      "application/vnd.truedoc": {
        source: "iana"
      },
      "application/vnd.ubisoft.webplayer": {
        source: "iana"
      },
      "application/vnd.ufdl": {
        source: "iana",
        extensions: ["ufd", "ufdl"]
      },
      "application/vnd.uiq.theme": {
        source: "iana",
        extensions: ["utz"]
      },
      "application/vnd.umajin": {
        source: "iana",
        extensions: ["umj"]
      },
      "application/vnd.unity": {
        source: "iana",
        extensions: ["unityweb"]
      },
      "application/vnd.uoml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uoml"]
      },
      "application/vnd.uplanet.alert": {
        source: "iana"
      },
      "application/vnd.uplanet.alert-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.channel": {
        source: "iana"
      },
      "application/vnd.uplanet.channel-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.list": {
        source: "iana"
      },
      "application/vnd.uplanet.list-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.signal": {
        source: "iana"
      },
      "application/vnd.uri-map": {
        source: "iana"
      },
      "application/vnd.valve.source.material": {
        source: "iana"
      },
      "application/vnd.vcx": {
        source: "iana",
        extensions: ["vcx"]
      },
      "application/vnd.vd-study": {
        source: "iana"
      },
      "application/vnd.vectorworks": {
        source: "iana"
      },
      "application/vnd.vel+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.verimatrix.vcas": {
        source: "iana"
      },
      "application/vnd.veritone.aion+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.veryant.thin": {
        source: "iana"
      },
      "application/vnd.ves.encrypted": {
        source: "iana"
      },
      "application/vnd.vidsoft.vidconference": {
        source: "iana"
      },
      "application/vnd.visio": {
        source: "iana",
        extensions: ["vsd", "vst", "vss", "vsw"]
      },
      "application/vnd.visionary": {
        source: "iana",
        extensions: ["vis"]
      },
      "application/vnd.vividence.scriptfile": {
        source: "iana"
      },
      "application/vnd.vsf": {
        source: "iana",
        extensions: ["vsf"]
      },
      "application/vnd.wap.sic": {
        source: "iana"
      },
      "application/vnd.wap.slc": {
        source: "iana"
      },
      "application/vnd.wap.wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["wbxml"]
      },
      "application/vnd.wap.wmlc": {
        source: "iana",
        extensions: ["wmlc"]
      },
      "application/vnd.wap.wmlscriptc": {
        source: "iana",
        extensions: ["wmlsc"]
      },
      "application/vnd.webturbo": {
        source: "iana",
        extensions: ["wtb"]
      },
      "application/vnd.wfa.dpp": {
        source: "iana"
      },
      "application/vnd.wfa.p2p": {
        source: "iana"
      },
      "application/vnd.wfa.wsc": {
        source: "iana"
      },
      "application/vnd.windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.wmc": {
        source: "iana"
      },
      "application/vnd.wmf.bootstrap": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica.package": {
        source: "iana"
      },
      "application/vnd.wolfram.player": {
        source: "iana",
        extensions: ["nbp"]
      },
      "application/vnd.wordperfect": {
        source: "iana",
        extensions: ["wpd"]
      },
      "application/vnd.wqd": {
        source: "iana",
        extensions: ["wqd"]
      },
      "application/vnd.wrq-hp3000-labelled": {
        source: "iana"
      },
      "application/vnd.wt.stf": {
        source: "iana",
        extensions: ["stf"]
      },
      "application/vnd.wv.csp+wbxml": {
        source: "iana"
      },
      "application/vnd.wv.csp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.wv.ssp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xacml+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xara": {
        source: "iana",
        extensions: ["xar"]
      },
      "application/vnd.xfdl": {
        source: "iana",
        extensions: ["xfdl"]
      },
      "application/vnd.xfdl.webform": {
        source: "iana"
      },
      "application/vnd.xmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xmpie.cpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.dpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.plan": {
        source: "iana"
      },
      "application/vnd.xmpie.ppkg": {
        source: "iana"
      },
      "application/vnd.xmpie.xlim": {
        source: "iana"
      },
      "application/vnd.yamaha.hv-dic": {
        source: "iana",
        extensions: ["hvd"]
      },
      "application/vnd.yamaha.hv-script": {
        source: "iana",
        extensions: ["hvs"]
      },
      "application/vnd.yamaha.hv-voice": {
        source: "iana",
        extensions: ["hvp"]
      },
      "application/vnd.yamaha.openscoreformat": {
        source: "iana",
        extensions: ["osf"]
      },
      "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osfpvg"]
      },
      "application/vnd.yamaha.remote-setup": {
        source: "iana"
      },
      "application/vnd.yamaha.smaf-audio": {
        source: "iana",
        extensions: ["saf"]
      },
      "application/vnd.yamaha.smaf-phrase": {
        source: "iana",
        extensions: ["spf"]
      },
      "application/vnd.yamaha.through-ngn": {
        source: "iana"
      },
      "application/vnd.yamaha.tunnel-udpencap": {
        source: "iana"
      },
      "application/vnd.yaoweme": {
        source: "iana"
      },
      "application/vnd.yellowriver-custom-menu": {
        source: "iana",
        extensions: ["cmp"]
      },
      "application/vnd.youtube.yt": {
        source: "iana"
      },
      "application/vnd.zul": {
        source: "iana",
        extensions: ["zir", "zirz"]
      },
      "application/vnd.zzazz.deck+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zaz"]
      },
      "application/voicexml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["vxml"]
      },
      "application/voucher-cms+json": {
        source: "iana",
        compressible: true
      },
      "application/vq-rtcpxr": {
        source: "iana"
      },
      "application/wasm": {
        source: "iana",
        compressible: true,
        extensions: ["wasm"]
      },
      "application/watcherinfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wif"]
      },
      "application/webpush-options+json": {
        source: "iana",
        compressible: true
      },
      "application/whoispp-query": {
        source: "iana"
      },
      "application/whoispp-response": {
        source: "iana"
      },
      "application/widget": {
        source: "iana",
        extensions: ["wgt"]
      },
      "application/winhlp": {
        source: "apache",
        extensions: ["hlp"]
      },
      "application/wita": {
        source: "iana"
      },
      "application/wordperfect5.1": {
        source: "iana"
      },
      "application/wsdl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wsdl"]
      },
      "application/wspolicy+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wspolicy"]
      },
      "application/x-7z-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["7z"]
      },
      "application/x-abiword": {
        source: "apache",
        extensions: ["abw"]
      },
      "application/x-ace-compressed": {
        source: "apache",
        extensions: ["ace"]
      },
      "application/x-amf": {
        source: "apache"
      },
      "application/x-apple-diskimage": {
        source: "apache",
        extensions: ["dmg"]
      },
      "application/x-arj": {
        compressible: false,
        extensions: ["arj"]
      },
      "application/x-authorware-bin": {
        source: "apache",
        extensions: ["aab", "x32", "u32", "vox"]
      },
      "application/x-authorware-map": {
        source: "apache",
        extensions: ["aam"]
      },
      "application/x-authorware-seg": {
        source: "apache",
        extensions: ["aas"]
      },
      "application/x-bcpio": {
        source: "apache",
        extensions: ["bcpio"]
      },
      "application/x-bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/x-bittorrent": {
        source: "apache",
        extensions: ["torrent"]
      },
      "application/x-blorb": {
        source: "apache",
        extensions: ["blb", "blorb"]
      },
      "application/x-bzip": {
        source: "apache",
        compressible: false,
        extensions: ["bz"]
      },
      "application/x-bzip2": {
        source: "apache",
        compressible: false,
        extensions: ["bz2", "boz"]
      },
      "application/x-cbr": {
        source: "apache",
        extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
      },
      "application/x-cdlink": {
        source: "apache",
        extensions: ["vcd"]
      },
      "application/x-cfs-compressed": {
        source: "apache",
        extensions: ["cfs"]
      },
      "application/x-chat": {
        source: "apache",
        extensions: ["chat"]
      },
      "application/x-chess-pgn": {
        source: "apache",
        extensions: ["pgn"]
      },
      "application/x-chrome-extension": {
        extensions: ["crx"]
      },
      "application/x-cocoa": {
        source: "nginx",
        extensions: ["cco"]
      },
      "application/x-compress": {
        source: "apache"
      },
      "application/x-conference": {
        source: "apache",
        extensions: ["nsc"]
      },
      "application/x-cpio": {
        source: "apache",
        extensions: ["cpio"]
      },
      "application/x-csh": {
        source: "apache",
        extensions: ["csh"]
      },
      "application/x-deb": {
        compressible: false
      },
      "application/x-debian-package": {
        source: "apache",
        extensions: ["deb", "udeb"]
      },
      "application/x-dgc-compressed": {
        source: "apache",
        extensions: ["dgc"]
      },
      "application/x-director": {
        source: "apache",
        extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
      },
      "application/x-doom": {
        source: "apache",
        extensions: ["wad"]
      },
      "application/x-dtbncx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ncx"]
      },
      "application/x-dtbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dtb"]
      },
      "application/x-dtbresource+xml": {
        source: "apache",
        compressible: true,
        extensions: ["res"]
      },
      "application/x-dvi": {
        source: "apache",
        compressible: false,
        extensions: ["dvi"]
      },
      "application/x-envoy": {
        source: "apache",
        extensions: ["evy"]
      },
      "application/x-eva": {
        source: "apache",
        extensions: ["eva"]
      },
      "application/x-font-bdf": {
        source: "apache",
        extensions: ["bdf"]
      },
      "application/x-font-dos": {
        source: "apache"
      },
      "application/x-font-framemaker": {
        source: "apache"
      },
      "application/x-font-ghostscript": {
        source: "apache",
        extensions: ["gsf"]
      },
      "application/x-font-libgrx": {
        source: "apache"
      },
      "application/x-font-linux-psf": {
        source: "apache",
        extensions: ["psf"]
      },
      "application/x-font-pcf": {
        source: "apache",
        extensions: ["pcf"]
      },
      "application/x-font-snf": {
        source: "apache",
        extensions: ["snf"]
      },
      "application/x-font-speedo": {
        source: "apache"
      },
      "application/x-font-sunos-news": {
        source: "apache"
      },
      "application/x-font-type1": {
        source: "apache",
        extensions: ["pfa", "pfb", "pfm", "afm"]
      },
      "application/x-font-vfont": {
        source: "apache"
      },
      "application/x-freearc": {
        source: "apache",
        extensions: ["arc"]
      },
      "application/x-futuresplash": {
        source: "apache",
        extensions: ["spl"]
      },
      "application/x-gca-compressed": {
        source: "apache",
        extensions: ["gca"]
      },
      "application/x-glulx": {
        source: "apache",
        extensions: ["ulx"]
      },
      "application/x-gnumeric": {
        source: "apache",
        extensions: ["gnumeric"]
      },
      "application/x-gramps-xml": {
        source: "apache",
        extensions: ["gramps"]
      },
      "application/x-gtar": {
        source: "apache",
        extensions: ["gtar"]
      },
      "application/x-gzip": {
        source: "apache"
      },
      "application/x-hdf": {
        source: "apache",
        extensions: ["hdf"]
      },
      "application/x-httpd-php": {
        compressible: true,
        extensions: ["php"]
      },
      "application/x-install-instructions": {
        source: "apache",
        extensions: ["install"]
      },
      "application/x-iso9660-image": {
        source: "apache",
        extensions: ["iso"]
      },
      "application/x-iwork-keynote-sffkey": {
        extensions: ["key"]
      },
      "application/x-iwork-numbers-sffnumbers": {
        extensions: ["numbers"]
      },
      "application/x-iwork-pages-sffpages": {
        extensions: ["pages"]
      },
      "application/x-java-archive-diff": {
        source: "nginx",
        extensions: ["jardiff"]
      },
      "application/x-java-jnlp-file": {
        source: "apache",
        compressible: false,
        extensions: ["jnlp"]
      },
      "application/x-javascript": {
        compressible: true
      },
      "application/x-keepass2": {
        extensions: ["kdbx"]
      },
      "application/x-latex": {
        source: "apache",
        compressible: false,
        extensions: ["latex"]
      },
      "application/x-lua-bytecode": {
        extensions: ["luac"]
      },
      "application/x-lzh-compressed": {
        source: "apache",
        extensions: ["lzh", "lha"]
      },
      "application/x-makeself": {
        source: "nginx",
        extensions: ["run"]
      },
      "application/x-mie": {
        source: "apache",
        extensions: ["mie"]
      },
      "application/x-mobipocket-ebook": {
        source: "apache",
        extensions: ["prc", "mobi"]
      },
      "application/x-mpegurl": {
        compressible: false
      },
      "application/x-ms-application": {
        source: "apache",
        extensions: ["application"]
      },
      "application/x-ms-shortcut": {
        source: "apache",
        extensions: ["lnk"]
      },
      "application/x-ms-wmd": {
        source: "apache",
        extensions: ["wmd"]
      },
      "application/x-ms-wmz": {
        source: "apache",
        extensions: ["wmz"]
      },
      "application/x-ms-xbap": {
        source: "apache",
        extensions: ["xbap"]
      },
      "application/x-msaccess": {
        source: "apache",
        extensions: ["mdb"]
      },
      "application/x-msbinder": {
        source: "apache",
        extensions: ["obd"]
      },
      "application/x-mscardfile": {
        source: "apache",
        extensions: ["crd"]
      },
      "application/x-msclip": {
        source: "apache",
        extensions: ["clp"]
      },
      "application/x-msdos-program": {
        extensions: ["exe"]
      },
      "application/x-msdownload": {
        source: "apache",
        extensions: ["exe", "dll", "com", "bat", "msi"]
      },
      "application/x-msmediaview": {
        source: "apache",
        extensions: ["mvb", "m13", "m14"]
      },
      "application/x-msmetafile": {
        source: "apache",
        extensions: ["wmf", "wmz", "emf", "emz"]
      },
      "application/x-msmoney": {
        source: "apache",
        extensions: ["mny"]
      },
      "application/x-mspublisher": {
        source: "apache",
        extensions: ["pub"]
      },
      "application/x-msschedule": {
        source: "apache",
        extensions: ["scd"]
      },
      "application/x-msterminal": {
        source: "apache",
        extensions: ["trm"]
      },
      "application/x-mswrite": {
        source: "apache",
        extensions: ["wri"]
      },
      "application/x-netcdf": {
        source: "apache",
        extensions: ["nc", "cdf"]
      },
      "application/x-ns-proxy-autoconfig": {
        compressible: true,
        extensions: ["pac"]
      },
      "application/x-nzb": {
        source: "apache",
        extensions: ["nzb"]
      },
      "application/x-perl": {
        source: "nginx",
        extensions: ["pl", "pm"]
      },
      "application/x-pilot": {
        source: "nginx",
        extensions: ["prc", "pdb"]
      },
      "application/x-pkcs12": {
        source: "apache",
        compressible: false,
        extensions: ["p12", "pfx"]
      },
      "application/x-pkcs7-certificates": {
        source: "apache",
        extensions: ["p7b", "spc"]
      },
      "application/x-pkcs7-certreqresp": {
        source: "apache",
        extensions: ["p7r"]
      },
      "application/x-pki-message": {
        source: "iana"
      },
      "application/x-rar-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["rar"]
      },
      "application/x-redhat-package-manager": {
        source: "nginx",
        extensions: ["rpm"]
      },
      "application/x-research-info-systems": {
        source: "apache",
        extensions: ["ris"]
      },
      "application/x-sea": {
        source: "nginx",
        extensions: ["sea"]
      },
      "application/x-sh": {
        source: "apache",
        compressible: true,
        extensions: ["sh"]
      },
      "application/x-shar": {
        source: "apache",
        extensions: ["shar"]
      },
      "application/x-shockwave-flash": {
        source: "apache",
        compressible: false,
        extensions: ["swf"]
      },
      "application/x-silverlight-app": {
        source: "apache",
        extensions: ["xap"]
      },
      "application/x-sql": {
        source: "apache",
        extensions: ["sql"]
      },
      "application/x-stuffit": {
        source: "apache",
        compressible: false,
        extensions: ["sit"]
      },
      "application/x-stuffitx": {
        source: "apache",
        extensions: ["sitx"]
      },
      "application/x-subrip": {
        source: "apache",
        extensions: ["srt"]
      },
      "application/x-sv4cpio": {
        source: "apache",
        extensions: ["sv4cpio"]
      },
      "application/x-sv4crc": {
        source: "apache",
        extensions: ["sv4crc"]
      },
      "application/x-t3vm-image": {
        source: "apache",
        extensions: ["t3"]
      },
      "application/x-tads": {
        source: "apache",
        extensions: ["gam"]
      },
      "application/x-tar": {
        source: "apache",
        compressible: true,
        extensions: ["tar"]
      },
      "application/x-tcl": {
        source: "apache",
        extensions: ["tcl", "tk"]
      },
      "application/x-tex": {
        source: "apache",
        extensions: ["tex"]
      },
      "application/x-tex-tfm": {
        source: "apache",
        extensions: ["tfm"]
      },
      "application/x-texinfo": {
        source: "apache",
        extensions: ["texinfo", "texi"]
      },
      "application/x-tgif": {
        source: "apache",
        extensions: ["obj"]
      },
      "application/x-ustar": {
        source: "apache",
        extensions: ["ustar"]
      },
      "application/x-virtualbox-hdd": {
        compressible: true,
        extensions: ["hdd"]
      },
      "application/x-virtualbox-ova": {
        compressible: true,
        extensions: ["ova"]
      },
      "application/x-virtualbox-ovf": {
        compressible: true,
        extensions: ["ovf"]
      },
      "application/x-virtualbox-vbox": {
        compressible: true,
        extensions: ["vbox"]
      },
      "application/x-virtualbox-vbox-extpack": {
        compressible: false,
        extensions: ["vbox-extpack"]
      },
      "application/x-virtualbox-vdi": {
        compressible: true,
        extensions: ["vdi"]
      },
      "application/x-virtualbox-vhd": {
        compressible: true,
        extensions: ["vhd"]
      },
      "application/x-virtualbox-vmdk": {
        compressible: true,
        extensions: ["vmdk"]
      },
      "application/x-wais-source": {
        source: "apache",
        extensions: ["src"]
      },
      "application/x-web-app-manifest+json": {
        compressible: true,
        extensions: ["webapp"]
      },
      "application/x-www-form-urlencoded": {
        source: "iana",
        compressible: true
      },
      "application/x-x509-ca-cert": {
        source: "iana",
        extensions: ["der", "crt", "pem"]
      },
      "application/x-x509-ca-ra-cert": {
        source: "iana"
      },
      "application/x-x509-next-ca-cert": {
        source: "iana"
      },
      "application/x-xfig": {
        source: "apache",
        extensions: ["fig"]
      },
      "application/x-xliff+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/x-xpinstall": {
        source: "apache",
        compressible: false,
        extensions: ["xpi"]
      },
      "application/x-xz": {
        source: "apache",
        extensions: ["xz"]
      },
      "application/x-zmachine": {
        source: "apache",
        extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
      },
      "application/x400-bp": {
        source: "iana"
      },
      "application/xacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/xaml+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xaml"]
      },
      "application/xcap-att+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xav"]
      },
      "application/xcap-caps+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xca"]
      },
      "application/xcap-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdf"]
      },
      "application/xcap-el+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xel"]
      },
      "application/xcap-error+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcap-ns+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xns"]
      },
      "application/xcon-conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcon-conference-info-diff+xml": {
        source: "iana",
        compressible: true
      },
      "application/xenc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xenc"]
      },
      "application/xhtml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xhtml", "xht"]
      },
      "application/xhtml-voice+xml": {
        source: "apache",
        compressible: true
      },
      "application/xliff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml", "xsl", "xsd", "rng"]
      },
      "application/xml-dtd": {
        source: "iana",
        compressible: true,
        extensions: ["dtd"]
      },
      "application/xml-external-parsed-entity": {
        source: "iana"
      },
      "application/xml-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/xmpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/xop+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xop"]
      },
      "application/xproc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xpl"]
      },
      "application/xslt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xsl", "xslt"]
      },
      "application/xspf+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xspf"]
      },
      "application/xv+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mxml", "xhvml", "xvml", "xvm"]
      },
      "application/yang": {
        source: "iana",
        extensions: ["yang"]
      },
      "application/yang-data+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-data+xml": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/yin+xml": {
        source: "iana",
        compressible: true,
        extensions: ["yin"]
      },
      "application/zip": {
        source: "iana",
        compressible: false,
        extensions: ["zip"]
      },
      "application/zlib": {
        source: "iana"
      },
      "application/zstd": {
        source: "iana"
      },
      "audio/1d-interleaved-parityfec": {
        source: "iana"
      },
      "audio/32kadpcm": {
        source: "iana"
      },
      "audio/3gpp": {
        source: "iana",
        compressible: false,
        extensions: ["3gpp"]
      },
      "audio/3gpp2": {
        source: "iana"
      },
      "audio/aac": {
        source: "iana"
      },
      "audio/ac3": {
        source: "iana"
      },
      "audio/adpcm": {
        source: "apache",
        extensions: ["adp"]
      },
      "audio/amr": {
        source: "iana",
        extensions: ["amr"]
      },
      "audio/amr-wb": {
        source: "iana"
      },
      "audio/amr-wb+": {
        source: "iana"
      },
      "audio/aptx": {
        source: "iana"
      },
      "audio/asc": {
        source: "iana"
      },
      "audio/atrac-advanced-lossless": {
        source: "iana"
      },
      "audio/atrac-x": {
        source: "iana"
      },
      "audio/atrac3": {
        source: "iana"
      },
      "audio/basic": {
        source: "iana",
        compressible: false,
        extensions: ["au", "snd"]
      },
      "audio/bv16": {
        source: "iana"
      },
      "audio/bv32": {
        source: "iana"
      },
      "audio/clearmode": {
        source: "iana"
      },
      "audio/cn": {
        source: "iana"
      },
      "audio/dat12": {
        source: "iana"
      },
      "audio/dls": {
        source: "iana"
      },
      "audio/dsr-es201108": {
        source: "iana"
      },
      "audio/dsr-es202050": {
        source: "iana"
      },
      "audio/dsr-es202211": {
        source: "iana"
      },
      "audio/dsr-es202212": {
        source: "iana"
      },
      "audio/dv": {
        source: "iana"
      },
      "audio/dvi4": {
        source: "iana"
      },
      "audio/eac3": {
        source: "iana"
      },
      "audio/encaprtp": {
        source: "iana"
      },
      "audio/evrc": {
        source: "iana"
      },
      "audio/evrc-qcp": {
        source: "iana"
      },
      "audio/evrc0": {
        source: "iana"
      },
      "audio/evrc1": {
        source: "iana"
      },
      "audio/evrcb": {
        source: "iana"
      },
      "audio/evrcb0": {
        source: "iana"
      },
      "audio/evrcb1": {
        source: "iana"
      },
      "audio/evrcnw": {
        source: "iana"
      },
      "audio/evrcnw0": {
        source: "iana"
      },
      "audio/evrcnw1": {
        source: "iana"
      },
      "audio/evrcwb": {
        source: "iana"
      },
      "audio/evrcwb0": {
        source: "iana"
      },
      "audio/evrcwb1": {
        source: "iana"
      },
      "audio/evs": {
        source: "iana"
      },
      "audio/flexfec": {
        source: "iana"
      },
      "audio/fwdred": {
        source: "iana"
      },
      "audio/g711-0": {
        source: "iana"
      },
      "audio/g719": {
        source: "iana"
      },
      "audio/g722": {
        source: "iana"
      },
      "audio/g7221": {
        source: "iana"
      },
      "audio/g723": {
        source: "iana"
      },
      "audio/g726-16": {
        source: "iana"
      },
      "audio/g726-24": {
        source: "iana"
      },
      "audio/g726-32": {
        source: "iana"
      },
      "audio/g726-40": {
        source: "iana"
      },
      "audio/g728": {
        source: "iana"
      },
      "audio/g729": {
        source: "iana"
      },
      "audio/g7291": {
        source: "iana"
      },
      "audio/g729d": {
        source: "iana"
      },
      "audio/g729e": {
        source: "iana"
      },
      "audio/gsm": {
        source: "iana"
      },
      "audio/gsm-efr": {
        source: "iana"
      },
      "audio/gsm-hr-08": {
        source: "iana"
      },
      "audio/ilbc": {
        source: "iana"
      },
      "audio/ip-mr_v2.5": {
        source: "iana"
      },
      "audio/isac": {
        source: "apache"
      },
      "audio/l16": {
        source: "iana"
      },
      "audio/l20": {
        source: "iana"
      },
      "audio/l24": {
        source: "iana",
        compressible: false
      },
      "audio/l8": {
        source: "iana"
      },
      "audio/lpc": {
        source: "iana"
      },
      "audio/melp": {
        source: "iana"
      },
      "audio/melp1200": {
        source: "iana"
      },
      "audio/melp2400": {
        source: "iana"
      },
      "audio/melp600": {
        source: "iana"
      },
      "audio/mhas": {
        source: "iana"
      },
      "audio/midi": {
        source: "apache",
        extensions: ["mid", "midi", "kar", "rmi"]
      },
      "audio/mobile-xmf": {
        source: "iana",
        extensions: ["mxmf"]
      },
      "audio/mp3": {
        compressible: false,
        extensions: ["mp3"]
      },
      "audio/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["m4a", "mp4a"]
      },
      "audio/mp4a-latm": {
        source: "iana"
      },
      "audio/mpa": {
        source: "iana"
      },
      "audio/mpa-robust": {
        source: "iana"
      },
      "audio/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
      },
      "audio/mpeg4-generic": {
        source: "iana"
      },
      "audio/musepack": {
        source: "apache"
      },
      "audio/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["oga", "ogg", "spx", "opus"]
      },
      "audio/opus": {
        source: "iana"
      },
      "audio/parityfec": {
        source: "iana"
      },
      "audio/pcma": {
        source: "iana"
      },
      "audio/pcma-wb": {
        source: "iana"
      },
      "audio/pcmu": {
        source: "iana"
      },
      "audio/pcmu-wb": {
        source: "iana"
      },
      "audio/prs.sid": {
        source: "iana"
      },
      "audio/qcelp": {
        source: "iana"
      },
      "audio/raptorfec": {
        source: "iana"
      },
      "audio/red": {
        source: "iana"
      },
      "audio/rtp-enc-aescm128": {
        source: "iana"
      },
      "audio/rtp-midi": {
        source: "iana"
      },
      "audio/rtploopback": {
        source: "iana"
      },
      "audio/rtx": {
        source: "iana"
      },
      "audio/s3m": {
        source: "apache",
        extensions: ["s3m"]
      },
      "audio/scip": {
        source: "iana"
      },
      "audio/silk": {
        source: "apache",
        extensions: ["sil"]
      },
      "audio/smv": {
        source: "iana"
      },
      "audio/smv-qcp": {
        source: "iana"
      },
      "audio/smv0": {
        source: "iana"
      },
      "audio/sofa": {
        source: "iana"
      },
      "audio/sp-midi": {
        source: "iana"
      },
      "audio/speex": {
        source: "iana"
      },
      "audio/t140c": {
        source: "iana"
      },
      "audio/t38": {
        source: "iana"
      },
      "audio/telephone-event": {
        source: "iana"
      },
      "audio/tetra_acelp": {
        source: "iana"
      },
      "audio/tetra_acelp_bb": {
        source: "iana"
      },
      "audio/tone": {
        source: "iana"
      },
      "audio/tsvcis": {
        source: "iana"
      },
      "audio/uemclip": {
        source: "iana"
      },
      "audio/ulpfec": {
        source: "iana"
      },
      "audio/usac": {
        source: "iana"
      },
      "audio/vdvi": {
        source: "iana"
      },
      "audio/vmr-wb": {
        source: "iana"
      },
      "audio/vnd.3gpp.iufp": {
        source: "iana"
      },
      "audio/vnd.4sb": {
        source: "iana"
      },
      "audio/vnd.audiokoz": {
        source: "iana"
      },
      "audio/vnd.celp": {
        source: "iana"
      },
      "audio/vnd.cisco.nse": {
        source: "iana"
      },
      "audio/vnd.cmles.radio-events": {
        source: "iana"
      },
      "audio/vnd.cns.anp1": {
        source: "iana"
      },
      "audio/vnd.cns.inf1": {
        source: "iana"
      },
      "audio/vnd.dece.audio": {
        source: "iana",
        extensions: ["uva", "uvva"]
      },
      "audio/vnd.digital-winds": {
        source: "iana",
        extensions: ["eol"]
      },
      "audio/vnd.dlna.adts": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.1": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.2": {
        source: "iana"
      },
      "audio/vnd.dolby.mlp": {
        source: "iana"
      },
      "audio/vnd.dolby.mps": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2x": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2z": {
        source: "iana"
      },
      "audio/vnd.dolby.pulse.1": {
        source: "iana"
      },
      "audio/vnd.dra": {
        source: "iana",
        extensions: ["dra"]
      },
      "audio/vnd.dts": {
        source: "iana",
        extensions: ["dts"]
      },
      "audio/vnd.dts.hd": {
        source: "iana",
        extensions: ["dtshd"]
      },
      "audio/vnd.dts.uhd": {
        source: "iana"
      },
      "audio/vnd.dvb.file": {
        source: "iana"
      },
      "audio/vnd.everad.plj": {
        source: "iana"
      },
      "audio/vnd.hns.audio": {
        source: "iana"
      },
      "audio/vnd.lucent.voice": {
        source: "iana",
        extensions: ["lvp"]
      },
      "audio/vnd.ms-playready.media.pya": {
        source: "iana",
        extensions: ["pya"]
      },
      "audio/vnd.nokia.mobile-xmf": {
        source: "iana"
      },
      "audio/vnd.nortel.vbk": {
        source: "iana"
      },
      "audio/vnd.nuera.ecelp4800": {
        source: "iana",
        extensions: ["ecelp4800"]
      },
      "audio/vnd.nuera.ecelp7470": {
        source: "iana",
        extensions: ["ecelp7470"]
      },
      "audio/vnd.nuera.ecelp9600": {
        source: "iana",
        extensions: ["ecelp9600"]
      },
      "audio/vnd.octel.sbc": {
        source: "iana"
      },
      "audio/vnd.presonus.multitrack": {
        source: "iana"
      },
      "audio/vnd.qcelp": {
        source: "iana"
      },
      "audio/vnd.rhetorex.32kadpcm": {
        source: "iana"
      },
      "audio/vnd.rip": {
        source: "iana",
        extensions: ["rip"]
      },
      "audio/vnd.rn-realaudio": {
        compressible: false
      },
      "audio/vnd.sealedmedia.softseal.mpeg": {
        source: "iana"
      },
      "audio/vnd.vmx.cvsd": {
        source: "iana"
      },
      "audio/vnd.wave": {
        compressible: false
      },
      "audio/vorbis": {
        source: "iana",
        compressible: false
      },
      "audio/vorbis-config": {
        source: "iana"
      },
      "audio/wav": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/wave": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/webm": {
        source: "apache",
        compressible: false,
        extensions: ["weba"]
      },
      "audio/x-aac": {
        source: "apache",
        compressible: false,
        extensions: ["aac"]
      },
      "audio/x-aiff": {
        source: "apache",
        extensions: ["aif", "aiff", "aifc"]
      },
      "audio/x-caf": {
        source: "apache",
        compressible: false,
        extensions: ["caf"]
      },
      "audio/x-flac": {
        source: "apache",
        extensions: ["flac"]
      },
      "audio/x-m4a": {
        source: "nginx",
        extensions: ["m4a"]
      },
      "audio/x-matroska": {
        source: "apache",
        extensions: ["mka"]
      },
      "audio/x-mpegurl": {
        source: "apache",
        extensions: ["m3u"]
      },
      "audio/x-ms-wax": {
        source: "apache",
        extensions: ["wax"]
      },
      "audio/x-ms-wma": {
        source: "apache",
        extensions: ["wma"]
      },
      "audio/x-pn-realaudio": {
        source: "apache",
        extensions: ["ram", "ra"]
      },
      "audio/x-pn-realaudio-plugin": {
        source: "apache",
        extensions: ["rmp"]
      },
      "audio/x-realaudio": {
        source: "nginx",
        extensions: ["ra"]
      },
      "audio/x-tta": {
        source: "apache"
      },
      "audio/x-wav": {
        source: "apache",
        extensions: ["wav"]
      },
      "audio/xm": {
        source: "apache",
        extensions: ["xm"]
      },
      "chemical/x-cdx": {
        source: "apache",
        extensions: ["cdx"]
      },
      "chemical/x-cif": {
        source: "apache",
        extensions: ["cif"]
      },
      "chemical/x-cmdf": {
        source: "apache",
        extensions: ["cmdf"]
      },
      "chemical/x-cml": {
        source: "apache",
        extensions: ["cml"]
      },
      "chemical/x-csml": {
        source: "apache",
        extensions: ["csml"]
      },
      "chemical/x-pdb": {
        source: "apache"
      },
      "chemical/x-xyz": {
        source: "apache",
        extensions: ["xyz"]
      },
      "font/collection": {
        source: "iana",
        extensions: ["ttc"]
      },
      "font/otf": {
        source: "iana",
        compressible: true,
        extensions: ["otf"]
      },
      "font/sfnt": {
        source: "iana"
      },
      "font/ttf": {
        source: "iana",
        compressible: true,
        extensions: ["ttf"]
      },
      "font/woff": {
        source: "iana",
        extensions: ["woff"]
      },
      "font/woff2": {
        source: "iana",
        extensions: ["woff2"]
      },
      "image/aces": {
        source: "iana",
        extensions: ["exr"]
      },
      "image/apng": {
        compressible: false,
        extensions: ["apng"]
      },
      "image/avci": {
        source: "iana",
        extensions: ["avci"]
      },
      "image/avcs": {
        source: "iana",
        extensions: ["avcs"]
      },
      "image/avif": {
        source: "iana",
        compressible: false,
        extensions: ["avif"]
      },
      "image/bmp": {
        source: "iana",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/cgm": {
        source: "iana",
        extensions: ["cgm"]
      },
      "image/dicom-rle": {
        source: "iana",
        extensions: ["drle"]
      },
      "image/emf": {
        source: "iana",
        extensions: ["emf"]
      },
      "image/fits": {
        source: "iana",
        extensions: ["fits"]
      },
      "image/g3fax": {
        source: "iana",
        extensions: ["g3"]
      },
      "image/gif": {
        source: "iana",
        compressible: false,
        extensions: ["gif"]
      },
      "image/heic": {
        source: "iana",
        extensions: ["heic"]
      },
      "image/heic-sequence": {
        source: "iana",
        extensions: ["heics"]
      },
      "image/heif": {
        source: "iana",
        extensions: ["heif"]
      },
      "image/heif-sequence": {
        source: "iana",
        extensions: ["heifs"]
      },
      "image/hej2k": {
        source: "iana",
        extensions: ["hej2"]
      },
      "image/hsj2": {
        source: "iana",
        extensions: ["hsj2"]
      },
      "image/ief": {
        source: "iana",
        extensions: ["ief"]
      },
      "image/jls": {
        source: "iana",
        extensions: ["jls"]
      },
      "image/jp2": {
        source: "iana",
        compressible: false,
        extensions: ["jp2", "jpg2"]
      },
      "image/jpeg": {
        source: "iana",
        compressible: false,
        extensions: ["jpeg", "jpg", "jpe"]
      },
      "image/jph": {
        source: "iana",
        extensions: ["jph"]
      },
      "image/jphc": {
        source: "iana",
        extensions: ["jhc"]
      },
      "image/jpm": {
        source: "iana",
        compressible: false,
        extensions: ["jpm"]
      },
      "image/jpx": {
        source: "iana",
        compressible: false,
        extensions: ["jpx", "jpf"]
      },
      "image/jxr": {
        source: "iana",
        extensions: ["jxr"]
      },
      "image/jxra": {
        source: "iana",
        extensions: ["jxra"]
      },
      "image/jxrs": {
        source: "iana",
        extensions: ["jxrs"]
      },
      "image/jxs": {
        source: "iana",
        extensions: ["jxs"]
      },
      "image/jxsc": {
        source: "iana",
        extensions: ["jxsc"]
      },
      "image/jxsi": {
        source: "iana",
        extensions: ["jxsi"]
      },
      "image/jxss": {
        source: "iana",
        extensions: ["jxss"]
      },
      "image/ktx": {
        source: "iana",
        extensions: ["ktx"]
      },
      "image/ktx2": {
        source: "iana",
        extensions: ["ktx2"]
      },
      "image/naplps": {
        source: "iana"
      },
      "image/pjpeg": {
        compressible: false
      },
      "image/png": {
        source: "iana",
        compressible: false,
        extensions: ["png"]
      },
      "image/prs.btif": {
        source: "iana",
        extensions: ["btif"]
      },
      "image/prs.pti": {
        source: "iana",
        extensions: ["pti"]
      },
      "image/pwg-raster": {
        source: "iana"
      },
      "image/sgi": {
        source: "apache",
        extensions: ["sgi"]
      },
      "image/svg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["svg", "svgz"]
      },
      "image/t38": {
        source: "iana",
        extensions: ["t38"]
      },
      "image/tiff": {
        source: "iana",
        compressible: false,
        extensions: ["tif", "tiff"]
      },
      "image/tiff-fx": {
        source: "iana",
        extensions: ["tfx"]
      },
      "image/vnd.adobe.photoshop": {
        source: "iana",
        compressible: true,
        extensions: ["psd"]
      },
      "image/vnd.airzip.accelerator.azv": {
        source: "iana",
        extensions: ["azv"]
      },
      "image/vnd.cns.inf2": {
        source: "iana"
      },
      "image/vnd.dece.graphic": {
        source: "iana",
        extensions: ["uvi", "uvvi", "uvg", "uvvg"]
      },
      "image/vnd.djvu": {
        source: "iana",
        extensions: ["djvu", "djv"]
      },
      "image/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "image/vnd.dwg": {
        source: "iana",
        extensions: ["dwg"]
      },
      "image/vnd.dxf": {
        source: "iana",
        extensions: ["dxf"]
      },
      "image/vnd.fastbidsheet": {
        source: "iana",
        extensions: ["fbs"]
      },
      "image/vnd.fpx": {
        source: "iana",
        extensions: ["fpx"]
      },
      "image/vnd.fst": {
        source: "iana",
        extensions: ["fst"]
      },
      "image/vnd.fujixerox.edmics-mmr": {
        source: "iana",
        extensions: ["mmr"]
      },
      "image/vnd.fujixerox.edmics-rlc": {
        source: "iana",
        extensions: ["rlc"]
      },
      "image/vnd.globalgraphics.pgb": {
        source: "iana"
      },
      "image/vnd.microsoft.icon": {
        source: "iana",
        compressible: true,
        extensions: ["ico"]
      },
      "image/vnd.mix": {
        source: "iana"
      },
      "image/vnd.mozilla.apng": {
        source: "iana"
      },
      "image/vnd.ms-dds": {
        compressible: true,
        extensions: ["dds"]
      },
      "image/vnd.ms-modi": {
        source: "iana",
        extensions: ["mdi"]
      },
      "image/vnd.ms-photo": {
        source: "apache",
        extensions: ["wdp"]
      },
      "image/vnd.net-fpx": {
        source: "iana",
        extensions: ["npx"]
      },
      "image/vnd.pco.b16": {
        source: "iana",
        extensions: ["b16"]
      },
      "image/vnd.radiance": {
        source: "iana"
      },
      "image/vnd.sealed.png": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.gif": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.jpg": {
        source: "iana"
      },
      "image/vnd.svf": {
        source: "iana"
      },
      "image/vnd.tencent.tap": {
        source: "iana",
        extensions: ["tap"]
      },
      "image/vnd.valve.source.texture": {
        source: "iana",
        extensions: ["vtf"]
      },
      "image/vnd.wap.wbmp": {
        source: "iana",
        extensions: ["wbmp"]
      },
      "image/vnd.xiff": {
        source: "iana",
        extensions: ["xif"]
      },
      "image/vnd.zbrush.pcx": {
        source: "iana",
        extensions: ["pcx"]
      },
      "image/webp": {
        source: "apache",
        extensions: ["webp"]
      },
      "image/wmf": {
        source: "iana",
        extensions: ["wmf"]
      },
      "image/x-3ds": {
        source: "apache",
        extensions: ["3ds"]
      },
      "image/x-cmu-raster": {
        source: "apache",
        extensions: ["ras"]
      },
      "image/x-cmx": {
        source: "apache",
        extensions: ["cmx"]
      },
      "image/x-freehand": {
        source: "apache",
        extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
      },
      "image/x-icon": {
        source: "apache",
        compressible: true,
        extensions: ["ico"]
      },
      "image/x-jng": {
        source: "nginx",
        extensions: ["jng"]
      },
      "image/x-mrsid-image": {
        source: "apache",
        extensions: ["sid"]
      },
      "image/x-ms-bmp": {
        source: "nginx",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/x-pcx": {
        source: "apache",
        extensions: ["pcx"]
      },
      "image/x-pict": {
        source: "apache",
        extensions: ["pic", "pct"]
      },
      "image/x-portable-anymap": {
        source: "apache",
        extensions: ["pnm"]
      },
      "image/x-portable-bitmap": {
        source: "apache",
        extensions: ["pbm"]
      },
      "image/x-portable-graymap": {
        source: "apache",
        extensions: ["pgm"]
      },
      "image/x-portable-pixmap": {
        source: "apache",
        extensions: ["ppm"]
      },
      "image/x-rgb": {
        source: "apache",
        extensions: ["rgb"]
      },
      "image/x-tga": {
        source: "apache",
        extensions: ["tga"]
      },
      "image/x-xbitmap": {
        source: "apache",
        extensions: ["xbm"]
      },
      "image/x-xcf": {
        compressible: false
      },
      "image/x-xpixmap": {
        source: "apache",
        extensions: ["xpm"]
      },
      "image/x-xwindowdump": {
        source: "apache",
        extensions: ["xwd"]
      },
      "message/cpim": {
        source: "iana"
      },
      "message/delivery-status": {
        source: "iana"
      },
      "message/disposition-notification": {
        source: "iana",
        extensions: [
          "disposition-notification"
        ]
      },
      "message/external-body": {
        source: "iana"
      },
      "message/feedback-report": {
        source: "iana"
      },
      "message/global": {
        source: "iana",
        extensions: ["u8msg"]
      },
      "message/global-delivery-status": {
        source: "iana",
        extensions: ["u8dsn"]
      },
      "message/global-disposition-notification": {
        source: "iana",
        extensions: ["u8mdn"]
      },
      "message/global-headers": {
        source: "iana",
        extensions: ["u8hdr"]
      },
      "message/http": {
        source: "iana",
        compressible: false
      },
      "message/imdn+xml": {
        source: "iana",
        compressible: true
      },
      "message/news": {
        source: "iana"
      },
      "message/partial": {
        source: "iana",
        compressible: false
      },
      "message/rfc822": {
        source: "iana",
        compressible: true,
        extensions: ["eml", "mime"]
      },
      "message/s-http": {
        source: "iana"
      },
      "message/sip": {
        source: "iana"
      },
      "message/sipfrag": {
        source: "iana"
      },
      "message/tracking-status": {
        source: "iana"
      },
      "message/vnd.si.simp": {
        source: "iana"
      },
      "message/vnd.wfa.wsc": {
        source: "iana",
        extensions: ["wsc"]
      },
      "model/3mf": {
        source: "iana",
        extensions: ["3mf"]
      },
      "model/e57": {
        source: "iana"
      },
      "model/gltf+json": {
        source: "iana",
        compressible: true,
        extensions: ["gltf"]
      },
      "model/gltf-binary": {
        source: "iana",
        compressible: true,
        extensions: ["glb"]
      },
      "model/iges": {
        source: "iana",
        compressible: false,
        extensions: ["igs", "iges"]
      },
      "model/mesh": {
        source: "iana",
        compressible: false,
        extensions: ["msh", "mesh", "silo"]
      },
      "model/mtl": {
        source: "iana",
        extensions: ["mtl"]
      },
      "model/obj": {
        source: "iana",
        extensions: ["obj"]
      },
      "model/step": {
        source: "iana"
      },
      "model/step+xml": {
        source: "iana",
        compressible: true,
        extensions: ["stpx"]
      },
      "model/step+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpz"]
      },
      "model/step-xml+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpxz"]
      },
      "model/stl": {
        source: "iana",
        extensions: ["stl"]
      },
      "model/vnd.collada+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dae"]
      },
      "model/vnd.dwf": {
        source: "iana",
        extensions: ["dwf"]
      },
      "model/vnd.flatland.3dml": {
        source: "iana"
      },
      "model/vnd.gdl": {
        source: "iana",
        extensions: ["gdl"]
      },
      "model/vnd.gs-gdl": {
        source: "apache"
      },
      "model/vnd.gs.gdl": {
        source: "iana"
      },
      "model/vnd.gtw": {
        source: "iana",
        extensions: ["gtw"]
      },
      "model/vnd.moml+xml": {
        source: "iana",
        compressible: true
      },
      "model/vnd.mts": {
        source: "iana",
        extensions: ["mts"]
      },
      "model/vnd.opengex": {
        source: "iana",
        extensions: ["ogex"]
      },
      "model/vnd.parasolid.transmit.binary": {
        source: "iana",
        extensions: ["x_b"]
      },
      "model/vnd.parasolid.transmit.text": {
        source: "iana",
        extensions: ["x_t"]
      },
      "model/vnd.pytha.pyox": {
        source: "iana"
      },
      "model/vnd.rosette.annotated-data-model": {
        source: "iana"
      },
      "model/vnd.sap.vds": {
        source: "iana",
        extensions: ["vds"]
      },
      "model/vnd.usdz+zip": {
        source: "iana",
        compressible: false,
        extensions: ["usdz"]
      },
      "model/vnd.valve.source.compiled-map": {
        source: "iana",
        extensions: ["bsp"]
      },
      "model/vnd.vtu": {
        source: "iana",
        extensions: ["vtu"]
      },
      "model/vrml": {
        source: "iana",
        compressible: false,
        extensions: ["wrl", "vrml"]
      },
      "model/x3d+binary": {
        source: "apache",
        compressible: false,
        extensions: ["x3db", "x3dbz"]
      },
      "model/x3d+fastinfoset": {
        source: "iana",
        extensions: ["x3db"]
      },
      "model/x3d+vrml": {
        source: "apache",
        compressible: false,
        extensions: ["x3dv", "x3dvz"]
      },
      "model/x3d+xml": {
        source: "iana",
        compressible: true,
        extensions: ["x3d", "x3dz"]
      },
      "model/x3d-vrml": {
        source: "iana",
        extensions: ["x3dv"]
      },
      "multipart/alternative": {
        source: "iana",
        compressible: false
      },
      "multipart/appledouble": {
        source: "iana"
      },
      "multipart/byteranges": {
        source: "iana"
      },
      "multipart/digest": {
        source: "iana"
      },
      "multipart/encrypted": {
        source: "iana",
        compressible: false
      },
      "multipart/form-data": {
        source: "iana",
        compressible: false
      },
      "multipart/header-set": {
        source: "iana"
      },
      "multipart/mixed": {
        source: "iana"
      },
      "multipart/multilingual": {
        source: "iana"
      },
      "multipart/parallel": {
        source: "iana"
      },
      "multipart/related": {
        source: "iana",
        compressible: false
      },
      "multipart/report": {
        source: "iana"
      },
      "multipart/signed": {
        source: "iana",
        compressible: false
      },
      "multipart/vnd.bint.med-plus": {
        source: "iana"
      },
      "multipart/voice-message": {
        source: "iana"
      },
      "multipart/x-mixed-replace": {
        source: "iana"
      },
      "text/1d-interleaved-parityfec": {
        source: "iana"
      },
      "text/cache-manifest": {
        source: "iana",
        compressible: true,
        extensions: ["appcache", "manifest"]
      },
      "text/calendar": {
        source: "iana",
        extensions: ["ics", "ifb"]
      },
      "text/calender": {
        compressible: true
      },
      "text/cmd": {
        compressible: true
      },
      "text/coffeescript": {
        extensions: ["coffee", "litcoffee"]
      },
      "text/cql": {
        source: "iana"
      },
      "text/cql-expression": {
        source: "iana"
      },
      "text/cql-identifier": {
        source: "iana"
      },
      "text/css": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["css"]
      },
      "text/csv": {
        source: "iana",
        compressible: true,
        extensions: ["csv"]
      },
      "text/csv-schema": {
        source: "iana"
      },
      "text/directory": {
        source: "iana"
      },
      "text/dns": {
        source: "iana"
      },
      "text/ecmascript": {
        source: "iana"
      },
      "text/encaprtp": {
        source: "iana"
      },
      "text/enriched": {
        source: "iana"
      },
      "text/fhirpath": {
        source: "iana"
      },
      "text/flexfec": {
        source: "iana"
      },
      "text/fwdred": {
        source: "iana"
      },
      "text/gff3": {
        source: "iana"
      },
      "text/grammar-ref-list": {
        source: "iana"
      },
      "text/html": {
        source: "iana",
        compressible: true,
        extensions: ["html", "htm", "shtml"]
      },
      "text/jade": {
        extensions: ["jade"]
      },
      "text/javascript": {
        source: "iana",
        compressible: true
      },
      "text/jcr-cnd": {
        source: "iana"
      },
      "text/jsx": {
        compressible: true,
        extensions: ["jsx"]
      },
      "text/less": {
        compressible: true,
        extensions: ["less"]
      },
      "text/markdown": {
        source: "iana",
        compressible: true,
        extensions: ["markdown", "md"]
      },
      "text/mathml": {
        source: "nginx",
        extensions: ["mml"]
      },
      "text/mdx": {
        compressible: true,
        extensions: ["mdx"]
      },
      "text/mizar": {
        source: "iana"
      },
      "text/n3": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["n3"]
      },
      "text/parameters": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/parityfec": {
        source: "iana"
      },
      "text/plain": {
        source: "iana",
        compressible: true,
        extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
      },
      "text/provenance-notation": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/prs.fallenstein.rst": {
        source: "iana"
      },
      "text/prs.lines.tag": {
        source: "iana",
        extensions: ["dsc"]
      },
      "text/prs.prop.logic": {
        source: "iana"
      },
      "text/raptorfec": {
        source: "iana"
      },
      "text/red": {
        source: "iana"
      },
      "text/rfc822-headers": {
        source: "iana"
      },
      "text/richtext": {
        source: "iana",
        compressible: true,
        extensions: ["rtx"]
      },
      "text/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "text/rtp-enc-aescm128": {
        source: "iana"
      },
      "text/rtploopback": {
        source: "iana"
      },
      "text/rtx": {
        source: "iana"
      },
      "text/sgml": {
        source: "iana",
        extensions: ["sgml", "sgm"]
      },
      "text/shaclc": {
        source: "iana"
      },
      "text/shex": {
        source: "iana",
        extensions: ["shex"]
      },
      "text/slim": {
        extensions: ["slim", "slm"]
      },
      "text/spdx": {
        source: "iana",
        extensions: ["spdx"]
      },
      "text/strings": {
        source: "iana"
      },
      "text/stylus": {
        extensions: ["stylus", "styl"]
      },
      "text/t140": {
        source: "iana"
      },
      "text/tab-separated-values": {
        source: "iana",
        compressible: true,
        extensions: ["tsv"]
      },
      "text/troff": {
        source: "iana",
        extensions: ["t", "tr", "roff", "man", "me", "ms"]
      },
      "text/turtle": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["ttl"]
      },
      "text/ulpfec": {
        source: "iana"
      },
      "text/uri-list": {
        source: "iana",
        compressible: true,
        extensions: ["uri", "uris", "urls"]
      },
      "text/vcard": {
        source: "iana",
        compressible: true,
        extensions: ["vcard"]
      },
      "text/vnd.a": {
        source: "iana"
      },
      "text/vnd.abc": {
        source: "iana"
      },
      "text/vnd.ascii-art": {
        source: "iana"
      },
      "text/vnd.curl": {
        source: "iana",
        extensions: ["curl"]
      },
      "text/vnd.curl.dcurl": {
        source: "apache",
        extensions: ["dcurl"]
      },
      "text/vnd.curl.mcurl": {
        source: "apache",
        extensions: ["mcurl"]
      },
      "text/vnd.curl.scurl": {
        source: "apache",
        extensions: ["scurl"]
      },
      "text/vnd.debian.copyright": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.dmclientscript": {
        source: "iana"
      },
      "text/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "text/vnd.esmertec.theme-descriptor": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.familysearch.gedcom": {
        source: "iana",
        extensions: ["ged"]
      },
      "text/vnd.ficlab.flt": {
        source: "iana"
      },
      "text/vnd.fly": {
        source: "iana",
        extensions: ["fly"]
      },
      "text/vnd.fmi.flexstor": {
        source: "iana",
        extensions: ["flx"]
      },
      "text/vnd.gml": {
        source: "iana"
      },
      "text/vnd.graphviz": {
        source: "iana",
        extensions: ["gv"]
      },
      "text/vnd.hans": {
        source: "iana"
      },
      "text/vnd.hgl": {
        source: "iana"
      },
      "text/vnd.in3d.3dml": {
        source: "iana",
        extensions: ["3dml"]
      },
      "text/vnd.in3d.spot": {
        source: "iana",
        extensions: ["spot"]
      },
      "text/vnd.iptc.newsml": {
        source: "iana"
      },
      "text/vnd.iptc.nitf": {
        source: "iana"
      },
      "text/vnd.latex-z": {
        source: "iana"
      },
      "text/vnd.motorola.reflex": {
        source: "iana"
      },
      "text/vnd.ms-mediapackage": {
        source: "iana"
      },
      "text/vnd.net2phone.commcenter.command": {
        source: "iana"
      },
      "text/vnd.radisys.msml-basic-layout": {
        source: "iana"
      },
      "text/vnd.senx.warpscript": {
        source: "iana"
      },
      "text/vnd.si.uricatalogue": {
        source: "iana"
      },
      "text/vnd.sosi": {
        source: "iana"
      },
      "text/vnd.sun.j2me.app-descriptor": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["jad"]
      },
      "text/vnd.trolltech.linguist": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.wap.si": {
        source: "iana"
      },
      "text/vnd.wap.sl": {
        source: "iana"
      },
      "text/vnd.wap.wml": {
        source: "iana",
        extensions: ["wml"]
      },
      "text/vnd.wap.wmlscript": {
        source: "iana",
        extensions: ["wmls"]
      },
      "text/vtt": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["vtt"]
      },
      "text/x-asm": {
        source: "apache",
        extensions: ["s", "asm"]
      },
      "text/x-c": {
        source: "apache",
        extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
      },
      "text/x-component": {
        source: "nginx",
        extensions: ["htc"]
      },
      "text/x-fortran": {
        source: "apache",
        extensions: ["f", "for", "f77", "f90"]
      },
      "text/x-gwt-rpc": {
        compressible: true
      },
      "text/x-handlebars-template": {
        extensions: ["hbs"]
      },
      "text/x-java-source": {
        source: "apache",
        extensions: ["java"]
      },
      "text/x-jquery-tmpl": {
        compressible: true
      },
      "text/x-lua": {
        extensions: ["lua"]
      },
      "text/x-markdown": {
        compressible: true,
        extensions: ["mkd"]
      },
      "text/x-nfo": {
        source: "apache",
        extensions: ["nfo"]
      },
      "text/x-opml": {
        source: "apache",
        extensions: ["opml"]
      },
      "text/x-org": {
        compressible: true,
        extensions: ["org"]
      },
      "text/x-pascal": {
        source: "apache",
        extensions: ["p", "pas"]
      },
      "text/x-processing": {
        compressible: true,
        extensions: ["pde"]
      },
      "text/x-sass": {
        extensions: ["sass"]
      },
      "text/x-scss": {
        extensions: ["scss"]
      },
      "text/x-setext": {
        source: "apache",
        extensions: ["etx"]
      },
      "text/x-sfv": {
        source: "apache",
        extensions: ["sfv"]
      },
      "text/x-suse-ymp": {
        compressible: true,
        extensions: ["ymp"]
      },
      "text/x-uuencode": {
        source: "apache",
        extensions: ["uu"]
      },
      "text/x-vcalendar": {
        source: "apache",
        extensions: ["vcs"]
      },
      "text/x-vcard": {
        source: "apache",
        extensions: ["vcf"]
      },
      "text/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml"]
      },
      "text/xml-external-parsed-entity": {
        source: "iana"
      },
      "text/yaml": {
        compressible: true,
        extensions: ["yaml", "yml"]
      },
      "video/1d-interleaved-parityfec": {
        source: "iana"
      },
      "video/3gpp": {
        source: "iana",
        extensions: ["3gp", "3gpp"]
      },
      "video/3gpp-tt": {
        source: "iana"
      },
      "video/3gpp2": {
        source: "iana",
        extensions: ["3g2"]
      },
      "video/av1": {
        source: "iana"
      },
      "video/bmpeg": {
        source: "iana"
      },
      "video/bt656": {
        source: "iana"
      },
      "video/celb": {
        source: "iana"
      },
      "video/dv": {
        source: "iana"
      },
      "video/encaprtp": {
        source: "iana"
      },
      "video/ffv1": {
        source: "iana"
      },
      "video/flexfec": {
        source: "iana"
      },
      "video/h261": {
        source: "iana",
        extensions: ["h261"]
      },
      "video/h263": {
        source: "iana",
        extensions: ["h263"]
      },
      "video/h263-1998": {
        source: "iana"
      },
      "video/h263-2000": {
        source: "iana"
      },
      "video/h264": {
        source: "iana",
        extensions: ["h264"]
      },
      "video/h264-rcdo": {
        source: "iana"
      },
      "video/h264-svc": {
        source: "iana"
      },
      "video/h265": {
        source: "iana"
      },
      "video/iso.segment": {
        source: "iana",
        extensions: ["m4s"]
      },
      "video/jpeg": {
        source: "iana",
        extensions: ["jpgv"]
      },
      "video/jpeg2000": {
        source: "iana"
      },
      "video/jpm": {
        source: "apache",
        extensions: ["jpm", "jpgm"]
      },
      "video/jxsv": {
        source: "iana"
      },
      "video/mj2": {
        source: "iana",
        extensions: ["mj2", "mjp2"]
      },
      "video/mp1s": {
        source: "iana"
      },
      "video/mp2p": {
        source: "iana"
      },
      "video/mp2t": {
        source: "iana",
        extensions: ["ts"]
      },
      "video/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["mp4", "mp4v", "mpg4"]
      },
      "video/mp4v-es": {
        source: "iana"
      },
      "video/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
      },
      "video/mpeg4-generic": {
        source: "iana"
      },
      "video/mpv": {
        source: "iana"
      },
      "video/nv": {
        source: "iana"
      },
      "video/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogv"]
      },
      "video/parityfec": {
        source: "iana"
      },
      "video/pointer": {
        source: "iana"
      },
      "video/quicktime": {
        source: "iana",
        compressible: false,
        extensions: ["qt", "mov"]
      },
      "video/raptorfec": {
        source: "iana"
      },
      "video/raw": {
        source: "iana"
      },
      "video/rtp-enc-aescm128": {
        source: "iana"
      },
      "video/rtploopback": {
        source: "iana"
      },
      "video/rtx": {
        source: "iana"
      },
      "video/scip": {
        source: "iana"
      },
      "video/smpte291": {
        source: "iana"
      },
      "video/smpte292m": {
        source: "iana"
      },
      "video/ulpfec": {
        source: "iana"
      },
      "video/vc1": {
        source: "iana"
      },
      "video/vc2": {
        source: "iana"
      },
      "video/vnd.cctv": {
        source: "iana"
      },
      "video/vnd.dece.hd": {
        source: "iana",
        extensions: ["uvh", "uvvh"]
      },
      "video/vnd.dece.mobile": {
        source: "iana",
        extensions: ["uvm", "uvvm"]
      },
      "video/vnd.dece.mp4": {
        source: "iana"
      },
      "video/vnd.dece.pd": {
        source: "iana",
        extensions: ["uvp", "uvvp"]
      },
      "video/vnd.dece.sd": {
        source: "iana",
        extensions: ["uvs", "uvvs"]
      },
      "video/vnd.dece.video": {
        source: "iana",
        extensions: ["uvv", "uvvv"]
      },
      "video/vnd.directv.mpeg": {
        source: "iana"
      },
      "video/vnd.directv.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dlna.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dvb.file": {
        source: "iana",
        extensions: ["dvb"]
      },
      "video/vnd.fvt": {
        source: "iana",
        extensions: ["fvt"]
      },
      "video/vnd.hns.video": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsavc": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsmpeg2": {
        source: "iana"
      },
      "video/vnd.motorola.video": {
        source: "iana"
      },
      "video/vnd.motorola.videop": {
        source: "iana"
      },
      "video/vnd.mpegurl": {
        source: "iana",
        extensions: ["mxu", "m4u"]
      },
      "video/vnd.ms-playready.media.pyv": {
        source: "iana",
        extensions: ["pyv"]
      },
      "video/vnd.nokia.interleaved-multimedia": {
        source: "iana"
      },
      "video/vnd.nokia.mp4vr": {
        source: "iana"
      },
      "video/vnd.nokia.videovoip": {
        source: "iana"
      },
      "video/vnd.objectvideo": {
        source: "iana"
      },
      "video/vnd.radgamettools.bink": {
        source: "iana"
      },
      "video/vnd.radgamettools.smacker": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg1": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg4": {
        source: "iana"
      },
      "video/vnd.sealed.swf": {
        source: "iana"
      },
      "video/vnd.sealedmedia.softseal.mov": {
        source: "iana"
      },
      "video/vnd.uvvu.mp4": {
        source: "iana",
        extensions: ["uvu", "uvvu"]
      },
      "video/vnd.vivo": {
        source: "iana",
        extensions: ["viv"]
      },
      "video/vnd.youtube.yt": {
        source: "iana"
      },
      "video/vp8": {
        source: "iana"
      },
      "video/vp9": {
        source: "iana"
      },
      "video/webm": {
        source: "apache",
        compressible: false,
        extensions: ["webm"]
      },
      "video/x-f4v": {
        source: "apache",
        extensions: ["f4v"]
      },
      "video/x-fli": {
        source: "apache",
        extensions: ["fli"]
      },
      "video/x-flv": {
        source: "apache",
        compressible: false,
        extensions: ["flv"]
      },
      "video/x-m4v": {
        source: "apache",
        extensions: ["m4v"]
      },
      "video/x-matroska": {
        source: "apache",
        compressible: false,
        extensions: ["mkv", "mk3d", "mks"]
      },
      "video/x-mng": {
        source: "apache",
        extensions: ["mng"]
      },
      "video/x-ms-asf": {
        source: "apache",
        extensions: ["asf", "asx"]
      },
      "video/x-ms-vob": {
        source: "apache",
        extensions: ["vob"]
      },
      "video/x-ms-wm": {
        source: "apache",
        extensions: ["wm"]
      },
      "video/x-ms-wmv": {
        source: "apache",
        compressible: false,
        extensions: ["wmv"]
      },
      "video/x-ms-wmx": {
        source: "apache",
        extensions: ["wmx"]
      },
      "video/x-ms-wvx": {
        source: "apache",
        extensions: ["wvx"]
      },
      "video/x-msvideo": {
        source: "apache",
        extensions: ["avi"]
      },
      "video/x-sgi-movie": {
        source: "apache",
        extensions: ["movie"]
      },
      "video/x-smv": {
        source: "apache",
        extensions: ["smv"]
      },
      "x-conference/x-cooltalk": {
        source: "apache",
        extensions: ["ice"]
      },
      "x-shader/x-fragment": {
        compressible: true
      },
      "x-shader/x-vertex": {
        compressible: true
      }
    };
  }
});

// ../../node_modules/mime-db/index.js
var require_mime_db = __commonJS({
  "../../node_modules/mime-db/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_db();
  }
});

// ../../node_modules/mime-types/index.js
var require_mime_types = __commonJS({
  "../../node_modules/mime-types/index.js"(exports2) {
    "use strict";
    var db = require_mime_db();
    var extname = require("path").extname;
    var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
    var TEXT_TYPE_REGEXP = /^text\//i;
    exports2.charset = charset;
    exports2.charsets = { lookup: charset };
    exports2.contentType = contentType;
    exports2.extension = extension;
    exports2.extensions = /* @__PURE__ */ Object.create(null);
    exports2.lookup = lookup;
    exports2.types = /* @__PURE__ */ Object.create(null);
    populateMaps(exports2.extensions, exports2.types);
    function charset(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var mime = match && db[match[1].toLowerCase()];
      if (mime && mime.charset) {
        return mime.charset;
      }
      if (match && TEXT_TYPE_REGEXP.test(match[1])) {
        return "UTF-8";
      }
      return false;
    }
    function contentType(str) {
      if (!str || typeof str !== "string") {
        return false;
      }
      var mime = str.indexOf("/") === -1 ? exports2.lookup(str) : str;
      if (!mime) {
        return false;
      }
      if (mime.indexOf("charset") === -1) {
        var charset2 = exports2.charset(mime);
        if (charset2) mime += "; charset=" + charset2.toLowerCase();
      }
      return mime;
    }
    function extension(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var exts = match && exports2.extensions[match[1].toLowerCase()];
      if (!exts || !exts.length) {
        return false;
      }
      return exts[0];
    }
    function lookup(path2) {
      if (!path2 || typeof path2 !== "string") {
        return false;
      }
      var extension2 = extname("x." + path2).toLowerCase().substr(1);
      if (!extension2) {
        return false;
      }
      return exports2.types[extension2] || false;
    }
    function populateMaps(extensions, types) {
      var preference = ["nginx", "apache", void 0, "iana"];
      Object.keys(db).forEach(function forEachMimeType(type) {
        var mime = db[type];
        var exts = mime.extensions;
        if (!exts || !exts.length) {
          return;
        }
        extensions[type] = exts;
        for (var i = 0; i < exts.length; i++) {
          var extension2 = exts[i];
          if (types[extension2]) {
            var from = preference.indexOf(db[types[extension2]].source);
            var to = preference.indexOf(mime.source);
            if (types[extension2] !== "application/octet-stream" && (from > to || from === to && types[extension2].substr(0, 12) === "application/")) {
              continue;
            }
          }
          types[extension2] = type;
        }
      });
    }
  }
});

// ../../node_modules/asynckit/lib/defer.js
var require_defer = __commonJS({
  "../../node_modules/asynckit/lib/defer.js"(exports2, module2) {
    "use strict";
    module2.exports = defer;
    function defer(fn) {
      var nextTick = typeof setImmediate == "function" ? setImmediate : typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : null;
      if (nextTick) {
        nextTick(fn);
      } else {
        setTimeout(fn, 0);
      }
    }
  }
});

// ../../node_modules/asynckit/lib/async.js
var require_async = __commonJS({
  "../../node_modules/asynckit/lib/async.js"(exports2, module2) {
    "use strict";
    var defer = require_defer();
    module2.exports = async;
    function async(callback2) {
      var isAsync = false;
      defer(function() {
        isAsync = true;
      });
      return function async_callback(err, result) {
        if (isAsync) {
          callback2(err, result);
        } else {
          defer(function nextTick_callback() {
            callback2(err, result);
          });
        }
      };
    }
  }
});

// ../../node_modules/asynckit/lib/abort.js
var require_abort = __commonJS({
  "../../node_modules/asynckit/lib/abort.js"(exports2, module2) {
    "use strict";
    module2.exports = abort;
    function abort(state) {
      Object.keys(state.jobs).forEach(clean.bind(state));
      state.jobs = {};
    }
    function clean(key) {
      if (typeof this.jobs[key] == "function") {
        this.jobs[key]();
      }
    }
  }
});

// ../../node_modules/asynckit/lib/iterate.js
var require_iterate = __commonJS({
  "../../node_modules/asynckit/lib/iterate.js"(exports2, module2) {
    "use strict";
    var async = require_async();
    var abort = require_abort();
    module2.exports = iterate;
    function iterate(list, iterator, state, callback2) {
      var key = state["keyedList"] ? state["keyedList"][state.index] : state.index;
      state.jobs[key] = runJob(iterator, key, list[key], function(error, output) {
        if (!(key in state.jobs)) {
          return;
        }
        delete state.jobs[key];
        if (error) {
          abort(state);
        } else {
          state.results[key] = output;
        }
        callback2(error, state.results);
      });
    }
    function runJob(iterator, key, item, callback2) {
      var aborter;
      if (iterator.length == 2) {
        aborter = iterator(item, async(callback2));
      } else {
        aborter = iterator(item, key, async(callback2));
      }
      return aborter;
    }
  }
});

// ../../node_modules/asynckit/lib/state.js
var require_state = __commonJS({
  "../../node_modules/asynckit/lib/state.js"(exports2, module2) {
    "use strict";
    module2.exports = state;
    function state(list, sortMethod) {
      var isNamedList = !Array.isArray(list), initState = {
        index: 0,
        keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
        jobs: {},
        results: isNamedList ? {} : [],
        size: isNamedList ? Object.keys(list).length : list.length
      };
      if (sortMethod) {
        initState.keyedList.sort(isNamedList ? sortMethod : function(a, b) {
          return sortMethod(list[a], list[b]);
        });
      }
      return initState;
    }
  }
});

// ../../node_modules/asynckit/lib/terminator.js
var require_terminator = __commonJS({
  "../../node_modules/asynckit/lib/terminator.js"(exports2, module2) {
    "use strict";
    var abort = require_abort();
    var async = require_async();
    module2.exports = terminator;
    function terminator(callback2) {
      if (!Object.keys(this.jobs).length) {
        return;
      }
      this.index = this.size;
      abort(this);
      async(callback2)(null, this.results);
    }
  }
});

// ../../node_modules/asynckit/parallel.js
var require_parallel = __commonJS({
  "../../node_modules/asynckit/parallel.js"(exports2, module2) {
    "use strict";
    var iterate = require_iterate();
    var initState = require_state();
    var terminator = require_terminator();
    module2.exports = parallel;
    function parallel(list, iterator, callback2) {
      var state = initState(list);
      while (state.index < (state["keyedList"] || list).length) {
        iterate(list, iterator, state, function(error, result) {
          if (error) {
            callback2(error, result);
            return;
          }
          if (Object.keys(state.jobs).length === 0) {
            callback2(null, state.results);
            return;
          }
        });
        state.index++;
      }
      return terminator.bind(state, callback2);
    }
  }
});

// ../../node_modules/asynckit/serialOrdered.js
var require_serialOrdered = __commonJS({
  "../../node_modules/asynckit/serialOrdered.js"(exports2, module2) {
    "use strict";
    var iterate = require_iterate();
    var initState = require_state();
    var terminator = require_terminator();
    module2.exports = serialOrdered;
    module2.exports.ascending = ascending;
    module2.exports.descending = descending;
    function serialOrdered(list, iterator, sortMethod, callback2) {
      var state = initState(list, sortMethod);
      iterate(list, iterator, state, function iteratorHandler(error, result) {
        if (error) {
          callback2(error, result);
          return;
        }
        state.index++;
        if (state.index < (state["keyedList"] || list).length) {
          iterate(list, iterator, state, iteratorHandler);
          return;
        }
        callback2(null, state.results);
      });
      return terminator.bind(state, callback2);
    }
    function ascending(a, b) {
      return a < b ? -1 : a > b ? 1 : 0;
    }
    function descending(a, b) {
      return -1 * ascending(a, b);
    }
  }
});

// ../../node_modules/asynckit/serial.js
var require_serial = __commonJS({
  "../../node_modules/asynckit/serial.js"(exports2, module2) {
    "use strict";
    var serialOrdered = require_serialOrdered();
    module2.exports = serial;
    function serial(list, iterator, callback2) {
      return serialOrdered(list, iterator, null, callback2);
    }
  }
});

// ../../node_modules/asynckit/index.js
var require_asynckit = __commonJS({
  "../../node_modules/asynckit/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      parallel: require_parallel(),
      serial: require_serial(),
      serialOrdered: require_serialOrdered()
    };
  }
});

// ../../node_modules/es-object-atoms/index.js
var require_es_object_atoms = __commonJS({
  "../../node_modules/es-object-atoms/index.js"(exports2, module2) {
    "use strict";
    module2.exports = Object;
  }
});

// ../../node_modules/es-errors/index.js
var require_es_errors = __commonJS({
  "../../node_modules/es-errors/index.js"(exports2, module2) {
    "use strict";
    module2.exports = Error;
  }
});

// ../../node_modules/es-errors/eval.js
var require_eval = __commonJS({
  "../../node_modules/es-errors/eval.js"(exports2, module2) {
    "use strict";
    module2.exports = EvalError;
  }
});

// ../../node_modules/es-errors/range.js
var require_range = __commonJS({
  "../../node_modules/es-errors/range.js"(exports2, module2) {
    "use strict";
    module2.exports = RangeError;
  }
});

// ../../node_modules/es-errors/ref.js
var require_ref = __commonJS({
  "../../node_modules/es-errors/ref.js"(exports2, module2) {
    "use strict";
    module2.exports = ReferenceError;
  }
});

// ../../node_modules/es-errors/syntax.js
var require_syntax = __commonJS({
  "../../node_modules/es-errors/syntax.js"(exports2, module2) {
    "use strict";
    module2.exports = SyntaxError;
  }
});

// ../../node_modules/es-errors/type.js
var require_type = __commonJS({
  "../../node_modules/es-errors/type.js"(exports2, module2) {
    "use strict";
    module2.exports = TypeError;
  }
});

// ../../node_modules/es-errors/uri.js
var require_uri = __commonJS({
  "../../node_modules/es-errors/uri.js"(exports2, module2) {
    "use strict";
    module2.exports = URIError;
  }
});

// ../../node_modules/math-intrinsics/abs.js
var require_abs = __commonJS({
  "../../node_modules/math-intrinsics/abs.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.abs;
  }
});

// ../../node_modules/math-intrinsics/floor.js
var require_floor = __commonJS({
  "../../node_modules/math-intrinsics/floor.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.floor;
  }
});

// ../../node_modules/math-intrinsics/max.js
var require_max = __commonJS({
  "../../node_modules/math-intrinsics/max.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.max;
  }
});

// ../../node_modules/math-intrinsics/min.js
var require_min = __commonJS({
  "../../node_modules/math-intrinsics/min.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.min;
  }
});

// ../../node_modules/math-intrinsics/pow.js
var require_pow = __commonJS({
  "../../node_modules/math-intrinsics/pow.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.pow;
  }
});

// ../../node_modules/math-intrinsics/round.js
var require_round = __commonJS({
  "../../node_modules/math-intrinsics/round.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.round;
  }
});

// ../../node_modules/math-intrinsics/isNaN.js
var require_isNaN = __commonJS({
  "../../node_modules/math-intrinsics/isNaN.js"(exports2, module2) {
    "use strict";
    module2.exports = Number.isNaN || function isNaN2(a) {
      return a !== a;
    };
  }
});

// ../../node_modules/math-intrinsics/sign.js
var require_sign = __commonJS({
  "../../node_modules/math-intrinsics/sign.js"(exports2, module2) {
    "use strict";
    var $isNaN = require_isNaN();
    module2.exports = function sign(number) {
      if ($isNaN(number) || number === 0) {
        return number;
      }
      return number < 0 ? -1 : 1;
    };
  }
});

// ../../node_modules/gopd/gOPD.js
var require_gOPD = __commonJS({
  "../../node_modules/gopd/gOPD.js"(exports2, module2) {
    "use strict";
    module2.exports = Object.getOwnPropertyDescriptor;
  }
});

// ../../node_modules/gopd/index.js
var require_gopd = __commonJS({
  "../../node_modules/gopd/index.js"(exports2, module2) {
    "use strict";
    var $gOPD = require_gOPD();
    if ($gOPD) {
      try {
        $gOPD([], "length");
      } catch (e) {
        $gOPD = null;
      }
    }
    module2.exports = $gOPD;
  }
});

// ../../node_modules/es-define-property/index.js
var require_es_define_property = __commonJS({
  "../../node_modules/es-define-property/index.js"(exports2, module2) {
    "use strict";
    var $defineProperty = Object.defineProperty || false;
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e) {
        $defineProperty = false;
      }
    }
    module2.exports = $defineProperty;
  }
});

// ../../node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  "../../node_modules/has-symbols/shams.js"(exports2, module2) {
    "use strict";
    module2.exports = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = /* @__PURE__ */ Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (var _ in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = (
          /** @type {PropertyDescriptor} */
          Object.getOwnPropertyDescriptor(obj, sym)
        );
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  }
});

// ../../node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  "../../node_modules/has-symbols/index.js"(exports2, module2) {
    "use strict";
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module2.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof /* @__PURE__ */ Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
  }
});

// ../../node_modules/get-proto/Reflect.getPrototypeOf.js
var require_Reflect_getPrototypeOf = __commonJS({
  "../../node_modules/get-proto/Reflect.getPrototypeOf.js"(exports2, module2) {
    "use strict";
    module2.exports = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
  }
});

// ../../node_modules/get-proto/Object.getPrototypeOf.js
var require_Object_getPrototypeOf = __commonJS({
  "../../node_modules/get-proto/Object.getPrototypeOf.js"(exports2, module2) {
    "use strict";
    var $Object = require_es_object_atoms();
    module2.exports = $Object.getPrototypeOf || null;
  }
});

// ../../node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "../../node_modules/function-bind/implementation.js"(exports2, module2) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var toStr = Object.prototype.toString;
    var max = Math.max;
    var funcType = "[object Function]";
    var concatty = function concatty2(a, b) {
      var arr = [];
      for (var i = 0; i < a.length; i += 1) {
        arr[i] = a[i];
      }
      for (var j = 0; j < b.length; j += 1) {
        arr[j + a.length] = b[j];
      }
      return arr;
    };
    var slicy = function slicy2(arrLike, offset) {
      var arr = [];
      for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr[j] = arrLike[i];
      }
      return arr;
    };
    var joiny = function(arr, joiner) {
      var str = "";
      for (var i = 0; i < arr.length; i += 1) {
        str += arr[i];
        if (i + 1 < arr.length) {
          str += joiner;
        }
      }
      return str;
    };
    module2.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slicy(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            concatty(args, arguments)
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        }
        return target.apply(
          that,
          concatty(args, arguments)
        );
      };
      var boundLength = max(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = "$" + i;
      }
      bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// ../../node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "../../node_modules/function-bind/index.js"(exports2, module2) {
    "use strict";
    var implementation = require_implementation();
    module2.exports = Function.prototype.bind || implementation;
  }
});

// ../../node_modules/call-bind-apply-helpers/functionCall.js
var require_functionCall = __commonJS({
  "../../node_modules/call-bind-apply-helpers/functionCall.js"(exports2, module2) {
    "use strict";
    module2.exports = Function.prototype.call;
  }
});

// ../../node_modules/call-bind-apply-helpers/functionApply.js
var require_functionApply = __commonJS({
  "../../node_modules/call-bind-apply-helpers/functionApply.js"(exports2, module2) {
    "use strict";
    module2.exports = Function.prototype.apply;
  }
});

// ../../node_modules/call-bind-apply-helpers/reflectApply.js
var require_reflectApply = __commonJS({
  "../../node_modules/call-bind-apply-helpers/reflectApply.js"(exports2, module2) {
    "use strict";
    module2.exports = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
  }
});

// ../../node_modules/call-bind-apply-helpers/actualApply.js
var require_actualApply = __commonJS({
  "../../node_modules/call-bind-apply-helpers/actualApply.js"(exports2, module2) {
    "use strict";
    var bind = require_function_bind();
    var $apply = require_functionApply();
    var $call = require_functionCall();
    var $reflectApply = require_reflectApply();
    module2.exports = $reflectApply || bind.call($call, $apply);
  }
});

// ../../node_modules/call-bind-apply-helpers/index.js
var require_call_bind_apply_helpers = __commonJS({
  "../../node_modules/call-bind-apply-helpers/index.js"(exports2, module2) {
    "use strict";
    var bind = require_function_bind();
    var $TypeError = require_type();
    var $call = require_functionCall();
    var $actualApply = require_actualApply();
    module2.exports = function callBindBasic(args) {
      if (args.length < 1 || typeof args[0] !== "function") {
        throw new $TypeError("a function is required");
      }
      return $actualApply(bind, $call, args);
    };
  }
});

// ../../node_modules/dunder-proto/get.js
var require_get = __commonJS({
  "../../node_modules/dunder-proto/get.js"(exports2, module2) {
    "use strict";
    var callBind = require_call_bind_apply_helpers();
    var gOPD = require_gopd();
    var hasProtoAccessor;
    try {
      hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */
      [].__proto__ === Array.prototype;
    } catch (e) {
      if (!e || typeof e !== "object" || !("code" in e) || e.code !== "ERR_PROTO_ACCESS") {
        throw e;
      }
    }
    var desc = !!hasProtoAccessor && gOPD && gOPD(
      Object.prototype,
      /** @type {keyof typeof Object.prototype} */
      "__proto__"
    );
    var $Object = Object;
    var $getPrototypeOf = $Object.getPrototypeOf;
    module2.exports = desc && typeof desc.get === "function" ? callBind([desc.get]) : typeof $getPrototypeOf === "function" ? (
      /** @type {import('./get')} */
      function getDunder(value) {
        return $getPrototypeOf(value == null ? value : $Object(value));
      }
    ) : false;
  }
});

// ../../node_modules/get-proto/index.js
var require_get_proto = __commonJS({
  "../../node_modules/get-proto/index.js"(exports2, module2) {
    "use strict";
    var reflectGetProto = require_Reflect_getPrototypeOf();
    var originalGetProto = require_Object_getPrototypeOf();
    var getDunderProto = require_get();
    module2.exports = reflectGetProto ? function getProto(O) {
      return reflectGetProto(O);
    } : originalGetProto ? function getProto(O) {
      if (!O || typeof O !== "object" && typeof O !== "function") {
        throw new TypeError("getProto: not an object");
      }
      return originalGetProto(O);
    } : getDunderProto ? function getProto(O) {
      return getDunderProto(O);
    } : null;
  }
});

// ../../node_modules/hasown/index.js
var require_hasown = __commonJS({
  "../../node_modules/hasown/index.js"(exports2, module2) {
    "use strict";
    var call = Function.prototype.call;
    var $hasOwn = Object.prototype.hasOwnProperty;
    var bind = require_function_bind();
    module2.exports = bind.call(call, $hasOwn);
  }
});

// ../../node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  "../../node_modules/get-intrinsic/index.js"(exports2, module2) {
    "use strict";
    var undefined2;
    var $Object = require_es_object_atoms();
    var $Error = require_es_errors();
    var $EvalError = require_eval();
    var $RangeError = require_range();
    var $ReferenceError = require_ref();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var $URIError = require_uri();
    var abs = require_abs();
    var floor = require_floor();
    var max = require_max();
    var min = require_min();
    var pow = require_pow();
    var round = require_round();
    var sign = require_sign();
    var $Function = Function;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e) {
      }
    };
    var $gOPD = require_gopd();
    var $defineProperty = require_es_define_property();
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? (function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    })() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var getProto = require_get_proto();
    var $ObjectGPO = require_Object_getPrototypeOf();
    var $ReflectGPO = require_Reflect_getPrototypeOf();
    var $apply = require_functionApply();
    var $call = require_functionCall();
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      __proto__: null,
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": $Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": $EvalError,
      "%Float16Array%": typeof Float16Array === "undefined" ? undefined2 : Float16Array,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": $Object,
      "%Object.getOwnPropertyDescriptor%": $gOPD,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": $RangeError,
      "%ReferenceError%": $ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": $URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet,
      "%Function.prototype.call%": $call,
      "%Function.prototype.apply%": $apply,
      "%Object.defineProperty%": $defineProperty,
      "%Object.getPrototypeOf%": $ObjectGPO,
      "%Math.abs%": abs,
      "%Math.floor%": floor,
      "%Math.max%": max,
      "%Math.min%": min,
      "%Math.pow%": pow,
      "%Math.round%": round,
      "%Math.sign%": sign,
      "%Reflect.getPrototypeOf%": $ReflectGPO
    };
    if (getProto) {
      try {
        null.error;
      } catch (e) {
        errorProto = getProto(getProto(e));
        INTRINSICS["%Error.prototype%"] = errorProto;
      }
    }
    var errorProto;
    var doEval = function doEval2(name) {
      var value;
      if (name === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen && getProto) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      __proto__: null,
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = require_function_bind();
    var hasOwn = require_hasown();
    var $concat = bind.call($call, Array.prototype.concat);
    var $spliceApply = bind.call($apply, Array.prototype.splice);
    var $replace = bind.call($call, String.prototype.replace);
    var $strSlice = bind.call($call, String.prototype.slice);
    var $exec = bind.call($call, RegExp.prototype.exec);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string) {
      var first = $strSlice(string, 0, 1);
      var last = $strSlice(string, -1);
      if (first === "%" && last !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last === "%" && first !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
      var intrinsicName = name;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name + " does not exist!");
    };
    module2.exports = function GetIntrinsic(name, allowMissing) {
      if (typeof name !== "string" || name.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath(name);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i = 1, isOwn = true; i < parts.length; i += 1) {
        var part = parts[i];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
            }
            return void undefined2;
          }
          if ($gOPD && i + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
  }
});

// ../../node_modules/has-tostringtag/shams.js
var require_shams2 = __commonJS({
  "../../node_modules/has-tostringtag/shams.js"(exports2, module2) {
    "use strict";
    var hasSymbols = require_shams();
    module2.exports = function hasToStringTagShams() {
      return hasSymbols() && !!Symbol.toStringTag;
    };
  }
});

// ../../node_modules/es-set-tostringtag/index.js
var require_es_set_tostringtag = __commonJS({
  "../../node_modules/es-set-tostringtag/index.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
    var hasToStringTag = require_shams2()();
    var hasOwn = require_hasown();
    var $TypeError = require_type();
    var toStringTag = hasToStringTag ? Symbol.toStringTag : null;
    module2.exports = function setToStringTag(object, value) {
      var overrideIfSet = arguments.length > 2 && !!arguments[2] && arguments[2].force;
      var nonConfigurable = arguments.length > 2 && !!arguments[2] && arguments[2].nonConfigurable;
      if (typeof overrideIfSet !== "undefined" && typeof overrideIfSet !== "boolean" || typeof nonConfigurable !== "undefined" && typeof nonConfigurable !== "boolean") {
        throw new $TypeError("if provided, the `overrideIfSet` and `nonConfigurable` options must be booleans");
      }
      if (toStringTag && (overrideIfSet || !hasOwn(object, toStringTag))) {
        if ($defineProperty) {
          $defineProperty(object, toStringTag, {
            configurable: !nonConfigurable,
            enumerable: false,
            value,
            writable: false
          });
        } else {
          object[toStringTag] = value;
        }
      }
    };
  }
});

// ../../node_modules/form-data/lib/populate.js
var require_populate = __commonJS({
  "../../node_modules/form-data/lib/populate.js"(exports2, module2) {
    "use strict";
    module2.exports = function(dst, src) {
      Object.keys(src).forEach(function(prop) {
        dst[prop] = dst[prop] || src[prop];
      });
      return dst;
    };
  }
});

// ../../node_modules/form-data/lib/form_data.js
var require_form_data = __commonJS({
  "../../node_modules/form-data/lib/form_data.js"(exports2, module2) {
    "use strict";
    var CombinedStream = require_combined_stream();
    var util = require("util");
    var path2 = require("path");
    var http = require("http");
    var https = require("https");
    var parseUrl = require("url").parse;
    var fs2 = require("fs");
    var Stream = require("stream").Stream;
    var crypto2 = require("crypto");
    var mime = require_mime_types();
    var asynckit = require_asynckit();
    var setToStringTag = require_es_set_tostringtag();
    var hasOwn = require_hasown();
    var populate = require_populate();
    function FormData2(options) {
      if (!(this instanceof FormData2)) {
        return new FormData2(options);
      }
      this._overheadLength = 0;
      this._valueLength = 0;
      this._valuesToMeasure = [];
      CombinedStream.call(this);
      options = options || {};
      for (var option in options) {
        this[option] = options[option];
      }
    }
    util.inherits(FormData2, CombinedStream);
    FormData2.LINE_BREAK = "\r\n";
    FormData2.DEFAULT_CONTENT_TYPE = "application/octet-stream";
    FormData2.prototype.append = function(field, value, options) {
      options = options || {};
      if (typeof options === "string") {
        options = { filename: options };
      }
      var append = CombinedStream.prototype.append.bind(this);
      if (typeof value === "number" || value == null) {
        value = String(value);
      }
      if (Array.isArray(value)) {
        this._error(new Error("Arrays are not supported."));
        return;
      }
      var header = this._multiPartHeader(field, value, options);
      var footer = this._multiPartFooter();
      append(header);
      append(value);
      append(footer);
      this._trackLength(header, value, options);
    };
    FormData2.prototype._trackLength = function(header, value, options) {
      var valueLength = 0;
      if (options.knownLength != null) {
        valueLength += Number(options.knownLength);
      } else if (Buffer.isBuffer(value)) {
        valueLength = value.length;
      } else if (typeof value === "string") {
        valueLength = Buffer.byteLength(value);
      }
      this._valueLength += valueLength;
      this._overheadLength += Buffer.byteLength(header) + FormData2.LINE_BREAK.length;
      if (!value || !value.path && !(value.readable && hasOwn(value, "httpVersion")) && !(value instanceof Stream)) {
        return;
      }
      if (!options.knownLength) {
        this._valuesToMeasure.push(value);
      }
    };
    FormData2.prototype._lengthRetriever = function(value, callback2) {
      if (hasOwn(value, "fd")) {
        if (value.end != void 0 && value.end != Infinity && value.start != void 0) {
          callback2(null, value.end + 1 - (value.start ? value.start : 0));
        } else {
          fs2.stat(value.path, function(err, stat) {
            if (err) {
              callback2(err);
              return;
            }
            var fileSize = stat.size - (value.start ? value.start : 0);
            callback2(null, fileSize);
          });
        }
      } else if (hasOwn(value, "httpVersion")) {
        callback2(null, Number(value.headers["content-length"]));
      } else if (hasOwn(value, "httpModule")) {
        value.on("response", function(response) {
          value.pause();
          callback2(null, Number(response.headers["content-length"]));
        });
        value.resume();
      } else {
        callback2("Unknown stream");
      }
    };
    FormData2.prototype._multiPartHeader = function(field, value, options) {
      if (typeof options.header === "string") {
        return options.header;
      }
      var contentDisposition = this._getContentDisposition(value, options);
      var contentType = this._getContentType(value, options);
      var contents = "";
      var headers = {
        // add custom disposition as third element or keep it two elements if not
        "Content-Disposition": ["form-data", 'name="' + field + '"'].concat(contentDisposition || []),
        // if no content type. allow it to be empty array
        "Content-Type": [].concat(contentType || [])
      };
      if (typeof options.header === "object") {
        populate(headers, options.header);
      }
      var header;
      for (var prop in headers) {
        if (hasOwn(headers, prop)) {
          header = headers[prop];
          if (header == null) {
            continue;
          }
          if (!Array.isArray(header)) {
            header = [header];
          }
          if (header.length) {
            contents += prop + ": " + header.join("; ") + FormData2.LINE_BREAK;
          }
        }
      }
      return "--" + this.getBoundary() + FormData2.LINE_BREAK + contents + FormData2.LINE_BREAK;
    };
    FormData2.prototype._getContentDisposition = function(value, options) {
      var filename;
      if (typeof options.filepath === "string") {
        filename = path2.normalize(options.filepath).replace(/\\/g, "/");
      } else if (options.filename || value && (value.name || value.path)) {
        filename = path2.basename(options.filename || value && (value.name || value.path));
      } else if (value && value.readable && hasOwn(value, "httpVersion")) {
        filename = path2.basename(value.client._httpMessage.path || "");
      }
      if (filename) {
        return 'filename="' + filename + '"';
      }
    };
    FormData2.prototype._getContentType = function(value, options) {
      var contentType = options.contentType;
      if (!contentType && value && value.name) {
        contentType = mime.lookup(value.name);
      }
      if (!contentType && value && value.path) {
        contentType = mime.lookup(value.path);
      }
      if (!contentType && value && value.readable && hasOwn(value, "httpVersion")) {
        contentType = value.headers["content-type"];
      }
      if (!contentType && (options.filepath || options.filename)) {
        contentType = mime.lookup(options.filepath || options.filename);
      }
      if (!contentType && value && typeof value === "object") {
        contentType = FormData2.DEFAULT_CONTENT_TYPE;
      }
      return contentType;
    };
    FormData2.prototype._multiPartFooter = function() {
      return function(next) {
        var footer = FormData2.LINE_BREAK;
        var lastPart = this._streams.length === 0;
        if (lastPart) {
          footer += this._lastBoundary();
        }
        next(footer);
      }.bind(this);
    };
    FormData2.prototype._lastBoundary = function() {
      return "--" + this.getBoundary() + "--" + FormData2.LINE_BREAK;
    };
    FormData2.prototype.getHeaders = function(userHeaders) {
      var header;
      var formHeaders = {
        "content-type": "multipart/form-data; boundary=" + this.getBoundary()
      };
      for (header in userHeaders) {
        if (hasOwn(userHeaders, header)) {
          formHeaders[header.toLowerCase()] = userHeaders[header];
        }
      }
      return formHeaders;
    };
    FormData2.prototype.setBoundary = function(boundary) {
      if (typeof boundary !== "string") {
        throw new TypeError("FormData boundary must be a string");
      }
      this._boundary = boundary;
    };
    FormData2.prototype.getBoundary = function() {
      if (!this._boundary) {
        this._generateBoundary();
      }
      return this._boundary;
    };
    FormData2.prototype.getBuffer = function() {
      var dataBuffer = new Buffer.alloc(0);
      var boundary = this.getBoundary();
      for (var i = 0, len = this._streams.length; i < len; i++) {
        if (typeof this._streams[i] !== "function") {
          if (Buffer.isBuffer(this._streams[i])) {
            dataBuffer = Buffer.concat([dataBuffer, this._streams[i]]);
          } else {
            dataBuffer = Buffer.concat([dataBuffer, Buffer.from(this._streams[i])]);
          }
          if (typeof this._streams[i] !== "string" || this._streams[i].substring(2, boundary.length + 2) !== boundary) {
            dataBuffer = Buffer.concat([dataBuffer, Buffer.from(FormData2.LINE_BREAK)]);
          }
        }
      }
      return Buffer.concat([dataBuffer, Buffer.from(this._lastBoundary())]);
    };
    FormData2.prototype._generateBoundary = function() {
      this._boundary = "--------------------------" + crypto2.randomBytes(12).toString("hex");
    };
    FormData2.prototype.getLengthSync = function() {
      var knownLength = this._overheadLength + this._valueLength;
      if (this._streams.length) {
        knownLength += this._lastBoundary().length;
      }
      if (!this.hasKnownLength()) {
        this._error(new Error("Cannot calculate proper length in synchronous way."));
      }
      return knownLength;
    };
    FormData2.prototype.hasKnownLength = function() {
      var hasKnownLength = true;
      if (this._valuesToMeasure.length) {
        hasKnownLength = false;
      }
      return hasKnownLength;
    };
    FormData2.prototype.getLength = function(cb) {
      var knownLength = this._overheadLength + this._valueLength;
      if (this._streams.length) {
        knownLength += this._lastBoundary().length;
      }
      if (!this._valuesToMeasure.length) {
        process.nextTick(cb.bind(this, null, knownLength));
        return;
      }
      asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
        if (err) {
          cb(err);
          return;
        }
        values.forEach(function(length) {
          knownLength += length;
        });
        cb(null, knownLength);
      });
    };
    FormData2.prototype.submit = function(params, cb) {
      var request;
      var options;
      var defaults = { method: "post" };
      if (typeof params === "string") {
        params = parseUrl(params);
        options = populate({
          port: params.port,
          path: params.pathname,
          host: params.hostname,
          protocol: params.protocol
        }, defaults);
      } else {
        options = populate(params, defaults);
        if (!options.port) {
          options.port = options.protocol === "https:" ? 443 : 80;
        }
      }
      options.headers = this.getHeaders(params.headers);
      if (options.protocol === "https:") {
        request = https.request(options);
      } else {
        request = http.request(options);
      }
      this.getLength(function(err, length) {
        if (err && err !== "Unknown stream") {
          this._error(err);
          return;
        }
        if (length) {
          request.setHeader("Content-Length", length);
        }
        this.pipe(request);
        if (cb) {
          var onResponse;
          var callback2 = function(error, responce) {
            request.removeListener("error", callback2);
            request.removeListener("response", onResponse);
            return cb.call(this, error, responce);
          };
          onResponse = callback2.bind(this, null);
          request.on("error", callback2);
          request.on("response", onResponse);
        }
      }.bind(this));
      return request;
    };
    FormData2.prototype._error = function(err) {
      if (!this.error) {
        this.error = err;
        this.pause();
        this.emit("error", err);
      }
    };
    FormData2.prototype.toString = function() {
      return "[object FormData]";
    };
    setToStringTag(FormData2.prototype, "FormData");
    module2.exports = FormData2;
  }
});

// ../../node_modules/proxy-from-env/index.js
var require_proxy_from_env = __commonJS({
  "../../node_modules/proxy-from-env/index.js"(exports2) {
    "use strict";
    var parseUrl = require("url").parse;
    var DEFAULT_PORTS = {
      ftp: 21,
      gopher: 70,
      http: 80,
      https: 443,
      ws: 80,
      wss: 443
    };
    var stringEndsWith = String.prototype.endsWith || function(s) {
      return s.length <= this.length && this.indexOf(s, this.length - s.length) !== -1;
    };
    function getProxyForUrl(url) {
      var parsedUrl = typeof url === "string" ? parseUrl(url) : url || {};
      var proto = parsedUrl.protocol;
      var hostname = parsedUrl.host;
      var port = parsedUrl.port;
      if (typeof hostname !== "string" || !hostname || typeof proto !== "string") {
        return "";
      }
      proto = proto.split(":", 1)[0];
      hostname = hostname.replace(/:\d*$/, "");
      port = parseInt(port) || DEFAULT_PORTS[proto] || 0;
      if (!shouldProxy(hostname, port)) {
        return "";
      }
      var proxy = getEnv("npm_config_" + proto + "_proxy") || getEnv(proto + "_proxy") || getEnv("npm_config_proxy") || getEnv("all_proxy");
      if (proxy && proxy.indexOf("://") === -1) {
        proxy = proto + "://" + proxy;
      }
      return proxy;
    }
    function shouldProxy(hostname, port) {
      var NO_PROXY = (getEnv("npm_config_no_proxy") || getEnv("no_proxy")).toLowerCase();
      if (!NO_PROXY) {
        return true;
      }
      if (NO_PROXY === "*") {
        return false;
      }
      return NO_PROXY.split(/[,\s]/).every(function(proxy) {
        if (!proxy) {
          return true;
        }
        var parsedProxy = proxy.match(/^(.+):(\d+)$/);
        var parsedProxyHostname = parsedProxy ? parsedProxy[1] : proxy;
        var parsedProxyPort = parsedProxy ? parseInt(parsedProxy[2]) : 0;
        if (parsedProxyPort && parsedProxyPort !== port) {
          return true;
        }
        if (!/^[.*]/.test(parsedProxyHostname)) {
          return hostname !== parsedProxyHostname;
        }
        if (parsedProxyHostname.charAt(0) === "*") {
          parsedProxyHostname = parsedProxyHostname.slice(1);
        }
        return !stringEndsWith.call(hostname, parsedProxyHostname);
      });
    }
    function getEnv(key) {
      return process.env[key.toLowerCase()] || process.env[key.toUpperCase()] || "";
    }
    exports2.getProxyForUrl = getProxyForUrl;
  }
});

// ../../node_modules/ms/index.js
var require_ms = __commonJS({
  "../../node_modules/ms/index.js"(exports2, module2) {
    "use strict";
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// ../../node_modules/debug/src/common.js
var require_common = __commonJS({
  "../../node_modules/debug/src/common.js"(exports2, module2) {
    "use strict";
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
        for (const ns of split) {
          if (ns[0] === "-") {
            createDebug.skips.push(ns.slice(1));
          } else {
            createDebug.names.push(ns);
          }
        }
      }
      function matchesTemplate(search, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while (searchIndex < search.length) {
          if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
            if (template[templateIndex] === "*") {
              starIndex = templateIndex;
              matchIndex = searchIndex;
              templateIndex++;
            } else {
              searchIndex++;
              templateIndex++;
            }
          } else if (starIndex !== -1) {
            templateIndex = starIndex + 1;
            matchIndex++;
            searchIndex = matchIndex;
          } else {
            return false;
          }
        }
        while (templateIndex < template.length && template[templateIndex] === "*") {
          templateIndex++;
        }
        return templateIndex === template.length;
      }
      function disable() {
        const namespaces = [
          ...createDebug.names,
          ...createDebug.skips.map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        for (const skip of createDebug.skips) {
          if (matchesTemplate(name, skip)) {
            return false;
          }
        }
        for (const ns of createDebug.names) {
          if (matchesTemplate(name, ns)) {
            return true;
          }
        }
        return false;
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// ../../node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "../../node_modules/debug/src/browser.js"(exports2, module2) {
    "use strict";
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports2.storage.getItem("debug") || exports2.storage.getItem("DEBUG");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// ../../node_modules/debug/src/node.js
var require_node = __commonJS({
  "../../node_modules/debug/src/node.js"(exports2, module2) {
    "use strict";
    var tty = require("tty");
    var util = require("util");
    exports2.init = init;
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.destroy = util.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports2.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require("supports-color");
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util.formatWithOptions(exports2.inspectOpts, ...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug) {
      debug.inspectOpts = {};
      const keys = Object.keys(exports2.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  }
});

// ../../node_modules/debug/src/index.js
var require_src = __commonJS({
  "../../node_modules/debug/src/index.js"(exports2, module2) {
    "use strict";
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node();
    }
  }
});

// ../../node_modules/follow-redirects/debug.js
var require_debug = __commonJS({
  "../../node_modules/follow-redirects/debug.js"(exports2, module2) {
    "use strict";
    var debug;
    module2.exports = function() {
      if (!debug) {
        try {
          debug = require_src()("follow-redirects");
        } catch (error) {
        }
        if (typeof debug !== "function") {
          debug = function() {
          };
        }
      }
      debug.apply(null, arguments);
    };
  }
});

// ../../node_modules/follow-redirects/index.js
var require_follow_redirects = __commonJS({
  "../../node_modules/follow-redirects/index.js"(exports2, module2) {
    "use strict";
    var url = require("url");
    var URL2 = url.URL;
    var http = require("http");
    var https = require("https");
    var Writable = require("stream").Writable;
    var assert = require("assert");
    var debug = require_debug();
    (function detectUnsupportedEnvironment() {
      var looksLikeNode = typeof process !== "undefined";
      var looksLikeBrowser = typeof window !== "undefined" && typeof document !== "undefined";
      var looksLikeV8 = isFunction(Error.captureStackTrace);
      if (!looksLikeNode && (looksLikeBrowser || !looksLikeV8)) {
        console.warn("The follow-redirects package should be excluded from browser builds.");
      }
    })();
    var useNativeURL = false;
    try {
      assert(new URL2(""));
    } catch (error) {
      useNativeURL = error.code === "ERR_INVALID_URL";
    }
    var preservedUrlFields = [
      "auth",
      "host",
      "hostname",
      "href",
      "path",
      "pathname",
      "port",
      "protocol",
      "query",
      "search",
      "hash"
    ];
    var events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
    var eventHandlers = /* @__PURE__ */ Object.create(null);
    events.forEach(function(event) {
      eventHandlers[event] = function(arg1, arg2, arg3) {
        this._redirectable.emit(event, arg1, arg2, arg3);
      };
    });
    var InvalidUrlError = createErrorType(
      "ERR_INVALID_URL",
      "Invalid URL",
      TypeError
    );
    var RedirectionError = createErrorType(
      "ERR_FR_REDIRECTION_FAILURE",
      "Redirected request failed"
    );
    var TooManyRedirectsError = createErrorType(
      "ERR_FR_TOO_MANY_REDIRECTS",
      "Maximum number of redirects exceeded",
      RedirectionError
    );
    var MaxBodyLengthExceededError = createErrorType(
      "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
      "Request body larger than maxBodyLength limit"
    );
    var WriteAfterEndError = createErrorType(
      "ERR_STREAM_WRITE_AFTER_END",
      "write after end"
    );
    var destroy = Writable.prototype.destroy || noop;
    function RedirectableRequest(options, responseCallback) {
      Writable.call(this);
      this._sanitizeOptions(options);
      this._options = options;
      this._ended = false;
      this._ending = false;
      this._redirectCount = 0;
      this._redirects = [];
      this._requestBodyLength = 0;
      this._requestBodyBuffers = [];
      if (responseCallback) {
        this.on("response", responseCallback);
      }
      var self2 = this;
      this._onNativeResponse = function(response) {
        try {
          self2._processResponse(response);
        } catch (cause) {
          self2.emit("error", cause instanceof RedirectionError ? cause : new RedirectionError({ cause }));
        }
      };
      this._performRequest();
    }
    RedirectableRequest.prototype = Object.create(Writable.prototype);
    RedirectableRequest.prototype.abort = function() {
      destroyRequest(this._currentRequest);
      this._currentRequest.abort();
      this.emit("abort");
    };
    RedirectableRequest.prototype.destroy = function(error) {
      destroyRequest(this._currentRequest, error);
      destroy.call(this, error);
      return this;
    };
    RedirectableRequest.prototype.write = function(data, encoding, callback2) {
      if (this._ending) {
        throw new WriteAfterEndError();
      }
      if (!isString(data) && !isBuffer(data)) {
        throw new TypeError("data should be a string, Buffer or Uint8Array");
      }
      if (isFunction(encoding)) {
        callback2 = encoding;
        encoding = null;
      }
      if (data.length === 0) {
        if (callback2) {
          callback2();
        }
        return;
      }
      if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
        this._requestBodyLength += data.length;
        this._requestBodyBuffers.push({ data, encoding });
        this._currentRequest.write(data, encoding, callback2);
      } else {
        this.emit("error", new MaxBodyLengthExceededError());
        this.abort();
      }
    };
    RedirectableRequest.prototype.end = function(data, encoding, callback2) {
      if (isFunction(data)) {
        callback2 = data;
        data = encoding = null;
      } else if (isFunction(encoding)) {
        callback2 = encoding;
        encoding = null;
      }
      if (!data) {
        this._ended = this._ending = true;
        this._currentRequest.end(null, null, callback2);
      } else {
        var self2 = this;
        var currentRequest = this._currentRequest;
        this.write(data, encoding, function() {
          self2._ended = true;
          currentRequest.end(null, null, callback2);
        });
        this._ending = true;
      }
    };
    RedirectableRequest.prototype.setHeader = function(name, value) {
      this._options.headers[name] = value;
      this._currentRequest.setHeader(name, value);
    };
    RedirectableRequest.prototype.removeHeader = function(name) {
      delete this._options.headers[name];
      this._currentRequest.removeHeader(name);
    };
    RedirectableRequest.prototype.setTimeout = function(msecs, callback2) {
      var self2 = this;
      function destroyOnTimeout(socket) {
        socket.setTimeout(msecs);
        socket.removeListener("timeout", socket.destroy);
        socket.addListener("timeout", socket.destroy);
      }
      function startTimer(socket) {
        if (self2._timeout) {
          clearTimeout(self2._timeout);
        }
        self2._timeout = setTimeout(function() {
          self2.emit("timeout");
          clearTimer();
        }, msecs);
        destroyOnTimeout(socket);
      }
      function clearTimer() {
        if (self2._timeout) {
          clearTimeout(self2._timeout);
          self2._timeout = null;
        }
        self2.removeListener("abort", clearTimer);
        self2.removeListener("error", clearTimer);
        self2.removeListener("response", clearTimer);
        self2.removeListener("close", clearTimer);
        if (callback2) {
          self2.removeListener("timeout", callback2);
        }
        if (!self2.socket) {
          self2._currentRequest.removeListener("socket", startTimer);
        }
      }
      if (callback2) {
        this.on("timeout", callback2);
      }
      if (this.socket) {
        startTimer(this.socket);
      } else {
        this._currentRequest.once("socket", startTimer);
      }
      this.on("socket", destroyOnTimeout);
      this.on("abort", clearTimer);
      this.on("error", clearTimer);
      this.on("response", clearTimer);
      this.on("close", clearTimer);
      return this;
    };
    [
      "flushHeaders",
      "getHeader",
      "setNoDelay",
      "setSocketKeepAlive"
    ].forEach(function(method) {
      RedirectableRequest.prototype[method] = function(a, b) {
        return this._currentRequest[method](a, b);
      };
    });
    ["aborted", "connection", "socket"].forEach(function(property) {
      Object.defineProperty(RedirectableRequest.prototype, property, {
        get: function() {
          return this._currentRequest[property];
        }
      });
    });
    RedirectableRequest.prototype._sanitizeOptions = function(options) {
      if (!options.headers) {
        options.headers = {};
      }
      if (options.host) {
        if (!options.hostname) {
          options.hostname = options.host;
        }
        delete options.host;
      }
      if (!options.pathname && options.path) {
        var searchPos = options.path.indexOf("?");
        if (searchPos < 0) {
          options.pathname = options.path;
        } else {
          options.pathname = options.path.substring(0, searchPos);
          options.search = options.path.substring(searchPos);
        }
      }
    };
    RedirectableRequest.prototype._performRequest = function() {
      var protocol = this._options.protocol;
      var nativeProtocol = this._options.nativeProtocols[protocol];
      if (!nativeProtocol) {
        throw new TypeError("Unsupported protocol " + protocol);
      }
      if (this._options.agents) {
        var scheme = protocol.slice(0, -1);
        this._options.agent = this._options.agents[scheme];
      }
      var request = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
      request._redirectable = this;
      for (var event of events) {
        request.on(event, eventHandlers[event]);
      }
      this._currentUrl = /^\//.test(this._options.path) ? url.format(this._options) : (
        // When making a request to a proxy, []
        // a client MUST send the target URI in absolute-form [].
        this._options.path
      );
      if (this._isRedirect) {
        var i = 0;
        var self2 = this;
        var buffers = this._requestBodyBuffers;
        (function writeNext(error) {
          if (request === self2._currentRequest) {
            if (error) {
              self2.emit("error", error);
            } else if (i < buffers.length) {
              var buffer = buffers[i++];
              if (!request.finished) {
                request.write(buffer.data, buffer.encoding, writeNext);
              }
            } else if (self2._ended) {
              request.end();
            }
          }
        })();
      }
    };
    RedirectableRequest.prototype._processResponse = function(response) {
      var statusCode = response.statusCode;
      if (this._options.trackRedirects) {
        this._redirects.push({
          url: this._currentUrl,
          headers: response.headers,
          statusCode
        });
      }
      var location = response.headers.location;
      if (!location || this._options.followRedirects === false || statusCode < 300 || statusCode >= 400) {
        response.responseUrl = this._currentUrl;
        response.redirects = this._redirects;
        this.emit("response", response);
        this._requestBodyBuffers = [];
        return;
      }
      destroyRequest(this._currentRequest);
      response.destroy();
      if (++this._redirectCount > this._options.maxRedirects) {
        throw new TooManyRedirectsError();
      }
      var requestHeaders;
      var beforeRedirect = this._options.beforeRedirect;
      if (beforeRedirect) {
        requestHeaders = Object.assign({
          // The Host header was set by nativeProtocol.request
          Host: response.req.getHeader("host")
        }, this._options.headers);
      }
      var method = this._options.method;
      if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || // RFC72316.4.4: The 303 (See Other) status code indicates that
      // the server is redirecting the user agent to a different resource []
      // A user agent can perform a retrieval request targeting that URI
      // (a GET or HEAD request if using HTTP) []
      statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
        this._options.method = "GET";
        this._requestBodyBuffers = [];
        removeMatchingHeaders(/^content-/i, this._options.headers);
      }
      var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);
      var currentUrlParts = parseUrl(this._currentUrl);
      var currentHost = currentHostHeader || currentUrlParts.host;
      var currentUrl = /^\w+:/.test(location) ? this._currentUrl : url.format(Object.assign(currentUrlParts, { host: currentHost }));
      var redirectUrl = resolveUrl(location, currentUrl);
      debug("redirecting to", redirectUrl.href);
      this._isRedirect = true;
      spreadUrlObject(redirectUrl, this._options);
      if (redirectUrl.protocol !== currentUrlParts.protocol && redirectUrl.protocol !== "https:" || redirectUrl.host !== currentHost && !isSubdomain(redirectUrl.host, currentHost)) {
        removeMatchingHeaders(/^(?:(?:proxy-)?authorization|cookie)$/i, this._options.headers);
      }
      if (isFunction(beforeRedirect)) {
        var responseDetails = {
          headers: response.headers,
          statusCode
        };
        var requestDetails = {
          url: currentUrl,
          method,
          headers: requestHeaders
        };
        beforeRedirect(this._options, responseDetails, requestDetails);
        this._sanitizeOptions(this._options);
      }
      this._performRequest();
    };
    function wrap(protocols) {
      var exports3 = {
        maxRedirects: 21,
        maxBodyLength: 10 * 1024 * 1024
      };
      var nativeProtocols = {};
      Object.keys(protocols).forEach(function(scheme) {
        var protocol = scheme + ":";
        var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
        var wrappedProtocol = exports3[scheme] = Object.create(nativeProtocol);
        function request(input, options, callback2) {
          if (isURL(input)) {
            input = spreadUrlObject(input);
          } else if (isString(input)) {
            input = spreadUrlObject(parseUrl(input));
          } else {
            callback2 = options;
            options = validateUrl(input);
            input = { protocol };
          }
          if (isFunction(options)) {
            callback2 = options;
            options = null;
          }
          options = Object.assign({
            maxRedirects: exports3.maxRedirects,
            maxBodyLength: exports3.maxBodyLength
          }, input, options);
          options.nativeProtocols = nativeProtocols;
          if (!isString(options.host) && !isString(options.hostname)) {
            options.hostname = "::1";
          }
          assert.equal(options.protocol, protocol, "protocol mismatch");
          debug("options", options);
          return new RedirectableRequest(options, callback2);
        }
        function get(input, options, callback2) {
          var wrappedRequest = wrappedProtocol.request(input, options, callback2);
          wrappedRequest.end();
          return wrappedRequest;
        }
        Object.defineProperties(wrappedProtocol, {
          request: { value: request, configurable: true, enumerable: true, writable: true },
          get: { value: get, configurable: true, enumerable: true, writable: true }
        });
      });
      return exports3;
    }
    function noop() {
    }
    function parseUrl(input) {
      var parsed;
      if (useNativeURL) {
        parsed = new URL2(input);
      } else {
        parsed = validateUrl(url.parse(input));
        if (!isString(parsed.protocol)) {
          throw new InvalidUrlError({ input });
        }
      }
      return parsed;
    }
    function resolveUrl(relative2, base) {
      return useNativeURL ? new URL2(relative2, base) : parseUrl(url.resolve(base, relative2));
    }
    function validateUrl(input) {
      if (/^\[/.test(input.hostname) && !/^\[[:0-9a-f]+\]$/i.test(input.hostname)) {
        throw new InvalidUrlError({ input: input.href || input });
      }
      if (/^\[/.test(input.host) && !/^\[[:0-9a-f]+\](:\d+)?$/i.test(input.host)) {
        throw new InvalidUrlError({ input: input.href || input });
      }
      return input;
    }
    function spreadUrlObject(urlObject, target) {
      var spread = target || {};
      for (var key of preservedUrlFields) {
        spread[key] = urlObject[key];
      }
      if (spread.hostname.startsWith("[")) {
        spread.hostname = spread.hostname.slice(1, -1);
      }
      if (spread.port !== "") {
        spread.port = Number(spread.port);
      }
      spread.path = spread.search ? spread.pathname + spread.search : spread.pathname;
      return spread;
    }
    function removeMatchingHeaders(regex, headers) {
      var lastValue;
      for (var header in headers) {
        if (regex.test(header)) {
          lastValue = headers[header];
          delete headers[header];
        }
      }
      return lastValue === null || typeof lastValue === "undefined" ? void 0 : String(lastValue).trim();
    }
    function createErrorType(code, message, baseClass) {
      function CustomError(properties) {
        if (isFunction(Error.captureStackTrace)) {
          Error.captureStackTrace(this, this.constructor);
        }
        Object.assign(this, properties || {});
        this.code = code;
        this.message = this.cause ? message + ": " + this.cause.message : message;
      }
      CustomError.prototype = new (baseClass || Error)();
      Object.defineProperties(CustomError.prototype, {
        constructor: {
          value: CustomError,
          enumerable: false
        },
        name: {
          value: "Error [" + code + "]",
          enumerable: false
        }
      });
      return CustomError;
    }
    function destroyRequest(request, error) {
      for (var event of events) {
        request.removeListener(event, eventHandlers[event]);
      }
      request.on("error", noop);
      request.destroy(error);
    }
    function isSubdomain(subdomain, domain) {
      assert(isString(subdomain) && isString(domain));
      var dot = subdomain.length - domain.length - 1;
      return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
    }
    function isString(value) {
      return typeof value === "string" || value instanceof String;
    }
    function isFunction(value) {
      return typeof value === "function";
    }
    function isBuffer(value) {
      return typeof value === "object" && "length" in value;
    }
    function isURL(value) {
      return URL2 && value instanceof URL2;
    }
    module2.exports = wrap({ http, https });
    module2.exports.wrap = wrap;
  }
});

// ../../node_modules/axios/dist/node/axios.cjs
var require_axios = __commonJS({
  "../../node_modules/axios/dist/node/axios.cjs"(exports2, module2) {
    "use strict";
    var FormData$1 = require_form_data();
    var crypto2 = require("crypto");
    var url = require("url");
    var proxyFromEnv = require_proxy_from_env();
    var http = require("http");
    var https = require("https");
    var http2 = require("http2");
    var util = require("util");
    var followRedirects = require_follow_redirects();
    var zlib = require("zlib");
    var stream = require("stream");
    var events = require("events");
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var FormData__default = /* @__PURE__ */ _interopDefaultLegacy(FormData$1);
    var crypto__default = /* @__PURE__ */ _interopDefaultLegacy(crypto2);
    var url__default = /* @__PURE__ */ _interopDefaultLegacy(url);
    var proxyFromEnv__default = /* @__PURE__ */ _interopDefaultLegacy(proxyFromEnv);
    var http__default = /* @__PURE__ */ _interopDefaultLegacy(http);
    var https__default = /* @__PURE__ */ _interopDefaultLegacy(https);
    var http2__default = /* @__PURE__ */ _interopDefaultLegacy(http2);
    var util__default = /* @__PURE__ */ _interopDefaultLegacy(util);
    var followRedirects__default = /* @__PURE__ */ _interopDefaultLegacy(followRedirects);
    var zlib__default = /* @__PURE__ */ _interopDefaultLegacy(zlib);
    var stream__default = /* @__PURE__ */ _interopDefaultLegacy(stream);
    function bind(fn, thisArg) {
      return function wrap() {
        return fn.apply(thisArg, arguments);
      };
    }
    var { toString } = Object.prototype;
    var { getPrototypeOf } = Object;
    var { iterator, toStringTag } = Symbol;
    var kindOf = /* @__PURE__ */ ((cache) => (thing) => {
      const str = toString.call(thing);
      return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
    })(/* @__PURE__ */ Object.create(null));
    var kindOfTest = (type) => {
      type = type.toLowerCase();
      return (thing) => kindOf(thing) === type;
    };
    var typeOfTest = (type) => (thing) => typeof thing === type;
    var { isArray } = Array;
    var isUndefined = typeOfTest("undefined");
    function isBuffer(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction$1(val.constructor.isBuffer) && val.constructor.isBuffer(val);
    }
    var isArrayBuffer = kindOfTest("ArrayBuffer");
    function isArrayBufferView(val) {
      let result;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
      } else {
        result = val && val.buffer && isArrayBuffer(val.buffer);
      }
      return result;
    }
    var isString = typeOfTest("string");
    var isFunction$1 = typeOfTest("function");
    var isNumber = typeOfTest("number");
    var isObject = (thing) => thing !== null && typeof thing === "object";
    var isBoolean = (thing) => thing === true || thing === false;
    var isPlainObject = (val) => {
      if (kindOf(val) !== "object") {
        return false;
      }
      const prototype2 = getPrototypeOf(val);
      return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(toStringTag in val) && !(iterator in val);
    };
    var isEmptyObject = (val) => {
      if (!isObject(val) || isBuffer(val)) {
        return false;
      }
      try {
        return Object.keys(val).length === 0 && Object.getPrototypeOf(val) === Object.prototype;
      } catch (e) {
        return false;
      }
    };
    var isDate = kindOfTest("Date");
    var isFile = kindOfTest("File");
    var isBlob = kindOfTest("Blob");
    var isFileList = kindOfTest("FileList");
    var isStream = (val) => isObject(val) && isFunction$1(val.pipe);
    var isFormData = (thing) => {
      let kind;
      return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction$1(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
      kind === "object" && isFunction$1(thing.toString) && thing.toString() === "[object FormData]"));
    };
    var isURLSearchParams = kindOfTest("URLSearchParams");
    var [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
    var trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
    function forEach(obj, fn, { allOwnKeys = false } = {}) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      let i;
      let l;
      if (typeof obj !== "object") {
        obj = [obj];
      }
      if (isArray(obj)) {
        for (i = 0, l = obj.length; i < l; i++) {
          fn.call(null, obj[i], i, obj);
        }
      } else {
        if (isBuffer(obj)) {
          return;
        }
        const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
        const len = keys.length;
        let key;
        for (i = 0; i < len; i++) {
          key = keys[i];
          fn.call(null, obj[key], key, obj);
        }
      }
    }
    function findKey(obj, key) {
      if (isBuffer(obj)) {
        return null;
      }
      key = key.toLowerCase();
      const keys = Object.keys(obj);
      let i = keys.length;
      let _key;
      while (i-- > 0) {
        _key = keys[i];
        if (key === _key.toLowerCase()) {
          return _key;
        }
      }
      return null;
    }
    var _global = (() => {
      if (typeof globalThis !== "undefined") return globalThis;
      return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
    })();
    var isContextDefined = (context) => !isUndefined(context) && context !== _global;
    function merge() {
      const { caseless, skipUndefined } = isContextDefined(this) && this || {};
      const result = {};
      const assignValue = (val, key) => {
        const targetKey = caseless && findKey(result, key) || key;
        if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
          result[targetKey] = merge(result[targetKey], val);
        } else if (isPlainObject(val)) {
          result[targetKey] = merge({}, val);
        } else if (isArray(val)) {
          result[targetKey] = val.slice();
        } else if (!skipUndefined || !isUndefined(val)) {
          result[targetKey] = val;
        }
      };
      for (let i = 0, l = arguments.length; i < l; i++) {
        arguments[i] && forEach(arguments[i], assignValue);
      }
      return result;
    }
    var extend = (a, b, thisArg, { allOwnKeys } = {}) => {
      forEach(b, (val, key) => {
        if (thisArg && isFunction$1(val)) {
          a[key] = bind(val, thisArg);
        } else {
          a[key] = val;
        }
      }, { allOwnKeys });
      return a;
    };
    var stripBOM = (content) => {
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    };
    var inherits = (constructor, superConstructor, props, descriptors2) => {
      constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
      constructor.prototype.constructor = constructor;
      Object.defineProperty(constructor, "super", {
        value: superConstructor.prototype
      });
      props && Object.assign(constructor.prototype, props);
    };
    var toFlatObject = (sourceObj, destObj, filter, propFilter) => {
      let props;
      let i;
      let prop;
      const merged = {};
      destObj = destObj || {};
      if (sourceObj == null) return destObj;
      do {
        props = Object.getOwnPropertyNames(sourceObj);
        i = props.length;
        while (i-- > 0) {
          prop = props[i];
          if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
            destObj[prop] = sourceObj[prop];
            merged[prop] = true;
          }
        }
        sourceObj = filter !== false && getPrototypeOf(sourceObj);
      } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
      return destObj;
    };
    var endsWith = (str, searchString, position) => {
      str = String(str);
      if (position === void 0 || position > str.length) {
        position = str.length;
      }
      position -= searchString.length;
      const lastIndex = str.indexOf(searchString, position);
      return lastIndex !== -1 && lastIndex === position;
    };
    var toArray = (thing) => {
      if (!thing) return null;
      if (isArray(thing)) return thing;
      let i = thing.length;
      if (!isNumber(i)) return null;
      const arr = new Array(i);
      while (i-- > 0) {
        arr[i] = thing[i];
      }
      return arr;
    };
    var isTypedArray = /* @__PURE__ */ ((TypedArray) => {
      return (thing) => {
        return TypedArray && thing instanceof TypedArray;
      };
    })(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
    var forEachEntry = (obj, fn) => {
      const generator = obj && obj[iterator];
      const _iterator = generator.call(obj);
      let result;
      while ((result = _iterator.next()) && !result.done) {
        const pair = result.value;
        fn.call(obj, pair[0], pair[1]);
      }
    };
    var matchAll = (regExp, str) => {
      let matches;
      const arr = [];
      while ((matches = regExp.exec(str)) !== null) {
        arr.push(matches);
      }
      return arr;
    };
    var isHTMLForm = kindOfTest("HTMLFormElement");
    var toCamelCase = (str) => {
      return str.toLowerCase().replace(
        /[-_\s]([a-z\d])(\w*)/g,
        function replacer(m, p1, p2) {
          return p1.toUpperCase() + p2;
        }
      );
    };
    var hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
    var isRegExp = kindOfTest("RegExp");
    var reduceDescriptors = (obj, reducer) => {
      const descriptors2 = Object.getOwnPropertyDescriptors(obj);
      const reducedDescriptors = {};
      forEach(descriptors2, (descriptor, name) => {
        let ret;
        if ((ret = reducer(descriptor, name, obj)) !== false) {
          reducedDescriptors[name] = ret || descriptor;
        }
      });
      Object.defineProperties(obj, reducedDescriptors);
    };
    var freezeMethods = (obj) => {
      reduceDescriptors(obj, (descriptor, name) => {
        if (isFunction$1(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
          return false;
        }
        const value = obj[name];
        if (!isFunction$1(value)) return;
        descriptor.enumerable = false;
        if ("writable" in descriptor) {
          descriptor.writable = false;
          return;
        }
        if (!descriptor.set) {
          descriptor.set = () => {
            throw Error("Can not rewrite read-only method '" + name + "'");
          };
        }
      });
    };
    var toObjectSet = (arrayOrString, delimiter) => {
      const obj = {};
      const define = (arr) => {
        arr.forEach((value) => {
          obj[value] = true;
        });
      };
      isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
      return obj;
    };
    var noop = () => {
    };
    var toFiniteNumber = (value, defaultValue) => {
      return value != null && Number.isFinite(value = +value) ? value : defaultValue;
    };
    function isSpecCompliantForm(thing) {
      return !!(thing && isFunction$1(thing.append) && thing[toStringTag] === "FormData" && thing[iterator]);
    }
    var toJSONObject = (obj) => {
      const stack = new Array(10);
      const visit = (source, i) => {
        if (isObject(source)) {
          if (stack.indexOf(source) >= 0) {
            return;
          }
          if (isBuffer(source)) {
            return source;
          }
          if (!("toJSON" in source)) {
            stack[i] = source;
            const target = isArray(source) ? [] : {};
            forEach(source, (value, key) => {
              const reducedValue = visit(value, i + 1);
              !isUndefined(reducedValue) && (target[key] = reducedValue);
            });
            stack[i] = void 0;
            return target;
          }
        }
        return source;
      };
      return visit(obj, 0);
    };
    var isAsyncFn = kindOfTest("AsyncFunction");
    var isThenable = (thing) => thing && (isObject(thing) || isFunction$1(thing)) && isFunction$1(thing.then) && isFunction$1(thing.catch);
    var _setImmediate = ((setImmediateSupported, postMessageSupported) => {
      if (setImmediateSupported) {
        return setImmediate;
      }
      return postMessageSupported ? ((token, callbacks) => {
        _global.addEventListener("message", ({ source, data }) => {
          if (source === _global && data === token) {
            callbacks.length && callbacks.shift()();
          }
        }, false);
        return (cb) => {
          callbacks.push(cb);
          _global.postMessage(token, "*");
        };
      })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
    })(
      typeof setImmediate === "function",
      isFunction$1(_global.postMessage)
    );
    var asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
    var isIterable = (thing) => thing != null && isFunction$1(thing[iterator]);
    var utils$1 = {
      isArray,
      isArrayBuffer,
      isBuffer,
      isFormData,
      isArrayBufferView,
      isString,
      isNumber,
      isBoolean,
      isObject,
      isPlainObject,
      isEmptyObject,
      isReadableStream,
      isRequest,
      isResponse,
      isHeaders,
      isUndefined,
      isDate,
      isFile,
      isBlob,
      isRegExp,
      isFunction: isFunction$1,
      isStream,
      isURLSearchParams,
      isTypedArray,
      isFileList,
      forEach,
      merge,
      extend,
      trim,
      stripBOM,
      inherits,
      toFlatObject,
      kindOf,
      kindOfTest,
      endsWith,
      toArray,
      forEachEntry,
      matchAll,
      isHTMLForm,
      hasOwnProperty,
      hasOwnProp: hasOwnProperty,
      // an alias to avoid ESLint no-prototype-builtins detection
      reduceDescriptors,
      freezeMethods,
      toObjectSet,
      toCamelCase,
      noop,
      toFiniteNumber,
      findKey,
      global: _global,
      isContextDefined,
      isSpecCompliantForm,
      toJSONObject,
      isAsyncFn,
      isThenable,
      setImmediate: _setImmediate,
      asap,
      isIterable
    };
    function AxiosError(message, code, config, request, response) {
      Error.call(this);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      } else {
        this.stack = new Error().stack;
      }
      this.message = message;
      this.name = "AxiosError";
      code && (this.code = code);
      config && (this.config = config);
      request && (this.request = request);
      if (response) {
        this.response = response;
        this.status = response.status ? response.status : null;
      }
    }
    utils$1.inherits(AxiosError, Error, {
      toJSON: function toJSON() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: utils$1.toJSONObject(this.config),
          code: this.code,
          status: this.status
        };
      }
    });
    var prototype$1 = AxiosError.prototype;
    var descriptors = {};
    [
      "ERR_BAD_OPTION_VALUE",
      "ERR_BAD_OPTION",
      "ECONNABORTED",
      "ETIMEDOUT",
      "ERR_NETWORK",
      "ERR_FR_TOO_MANY_REDIRECTS",
      "ERR_DEPRECATED",
      "ERR_BAD_RESPONSE",
      "ERR_BAD_REQUEST",
      "ERR_CANCELED",
      "ERR_NOT_SUPPORT",
      "ERR_INVALID_URL"
      // eslint-disable-next-line func-names
    ].forEach((code) => {
      descriptors[code] = { value: code };
    });
    Object.defineProperties(AxiosError, descriptors);
    Object.defineProperty(prototype$1, "isAxiosError", { value: true });
    AxiosError.from = (error, code, config, request, response, customProps) => {
      const axiosError = Object.create(prototype$1);
      utils$1.toFlatObject(error, axiosError, function filter(obj) {
        return obj !== Error.prototype;
      }, (prop) => {
        return prop !== "isAxiosError";
      });
      const msg = error && error.message ? error.message : "Error";
      const errCode = code == null && error ? error.code : code;
      AxiosError.call(axiosError, msg, errCode, config, request, response);
      if (error && axiosError.cause == null) {
        Object.defineProperty(axiosError, "cause", { value: error, configurable: true });
      }
      axiosError.name = error && error.name || "Error";
      customProps && Object.assign(axiosError, customProps);
      return axiosError;
    };
    function isVisitable(thing) {
      return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
    }
    function removeBrackets(key) {
      return utils$1.endsWith(key, "[]") ? key.slice(0, -2) : key;
    }
    function renderKey(path2, key, dots) {
      if (!path2) return key;
      return path2.concat(key).map(function each(token, i) {
        token = removeBrackets(token);
        return !dots && i ? "[" + token + "]" : token;
      }).join(dots ? "." : "");
    }
    function isFlatArray(arr) {
      return utils$1.isArray(arr) && !arr.some(isVisitable);
    }
    var predicates = utils$1.toFlatObject(utils$1, {}, null, function filter(prop) {
      return /^is[A-Z]/.test(prop);
    });
    function toFormData(obj, formData, options) {
      if (!utils$1.isObject(obj)) {
        throw new TypeError("target must be an object");
      }
      formData = formData || new (FormData__default["default"] || FormData)();
      options = utils$1.toFlatObject(options, {
        metaTokens: true,
        dots: false,
        indexes: false
      }, false, function defined(option, source) {
        return !utils$1.isUndefined(source[option]);
      });
      const metaTokens = options.metaTokens;
      const visitor = options.visitor || defaultVisitor;
      const dots = options.dots;
      const indexes = options.indexes;
      const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
      const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);
      if (!utils$1.isFunction(visitor)) {
        throw new TypeError("visitor must be a function");
      }
      function convertValue(value) {
        if (value === null) return "";
        if (utils$1.isDate(value)) {
          return value.toISOString();
        }
        if (utils$1.isBoolean(value)) {
          return value.toString();
        }
        if (!useBlob && utils$1.isBlob(value)) {
          throw new AxiosError("Blob is not supported. Use a Buffer instead.");
        }
        if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {
          return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
        }
        return value;
      }
      function defaultVisitor(value, key, path2) {
        let arr = value;
        if (value && !path2 && typeof value === "object") {
          if (utils$1.endsWith(key, "{}")) {
            key = metaTokens ? key : key.slice(0, -2);
            value = JSON.stringify(value);
          } else if (utils$1.isArray(value) && isFlatArray(value) || (utils$1.isFileList(value) || utils$1.endsWith(key, "[]")) && (arr = utils$1.toArray(value))) {
            key = removeBrackets(key);
            arr.forEach(function each(el, index) {
              !(utils$1.isUndefined(el) || el === null) && formData.append(
                // eslint-disable-next-line no-nested-ternary
                indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
                convertValue(el)
              );
            });
            return false;
          }
        }
        if (isVisitable(value)) {
          return true;
        }
        formData.append(renderKey(path2, key, dots), convertValue(value));
        return false;
      }
      const stack = [];
      const exposedHelpers = Object.assign(predicates, {
        defaultVisitor,
        convertValue,
        isVisitable
      });
      function build2(value, path2) {
        if (utils$1.isUndefined(value)) return;
        if (stack.indexOf(value) !== -1) {
          throw Error("Circular reference detected in " + path2.join("."));
        }
        stack.push(value);
        utils$1.forEach(value, function each(el, key) {
          const result = !(utils$1.isUndefined(el) || el === null) && visitor.call(
            formData,
            el,
            utils$1.isString(key) ? key.trim() : key,
            path2,
            exposedHelpers
          );
          if (result === true) {
            build2(el, path2 ? path2.concat(key) : [key]);
          }
        });
        stack.pop();
      }
      if (!utils$1.isObject(obj)) {
        throw new TypeError("data must be an object");
      }
      build2(obj);
      return formData;
    }
    function encode$1(str) {
      const charMap = {
        "!": "%21",
        "'": "%27",
        "(": "%28",
        ")": "%29",
        "~": "%7E",
        "%20": "+",
        "%00": "\0"
      };
      return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
        return charMap[match];
      });
    }
    function AxiosURLSearchParams(params, options) {
      this._pairs = [];
      params && toFormData(params, this, options);
    }
    var prototype = AxiosURLSearchParams.prototype;
    prototype.append = function append(name, value) {
      this._pairs.push([name, value]);
    };
    prototype.toString = function toString2(encoder) {
      const _encode = encoder ? function(value) {
        return encoder.call(this, value, encode$1);
      } : encode$1;
      return this._pairs.map(function each(pair) {
        return _encode(pair[0]) + "=" + _encode(pair[1]);
      }, "").join("&");
    };
    function encode(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+");
    }
    function buildURL(url2, params, options) {
      if (!params) {
        return url2;
      }
      const _encode = options && options.encode || encode;
      if (utils$1.isFunction(options)) {
        options = {
          serialize: options
        };
      }
      const serializeFn = options && options.serialize;
      let serializedParams;
      if (serializeFn) {
        serializedParams = serializeFn(params, options);
      } else {
        serializedParams = utils$1.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
      }
      if (serializedParams) {
        const hashmarkIndex = url2.indexOf("#");
        if (hashmarkIndex !== -1) {
          url2 = url2.slice(0, hashmarkIndex);
        }
        url2 += (url2.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url2;
    }
    var InterceptorManager = class {
      constructor() {
        this.handlers = [];
      }
      /**
       * Add a new interceptor to the stack
       *
       * @param {Function} fulfilled The function to handle `then` for a `Promise`
       * @param {Function} rejected The function to handle `reject` for a `Promise`
       *
       * @return {Number} An ID used to remove interceptor later
       */
      use(fulfilled, rejected, options) {
        this.handlers.push({
          fulfilled,
          rejected,
          synchronous: options ? options.synchronous : false,
          runWhen: options ? options.runWhen : null
        });
        return this.handlers.length - 1;
      }
      /**
       * Remove an interceptor from the stack
       *
       * @param {Number} id The ID that was returned by `use`
       *
       * @returns {void}
       */
      eject(id) {
        if (this.handlers[id]) {
          this.handlers[id] = null;
        }
      }
      /**
       * Clear all interceptors from the stack
       *
       * @returns {void}
       */
      clear() {
        if (this.handlers) {
          this.handlers = [];
        }
      }
      /**
       * Iterate over all the registered interceptors
       *
       * This method is particularly useful for skipping over any
       * interceptors that may have become `null` calling `eject`.
       *
       * @param {Function} fn The function to call for each interceptor
       *
       * @returns {void}
       */
      forEach(fn) {
        utils$1.forEach(this.handlers, function forEachHandler(h) {
          if (h !== null) {
            fn(h);
          }
        });
      }
    };
    var InterceptorManager$1 = InterceptorManager;
    var transitionalDefaults = {
      silentJSONParsing: true,
      forcedJSONParsing: true,
      clarifyTimeoutError: false
    };
    var URLSearchParams = url__default["default"].URLSearchParams;
    var ALPHA = "abcdefghijklmnopqrstuvwxyz";
    var DIGIT = "0123456789";
    var ALPHABET = {
      DIGIT,
      ALPHA,
      ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
    };
    var generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
      let str = "";
      const { length } = alphabet;
      const randomValues = new Uint32Array(size);
      crypto__default["default"].randomFillSync(randomValues);
      for (let i = 0; i < size; i++) {
        str += alphabet[randomValues[i] % length];
      }
      return str;
    };
    var platform$1 = {
      isNode: true,
      classes: {
        URLSearchParams,
        FormData: FormData__default["default"],
        Blob: typeof Blob !== "undefined" && Blob || null
      },
      ALPHABET,
      generateString,
      protocols: ["http", "https", "file", "data"]
    };
    var hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
    var _navigator = typeof navigator === "object" && navigator || void 0;
    var hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0);
    var hasStandardBrowserWebWorkerEnv = (() => {
      return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
      self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
    })();
    var origin = hasBrowserEnv && window.location.href || "http://localhost";
    var utils = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      hasBrowserEnv,
      hasStandardBrowserWebWorkerEnv,
      hasStandardBrowserEnv,
      navigator: _navigator,
      origin
    });
    var platform = {
      ...utils,
      ...platform$1
    };
    function toURLEncodedForm(data, options) {
      return toFormData(data, new platform.classes.URLSearchParams(), {
        visitor: function(value, key, path2, helpers) {
          if (platform.isNode && utils$1.isBuffer(value)) {
            this.append(key, value.toString("base64"));
            return false;
          }
          return helpers.defaultVisitor.apply(this, arguments);
        },
        ...options
      });
    }
    function parsePropPath(name) {
      return utils$1.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
        return match[0] === "[]" ? "" : match[1] || match[0];
      });
    }
    function arrayToObject(arr) {
      const obj = {};
      const keys = Object.keys(arr);
      let i;
      const len = keys.length;
      let key;
      for (i = 0; i < len; i++) {
        key = keys[i];
        obj[key] = arr[key];
      }
      return obj;
    }
    function formDataToJSON(formData) {
      function buildPath(path2, value, target, index) {
        let name = path2[index++];
        if (name === "__proto__") return true;
        const isNumericKey = Number.isFinite(+name);
        const isLast = index >= path2.length;
        name = !name && utils$1.isArray(target) ? target.length : name;
        if (isLast) {
          if (utils$1.hasOwnProp(target, name)) {
            target[name] = [target[name], value];
          } else {
            target[name] = value;
          }
          return !isNumericKey;
        }
        if (!target[name] || !utils$1.isObject(target[name])) {
          target[name] = [];
        }
        const result = buildPath(path2, value, target[name], index);
        if (result && utils$1.isArray(target[name])) {
          target[name] = arrayToObject(target[name]);
        }
        return !isNumericKey;
      }
      if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
        const obj = {};
        utils$1.forEachEntry(formData, (name, value) => {
          buildPath(parsePropPath(name), value, obj, 0);
        });
        return obj;
      }
      return null;
    }
    function stringifySafely(rawValue, parser, encoder) {
      if (utils$1.isString(rawValue)) {
        try {
          (parser || JSON.parse)(rawValue);
          return utils$1.trim(rawValue);
        } catch (e) {
          if (e.name !== "SyntaxError") {
            throw e;
          }
        }
      }
      return (encoder || JSON.stringify)(rawValue);
    }
    var defaults = {
      transitional: transitionalDefaults,
      adapter: ["xhr", "http", "fetch"],
      transformRequest: [function transformRequest(data, headers) {
        const contentType = headers.getContentType() || "";
        const hasJSONContentType = contentType.indexOf("application/json") > -1;
        const isObjectPayload = utils$1.isObject(data);
        if (isObjectPayload && utils$1.isHTMLForm(data)) {
          data = new FormData(data);
        }
        const isFormData2 = utils$1.isFormData(data);
        if (isFormData2) {
          return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
        }
        if (utils$1.isArrayBuffer(data) || utils$1.isBuffer(data) || utils$1.isStream(data) || utils$1.isFile(data) || utils$1.isBlob(data) || utils$1.isReadableStream(data)) {
          return data;
        }
        if (utils$1.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils$1.isURLSearchParams(data)) {
          headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
          return data.toString();
        }
        let isFileList2;
        if (isObjectPayload) {
          if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
            return toURLEncodedForm(data, this.formSerializer).toString();
          }
          if ((isFileList2 = utils$1.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
            const _FormData = this.env && this.env.FormData;
            return toFormData(
              isFileList2 ? { "files[]": data } : data,
              _FormData && new _FormData(),
              this.formSerializer
            );
          }
        }
        if (isObjectPayload || hasJSONContentType) {
          headers.setContentType("application/json", false);
          return stringifySafely(data);
        }
        return data;
      }],
      transformResponse: [function transformResponse(data) {
        const transitional = this.transitional || defaults.transitional;
        const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
        const JSONRequested = this.responseType === "json";
        if (utils$1.isResponse(data) || utils$1.isReadableStream(data)) {
          return data;
        }
        if (data && utils$1.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
          const silentJSONParsing = transitional && transitional.silentJSONParsing;
          const strictJSONParsing = !silentJSONParsing && JSONRequested;
          try {
            return JSON.parse(data, this.parseReviver);
          } catch (e) {
            if (strictJSONParsing) {
              if (e.name === "SyntaxError") {
                throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
              }
              throw e;
            }
          }
        }
        return data;
      }],
      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      env: {
        FormData: platform.classes.FormData,
        Blob: platform.classes.Blob
      },
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      },
      headers: {
        common: {
          "Accept": "application/json, text/plain, */*",
          "Content-Type": void 0
        }
      }
    };
    utils$1.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
      defaults.headers[method] = {};
    });
    var defaults$1 = defaults;
    var ignoreDuplicateOf = utils$1.toObjectSet([
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ]);
    var parseHeaders = (rawHeaders) => {
      const parsed = {};
      let key;
      let val;
      let i;
      rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
        i = line.indexOf(":");
        key = line.substring(0, i).trim().toLowerCase();
        val = line.substring(i + 1).trim();
        if (!key || parsed[key] && ignoreDuplicateOf[key]) {
          return;
        }
        if (key === "set-cookie") {
          if (parsed[key]) {
            parsed[key].push(val);
          } else {
            parsed[key] = [val];
          }
        } else {
          parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
        }
      });
      return parsed;
    };
    var $internals = /* @__PURE__ */ Symbol("internals");
    function normalizeHeader(header) {
      return header && String(header).trim().toLowerCase();
    }
    function normalizeValue(value) {
      if (value === false || value == null) {
        return value;
      }
      return utils$1.isArray(value) ? value.map(normalizeValue) : String(value);
    }
    function parseTokens(str) {
      const tokens = /* @__PURE__ */ Object.create(null);
      const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
      let match;
      while (match = tokensRE.exec(str)) {
        tokens[match[1]] = match[2];
      }
      return tokens;
    }
    var isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
    function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
      if (utils$1.isFunction(filter)) {
        return filter.call(this, value, header);
      }
      if (isHeaderNameFilter) {
        value = header;
      }
      if (!utils$1.isString(value)) return;
      if (utils$1.isString(filter)) {
        return value.indexOf(filter) !== -1;
      }
      if (utils$1.isRegExp(filter)) {
        return filter.test(value);
      }
    }
    function formatHeader(header) {
      return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
        return char.toUpperCase() + str;
      });
    }
    function buildAccessors(obj, header) {
      const accessorName = utils$1.toCamelCase(" " + header);
      ["get", "set", "has"].forEach((methodName) => {
        Object.defineProperty(obj, methodName + accessorName, {
          value: function(arg1, arg2, arg3) {
            return this[methodName].call(this, header, arg1, arg2, arg3);
          },
          configurable: true
        });
      });
    }
    var AxiosHeaders = class {
      constructor(headers) {
        headers && this.set(headers);
      }
      set(header, valueOrRewrite, rewrite) {
        const self2 = this;
        function setHeader(_value, _header, _rewrite) {
          const lHeader = normalizeHeader(_header);
          if (!lHeader) {
            throw new Error("header name must be a non-empty string");
          }
          const key = utils$1.findKey(self2, lHeader);
          if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
            self2[key || _header] = normalizeValue(_value);
          }
        }
        const setHeaders = (headers, _rewrite) => utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
        if (utils$1.isPlainObject(header) || header instanceof this.constructor) {
          setHeaders(header, valueOrRewrite);
        } else if (utils$1.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
          setHeaders(parseHeaders(header), valueOrRewrite);
        } else if (utils$1.isObject(header) && utils$1.isIterable(header)) {
          let obj = {}, dest, key;
          for (const entry of header) {
            if (!utils$1.isArray(entry)) {
              throw TypeError("Object iterator must return a key-value pair");
            }
            obj[key = entry[0]] = (dest = obj[key]) ? utils$1.isArray(dest) ? [...dest, entry[1]] : [dest, entry[1]] : entry[1];
          }
          setHeaders(obj, valueOrRewrite);
        } else {
          header != null && setHeader(valueOrRewrite, header, rewrite);
        }
        return this;
      }
      get(header, parser) {
        header = normalizeHeader(header);
        if (header) {
          const key = utils$1.findKey(this, header);
          if (key) {
            const value = this[key];
            if (!parser) {
              return value;
            }
            if (parser === true) {
              return parseTokens(value);
            }
            if (utils$1.isFunction(parser)) {
              return parser.call(this, value, key);
            }
            if (utils$1.isRegExp(parser)) {
              return parser.exec(value);
            }
            throw new TypeError("parser must be boolean|regexp|function");
          }
        }
      }
      has(header, matcher) {
        header = normalizeHeader(header);
        if (header) {
          const key = utils$1.findKey(this, header);
          return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
        }
        return false;
      }
      delete(header, matcher) {
        const self2 = this;
        let deleted = false;
        function deleteHeader(_header) {
          _header = normalizeHeader(_header);
          if (_header) {
            const key = utils$1.findKey(self2, _header);
            if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
              delete self2[key];
              deleted = true;
            }
          }
        }
        if (utils$1.isArray(header)) {
          header.forEach(deleteHeader);
        } else {
          deleteHeader(header);
        }
        return deleted;
      }
      clear(matcher) {
        const keys = Object.keys(this);
        let i = keys.length;
        let deleted = false;
        while (i--) {
          const key = keys[i];
          if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
            delete this[key];
            deleted = true;
          }
        }
        return deleted;
      }
      normalize(format) {
        const self2 = this;
        const headers = {};
        utils$1.forEach(this, (value, header) => {
          const key = utils$1.findKey(headers, header);
          if (key) {
            self2[key] = normalizeValue(value);
            delete self2[header];
            return;
          }
          const normalized = format ? formatHeader(header) : String(header).trim();
          if (normalized !== header) {
            delete self2[header];
          }
          self2[normalized] = normalizeValue(value);
          headers[normalized] = true;
        });
        return this;
      }
      concat(...targets) {
        return this.constructor.concat(this, ...targets);
      }
      toJSON(asStrings) {
        const obj = /* @__PURE__ */ Object.create(null);
        utils$1.forEach(this, (value, header) => {
          value != null && value !== false && (obj[header] = asStrings && utils$1.isArray(value) ? value.join(", ") : value);
        });
        return obj;
      }
      [Symbol.iterator]() {
        return Object.entries(this.toJSON())[Symbol.iterator]();
      }
      toString() {
        return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
      }
      getSetCookie() {
        return this.get("set-cookie") || [];
      }
      get [Symbol.toStringTag]() {
        return "AxiosHeaders";
      }
      static from(thing) {
        return thing instanceof this ? thing : new this(thing);
      }
      static concat(first, ...targets) {
        const computed = new this(first);
        targets.forEach((target) => computed.set(target));
        return computed;
      }
      static accessor(header) {
        const internals = this[$internals] = this[$internals] = {
          accessors: {}
        };
        const accessors = internals.accessors;
        const prototype2 = this.prototype;
        function defineAccessor(_header) {
          const lHeader = normalizeHeader(_header);
          if (!accessors[lHeader]) {
            buildAccessors(prototype2, _header);
            accessors[lHeader] = true;
          }
        }
        utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
        return this;
      }
    };
    AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
    utils$1.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
      let mapped = key[0].toUpperCase() + key.slice(1);
      return {
        get: () => value,
        set(headerValue) {
          this[mapped] = headerValue;
        }
      };
    });
    utils$1.freezeMethods(AxiosHeaders);
    var AxiosHeaders$1 = AxiosHeaders;
    function transformData(fns, response) {
      const config = this || defaults$1;
      const context = response || config;
      const headers = AxiosHeaders$1.from(context.headers);
      let data = context.data;
      utils$1.forEach(fns, function transform(fn) {
        data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
      });
      headers.normalize();
      return data;
    }
    function isCancel(value) {
      return !!(value && value.__CANCEL__);
    }
    function CanceledError(message, config, request) {
      AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED, config, request);
      this.name = "CanceledError";
    }
    utils$1.inherits(CanceledError, AxiosError, {
      __CANCEL__: true
    });
    function settle(resolve3, reject, response) {
      const validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve3(response);
      } else {
        reject(new AxiosError(
          "Request failed with status code " + response.status,
          [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
          response.config,
          response.request,
          response
        ));
      }
    }
    function isAbsoluteURL(url2) {
      return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url2);
    }
    function combineURLs(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    }
    function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
      let isRelativeUrl = !isAbsoluteURL(requestedURL);
      if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    }
    var VERSION = "1.13.2";
    function parseProtocol(url2) {
      const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url2);
      return match && match[1] || "";
    }
    var DATA_URL_PATTERN = /^(?:([^;]+);)?(?:[^;]+;)?(base64|),([\s\S]*)$/;
    function fromDataURI(uri, asBlob, options) {
      const _Blob = options && options.Blob || platform.classes.Blob;
      const protocol = parseProtocol(uri);
      if (asBlob === void 0 && _Blob) {
        asBlob = true;
      }
      if (protocol === "data") {
        uri = protocol.length ? uri.slice(protocol.length + 1) : uri;
        const match = DATA_URL_PATTERN.exec(uri);
        if (!match) {
          throw new AxiosError("Invalid URL", AxiosError.ERR_INVALID_URL);
        }
        const mime = match[1];
        const isBase64 = match[2];
        const body = match[3];
        const buffer = Buffer.from(decodeURIComponent(body), isBase64 ? "base64" : "utf8");
        if (asBlob) {
          if (!_Blob) {
            throw new AxiosError("Blob is not supported", AxiosError.ERR_NOT_SUPPORT);
          }
          return new _Blob([buffer], { type: mime });
        }
        return buffer;
      }
      throw new AxiosError("Unsupported protocol " + protocol, AxiosError.ERR_NOT_SUPPORT);
    }
    var kInternals = /* @__PURE__ */ Symbol("internals");
    var AxiosTransformStream = class extends stream__default["default"].Transform {
      constructor(options) {
        options = utils$1.toFlatObject(options, {
          maxRate: 0,
          chunkSize: 64 * 1024,
          minChunkSize: 100,
          timeWindow: 500,
          ticksRate: 2,
          samplesCount: 15
        }, null, (prop, source) => {
          return !utils$1.isUndefined(source[prop]);
        });
        super({
          readableHighWaterMark: options.chunkSize
        });
        const internals = this[kInternals] = {
          timeWindow: options.timeWindow,
          chunkSize: options.chunkSize,
          maxRate: options.maxRate,
          minChunkSize: options.minChunkSize,
          bytesSeen: 0,
          isCaptured: false,
          notifiedBytesLoaded: 0,
          ts: Date.now(),
          bytes: 0,
          onReadCallback: null
        };
        this.on("newListener", (event) => {
          if (event === "progress") {
            if (!internals.isCaptured) {
              internals.isCaptured = true;
            }
          }
        });
      }
      _read(size) {
        const internals = this[kInternals];
        if (internals.onReadCallback) {
          internals.onReadCallback();
        }
        return super._read(size);
      }
      _transform(chunk, encoding, callback2) {
        const internals = this[kInternals];
        const maxRate = internals.maxRate;
        const readableHighWaterMark = this.readableHighWaterMark;
        const timeWindow = internals.timeWindow;
        const divider = 1e3 / timeWindow;
        const bytesThreshold = maxRate / divider;
        const minChunkSize = internals.minChunkSize !== false ? Math.max(internals.minChunkSize, bytesThreshold * 0.01) : 0;
        const pushChunk = (_chunk, _callback) => {
          const bytes = Buffer.byteLength(_chunk);
          internals.bytesSeen += bytes;
          internals.bytes += bytes;
          internals.isCaptured && this.emit("progress", internals.bytesSeen);
          if (this.push(_chunk)) {
            process.nextTick(_callback);
          } else {
            internals.onReadCallback = () => {
              internals.onReadCallback = null;
              process.nextTick(_callback);
            };
          }
        };
        const transformChunk = (_chunk, _callback) => {
          const chunkSize = Buffer.byteLength(_chunk);
          let chunkRemainder = null;
          let maxChunkSize = readableHighWaterMark;
          let bytesLeft;
          let passed = 0;
          if (maxRate) {
            const now = Date.now();
            if (!internals.ts || (passed = now - internals.ts) >= timeWindow) {
              internals.ts = now;
              bytesLeft = bytesThreshold - internals.bytes;
              internals.bytes = bytesLeft < 0 ? -bytesLeft : 0;
              passed = 0;
            }
            bytesLeft = bytesThreshold - internals.bytes;
          }
          if (maxRate) {
            if (bytesLeft <= 0) {
              return setTimeout(() => {
                _callback(null, _chunk);
              }, timeWindow - passed);
            }
            if (bytesLeft < maxChunkSize) {
              maxChunkSize = bytesLeft;
            }
          }
          if (maxChunkSize && chunkSize > maxChunkSize && chunkSize - maxChunkSize > minChunkSize) {
            chunkRemainder = _chunk.subarray(maxChunkSize);
            _chunk = _chunk.subarray(0, maxChunkSize);
          }
          pushChunk(_chunk, chunkRemainder ? () => {
            process.nextTick(_callback, null, chunkRemainder);
          } : _callback);
        };
        transformChunk(chunk, function transformNextChunk(err, _chunk) {
          if (err) {
            return callback2(err);
          }
          if (_chunk) {
            transformChunk(_chunk, transformNextChunk);
          } else {
            callback2(null);
          }
        });
      }
    };
    var AxiosTransformStream$1 = AxiosTransformStream;
    var { asyncIterator } = Symbol;
    var readBlob = async function* (blob) {
      if (blob.stream) {
        yield* blob.stream();
      } else if (blob.arrayBuffer) {
        yield await blob.arrayBuffer();
      } else if (blob[asyncIterator]) {
        yield* blob[asyncIterator]();
      } else {
        yield blob;
      }
    };
    var readBlob$1 = readBlob;
    var BOUNDARY_ALPHABET = platform.ALPHABET.ALPHA_DIGIT + "-_";
    var textEncoder = typeof TextEncoder === "function" ? new TextEncoder() : new util__default["default"].TextEncoder();
    var CRLF = "\r\n";
    var CRLF_BYTES = textEncoder.encode(CRLF);
    var CRLF_BYTES_COUNT = 2;
    var FormDataPart = class {
      constructor(name, value) {
        const { escapeName } = this.constructor;
        const isStringValue = utils$1.isString(value);
        let headers = `Content-Disposition: form-data; name="${escapeName(name)}"${!isStringValue && value.name ? `; filename="${escapeName(value.name)}"` : ""}${CRLF}`;
        if (isStringValue) {
          value = textEncoder.encode(String(value).replace(/\r?\n|\r\n?/g, CRLF));
        } else {
          headers += `Content-Type: ${value.type || "application/octet-stream"}${CRLF}`;
        }
        this.headers = textEncoder.encode(headers + CRLF);
        this.contentLength = isStringValue ? value.byteLength : value.size;
        this.size = this.headers.byteLength + this.contentLength + CRLF_BYTES_COUNT;
        this.name = name;
        this.value = value;
      }
      async *encode() {
        yield this.headers;
        const { value } = this;
        if (utils$1.isTypedArray(value)) {
          yield value;
        } else {
          yield* readBlob$1(value);
        }
        yield CRLF_BYTES;
      }
      static escapeName(name) {
        return String(name).replace(/[\r\n"]/g, (match) => ({
          "\r": "%0D",
          "\n": "%0A",
          '"': "%22"
        })[match]);
      }
    };
    var formDataToStream = (form, headersHandler, options) => {
      const {
        tag = "form-data-boundary",
        size = 25,
        boundary = tag + "-" + platform.generateString(size, BOUNDARY_ALPHABET)
      } = options || {};
      if (!utils$1.isFormData(form)) {
        throw TypeError("FormData instance required");
      }
      if (boundary.length < 1 || boundary.length > 70) {
        throw Error("boundary must be 10-70 characters long");
      }
      const boundaryBytes = textEncoder.encode("--" + boundary + CRLF);
      const footerBytes = textEncoder.encode("--" + boundary + "--" + CRLF);
      let contentLength = footerBytes.byteLength;
      const parts = Array.from(form.entries()).map(([name, value]) => {
        const part = new FormDataPart(name, value);
        contentLength += part.size;
        return part;
      });
      contentLength += boundaryBytes.byteLength * parts.length;
      contentLength = utils$1.toFiniteNumber(contentLength);
      const computedHeaders = {
        "Content-Type": `multipart/form-data; boundary=${boundary}`
      };
      if (Number.isFinite(contentLength)) {
        computedHeaders["Content-Length"] = contentLength;
      }
      headersHandler && headersHandler(computedHeaders);
      return stream.Readable.from((async function* () {
        for (const part of parts) {
          yield boundaryBytes;
          yield* part.encode();
        }
        yield footerBytes;
      })());
    };
    var formDataToStream$1 = formDataToStream;
    var ZlibHeaderTransformStream = class extends stream__default["default"].Transform {
      __transform(chunk, encoding, callback2) {
        this.push(chunk);
        callback2();
      }
      _transform(chunk, encoding, callback2) {
        if (chunk.length !== 0) {
          this._transform = this.__transform;
          if (chunk[0] !== 120) {
            const header = Buffer.alloc(2);
            header[0] = 120;
            header[1] = 156;
            this.push(header, encoding);
          }
        }
        this.__transform(chunk, encoding, callback2);
      }
    };
    var ZlibHeaderTransformStream$1 = ZlibHeaderTransformStream;
    var callbackify = (fn, reducer) => {
      return utils$1.isAsyncFn(fn) ? function(...args) {
        const cb = args.pop();
        fn.apply(this, args).then((value) => {
          try {
            reducer ? cb(null, ...reducer(value)) : cb(null, value);
          } catch (err) {
            cb(err);
          }
        }, cb);
      } : fn;
    };
    var callbackify$1 = callbackify;
    function speedometer(samplesCount, min) {
      samplesCount = samplesCount || 10;
      const bytes = new Array(samplesCount);
      const timestamps = new Array(samplesCount);
      let head = 0;
      let tail = 0;
      let firstSampleTS;
      min = min !== void 0 ? min : 1e3;
      return function push(chunkLength) {
        const now = Date.now();
        const startedAt = timestamps[tail];
        if (!firstSampleTS) {
          firstSampleTS = now;
        }
        bytes[head] = chunkLength;
        timestamps[head] = now;
        let i = tail;
        let bytesCount = 0;
        while (i !== head) {
          bytesCount += bytes[i++];
          i = i % samplesCount;
        }
        head = (head + 1) % samplesCount;
        if (head === tail) {
          tail = (tail + 1) % samplesCount;
        }
        if (now - firstSampleTS < min) {
          return;
        }
        const passed = startedAt && now - startedAt;
        return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
      };
    }
    function throttle(fn, freq) {
      let timestamp = 0;
      let threshold = 1e3 / freq;
      let lastArgs;
      let timer;
      const invoke = (args, now = Date.now()) => {
        timestamp = now;
        lastArgs = null;
        if (timer) {
          clearTimeout(timer);
          timer = null;
        }
        fn(...args);
      };
      const throttled = (...args) => {
        const now = Date.now();
        const passed = now - timestamp;
        if (passed >= threshold) {
          invoke(args, now);
        } else {
          lastArgs = args;
          if (!timer) {
            timer = setTimeout(() => {
              timer = null;
              invoke(lastArgs);
            }, threshold - passed);
          }
        }
      };
      const flush = () => lastArgs && invoke(lastArgs);
      return [throttled, flush];
    }
    var progressEventReducer = (listener, isDownloadStream, freq = 3) => {
      let bytesNotified = 0;
      const _speedometer = speedometer(50, 250);
      return throttle((e) => {
        const loaded = e.loaded;
        const total = e.lengthComputable ? e.total : void 0;
        const progressBytes = loaded - bytesNotified;
        const rate = _speedometer(progressBytes);
        const inRange = loaded <= total;
        bytesNotified = loaded;
        const data = {
          loaded,
          total,
          progress: total ? loaded / total : void 0,
          bytes: progressBytes,
          rate: rate ? rate : void 0,
          estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
          event: e,
          lengthComputable: total != null,
          [isDownloadStream ? "download" : "upload"]: true
        };
        listener(data);
      }, freq);
    };
    var progressEventDecorator = (total, throttled) => {
      const lengthComputable = total != null;
      return [(loaded) => throttled[0]({
        lengthComputable,
        total,
        loaded
      }), throttled[1]];
    };
    var asyncDecorator = (fn) => (...args) => utils$1.asap(() => fn(...args));
    function estimateDataURLDecodedBytes(url2) {
      if (!url2 || typeof url2 !== "string") return 0;
      if (!url2.startsWith("data:")) return 0;
      const comma = url2.indexOf(",");
      if (comma < 0) return 0;
      const meta = url2.slice(5, comma);
      const body = url2.slice(comma + 1);
      const isBase64 = /;base64/i.test(meta);
      if (isBase64) {
        let effectiveLen = body.length;
        const len = body.length;
        for (let i = 0; i < len; i++) {
          if (body.charCodeAt(i) === 37 && i + 2 < len) {
            const a = body.charCodeAt(i + 1);
            const b = body.charCodeAt(i + 2);
            const isHex = (a >= 48 && a <= 57 || a >= 65 && a <= 70 || a >= 97 && a <= 102) && (b >= 48 && b <= 57 || b >= 65 && b <= 70 || b >= 97 && b <= 102);
            if (isHex) {
              effectiveLen -= 2;
              i += 2;
            }
          }
        }
        let pad = 0;
        let idx = len - 1;
        const tailIsPct3D = (j) => j >= 2 && body.charCodeAt(j - 2) === 37 && // '%'
        body.charCodeAt(j - 1) === 51 && // '3'
        (body.charCodeAt(j) === 68 || body.charCodeAt(j) === 100);
        if (idx >= 0) {
          if (body.charCodeAt(idx) === 61) {
            pad++;
            idx--;
          } else if (tailIsPct3D(idx)) {
            pad++;
            idx -= 3;
          }
        }
        if (pad === 1 && idx >= 0) {
          if (body.charCodeAt(idx) === 61) {
            pad++;
          } else if (tailIsPct3D(idx)) {
            pad++;
          }
        }
        const groups = Math.floor(effectiveLen / 4);
        const bytes = groups * 3 - (pad || 0);
        return bytes > 0 ? bytes : 0;
      }
      return Buffer.byteLength(body, "utf8");
    }
    var zlibOptions = {
      flush: zlib__default["default"].constants.Z_SYNC_FLUSH,
      finishFlush: zlib__default["default"].constants.Z_SYNC_FLUSH
    };
    var brotliOptions = {
      flush: zlib__default["default"].constants.BROTLI_OPERATION_FLUSH,
      finishFlush: zlib__default["default"].constants.BROTLI_OPERATION_FLUSH
    };
    var isBrotliSupported = utils$1.isFunction(zlib__default["default"].createBrotliDecompress);
    var { http: httpFollow, https: httpsFollow } = followRedirects__default["default"];
    var isHttps = /https:?/;
    var supportedProtocols = platform.protocols.map((protocol) => {
      return protocol + ":";
    });
    var flushOnFinish = (stream2, [throttled, flush]) => {
      stream2.on("end", flush).on("error", flush);
      return throttled;
    };
    var Http2Sessions = class {
      constructor() {
        this.sessions = /* @__PURE__ */ Object.create(null);
      }
      getSession(authority, options) {
        options = Object.assign({
          sessionTimeout: 1e3
        }, options);
        let authoritySessions = this.sessions[authority];
        if (authoritySessions) {
          let len = authoritySessions.length;
          for (let i = 0; i < len; i++) {
            const [sessionHandle, sessionOptions] = authoritySessions[i];
            if (!sessionHandle.destroyed && !sessionHandle.closed && util__default["default"].isDeepStrictEqual(sessionOptions, options)) {
              return sessionHandle;
            }
          }
        }
        const session = http2__default["default"].connect(authority, options);
        let removed;
        const removeSession = () => {
          if (removed) {
            return;
          }
          removed = true;
          let entries = authoritySessions, len = entries.length, i = len;
          while (i--) {
            if (entries[i][0] === session) {
              if (len === 1) {
                delete this.sessions[authority];
              } else {
                entries.splice(i, 1);
              }
              return;
            }
          }
        };
        const originalRequestFn = session.request;
        const { sessionTimeout } = options;
        if (sessionTimeout != null) {
          let timer;
          let streamsCount = 0;
          session.request = function() {
            const stream2 = originalRequestFn.apply(this, arguments);
            streamsCount++;
            if (timer) {
              clearTimeout(timer);
              timer = null;
            }
            stream2.once("close", () => {
              if (!--streamsCount) {
                timer = setTimeout(() => {
                  timer = null;
                  removeSession();
                }, sessionTimeout);
              }
            });
            return stream2;
          };
        }
        session.once("close", removeSession);
        let entry = [
          session,
          options
        ];
        authoritySessions ? authoritySessions.push(entry) : authoritySessions = this.sessions[authority] = [entry];
        return session;
      }
    };
    var http2Sessions = new Http2Sessions();
    function dispatchBeforeRedirect(options, responseDetails) {
      if (options.beforeRedirects.proxy) {
        options.beforeRedirects.proxy(options);
      }
      if (options.beforeRedirects.config) {
        options.beforeRedirects.config(options, responseDetails);
      }
    }
    function setProxy(options, configProxy, location) {
      let proxy = configProxy;
      if (!proxy && proxy !== false) {
        const proxyUrl = proxyFromEnv__default["default"].getProxyForUrl(location);
        if (proxyUrl) {
          proxy = new URL(proxyUrl);
        }
      }
      if (proxy) {
        if (proxy.username) {
          proxy.auth = (proxy.username || "") + ":" + (proxy.password || "");
        }
        if (proxy.auth) {
          if (proxy.auth.username || proxy.auth.password) {
            proxy.auth = (proxy.auth.username || "") + ":" + (proxy.auth.password || "");
          }
          const base64 = Buffer.from(proxy.auth, "utf8").toString("base64");
          options.headers["Proxy-Authorization"] = "Basic " + base64;
        }
        options.headers.host = options.hostname + (options.port ? ":" + options.port : "");
        const proxyHost = proxy.hostname || proxy.host;
        options.hostname = proxyHost;
        options.host = proxyHost;
        options.port = proxy.port;
        options.path = location;
        if (proxy.protocol) {
          options.protocol = proxy.protocol.includes(":") ? proxy.protocol : `${proxy.protocol}:`;
        }
      }
      options.beforeRedirects.proxy = function beforeRedirect(redirectOptions) {
        setProxy(redirectOptions, configProxy, redirectOptions.href);
      };
    }
    var isHttpAdapterSupported = typeof process !== "undefined" && utils$1.kindOf(process) === "process";
    var wrapAsync = (asyncExecutor) => {
      return new Promise((resolve3, reject) => {
        let onDone;
        let isDone;
        const done = (value, isRejected) => {
          if (isDone) return;
          isDone = true;
          onDone && onDone(value, isRejected);
        };
        const _resolve = (value) => {
          done(value);
          resolve3(value);
        };
        const _reject = (reason) => {
          done(reason, true);
          reject(reason);
        };
        asyncExecutor(_resolve, _reject, (onDoneHandler) => onDone = onDoneHandler).catch(_reject);
      });
    };
    var resolveFamily = ({ address, family }) => {
      if (!utils$1.isString(address)) {
        throw TypeError("address must be a string");
      }
      return {
        address,
        family: family || (address.indexOf(".") < 0 ? 6 : 4)
      };
    };
    var buildAddressEntry = (address, family) => resolveFamily(utils$1.isObject(address) ? address : { address, family });
    var http2Transport = {
      request(options, cb) {
        const authority = options.protocol + "//" + options.hostname + ":" + (options.port || 80);
        const { http2Options, headers } = options;
        const session = http2Sessions.getSession(authority, http2Options);
        const {
          HTTP2_HEADER_SCHEME,
          HTTP2_HEADER_METHOD,
          HTTP2_HEADER_PATH,
          HTTP2_HEADER_STATUS
        } = http2__default["default"].constants;
        const http2Headers = {
          [HTTP2_HEADER_SCHEME]: options.protocol.replace(":", ""),
          [HTTP2_HEADER_METHOD]: options.method,
          [HTTP2_HEADER_PATH]: options.path
        };
        utils$1.forEach(headers, (header, name) => {
          name.charAt(0) !== ":" && (http2Headers[name] = header);
        });
        const req = session.request(http2Headers);
        req.once("response", (responseHeaders) => {
          const response = req;
          responseHeaders = Object.assign({}, responseHeaders);
          const status = responseHeaders[HTTP2_HEADER_STATUS];
          delete responseHeaders[HTTP2_HEADER_STATUS];
          response.headers = responseHeaders;
          response.statusCode = +status;
          cb(response);
        });
        return req;
      }
    };
    var httpAdapter = isHttpAdapterSupported && function httpAdapter2(config) {
      return wrapAsync(async function dispatchHttpRequest(resolve3, reject, onDone) {
        let { data, lookup, family, httpVersion = 1, http2Options } = config;
        const { responseType, responseEncoding } = config;
        const method = config.method.toUpperCase();
        let isDone;
        let rejected = false;
        let req;
        httpVersion = +httpVersion;
        if (Number.isNaN(httpVersion)) {
          throw TypeError(`Invalid protocol version: '${config.httpVersion}' is not a number`);
        }
        if (httpVersion !== 1 && httpVersion !== 2) {
          throw TypeError(`Unsupported protocol version '${httpVersion}'`);
        }
        const isHttp2 = httpVersion === 2;
        if (lookup) {
          const _lookup = callbackify$1(lookup, (value) => utils$1.isArray(value) ? value : [value]);
          lookup = (hostname, opt, cb) => {
            _lookup(hostname, opt, (err, arg0, arg1) => {
              if (err) {
                return cb(err);
              }
              const addresses = utils$1.isArray(arg0) ? arg0.map((addr) => buildAddressEntry(addr)) : [buildAddressEntry(arg0, arg1)];
              opt.all ? cb(err, addresses) : cb(err, addresses[0].address, addresses[0].family);
            });
          };
        }
        const abortEmitter = new events.EventEmitter();
        function abort(reason) {
          try {
            abortEmitter.emit("abort", !reason || reason.type ? new CanceledError(null, config, req) : reason);
          } catch (err) {
            console.warn("emit error", err);
          }
        }
        abortEmitter.once("abort", reject);
        const onFinished = () => {
          if (config.cancelToken) {
            config.cancelToken.unsubscribe(abort);
          }
          if (config.signal) {
            config.signal.removeEventListener("abort", abort);
          }
          abortEmitter.removeAllListeners();
        };
        if (config.cancelToken || config.signal) {
          config.cancelToken && config.cancelToken.subscribe(abort);
          if (config.signal) {
            config.signal.aborted ? abort() : config.signal.addEventListener("abort", abort);
          }
        }
        onDone((response, isRejected) => {
          isDone = true;
          if (isRejected) {
            rejected = true;
            onFinished();
            return;
          }
          const { data: data2 } = response;
          if (data2 instanceof stream__default["default"].Readable || data2 instanceof stream__default["default"].Duplex) {
            const offListeners = stream__default["default"].finished(data2, () => {
              offListeners();
              onFinished();
            });
          } else {
            onFinished();
          }
        });
        const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);
        const parsed = new URL(fullPath, platform.hasBrowserEnv ? platform.origin : void 0);
        const protocol = parsed.protocol || supportedProtocols[0];
        if (protocol === "data:") {
          if (config.maxContentLength > -1) {
            const dataUrl = String(config.url || fullPath || "");
            const estimated = estimateDataURLDecodedBytes(dataUrl);
            if (estimated > config.maxContentLength) {
              return reject(new AxiosError(
                "maxContentLength size of " + config.maxContentLength + " exceeded",
                AxiosError.ERR_BAD_RESPONSE,
                config
              ));
            }
          }
          let convertedData;
          if (method !== "GET") {
            return settle(resolve3, reject, {
              status: 405,
              statusText: "method not allowed",
              headers: {},
              config
            });
          }
          try {
            convertedData = fromDataURI(config.url, responseType === "blob", {
              Blob: config.env && config.env.Blob
            });
          } catch (err) {
            throw AxiosError.from(err, AxiosError.ERR_BAD_REQUEST, config);
          }
          if (responseType === "text") {
            convertedData = convertedData.toString(responseEncoding);
            if (!responseEncoding || responseEncoding === "utf8") {
              convertedData = utils$1.stripBOM(convertedData);
            }
          } else if (responseType === "stream") {
            convertedData = stream__default["default"].Readable.from(convertedData);
          }
          return settle(resolve3, reject, {
            data: convertedData,
            status: 200,
            statusText: "OK",
            headers: new AxiosHeaders$1(),
            config
          });
        }
        if (supportedProtocols.indexOf(protocol) === -1) {
          return reject(new AxiosError(
            "Unsupported protocol " + protocol,
            AxiosError.ERR_BAD_REQUEST,
            config
          ));
        }
        const headers = AxiosHeaders$1.from(config.headers).normalize();
        headers.set("User-Agent", "axios/" + VERSION, false);
        const { onUploadProgress, onDownloadProgress } = config;
        const maxRate = config.maxRate;
        let maxUploadRate = void 0;
        let maxDownloadRate = void 0;
        if (utils$1.isSpecCompliantForm(data)) {
          const userBoundary = headers.getContentType(/boundary=([-_\w\d]{10,70})/i);
          data = formDataToStream$1(data, (formHeaders) => {
            headers.set(formHeaders);
          }, {
            tag: `axios-${VERSION}-boundary`,
            boundary: userBoundary && userBoundary[1] || void 0
          });
        } else if (utils$1.isFormData(data) && utils$1.isFunction(data.getHeaders)) {
          headers.set(data.getHeaders());
          if (!headers.hasContentLength()) {
            try {
              const knownLength = await util__default["default"].promisify(data.getLength).call(data);
              Number.isFinite(knownLength) && knownLength >= 0 && headers.setContentLength(knownLength);
            } catch (e) {
            }
          }
        } else if (utils$1.isBlob(data) || utils$1.isFile(data)) {
          data.size && headers.setContentType(data.type || "application/octet-stream");
          headers.setContentLength(data.size || 0);
          data = stream__default["default"].Readable.from(readBlob$1(data));
        } else if (data && !utils$1.isStream(data)) {
          if (Buffer.isBuffer(data)) ;
          else if (utils$1.isArrayBuffer(data)) {
            data = Buffer.from(new Uint8Array(data));
          } else if (utils$1.isString(data)) {
            data = Buffer.from(data, "utf-8");
          } else {
            return reject(new AxiosError(
              "Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream",
              AxiosError.ERR_BAD_REQUEST,
              config
            ));
          }
          headers.setContentLength(data.length, false);
          if (config.maxBodyLength > -1 && data.length > config.maxBodyLength) {
            return reject(new AxiosError(
              "Request body larger than maxBodyLength limit",
              AxiosError.ERR_BAD_REQUEST,
              config
            ));
          }
        }
        const contentLength = utils$1.toFiniteNumber(headers.getContentLength());
        if (utils$1.isArray(maxRate)) {
          maxUploadRate = maxRate[0];
          maxDownloadRate = maxRate[1];
        } else {
          maxUploadRate = maxDownloadRate = maxRate;
        }
        if (data && (onUploadProgress || maxUploadRate)) {
          if (!utils$1.isStream(data)) {
            data = stream__default["default"].Readable.from(data, { objectMode: false });
          }
          data = stream__default["default"].pipeline([data, new AxiosTransformStream$1({
            maxRate: utils$1.toFiniteNumber(maxUploadRate)
          })], utils$1.noop);
          onUploadProgress && data.on("progress", flushOnFinish(
            data,
            progressEventDecorator(
              contentLength,
              progressEventReducer(asyncDecorator(onUploadProgress), false, 3)
            )
          ));
        }
        let auth = void 0;
        if (config.auth) {
          const username = config.auth.username || "";
          const password = config.auth.password || "";
          auth = username + ":" + password;
        }
        if (!auth && parsed.username) {
          const urlUsername = parsed.username;
          const urlPassword = parsed.password;
          auth = urlUsername + ":" + urlPassword;
        }
        auth && headers.delete("authorization");
        let path2;
        try {
          path2 = buildURL(
            parsed.pathname + parsed.search,
            config.params,
            config.paramsSerializer
          ).replace(/^\?/, "");
        } catch (err) {
          const customErr = new Error(err.message);
          customErr.config = config;
          customErr.url = config.url;
          customErr.exists = true;
          return reject(customErr);
        }
        headers.set(
          "Accept-Encoding",
          "gzip, compress, deflate" + (isBrotliSupported ? ", br" : ""),
          false
        );
        const options = {
          path: path2,
          method,
          headers: headers.toJSON(),
          agents: { http: config.httpAgent, https: config.httpsAgent },
          auth,
          protocol,
          family,
          beforeRedirect: dispatchBeforeRedirect,
          beforeRedirects: {},
          http2Options
        };
        !utils$1.isUndefined(lookup) && (options.lookup = lookup);
        if (config.socketPath) {
          options.socketPath = config.socketPath;
        } else {
          options.hostname = parsed.hostname.startsWith("[") ? parsed.hostname.slice(1, -1) : parsed.hostname;
          options.port = parsed.port;
          setProxy(options, config.proxy, protocol + "//" + parsed.hostname + (parsed.port ? ":" + parsed.port : "") + options.path);
        }
        let transport;
        const isHttpsRequest = isHttps.test(options.protocol);
        options.agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;
        if (isHttp2) {
          transport = http2Transport;
        } else {
          if (config.transport) {
            transport = config.transport;
          } else if (config.maxRedirects === 0) {
            transport = isHttpsRequest ? https__default["default"] : http__default["default"];
          } else {
            if (config.maxRedirects) {
              options.maxRedirects = config.maxRedirects;
            }
            if (config.beforeRedirect) {
              options.beforeRedirects.config = config.beforeRedirect;
            }
            transport = isHttpsRequest ? httpsFollow : httpFollow;
          }
        }
        if (config.maxBodyLength > -1) {
          options.maxBodyLength = config.maxBodyLength;
        } else {
          options.maxBodyLength = Infinity;
        }
        if (config.insecureHTTPParser) {
          options.insecureHTTPParser = config.insecureHTTPParser;
        }
        req = transport.request(options, function handleResponse(res) {
          if (req.destroyed) return;
          const streams = [res];
          const responseLength = utils$1.toFiniteNumber(res.headers["content-length"]);
          if (onDownloadProgress || maxDownloadRate) {
            const transformStream = new AxiosTransformStream$1({
              maxRate: utils$1.toFiniteNumber(maxDownloadRate)
            });
            onDownloadProgress && transformStream.on("progress", flushOnFinish(
              transformStream,
              progressEventDecorator(
                responseLength,
                progressEventReducer(asyncDecorator(onDownloadProgress), true, 3)
              )
            ));
            streams.push(transformStream);
          }
          let responseStream = res;
          const lastRequest = res.req || req;
          if (config.decompress !== false && res.headers["content-encoding"]) {
            if (method === "HEAD" || res.statusCode === 204) {
              delete res.headers["content-encoding"];
            }
            switch ((res.headers["content-encoding"] || "").toLowerCase()) {
              /*eslint default-case:0*/
              case "gzip":
              case "x-gzip":
              case "compress":
              case "x-compress":
                streams.push(zlib__default["default"].createUnzip(zlibOptions));
                delete res.headers["content-encoding"];
                break;
              case "deflate":
                streams.push(new ZlibHeaderTransformStream$1());
                streams.push(zlib__default["default"].createUnzip(zlibOptions));
                delete res.headers["content-encoding"];
                break;
              case "br":
                if (isBrotliSupported) {
                  streams.push(zlib__default["default"].createBrotliDecompress(brotliOptions));
                  delete res.headers["content-encoding"];
                }
            }
          }
          responseStream = streams.length > 1 ? stream__default["default"].pipeline(streams, utils$1.noop) : streams[0];
          const response = {
            status: res.statusCode,
            statusText: res.statusMessage,
            headers: new AxiosHeaders$1(res.headers),
            config,
            request: lastRequest
          };
          if (responseType === "stream") {
            response.data = responseStream;
            settle(resolve3, reject, response);
          } else {
            const responseBuffer = [];
            let totalResponseBytes = 0;
            responseStream.on("data", function handleStreamData(chunk) {
              responseBuffer.push(chunk);
              totalResponseBytes += chunk.length;
              if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {
                rejected = true;
                responseStream.destroy();
                abort(new AxiosError(
                  "maxContentLength size of " + config.maxContentLength + " exceeded",
                  AxiosError.ERR_BAD_RESPONSE,
                  config,
                  lastRequest
                ));
              }
            });
            responseStream.on("aborted", function handlerStreamAborted() {
              if (rejected) {
                return;
              }
              const err = new AxiosError(
                "stream has been aborted",
                AxiosError.ERR_BAD_RESPONSE,
                config,
                lastRequest
              );
              responseStream.destroy(err);
              reject(err);
            });
            responseStream.on("error", function handleStreamError(err) {
              if (req.destroyed) return;
              reject(AxiosError.from(err, null, config, lastRequest));
            });
            responseStream.on("end", function handleStreamEnd() {
              try {
                let responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);
                if (responseType !== "arraybuffer") {
                  responseData = responseData.toString(responseEncoding);
                  if (!responseEncoding || responseEncoding === "utf8") {
                    responseData = utils$1.stripBOM(responseData);
                  }
                }
                response.data = responseData;
              } catch (err) {
                return reject(AxiosError.from(err, null, config, response.request, response));
              }
              settle(resolve3, reject, response);
            });
          }
          abortEmitter.once("abort", (err) => {
            if (!responseStream.destroyed) {
              responseStream.emit("error", err);
              responseStream.destroy();
            }
          });
        });
        abortEmitter.once("abort", (err) => {
          if (req.close) {
            req.close();
          } else {
            req.destroy(err);
          }
        });
        req.on("error", function handleRequestError(err) {
          reject(AxiosError.from(err, null, config, req));
        });
        req.on("socket", function handleRequestSocket(socket) {
          socket.setKeepAlive(true, 1e3 * 60);
        });
        if (config.timeout) {
          const timeout = parseInt(config.timeout, 10);
          if (Number.isNaN(timeout)) {
            abort(new AxiosError(
              "error trying to parse `config.timeout` to int",
              AxiosError.ERR_BAD_OPTION_VALUE,
              config,
              req
            ));
            return;
          }
          req.setTimeout(timeout, function handleRequestTimeout() {
            if (isDone) return;
            let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
            const transitional = config.transitional || transitionalDefaults;
            if (config.timeoutErrorMessage) {
              timeoutErrorMessage = config.timeoutErrorMessage;
            }
            abort(new AxiosError(
              timeoutErrorMessage,
              transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
              config,
              req
            ));
          });
        } else {
          req.setTimeout(0);
        }
        if (utils$1.isStream(data)) {
          let ended = false;
          let errored = false;
          data.on("end", () => {
            ended = true;
          });
          data.once("error", (err) => {
            errored = true;
            req.destroy(err);
          });
          data.on("close", () => {
            if (!ended && !errored) {
              abort(new CanceledError("Request stream has been aborted", config, req));
            }
          });
          data.pipe(req);
        } else {
          data && req.write(data);
          req.end();
        }
      });
    };
    var isURLSameOrigin = platform.hasStandardBrowserEnv ? /* @__PURE__ */ ((origin2, isMSIE) => (url2) => {
      url2 = new URL(url2, platform.origin);
      return origin2.protocol === url2.protocol && origin2.host === url2.host && (isMSIE || origin2.port === url2.port);
    })(
      new URL(platform.origin),
      platform.navigator && /(msie|trident)/i.test(platform.navigator.userAgent)
    ) : () => true;
    var cookies = platform.hasStandardBrowserEnv ? (
      // Standard browser envs support document.cookie
      {
        write(name, value, expires, path2, domain, secure, sameSite) {
          if (typeof document === "undefined") return;
          const cookie = [`${name}=${encodeURIComponent(value)}`];
          if (utils$1.isNumber(expires)) {
            cookie.push(`expires=${new Date(expires).toUTCString()}`);
          }
          if (utils$1.isString(path2)) {
            cookie.push(`path=${path2}`);
          }
          if (utils$1.isString(domain)) {
            cookie.push(`domain=${domain}`);
          }
          if (secure === true) {
            cookie.push("secure");
          }
          if (utils$1.isString(sameSite)) {
            cookie.push(`SameSite=${sameSite}`);
          }
          document.cookie = cookie.join("; ");
        },
        read(name) {
          if (typeof document === "undefined") return null;
          const match = document.cookie.match(new RegExp("(?:^|; )" + name + "=([^;]*)"));
          return match ? decodeURIComponent(match[1]) : null;
        },
        remove(name) {
          this.write(name, "", Date.now() - 864e5, "/");
        }
      }
    ) : (
      // Non-standard browser env (web workers, react-native) lack needed support.
      {
        write() {
        },
        read() {
          return null;
        },
        remove() {
        }
      }
    );
    var headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? { ...thing } : thing;
    function mergeConfig(config1, config2) {
      config2 = config2 || {};
      const config = {};
      function getMergedValue(target, source, prop, caseless) {
        if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {
          return utils$1.merge.call({ caseless }, target, source);
        } else if (utils$1.isPlainObject(source)) {
          return utils$1.merge({}, source);
        } else if (utils$1.isArray(source)) {
          return source.slice();
        }
        return source;
      }
      function mergeDeepProperties(a, b, prop, caseless) {
        if (!utils$1.isUndefined(b)) {
          return getMergedValue(a, b, prop, caseless);
        } else if (!utils$1.isUndefined(a)) {
          return getMergedValue(void 0, a, prop, caseless);
        }
      }
      function valueFromConfig2(a, b) {
        if (!utils$1.isUndefined(b)) {
          return getMergedValue(void 0, b);
        }
      }
      function defaultToConfig2(a, b) {
        if (!utils$1.isUndefined(b)) {
          return getMergedValue(void 0, b);
        } else if (!utils$1.isUndefined(a)) {
          return getMergedValue(void 0, a);
        }
      }
      function mergeDirectKeys(a, b, prop) {
        if (prop in config2) {
          return getMergedValue(a, b);
        } else if (prop in config1) {
          return getMergedValue(void 0, a);
        }
      }
      const mergeMap = {
        url: valueFromConfig2,
        method: valueFromConfig2,
        data: valueFromConfig2,
        baseURL: defaultToConfig2,
        transformRequest: defaultToConfig2,
        transformResponse: defaultToConfig2,
        paramsSerializer: defaultToConfig2,
        timeout: defaultToConfig2,
        timeoutMessage: defaultToConfig2,
        withCredentials: defaultToConfig2,
        withXSRFToken: defaultToConfig2,
        adapter: defaultToConfig2,
        responseType: defaultToConfig2,
        xsrfCookieName: defaultToConfig2,
        xsrfHeaderName: defaultToConfig2,
        onUploadProgress: defaultToConfig2,
        onDownloadProgress: defaultToConfig2,
        decompress: defaultToConfig2,
        maxContentLength: defaultToConfig2,
        maxBodyLength: defaultToConfig2,
        beforeRedirect: defaultToConfig2,
        transport: defaultToConfig2,
        httpAgent: defaultToConfig2,
        httpsAgent: defaultToConfig2,
        cancelToken: defaultToConfig2,
        socketPath: defaultToConfig2,
        responseEncoding: defaultToConfig2,
        validateStatus: mergeDirectKeys,
        headers: (a, b, prop) => mergeDeepProperties(headersToObject(a), headersToObject(b), prop, true)
      };
      utils$1.forEach(Object.keys({ ...config1, ...config2 }), function computeConfigValue(prop) {
        const merge2 = mergeMap[prop] || mergeDeepProperties;
        const configValue = merge2(config1[prop], config2[prop], prop);
        utils$1.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
      });
      return config;
    }
    var resolveConfig = (config) => {
      const newConfig = mergeConfig({}, config);
      let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
      newConfig.headers = headers = AxiosHeaders$1.from(headers);
      newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config.params, config.paramsSerializer);
      if (auth) {
        headers.set(
          "Authorization",
          "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
        );
      }
      if (utils$1.isFormData(data)) {
        if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
          headers.setContentType(void 0);
        } else if (utils$1.isFunction(data.getHeaders)) {
          const formHeaders = data.getHeaders();
          const allowedHeaders = ["content-type", "content-length"];
          Object.entries(formHeaders).forEach(([key, val]) => {
            if (allowedHeaders.includes(key.toLowerCase())) {
              headers.set(key, val);
            }
          });
        }
      }
      if (platform.hasStandardBrowserEnv) {
        withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
        if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(newConfig.url)) {
          const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);
          if (xsrfValue) {
            headers.set(xsrfHeaderName, xsrfValue);
          }
        }
      }
      return newConfig;
    };
    var isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
    var xhrAdapter = isXHRAdapterSupported && function(config) {
      return new Promise(function dispatchXhrRequest(resolve3, reject) {
        const _config = resolveConfig(config);
        let requestData = _config.data;
        const requestHeaders = AxiosHeaders$1.from(_config.headers).normalize();
        let { responseType, onUploadProgress, onDownloadProgress } = _config;
        let onCanceled;
        let uploadThrottled, downloadThrottled;
        let flushUpload, flushDownload;
        function done() {
          flushUpload && flushUpload();
          flushDownload && flushDownload();
          _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
          _config.signal && _config.signal.removeEventListener("abort", onCanceled);
        }
        let request = new XMLHttpRequest();
        request.open(_config.method.toUpperCase(), _config.url, true);
        request.timeout = _config.timeout;
        function onloadend() {
          if (!request) {
            return;
          }
          const responseHeaders = AxiosHeaders$1.from(
            "getAllResponseHeaders" in request && request.getAllResponseHeaders()
          );
          const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
          const response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config,
            request
          };
          settle(function _resolve(value) {
            resolve3(value);
            done();
          }, function _reject(err) {
            reject(err);
            done();
          }, response);
          request = null;
        }
        if ("onloadend" in request) {
          request.onloadend = onloadend;
        } else {
          request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
              return;
            }
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
              return;
            }
            setTimeout(onloadend);
          };
        }
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }
          reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config, request));
          request = null;
        };
        request.onerror = function handleError(event) {
          const msg = event && event.message ? event.message : "Network Error";
          const err = new AxiosError(msg, AxiosError.ERR_NETWORK, config, request);
          err.event = event || null;
          reject(err);
          request = null;
        };
        request.ontimeout = function handleTimeout() {
          let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
          const transitional = _config.transitional || transitionalDefaults;
          if (_config.timeoutErrorMessage) {
            timeoutErrorMessage = _config.timeoutErrorMessage;
          }
          reject(new AxiosError(
            timeoutErrorMessage,
            transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
            config,
            request
          ));
          request = null;
        };
        requestData === void 0 && requestHeaders.setContentType(null);
        if ("setRequestHeader" in request) {
          utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
            request.setRequestHeader(key, val);
          });
        }
        if (!utils$1.isUndefined(_config.withCredentials)) {
          request.withCredentials = !!_config.withCredentials;
        }
        if (responseType && responseType !== "json") {
          request.responseType = _config.responseType;
        }
        if (onDownloadProgress) {
          [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
          request.addEventListener("progress", downloadThrottled);
        }
        if (onUploadProgress && request.upload) {
          [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
          request.upload.addEventListener("progress", uploadThrottled);
          request.upload.addEventListener("loadend", flushUpload);
        }
        if (_config.cancelToken || _config.signal) {
          onCanceled = (cancel) => {
            if (!request) {
              return;
            }
            reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);
            request.abort();
            request = null;
          };
          _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
          if (_config.signal) {
            _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
          }
        }
        const protocol = parseProtocol(_config.url);
        if (protocol && platform.protocols.indexOf(protocol) === -1) {
          reject(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config));
          return;
        }
        request.send(requestData || null);
      });
    };
    var composeSignals = (signals, timeout) => {
      const { length } = signals = signals ? signals.filter(Boolean) : [];
      if (timeout || length) {
        let controller = new AbortController();
        let aborted;
        const onabort = function(reason) {
          if (!aborted) {
            aborted = true;
            unsubscribe();
            const err = reason instanceof Error ? reason : this.reason;
            controller.abort(err instanceof AxiosError ? err : new CanceledError(err instanceof Error ? err.message : err));
          }
        };
        let timer = timeout && setTimeout(() => {
          timer = null;
          onabort(new AxiosError(`timeout ${timeout} of ms exceeded`, AxiosError.ETIMEDOUT));
        }, timeout);
        const unsubscribe = () => {
          if (signals) {
            timer && clearTimeout(timer);
            timer = null;
            signals.forEach((signal2) => {
              signal2.unsubscribe ? signal2.unsubscribe(onabort) : signal2.removeEventListener("abort", onabort);
            });
            signals = null;
          }
        };
        signals.forEach((signal2) => signal2.addEventListener("abort", onabort));
        const { signal } = controller;
        signal.unsubscribe = () => utils$1.asap(unsubscribe);
        return signal;
      }
    };
    var composeSignals$1 = composeSignals;
    var streamChunk = function* (chunk, chunkSize) {
      let len = chunk.byteLength;
      if (!chunkSize || len < chunkSize) {
        yield chunk;
        return;
      }
      let pos = 0;
      let end;
      while (pos < len) {
        end = pos + chunkSize;
        yield chunk.slice(pos, end);
        pos = end;
      }
    };
    var readBytes = async function* (iterable, chunkSize) {
      for await (const chunk of readStream(iterable)) {
        yield* streamChunk(chunk, chunkSize);
      }
    };
    var readStream = async function* (stream2) {
      if (stream2[Symbol.asyncIterator]) {
        yield* stream2;
        return;
      }
      const reader = stream2.getReader();
      try {
        for (; ; ) {
          const { done, value } = await reader.read();
          if (done) {
            break;
          }
          yield value;
        }
      } finally {
        await reader.cancel();
      }
    };
    var trackStream = (stream2, chunkSize, onProgress, onFinish) => {
      const iterator2 = readBytes(stream2, chunkSize);
      let bytes = 0;
      let done;
      let _onFinish = (e) => {
        if (!done) {
          done = true;
          onFinish && onFinish(e);
        }
      };
      return new ReadableStream({
        async pull(controller) {
          try {
            const { done: done2, value } = await iterator2.next();
            if (done2) {
              _onFinish();
              controller.close();
              return;
            }
            let len = value.byteLength;
            if (onProgress) {
              let loadedBytes = bytes += len;
              onProgress(loadedBytes);
            }
            controller.enqueue(new Uint8Array(value));
          } catch (err) {
            _onFinish(err);
            throw err;
          }
        },
        cancel(reason) {
          _onFinish(reason);
          return iterator2.return();
        }
      }, {
        highWaterMark: 2
      });
    };
    var DEFAULT_CHUNK_SIZE = 64 * 1024;
    var { isFunction } = utils$1;
    var globalFetchAPI = (({ Request, Response }) => ({
      Request,
      Response
    }))(utils$1.global);
    var {
      ReadableStream: ReadableStream$1,
      TextEncoder: TextEncoder$1
    } = utils$1.global;
    var test = (fn, ...args) => {
      try {
        return !!fn(...args);
      } catch (e) {
        return false;
      }
    };
    var factory = (env) => {
      env = utils$1.merge.call({
        skipUndefined: true
      }, globalFetchAPI, env);
      const { fetch: envFetch, Request, Response } = env;
      const isFetchSupported = envFetch ? isFunction(envFetch) : typeof fetch === "function";
      const isRequestSupported = isFunction(Request);
      const isResponseSupported = isFunction(Response);
      if (!isFetchSupported) {
        return false;
      }
      const isReadableStreamSupported = isFetchSupported && isFunction(ReadableStream$1);
      const encodeText = isFetchSupported && (typeof TextEncoder$1 === "function" ? /* @__PURE__ */ ((encoder) => (str) => encoder.encode(str))(new TextEncoder$1()) : async (str) => new Uint8Array(await new Request(str).arrayBuffer()));
      const supportsRequestStream = isRequestSupported && isReadableStreamSupported && test(() => {
        let duplexAccessed = false;
        const hasContentType = new Request(platform.origin, {
          body: new ReadableStream$1(),
          method: "POST",
          get duplex() {
            duplexAccessed = true;
            return "half";
          }
        }).headers.has("Content-Type");
        return duplexAccessed && !hasContentType;
      });
      const supportsResponseStream = isResponseSupported && isReadableStreamSupported && test(() => utils$1.isReadableStream(new Response("").body));
      const resolvers = {
        stream: supportsResponseStream && ((res) => res.body)
      };
      isFetchSupported && (() => {
        ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type) => {
          !resolvers[type] && (resolvers[type] = (res, config) => {
            let method = res && res[type];
            if (method) {
              return method.call(res);
            }
            throw new AxiosError(`Response type '${type}' is not supported`, AxiosError.ERR_NOT_SUPPORT, config);
          });
        });
      })();
      const getBodyLength = async (body) => {
        if (body == null) {
          return 0;
        }
        if (utils$1.isBlob(body)) {
          return body.size;
        }
        if (utils$1.isSpecCompliantForm(body)) {
          const _request = new Request(platform.origin, {
            method: "POST",
            body
          });
          return (await _request.arrayBuffer()).byteLength;
        }
        if (utils$1.isArrayBufferView(body) || utils$1.isArrayBuffer(body)) {
          return body.byteLength;
        }
        if (utils$1.isURLSearchParams(body)) {
          body = body + "";
        }
        if (utils$1.isString(body)) {
          return (await encodeText(body)).byteLength;
        }
      };
      const resolveBodyLength = async (headers, body) => {
        const length = utils$1.toFiniteNumber(headers.getContentLength());
        return length == null ? getBodyLength(body) : length;
      };
      return async (config) => {
        let {
          url: url2,
          method,
          data,
          signal,
          cancelToken,
          timeout,
          onDownloadProgress,
          onUploadProgress,
          responseType,
          headers,
          withCredentials = "same-origin",
          fetchOptions
        } = resolveConfig(config);
        let _fetch = envFetch || fetch;
        responseType = responseType ? (responseType + "").toLowerCase() : "text";
        let composedSignal = composeSignals$1([signal, cancelToken && cancelToken.toAbortSignal()], timeout);
        let request = null;
        const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
          composedSignal.unsubscribe();
        });
        let requestContentLength;
        try {
          if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
            let _request = new Request(url2, {
              method: "POST",
              body: data,
              duplex: "half"
            });
            let contentTypeHeader;
            if (utils$1.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
              headers.setContentType(contentTypeHeader);
            }
            if (_request.body) {
              const [onProgress, flush] = progressEventDecorator(
                requestContentLength,
                progressEventReducer(asyncDecorator(onUploadProgress))
              );
              data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
            }
          }
          if (!utils$1.isString(withCredentials)) {
            withCredentials = withCredentials ? "include" : "omit";
          }
          const isCredentialsSupported = isRequestSupported && "credentials" in Request.prototype;
          const resolvedOptions = {
            ...fetchOptions,
            signal: composedSignal,
            method: method.toUpperCase(),
            headers: headers.normalize().toJSON(),
            body: data,
            duplex: "half",
            credentials: isCredentialsSupported ? withCredentials : void 0
          };
          request = isRequestSupported && new Request(url2, resolvedOptions);
          let response = await (isRequestSupported ? _fetch(request, fetchOptions) : _fetch(url2, resolvedOptions));
          const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
          if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
            const options = {};
            ["status", "statusText", "headers"].forEach((prop) => {
              options[prop] = response[prop];
            });
            const responseContentLength = utils$1.toFiniteNumber(response.headers.get("content-length"));
            const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
              responseContentLength,
              progressEventReducer(asyncDecorator(onDownloadProgress), true)
            ) || [];
            response = new Response(
              trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
                flush && flush();
                unsubscribe && unsubscribe();
              }),
              options
            );
          }
          responseType = responseType || "text";
          let responseData = await resolvers[utils$1.findKey(resolvers, responseType) || "text"](response, config);
          !isStreamResponse && unsubscribe && unsubscribe();
          return await new Promise((resolve3, reject) => {
            settle(resolve3, reject, {
              data: responseData,
              headers: AxiosHeaders$1.from(response.headers),
              status: response.status,
              statusText: response.statusText,
              config,
              request
            });
          });
        } catch (err) {
          unsubscribe && unsubscribe();
          if (err && err.name === "TypeError" && /Load failed|fetch/i.test(err.message)) {
            throw Object.assign(
              new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request),
              {
                cause: err.cause || err
              }
            );
          }
          throw AxiosError.from(err, err && err.code, config, request);
        }
      };
    };
    var seedCache = /* @__PURE__ */ new Map();
    var getFetch = (config) => {
      let env = config && config.env || {};
      const { fetch: fetch2, Request, Response } = env;
      const seeds = [
        Request,
        Response,
        fetch2
      ];
      let len = seeds.length, i = len, seed, target, map = seedCache;
      while (i--) {
        seed = seeds[i];
        target = map.get(seed);
        target === void 0 && map.set(seed, target = i ? /* @__PURE__ */ new Map() : factory(env));
        map = target;
      }
      return target;
    };
    getFetch();
    var knownAdapters = {
      http: httpAdapter,
      xhr: xhrAdapter,
      fetch: {
        get: getFetch
      }
    };
    utils$1.forEach(knownAdapters, (fn, value) => {
      if (fn) {
        try {
          Object.defineProperty(fn, "name", { value });
        } catch (e) {
        }
        Object.defineProperty(fn, "adapterName", { value });
      }
    });
    var renderReason = (reason) => `- ${reason}`;
    var isResolvedHandle = (adapter) => utils$1.isFunction(adapter) || adapter === null || adapter === false;
    function getAdapter(adapters2, config) {
      adapters2 = utils$1.isArray(adapters2) ? adapters2 : [adapters2];
      const { length } = adapters2;
      let nameOrAdapter;
      let adapter;
      const rejectedReasons = {};
      for (let i = 0; i < length; i++) {
        nameOrAdapter = adapters2[i];
        let id;
        adapter = nameOrAdapter;
        if (!isResolvedHandle(nameOrAdapter)) {
          adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
          if (adapter === void 0) {
            throw new AxiosError(`Unknown adapter '${id}'`);
          }
        }
        if (adapter && (utils$1.isFunction(adapter) || (adapter = adapter.get(config)))) {
          break;
        }
        rejectedReasons[id || "#" + i] = adapter;
      }
      if (!adapter) {
        const reasons = Object.entries(rejectedReasons).map(
          ([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
        );
        let s = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
        throw new AxiosError(
          `There is no suitable adapter to dispatch the request ` + s,
          "ERR_NOT_SUPPORT"
        );
      }
      return adapter;
    }
    var adapters = {
      /**
       * Resolve an adapter from a list of adapter names or functions.
       * @type {Function}
       */
      getAdapter,
      /**
       * Exposes all known adapters
       * @type {Object<string, Function|Object>}
       */
      adapters: knownAdapters
    };
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }
      if (config.signal && config.signal.aborted) {
        throw new CanceledError(null, config);
      }
    }
    function dispatchRequest(config) {
      throwIfCancellationRequested(config);
      config.headers = AxiosHeaders$1.from(config.headers);
      config.data = transformData.call(
        config,
        config.transformRequest
      );
      if (["post", "put", "patch"].indexOf(config.method) !== -1) {
        config.headers.setContentType("application/x-www-form-urlencoded", false);
      }
      const adapter = adapters.getAdapter(config.adapter || defaults$1.adapter, config);
      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);
        response.data = transformData.call(
          config,
          config.transformResponse,
          response
        );
        response.headers = AxiosHeaders$1.from(response.headers);
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config);
          if (reason && reason.response) {
            reason.response.data = transformData.call(
              config,
              config.transformResponse,
              reason.response
            );
            reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
          }
        }
        return Promise.reject(reason);
      });
    }
    var validators$1 = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
      validators$1[type] = function validator2(thing) {
        return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
      };
    });
    var deprecatedWarnings = {};
    validators$1.transitional = function transitional(validator2, version, message) {
      function formatMessage(opt, desc) {
        return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
      }
      return (value, opt, opts) => {
        if (validator2 === false) {
          throw new AxiosError(
            formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
            AxiosError.ERR_DEPRECATED
          );
        }
        if (version && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          console.warn(
            formatMessage(
              opt,
              " has been deprecated since v" + version + " and will be removed in the near future"
            )
          );
        }
        return validator2 ? validator2(value, opt, opts) : true;
      };
    };
    validators$1.spelling = function spelling(correctSpelling) {
      return (value, opt) => {
        console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
        return true;
      };
    };
    function assertOptions(options, schema, allowUnknown) {
      if (typeof options !== "object") {
        throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
      }
      const keys = Object.keys(options);
      let i = keys.length;
      while (i-- > 0) {
        const opt = keys[i];
        const validator2 = schema[opt];
        if (validator2) {
          const value = options[opt];
          const result = value === void 0 || validator2(value, opt, options);
          if (result !== true) {
            throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
        }
      }
    }
    var validator = {
      assertOptions,
      validators: validators$1
    };
    var validators = validator.validators;
    var Axios = class {
      constructor(instanceConfig) {
        this.defaults = instanceConfig || {};
        this.interceptors = {
          request: new InterceptorManager$1(),
          response: new InterceptorManager$1()
        };
      }
      /**
       * Dispatch a request
       *
       * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
       * @param {?Object} config
       *
       * @returns {Promise} The Promise to be fulfilled
       */
      async request(configOrUrl, config) {
        try {
          return await this._request(configOrUrl, config);
        } catch (err) {
          if (err instanceof Error) {
            let dummy = {};
            Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = new Error();
            const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
            try {
              if (!err.stack) {
                err.stack = stack;
              } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
                err.stack += "\n" + stack;
              }
            } catch (e) {
            }
          }
          throw err;
        }
      }
      _request(configOrUrl, config) {
        if (typeof configOrUrl === "string") {
          config = config || {};
          config.url = configOrUrl;
        } else {
          config = configOrUrl || {};
        }
        config = mergeConfig(this.defaults, config);
        const { transitional, paramsSerializer, headers } = config;
        if (transitional !== void 0) {
          validator.assertOptions(transitional, {
            silentJSONParsing: validators.transitional(validators.boolean),
            forcedJSONParsing: validators.transitional(validators.boolean),
            clarifyTimeoutError: validators.transitional(validators.boolean)
          }, false);
        }
        if (paramsSerializer != null) {
          if (utils$1.isFunction(paramsSerializer)) {
            config.paramsSerializer = {
              serialize: paramsSerializer
            };
          } else {
            validator.assertOptions(paramsSerializer, {
              encode: validators.function,
              serialize: validators.function
            }, true);
          }
        }
        if (config.allowAbsoluteUrls !== void 0) ;
        else if (this.defaults.allowAbsoluteUrls !== void 0) {
          config.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
        } else {
          config.allowAbsoluteUrls = true;
        }
        validator.assertOptions(config, {
          baseUrl: validators.spelling("baseURL"),
          withXsrfToken: validators.spelling("withXSRFToken")
        }, true);
        config.method = (config.method || this.defaults.method || "get").toLowerCase();
        let contextHeaders = headers && utils$1.merge(
          headers.common,
          headers[config.method]
        );
        headers && utils$1.forEach(
          ["delete", "get", "head", "post", "put", "patch", "common"],
          (method) => {
            delete headers[method];
          }
        );
        config.headers = AxiosHeaders$1.concat(contextHeaders, headers);
        const requestInterceptorChain = [];
        let synchronousRequestInterceptors = true;
        this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
          if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
            return;
          }
          synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
          requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
        });
        const responseInterceptorChain = [];
        this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
          responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
        });
        let promise2;
        let i = 0;
        let len;
        if (!synchronousRequestInterceptors) {
          const chain = [dispatchRequest.bind(this), void 0];
          chain.unshift(...requestInterceptorChain);
          chain.push(...responseInterceptorChain);
          len = chain.length;
          promise2 = Promise.resolve(config);
          while (i < len) {
            promise2 = promise2.then(chain[i++], chain[i++]);
          }
          return promise2;
        }
        len = requestInterceptorChain.length;
        let newConfig = config;
        while (i < len) {
          const onFulfilled = requestInterceptorChain[i++];
          const onRejected = requestInterceptorChain[i++];
          try {
            newConfig = onFulfilled(newConfig);
          } catch (error) {
            onRejected.call(this, error);
            break;
          }
        }
        try {
          promise2 = dispatchRequest.call(this, newConfig);
        } catch (error) {
          return Promise.reject(error);
        }
        i = 0;
        len = responseInterceptorChain.length;
        while (i < len) {
          promise2 = promise2.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
        }
        return promise2;
      }
      getUri(config) {
        config = mergeConfig(this.defaults, config);
        const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);
        return buildURL(fullPath, config.params, config.paramsSerializer);
      }
    };
    utils$1.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
      Axios.prototype[method] = function(url2, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          url: url2,
          data: (config || {}).data
        }));
      };
    });
    utils$1.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      function generateHTTPMethod(isForm) {
        return function httpMethod(url2, data, config) {
          return this.request(mergeConfig(config || {}, {
            method,
            headers: isForm ? {
              "Content-Type": "multipart/form-data"
            } : {},
            url: url2,
            data
          }));
        };
      }
      Axios.prototype[method] = generateHTTPMethod();
      Axios.prototype[method + "Form"] = generateHTTPMethod(true);
    });
    var Axios$1 = Axios;
    var CancelToken = class _CancelToken {
      constructor(executor) {
        if (typeof executor !== "function") {
          throw new TypeError("executor must be a function.");
        }
        let resolvePromise;
        this.promise = new Promise(function promiseExecutor(resolve3) {
          resolvePromise = resolve3;
        });
        const token = this;
        this.promise.then((cancel) => {
          if (!token._listeners) return;
          let i = token._listeners.length;
          while (i-- > 0) {
            token._listeners[i](cancel);
          }
          token._listeners = null;
        });
        this.promise.then = (onfulfilled) => {
          let _resolve;
          const promise2 = new Promise((resolve3) => {
            token.subscribe(resolve3);
            _resolve = resolve3;
          }).then(onfulfilled);
          promise2.cancel = function reject() {
            token.unsubscribe(_resolve);
          };
          return promise2;
        };
        executor(function cancel(message, config, request) {
          if (token.reason) {
            return;
          }
          token.reason = new CanceledError(message, config, request);
          resolvePromise(token.reason);
        });
      }
      /**
       * Throws a `CanceledError` if cancellation has been requested.
       */
      throwIfRequested() {
        if (this.reason) {
          throw this.reason;
        }
      }
      /**
       * Subscribe to the cancel signal
       */
      subscribe(listener) {
        if (this.reason) {
          listener(this.reason);
          return;
        }
        if (this._listeners) {
          this._listeners.push(listener);
        } else {
          this._listeners = [listener];
        }
      }
      /**
       * Unsubscribe from the cancel signal
       */
      unsubscribe(listener) {
        if (!this._listeners) {
          return;
        }
        const index = this._listeners.indexOf(listener);
        if (index !== -1) {
          this._listeners.splice(index, 1);
        }
      }
      toAbortSignal() {
        const controller = new AbortController();
        const abort = (err) => {
          controller.abort(err);
        };
        this.subscribe(abort);
        controller.signal.unsubscribe = () => this.unsubscribe(abort);
        return controller.signal;
      }
      /**
       * Returns an object that contains a new `CancelToken` and a function that, when called,
       * cancels the `CancelToken`.
       */
      static source() {
        let cancel;
        const token = new _CancelToken(function executor(c) {
          cancel = c;
        });
        return {
          token,
          cancel
        };
      }
    };
    var CancelToken$1 = CancelToken;
    function spread(callback2) {
      return function wrap(arr) {
        return callback2.apply(null, arr);
      };
    }
    function isAxiosError(payload) {
      return utils$1.isObject(payload) && payload.isAxiosError === true;
    }
    var HttpStatusCode = {
      Continue: 100,
      SwitchingProtocols: 101,
      Processing: 102,
      EarlyHints: 103,
      Ok: 200,
      Created: 201,
      Accepted: 202,
      NonAuthoritativeInformation: 203,
      NoContent: 204,
      ResetContent: 205,
      PartialContent: 206,
      MultiStatus: 207,
      AlreadyReported: 208,
      ImUsed: 226,
      MultipleChoices: 300,
      MovedPermanently: 301,
      Found: 302,
      SeeOther: 303,
      NotModified: 304,
      UseProxy: 305,
      Unused: 306,
      TemporaryRedirect: 307,
      PermanentRedirect: 308,
      BadRequest: 400,
      Unauthorized: 401,
      PaymentRequired: 402,
      Forbidden: 403,
      NotFound: 404,
      MethodNotAllowed: 405,
      NotAcceptable: 406,
      ProxyAuthenticationRequired: 407,
      RequestTimeout: 408,
      Conflict: 409,
      Gone: 410,
      LengthRequired: 411,
      PreconditionFailed: 412,
      PayloadTooLarge: 413,
      UriTooLong: 414,
      UnsupportedMediaType: 415,
      RangeNotSatisfiable: 416,
      ExpectationFailed: 417,
      ImATeapot: 418,
      MisdirectedRequest: 421,
      UnprocessableEntity: 422,
      Locked: 423,
      FailedDependency: 424,
      TooEarly: 425,
      UpgradeRequired: 426,
      PreconditionRequired: 428,
      TooManyRequests: 429,
      RequestHeaderFieldsTooLarge: 431,
      UnavailableForLegalReasons: 451,
      InternalServerError: 500,
      NotImplemented: 501,
      BadGateway: 502,
      ServiceUnavailable: 503,
      GatewayTimeout: 504,
      HttpVersionNotSupported: 505,
      VariantAlsoNegotiates: 506,
      InsufficientStorage: 507,
      LoopDetected: 508,
      NotExtended: 510,
      NetworkAuthenticationRequired: 511,
      WebServerIsDown: 521,
      ConnectionTimedOut: 522,
      OriginIsUnreachable: 523,
      TimeoutOccurred: 524,
      SslHandshakeFailed: 525,
      InvalidSslCertificate: 526
    };
    Object.entries(HttpStatusCode).forEach(([key, value]) => {
      HttpStatusCode[value] = key;
    });
    var HttpStatusCode$1 = HttpStatusCode;
    function createInstance(defaultConfig) {
      const context = new Axios$1(defaultConfig);
      const instance = bind(Axios$1.prototype.request, context);
      utils$1.extend(instance, Axios$1.prototype, context, { allOwnKeys: true });
      utils$1.extend(instance, context, null, { allOwnKeys: true });
      instance.create = function create(instanceConfig) {
        return createInstance(mergeConfig(defaultConfig, instanceConfig));
      };
      return instance;
    }
    var axios = createInstance(defaults$1);
    axios.Axios = Axios$1;
    axios.CanceledError = CanceledError;
    axios.CancelToken = CancelToken$1;
    axios.isCancel = isCancel;
    axios.VERSION = VERSION;
    axios.toFormData = toFormData;
    axios.AxiosError = AxiosError;
    axios.Cancel = axios.CanceledError;
    axios.all = function all(promises) {
      return Promise.all(promises);
    };
    axios.spread = spread;
    axios.isAxiosError = isAxiosError;
    axios.mergeConfig = mergeConfig;
    axios.AxiosHeaders = AxiosHeaders$1;
    axios.formToJSON = (thing) => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);
    axios.getAdapter = adapters.getAdapter;
    axios.HttpStatusCode = HttpStatusCode$1;
    axios.default = axios;
    module2.exports = axios;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-management/tunnelPlanTokenProperties.js
var require_tunnelPlanTokenProperties = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-management/tunnelPlanTokenProperties.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TunnelPlanTokenProperties = void 0;
    var TunnelPlanTokenProperties = class _TunnelPlanTokenProperties {
      constructor(clusterId, issuer, expiration, userEmail, tunnelPlanId, subscriptionId, scopes) {
        this.clusterId = clusterId;
        this.issuer = issuer;
        this.expiration = expiration;
        this.userEmail = userEmail;
        this.tunnelPlanId = tunnelPlanId;
        this.subscriptionId = subscriptionId;
        this.scopes = scopes;
      }
      /**
       * Checks if the tunnel access token expiration claim is in the past.
       * Note: uses client's system time for the validation.
       * (Does not throw if the token is an invalid format.)
       */
      static validateTokenExpiration(token) {
        const t = _TunnelPlanTokenProperties.tryParse(token);
        if (t === null || t === void 0 ? void 0 : t.expiration) {
          if (t.expiration < /* @__PURE__ */ new Date()) {
            throw new Error("The access token is expired: " + t);
          }
        }
      }
      /**
       * Attempts to parse a tunnel access token (JWT). This does NOT validate the token
       * signature or any claims.
       */
      static tryParse(token) {
        if (typeof token !== "string")
          throw new TypeError("Token string expected.");
        const tokenParts = token.split(".");
        if (tokenParts.length !== 3) {
          return null;
        }
        const tokenBodyJson = _TunnelPlanTokenProperties.base64UrlDecode(tokenParts[1]);
        if (!tokenBodyJson) {
          return null;
        }
        try {
          const tokenJson = JSON.parse(tokenBodyJson);
          const clusterId = tokenJson.clusterId;
          const subscriptionId = tokenJson.subscriptionId;
          const tunnelPlanId = tokenJson.tunnelPlanId;
          const userEmail = tokenJson.userEmail;
          const scp = tokenJson.scp;
          const iss = tokenJson.iss;
          const exp = tokenJson.exp;
          return new _TunnelPlanTokenProperties(clusterId, iss, typeof exp === "number" ? new Date(exp * 1e3) : void 0, userEmail, tunnelPlanId, subscriptionId, scp === null || scp === void 0 ? void 0 : scp.split(" "));
        } catch (_a) {
          return null;
        }
      }
      /**
       * Gets the tunnal access token trace string.
       * 'none' if null or undefined, parsed token info if can be parsed, or 'token' if cannot be parsed.
       */
      static getTokenTrace(token) {
        var _a, _b;
        return !token ? "none" : (_b = (_a = _TunnelPlanTokenProperties.tryParse(token)) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : "token";
      }
      static base64UrlDecode(encodedString) {
        encodedString = encodedString.replace("-", "+");
        while (encodedString.length % 4 !== 0) {
          encodedString += "=";
        }
        try {
          const result = atob(encodedString);
          return result;
        } catch (_a) {
          return null;
        }
      }
    };
    exports2.TunnelPlanTokenProperties = TunnelPlanTokenProperties;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-management/idGeneration.js
var require_idGeneration = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-management/idGeneration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IdGeneration = void 0;
    var dev_tunnels_contracts_1 = require_dev_tunnels_contracts();
    var IdGeneration = class {
      static generateTunnelId() {
        let tunnelId = "";
        tunnelId += this.adjectives[Math.floor(Math.random() * this.adjectives.length)] + "-";
        tunnelId += this.nouns[Math.floor(Math.random() * this.nouns.length)] + "-";
        for (let i = 0; i < 7; i++) {
          tunnelId += dev_tunnels_contracts_1.TunnelConstraints.oldTunnelIdChars[Math.floor(Math.random() * dev_tunnels_contracts_1.TunnelConstraints.oldTunnelIdChars.length)];
        }
        return tunnelId;
      }
    };
    exports2.IdGeneration = IdGeneration;
    IdGeneration.nouns = ["pond", "hill", "mountain", "field", "fog", "ant", "dog", "cat", "shoe", "plane", "chair", "book", "ocean", "lake", "river", "horse"];
    IdGeneration.adjectives = ["fun", "happy", "interesting", "neat", "peaceful", "puzzled", "kind", "joyful", "new", "giant", "sneaky", "quick", "majestic", "jolly", "fancy", "tidy", "swift", "silent", "amusing", "spiffy"];
  }
});

// ../../node_modules/@microsoft/dev-tunnels-management/tunnelManagementHttpClient.js
var require_tunnelManagementHttpClient = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-management/tunnelManagementHttpClient.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TunnelManagementHttpClient = exports2.ManagementApiVersions = void 0;
    var vscode_jsonrpc_1 = require_main();
    var dev_tunnels_ssh_1 = require_dev_tunnels_ssh();
    var dev_tunnels_contracts_1 = require_dev_tunnels_contracts();
    var tunnelManagementClient_1 = require_tunnelManagementClient();
    var tunnelAccessTokenProperties_1 = require_tunnelAccessTokenProperties();
    var version_1 = require_version();
    var axios_1 = require_axios();
    var tunnelPlanTokenProperties_1 = require_tunnelPlanTokenProperties();
    var idGeneration_1 = require_idGeneration();
    var tunnelsApiPath = "/tunnels";
    var limitsApiPath = "/userlimits";
    var endpointsApiSubPath = "/endpoints";
    var portsApiSubPath = "/ports";
    var eventsApiSubPath = "/events";
    var clustersApiPath = "/clusters";
    var tunnelAuthentication = "Authorization";
    var checkAvailablePath = ":checkNameAvailability";
    var createNameRetries = 3;
    var ManagementApiVersions3;
    (function(ManagementApiVersions4) {
      ManagementApiVersions4["Version20230927preview"] = "2023-09-27-preview";
    })(ManagementApiVersions3 = exports2.ManagementApiVersions || (exports2.ManagementApiVersions = {}));
    function comparePorts(a, b) {
      var _a, _b;
      return ((_a = a.portNumber) !== null && _a !== void 0 ? _a : Number.MAX_SAFE_INTEGER) - ((_b = b.portNumber) !== null && _b !== void 0 ? _b : Number.MAX_SAFE_INTEGER);
    }
    function parseDate(value) {
      return typeof value === "string" ? new Date(Date.parse(value)) : value;
    }
    function parseTunnelDates(tunnel) {
      if (!tunnel)
        return;
      tunnel.created = parseDate(tunnel.created);
      if (tunnel.status) {
        tunnel.status.lastHostConnectionTime = parseDate(tunnel.status.lastHostConnectionTime);
        tunnel.status.lastClientConnectionTime = parseDate(tunnel.status.lastClientConnectionTime);
      }
    }
    function parseTunnelPortDates(port) {
      if (!port)
        return;
      if (port.status) {
        port.status.lastClientConnectionTime = parseDate(port.status.lastClientConnectionTime);
      }
    }
    function preserveAccessTokens(requestObject, resultObject) {
      var _a;
      if (requestObject.accessTokens && resultObject) {
        (_a = resultObject.accessTokens) !== null && _a !== void 0 ? _a : resultObject.accessTokens = {};
        for (const scopeAndToken of Object.entries(requestObject.accessTokens)) {
          if (!resultObject.accessTokens[scopeAndToken[0]]) {
            resultObject.accessTokens[scopeAndToken[0]] = scopeAndToken[1];
          }
        }
      }
    }
    var manageAccessTokenScope = [dev_tunnels_contracts_1.TunnelAccessScopes.Manage];
    var hostAccessTokenScope = [dev_tunnels_contracts_1.TunnelAccessScopes.Host];
    var managePortsAccessTokenScopes = [
      dev_tunnels_contracts_1.TunnelAccessScopes.Manage,
      dev_tunnels_contracts_1.TunnelAccessScopes.ManagePorts,
      dev_tunnels_contracts_1.TunnelAccessScopes.Host
    ];
    var readAccessTokenScopes = [
      dev_tunnels_contracts_1.TunnelAccessScopes.Manage,
      dev_tunnels_contracts_1.TunnelAccessScopes.ManagePorts,
      dev_tunnels_contracts_1.TunnelAccessScopes.Host,
      dev_tunnels_contracts_1.TunnelAccessScopes.Connect
    ];
    var apiVersions = ["2023-09-27-preview"];
    var defaultRequestTimeoutMS = 2e4;
    var TunnelManagementHttpClient3 = class _TunnelManagementHttpClient {
      /**
       * Initializes a new instance of the `TunnelManagementHttpClient` class
       * with a client authentication callback, service URI, and HTTP handler.
       *
       * @param userAgent { name, version } object or a comment string to use as the User-Agent header.
       * @param apiVersion ApiVersion to be used for requests, value should be one of ManagementApiVersions enum.
       * @param userTokenCallback Optional async callback for retrieving a client authentication
       * header value with access token, for AAD or GitHub user authentication. This may be omitted
       * for anonymous tunnel clients, or if tunnel access tokens will be specified via
       * `TunnelRequestOptions.accessToken`.
       * @param tunnelServiceUri Optional tunnel service URI (not including any path). Defaults to
       * the global tunnel service URI.
       * @param httpsAgent Optional agent that will be invoked for HTTPS requests to the tunnel
       * service.
       * @param adapter Optional axios adapter to use for HTTP requests.
       */
      constructor(userAgents, apiVersion, userTokenCallback, tunnelServiceUri, httpsAgent, adapter) {
        var _a;
        this.httpsAgent = httpsAgent;
        this.adapter = adapter;
        this.reportProgressEmitter = new vscode_jsonrpc_1.Emitter();
        this.onReportProgress = this.reportProgressEmitter.event;
        this.trace = (msg) => {
        };
        this.enableEventsReporting = false;
        this.eventsQueue = [];
        this.eventsPromise = null;
        this.isDisposed = false;
        this.eventsAvailableCompletion = new dev_tunnels_ssh_1.PromiseCompletionSource();
        if (apiVersions.indexOf(apiVersion) === -1) {
          throw new TypeError(`Invalid API version: ${apiVersion}, must be one of ${apiVersions}`);
        }
        this.apiVersion = apiVersion;
        if (!userAgents) {
          throw new TypeError("User agent must be provided.");
        }
        if (Array.isArray(userAgents)) {
          if (userAgents.length === 0) {
            throw new TypeError("User agents cannot be empty.");
          }
          let combinedUserAgents = "";
          userAgents.forEach((userAgent) => {
            var _a2;
            if (typeof userAgent !== "string") {
              if (!userAgent.name) {
                throw new TypeError("Invalid user agent. The name must be provided.");
              }
              if (typeof userAgent.name !== "string") {
                throw new TypeError("Invalid user agent. The name must be a string.");
              }
              if (userAgent.version && typeof userAgent.version !== "string") {
                throw new TypeError("Invalid user agent. The version must be a string.");
              }
              combinedUserAgents = `${combinedUserAgents}${userAgent.name}/${(_a2 = userAgent.version) !== null && _a2 !== void 0 ? _a2 : "unknown"} `;
            } else {
              combinedUserAgents = `${combinedUserAgents}${userAgent} `;
            }
          });
          this.userAgents = combinedUserAgents.trim();
        } else if (typeof userAgents !== "string") {
          if (!userAgents.name) {
            throw new TypeError("Invalid user agent. The name must be provided.");
          }
          if (typeof userAgents.name !== "string") {
            throw new TypeError("Invalid user agent. The name must be a string.");
          }
          if (userAgents.version && typeof userAgents.version !== "string") {
            throw new TypeError("Invalid user agent. The version must be a string.");
          }
          this.userAgents = `${userAgents.name}/${(_a = userAgents.version) !== null && _a !== void 0 ? _a : "unknown"}`;
        } else {
          this.userAgents = userAgents;
        }
        this.userTokenCallback = userTokenCallback !== null && userTokenCallback !== void 0 ? userTokenCallback : (() => Promise.resolve(null));
        if (!tunnelServiceUri) {
          tunnelServiceUri = dev_tunnels_contracts_1.TunnelServiceProperties.production.serviceUri;
        }
        const parsedUri = new URL(tunnelServiceUri);
        if (!parsedUri || parsedUri.pathname !== "/") {
          throw new TypeError(`Invalid tunnel service URI: ${tunnelServiceUri}`);
        }
        this.baseAddress = tunnelServiceUri;
      }
      async listTunnels(clusterId, domain, options, cancellation) {
        const queryParams = [clusterId ? null : "global=true", domain ? `domain=${domain}` : null];
        const query = queryParams.filter((p) => !!p).join("&");
        const results = await this.sendRequest("GET", clusterId, tunnelsApiPath, query, options, void 0, void 0, cancellation);
        let tunnels = new Array();
        if (results.value) {
          for (const region of results.value) {
            if (region.value) {
              tunnels = tunnels.concat(region.value);
            }
          }
        }
        tunnels.forEach(parseTunnelDates);
        return tunnels;
      }
      async getTunnel(tunnel, options, cancellation) {
        const result = await this.sendTunnelRequest("GET", tunnel, readAccessTokenScopes, void 0, void 0, options, void 0, void 0, cancellation);
        preserveAccessTokens(tunnel, result);
        parseTunnelDates(result);
        return result;
      }
      async createTunnel(tunnel, options, cancellation) {
        const tunnelId = tunnel.tunnelId;
        const idGenerated = tunnelId === void 0 || tunnelId === null || tunnelId === "";
        options = options || {};
        options.additionalHeaders = options.additionalHeaders || {};
        options.additionalHeaders["If-Not-Match"] = "*";
        if (idGenerated) {
          tunnel.tunnelId = idGeneration_1.IdGeneration.generateTunnelId();
        }
        for (let i = 0; i <= createNameRetries; i++) {
          try {
            const result = await this.sendTunnelRequest("PUT", tunnel, manageAccessTokenScope, void 0, void 0, options, this.convertTunnelForRequest(tunnel), void 0, cancellation, true);
            preserveAccessTokens(tunnel, result);
            parseTunnelDates(result);
            return result;
          } catch (error) {
            if (idGenerated) {
              tunnel.tunnelId = idGeneration_1.IdGeneration.generateTunnelId();
            } else {
              throw error;
            }
          }
        }
        const result2 = await this.sendTunnelRequest("PUT", tunnel, manageAccessTokenScope, void 0, void 0, options, this.convertTunnelForRequest(tunnel), void 0, cancellation, true);
        preserveAccessTokens(tunnel, result2);
        parseTunnelDates(result2);
        return result2;
      }
      async createOrUpdateTunnel(tunnel, options, cancellation) {
        const tunnelId = tunnel.tunnelId;
        const idGenerated = tunnelId === void 0 || tunnelId === null || tunnelId === "";
        if (idGenerated) {
          tunnel.tunnelId = idGeneration_1.IdGeneration.generateTunnelId();
        }
        for (let i = 0; i <= createNameRetries; i++) {
          try {
            const result = await this.sendTunnelRequest("PUT", tunnel, manageAccessTokenScope, void 0, void 0, options, this.convertTunnelForRequest(tunnel), void 0, cancellation, true);
            preserveAccessTokens(tunnel, result);
            parseTunnelDates(result);
            return result;
          } catch (error) {
            if (idGenerated) {
              tunnel.tunnelId = idGeneration_1.IdGeneration.generateTunnelId();
            } else {
              throw error;
            }
          }
        }
        const result2 = await this.sendTunnelRequest("PUT", tunnel, manageAccessTokenScope, void 0, "forceCreate=true", options, this.convertTunnelForRequest(tunnel), void 0, cancellation, true);
        preserveAccessTokens(tunnel, result2);
        parseTunnelDates(result2);
        return result2;
      }
      async updateTunnel(tunnel, options, cancellation) {
        options = options || {};
        options.additionalHeaders = options.additionalHeaders || {};
        options.additionalHeaders["If-Match"] = "*";
        const result = await this.sendTunnelRequest("PUT", tunnel, manageAccessTokenScope, void 0, void 0, options, this.convertTunnelForRequest(tunnel), void 0, cancellation);
        preserveAccessTokens(tunnel, result);
        parseTunnelDates(result);
        return result;
      }
      async deleteTunnel(tunnel, options, cancellation) {
        return await this.sendTunnelRequest("DELETE", tunnel, manageAccessTokenScope, void 0, void 0, options, void 0, true, cancellation);
      }
      async updateTunnelEndpoint(tunnel, endpoint, options, cancellation) {
        if (endpoint.id == null) {
          throw new Error("Endpoint ID must be specified when updating an endpoint.");
        }
        const path2 = `${endpointsApiSubPath}/${endpoint.id}`;
        const result = await this.sendTunnelRequest("PUT", tunnel, hostAccessTokenScope, path2, "connectionMode=" + endpoint.connectionMode, options, endpoint, void 0, cancellation);
        if (tunnel.endpoints) {
          tunnel.endpoints = tunnel.endpoints.filter((e) => e.hostId !== endpoint.hostId || e.connectionMode !== endpoint.connectionMode).concat(result);
        }
        return result;
      }
      async deleteTunnelEndpoints(tunnel, id, options, cancellation) {
        const path2 = `${endpointsApiSubPath}/${id}`;
        const result = await this.sendTunnelRequest("DELETE", tunnel, hostAccessTokenScope, path2, void 0, options, void 0, true, cancellation);
        if (result && tunnel.endpoints) {
          tunnel.endpoints = tunnel.endpoints.filter((e) => e.id !== id);
        }
        return result;
      }
      async listUserLimits(cancellation) {
        const results = await this.sendRequest("GET", void 0, limitsApiPath, void 0, void 0, void 0, void 0, cancellation);
        return results || [];
      }
      async listTunnelPorts(tunnel, options, cancellation) {
        const results = await this.sendTunnelRequest("GET", tunnel, readAccessTokenScopes, portsApiSubPath, void 0, options, void 0, void 0, cancellation);
        if (results.value) {
          results.value.forEach(parseTunnelPortDates);
        }
        return results.value;
      }
      async getTunnelPort(tunnel, portNumber, options, cancellation) {
        this.raiseReportProgress(dev_tunnels_contracts_1.TunnelProgress.StartingGetTunnelPort);
        const path2 = `${portsApiSubPath}/${portNumber}`;
        const result = await this.sendTunnelRequest("GET", tunnel, readAccessTokenScopes, path2, void 0, options, void 0, void 0, cancellation);
        parseTunnelPortDates(result);
        this.raiseReportProgress(dev_tunnels_contracts_1.TunnelProgress.CompletedGetTunnelPort);
        return result;
      }
      async createTunnelPort(tunnel, tunnelPort, options, cancellation) {
        this.raiseReportProgress(dev_tunnels_contracts_1.TunnelProgress.StartingCreateTunnelPort);
        tunnelPort = this.convertTunnelPortForRequest(tunnel, tunnelPort);
        const path2 = `${portsApiSubPath}/${tunnelPort.portNumber}`;
        options = options || {};
        options.additionalHeaders = options.additionalHeaders || {};
        options.additionalHeaders["If-Not-Match"] = "*";
        const result = await this.sendTunnelRequest("PUT", tunnel, managePortsAccessTokenScopes, path2, void 0, options, tunnelPort, void 0, cancellation);
        tunnel.ports = tunnel.ports || [];
        tunnel.ports = tunnel.ports.filter((p) => p.portNumber !== tunnelPort.portNumber).concat(result).sort(comparePorts);
        parseTunnelPortDates(result);
        this.raiseReportProgress(dev_tunnels_contracts_1.TunnelProgress.CompletedCreateTunnelPort);
        return result;
      }
      async updateTunnelPort(tunnel, tunnelPort, options, cancellation) {
        if (tunnelPort.clusterId && tunnel.clusterId && tunnelPort.clusterId !== tunnel.clusterId) {
          throw new Error("Tunnel port cluster ID is not consistent.");
        }
        options = options || {};
        options.additionalHeaders = options.additionalHeaders || {};
        options.additionalHeaders["If-Match"] = "*";
        const portNumber = tunnelPort.portNumber;
        const path2 = `${portsApiSubPath}/${portNumber}`;
        tunnelPort = this.convertTunnelPortForRequest(tunnel, tunnelPort);
        const result = await this.sendTunnelRequest("PUT", tunnel, managePortsAccessTokenScopes, path2, void 0, options, tunnelPort, void 0, cancellation);
        preserveAccessTokens(tunnelPort, result);
        parseTunnelPortDates(result);
        tunnel.ports = tunnel.ports || [];
        tunnel.ports = tunnel.ports.filter((p) => p.portNumber !== tunnelPort.portNumber).concat(result).sort(comparePorts);
        return result;
      }
      async createOrUpdateTunnelPort(tunnel, tunnelPort, options, cancellation) {
        tunnelPort = this.convertTunnelPortForRequest(tunnel, tunnelPort);
        const path2 = `${portsApiSubPath}/${tunnelPort.portNumber}`;
        const result = await this.sendTunnelRequest("PUT", tunnel, managePortsAccessTokenScopes, path2, void 0, options, tunnelPort, void 0, cancellation);
        tunnel.ports = tunnel.ports || [];
        tunnel.ports = tunnel.ports.filter((p) => p.portNumber !== tunnelPort.portNumber).concat(result).sort(comparePorts);
        parseTunnelPortDates(result);
        return result;
      }
      async deleteTunnelPort(tunnel, portNumber, options, cancellation) {
        const path2 = `${portsApiSubPath}/${portNumber}`;
        const result = await this.sendTunnelRequest("DELETE", tunnel, managePortsAccessTokenScopes, path2, void 0, options, void 0, true, cancellation);
        if (result && tunnel.ports) {
          tunnel.ports = tunnel.ports.filter((p) => p.portNumber !== portNumber).sort(comparePorts);
        }
        return result;
      }
      async listClusters(cancellation) {
        return await this.sendRequest("GET", void 0, clustersApiPath, void 0, void 0, void 0, false, cancellation);
      }
      /**
       * Sends an HTTP request to the tunnel management API, targeting a specific tunnel.
       * This protected method enables subclasses to support additional tunnel management APIs.
       * @param method HTTP request method.
       * @param tunnel Tunnel that the request is targeting.
       * @param accessTokenScopes Required array of access scopes for tokens in `tunnel.accessTokens`
       * that could be used to authorize the request.
       * @param path Optional request sub-path relative to the tunnel.
       * @param query Optional query string to append to the request.
       * @param options Request options.
       * @param body Optional request body object.
       * @param allowNotFound If true, a 404 response is returned as a null or false result
       * instead of an error.
       * @param cancellationToken Optional cancellation token for the request.
       * @param isCreate Set to true if this is a tunnel create request, default is false.
       * @returns Result of the request.
       */
      async sendTunnelRequest(method, tunnel, accessTokenScopes, path2, query, options, body, allowNotFound, cancellation, isCreate = false) {
        this.raiseReportProgress(dev_tunnels_contracts_1.TunnelProgress.StartingRequestUri);
        const uri = await this.buildUriForTunnel(tunnel, path2, query, options, isCreate);
        this.raiseReportProgress(dev_tunnels_contracts_1.TunnelProgress.StartingRequestConfig);
        const config = await this.getAxiosRequestConfig(tunnel, options, accessTokenScopes);
        this.raiseReportProgress(dev_tunnels_contracts_1.TunnelProgress.StartingSendTunnelRequest);
        try {
          const result = await this.request(method, uri, body, config, allowNotFound, cancellation);
          this.raiseReportProgress(dev_tunnels_contracts_1.TunnelProgress.CompletedSendTunnelRequest);
          return result;
        } catch (error) {
          if (/certificate/i.test(error.message)) {
            const originalErrorMessage = error.message;
            throw new Error("Tunnel service HTTPS certificate is invalid. This may be caused by the use of a self-signed certificate or a firewall intercepting the connection. " + originalErrorMessage + ". ");
          }
          throw error;
        }
      }
      /**
       * Sends an HTTP request to the tunnel management API.
       * This protected method enables subclasses to support additional tunnel management APIs.
       * @param method HTTP request method.
       * @param clusterId Optional tunnel service cluster ID to direct the request to. If unspecified,
       * the request will use the global traffic-manager to find the nearest cluster.
       * @param path Required request path.
       * @param query Optional query string to append to the request.
       * @param options Request options.
       * @param body Optional request body object.
       * @param allowNotFound If true, a 404 response is returned as a null or false result
       * instead of an error.
       * @param cancellationToken Optional cancellation token for the request.
       * @returns Result of the request.
       */
      async sendRequest(method, clusterId, path2, query, options, body, allowNotFound, cancellation) {
        this.raiseReportProgress(dev_tunnels_contracts_1.TunnelProgress.StartingSendTunnelRequest);
        const uri = await this.buildUri(clusterId, path2, query, options);
        const config = await this.getAxiosRequestConfig(void 0, options);
        try {
          const result = await this.request(method, uri, body, config, allowNotFound, cancellation);
          this.raiseReportProgress(dev_tunnels_contracts_1.TunnelProgress.CompletedSendTunnelRequest);
          return result;
        } catch (error) {
          if (/certificate/i.test(error.message)) {
            throw new Error("Tunnel service HTTPS certificate is invalid. This may be caused by the use of a self signed certificate or a firewall intercepting the connection.");
          }
          throw error;
        }
      }
      async checkNameAvailablility(tunnelName, cancellation) {
        tunnelName = encodeURI(tunnelName);
        const uri = await this.buildUri(void 0, `${tunnelsApiPath}/${tunnelName}${checkAvailablePath}`);
        const config = {
          httpsAgent: this.httpsAgent,
          adapter: this.adapter
        };
        return await this.request("GET", uri, void 0, config, void 0, cancellation);
      }
      reportEvent(tunnel, tunnelEvent, options) {
        var _a;
        if (!tunnel) {
          throw new TypeError("A tunnel is required.");
        }
        if (!tunnelEvent) {
          throw new TypeError("A tunnelEvent is required.");
        }
        if (!this.apiVersion) {
          return;
        }
        if (!this.enableEventsReporting) {
          return;
        }
        if (this.isDisposed) {
          return;
        }
        (_a = tunnelEvent.timestamp) !== null && _a !== void 0 ? _a : tunnelEvent.timestamp = /* @__PURE__ */ new Date();
        const wasEmpty = this.eventsQueue.length === 0;
        this.eventsQueue.push({
          tunnel,
          event: tunnelEvent,
          requestOptions: options
        });
        if (wasEmpty) {
          this.eventsAvailableCompletion.resolve();
        }
        if (this.eventsPromise === null) {
          this.eventsPromise = this.processPendingEventsAsync();
        }
      }
      async processPendingEventsAsync() {
        const eventsToSend = [];
        while (!this.isDisposed) {
          await this.eventsAvailableCompletion.promise;
          this.eventsAvailableCompletion = new dev_tunnels_ssh_1.PromiseCompletionSource();
          const nextEventInfo = this.eventsQueue.shift();
          if (!nextEventInfo) {
            break;
          }
          const tunnel = nextEventInfo.tunnel;
          const requestOptions = nextEventInfo.requestOptions;
          eventsToSend.length = 0;
          eventsToSend.push(nextEventInfo.event);
          while (this.eventsQueue.length > 0) {
            const peekEventInfo = this.eventsQueue[0];
            if (peekEventInfo.tunnel !== tunnel || peekEventInfo.requestOptions !== requestOptions) {
              break;
            }
            eventsToSend.push(this.eventsQueue.shift().event);
          }
          try {
            const uri = await this.buildUriForTunnel(tunnel, eventsApiSubPath, this.tunnelRequestOptionsToQueryString(requestOptions), requestOptions);
            const config = await this.getAxiosRequestConfig(tunnel, requestOptions, readAccessTokenScopes);
            await this.request(
              "POST",
              uri,
              [...eventsToSend],
              // Create a copy to avoid mutation issues
              config,
              void 0,
              void 0
            );
          } catch (error) {
            this.trace(`Error uploading events: ${error}`);
          }
        }
      }
      raiseReportProgress(progress) {
        const args = {
          progress
        };
        this.reportProgressEmitter.fire(args);
      }
      getResponseErrorMessage(error, signal) {
        var _a, _b, _c, _d, _e, _f;
        let errorMessage = "";
        if (signal.aborted) {
          error.code = "ECONNABORTED";
          errorMessage = `ECONNABORTED: (signal aborted) ${error.message}`;
        } else if (error.code === "ECONNABORTED") {
          errorMessage = `ECONNABORTED: (timeout) ${error.message}`;
        }
        if ((_a = error.response) === null || _a === void 0 ? void 0 : _a.data) {
          const problemDetails = error.response.data;
          if (problemDetails.title || problemDetails.detail) {
            errorMessage = `Tunnel service error: ${problemDetails.title}`;
            if (problemDetails.detail) {
              errorMessage += " " + problemDetails.detail;
            }
            if (problemDetails.errors) {
              errorMessage += JSON.stringify(problemDetails.errors);
            }
          }
        }
        if (!errorMessage && error.response && error.response.status && error.response.status >= 400 && error.response.status < 500 && error.response.headers) {
          const headers = error.response.headers;
          const servedBy = headers["X-Served-By"] || headers["x-served-by"];
          if (!/tunnels-/.test(servedBy)) {
            const requestDomain = new URL((_c = (_b = error.config) === null || _b === void 0 ? void 0 : _b.url) !== null && _c !== void 0 ? _c : dev_tunnels_contracts_1.TunnelServiceProperties.production.serviceUri).host;
            errorMessage = `The tunnel request resulted in ${error.response.status} status, but the request did not reach the tunnel service. This may indicate the domain '${requestDomain}' is blocked by a firewall.`;
          }
        }
        if (!errorMessage) {
          if (error.response) {
            errorMessage = `Tunnel service returned status code: ${error.response.status} ${error.response.statusText}`;
          } else {
            errorMessage = (_e = (_d = error === null || error === void 0 ? void 0 : error.message) !== null && _d !== void 0 ? _d : error) !== null && _e !== void 0 ? _e : "Unknown tunnel service request error.";
          }
        }
        const requestIdHeaderName = "VsSaaS-Request-Id";
        if (((_f = error.response) === null || _f === void 0 ? void 0 : _f.headers) && error.response.headers[requestIdHeaderName]) {
          errorMessage += `
Request ID: ${error.response.headers[requestIdHeaderName]}`;
        }
        return errorMessage;
      }
      // Helper functions
      async buildUri(clusterId, path2, query, options) {
        if (clusterId === void 0 && this.userTokenCallback) {
          let token = await this.userTokenCallback();
          if (token && token.startsWith("tunnelplan")) {
            token = token.replace("tunnelplan ", "");
            const parsedToken = tunnelPlanTokenProperties_1.TunnelPlanTokenProperties.tryParse(token);
            if (parsedToken !== null && parsedToken.clusterId) {
              clusterId = parsedToken.clusterId;
            }
          }
        }
        let baseAddress = this.baseAddress;
        if (clusterId) {
          const url = new URL(baseAddress);
          const portNumber = parseInt(url.port, 10);
          url.hostname = _TunnelManagementHttpClient.replaceTunnelServiceHostnameClusterId(url.hostname, clusterId);
          if (url.protocol === "https:" && clusterId.startsWith("localhost") && portNumber % 10 > 0) {
            const clusterNumber = parseInt(clusterId.substring("localhost".length), 10);
            if (clusterNumber > 0 && clusterNumber < 10) {
              url.port = (portNumber - portNumber % 10 + clusterNumber).toString();
            }
          }
          baseAddress = url.toString();
        }
        baseAddress = `${baseAddress.replace(/\/$/, "")}${path2}`;
        const optionsQuery = this.tunnelRequestOptionsToQueryString(options, query);
        if (optionsQuery) {
          baseAddress += `?${optionsQuery}`;
        }
        return baseAddress;
      }
      static replaceTunnelServiceHostnameClusterId(hostname, clusterId) {
        if (!clusterId || hostname === "localhost" || hostname === "tunnels.local.api.visualstudio.com") {
          return hostname;
        }
        if (hostname.startsWith("global.") || dev_tunnels_contracts_1.TunnelConstraints.clusterIdPrefixRegex.test(hostname)) {
          return clusterId + hostname.substring(hostname.indexOf("."));
        } else {
          return `${clusterId}.${hostname}`;
        }
      }
      buildUriForTunnel(tunnel, path2, query, options, isCreate = false) {
        let tunnelPath = "";
        if ((tunnel.clusterId || isCreate) && tunnel.tunnelId) {
          tunnelPath = `${tunnelsApiPath}/${tunnel.tunnelId}`;
        } else {
          throw new Error("Tunnel object must include a tunnel ID always and cluster ID for non creates.");
        }
        if (options === null || options === void 0 ? void 0 : options.additionalQueryParameters) {
          for (const [paramName, paramValue] of Object.entries(options.additionalQueryParameters)) {
            if (query) {
              query += `&${paramName}=${paramValue}`;
            } else {
              query = `${paramName}=${paramValue}`;
            }
          }
        }
        return this.buildUri(tunnel.clusterId, tunnelPath + (path2 ? path2 : ""), query, options);
      }
      async getAxiosRequestConfig(tunnel, options, accessTokenScopes) {
        const headers = {};
        if (options && options.accessToken) {
          headers[tunnelAuthentication] = `${tunnelManagementClient_1.TunnelAuthenticationSchemes.tunnel} ${options.accessToken}`;
        }
        if (!(tunnelAuthentication in headers) && this.userTokenCallback) {
          const token = await this.userTokenCallback();
          if (token) {
            headers[tunnelAuthentication] = token;
          }
        }
        if (!(tunnelAuthentication in headers)) {
          const accessToken = tunnelAccessTokenProperties_1.TunnelAccessTokenProperties.getTunnelAccessToken(tunnel, accessTokenScopes);
          if (accessToken) {
            headers[tunnelAuthentication] = `${tunnelManagementClient_1.TunnelAuthenticationSchemes.tunnel} ${accessToken}`;
          }
        }
        const copyAdditionalHeaders = (additionalHeaders) => {
          if (additionalHeaders) {
            for (const [headerName, headerValue] of Object.entries(additionalHeaders)) {
              headers[headerName] = headerValue;
            }
          }
        };
        copyAdditionalHeaders(this.additionalRequestHeaders);
        copyAdditionalHeaders(options === null || options === void 0 ? void 0 : options.additionalHeaders);
        const userAgentPrefix = headers["User-Agent"] ? headers["User-Agent"] + " " : "";
        headers["User-Agent"] = `${userAgentPrefix}${this.userAgents} ${version_1.tunnelSdkUserAgent}`;
        const config = Object.assign(Object.assign({ headers }, this.httpsAgent && { httpsAgent: this.httpsAgent }), this.adapter && { adapter: this.adapter });
        if ((options === null || options === void 0 ? void 0 : options.followRedirects) === false) {
          config.maxRedirects = 0;
        }
        return config;
      }
      convertTunnelForRequest(tunnel) {
        var _a;
        const convertedTunnel = {
          tunnelId: tunnel.tunnelId,
          name: tunnel.name,
          domain: tunnel.domain,
          description: tunnel.description,
          labels: tunnel.labels,
          options: tunnel.options,
          customExpiration: tunnel.customExpiration,
          accessControl: !tunnel.accessControl ? void 0 : { entries: tunnel.accessControl.entries.filter((ace) => !ace.isInherited) },
          endpoints: tunnel.endpoints,
          ports: (_a = tunnel.ports) === null || _a === void 0 ? void 0 : _a.map((p) => this.convertTunnelPortForRequest(tunnel, p))
        };
        return convertedTunnel;
      }
      convertTunnelPortForRequest(tunnel, tunnelPort) {
        if (tunnelPort.clusterId && tunnel.clusterId && tunnelPort.clusterId !== tunnel.clusterId) {
          throw new Error("Tunnel port cluster ID does not match tunnel.");
        }
        if (tunnelPort.tunnelId && tunnel.tunnelId && tunnelPort.tunnelId !== tunnel.tunnelId) {
          throw new Error("Tunnel port tunnel ID does not match tunnel.");
        }
        return {
          portNumber: tunnelPort.portNumber,
          protocol: tunnelPort.protocol,
          isDefault: tunnelPort.isDefault,
          description: tunnelPort.description,
          labels: tunnelPort.labels,
          sshUser: tunnelPort.sshUser,
          options: tunnelPort.options,
          accessControl: !tunnelPort.accessControl ? void 0 : { entries: tunnelPort.accessControl.entries.filter((ace) => !ace.isInherited) }
        };
      }
      tunnelRequestOptionsToQueryString(options, additionalQuery) {
        const queryOptions = {};
        const queryItems = [];
        if (options) {
          if (options.includePorts) {
            queryOptions.includePorts = ["true"];
          }
          if (options.includeAccessControl) {
            queryOptions.includeAccessControl = ["true"];
          }
          if (options.tokenScopes) {
            dev_tunnels_contracts_1.TunnelAccessControl.validateScopes(options.tokenScopes, void 0, true);
            queryOptions.tokenScopes = options.tokenScopes;
          }
          if (options.forceRename) {
            queryOptions.forceRename = ["true"];
          }
          if (options.labels) {
            queryOptions.labels = options.labels;
            if (options.requireAllLabels) {
              queryOptions.allLabels = ["true"];
            }
          }
          if (options.limit) {
            queryOptions.limit = [options.limit.toString()];
          }
          queryItems.push(...Object.keys(queryOptions).map((key) => {
            const value = queryOptions[key];
            return `${key}=${value.map(encodeURIComponent).join(",")}`;
          }));
        }
        if (additionalQuery) {
          queryItems.push(additionalQuery);
        }
        queryItems.push(`api-version=${this.apiVersion}`);
        const queryString = queryItems.join("&");
        return queryString;
      }
      /**
       * Axios request that can be overridden for unit tests purposes.
       * @param config axios request config
       * @param _cancellation the cancellation token for the request (used by unit tests to simulate timeouts).
       */
      async axiosRequest(config, _cancellation) {
        return await axios_1.default.request(config);
      }
      /**
       * Makes an HTTP request using Axios, while tracing request and response details.
       */
      async request(method, uri, data, config, allowNotFound, cancellation) {
        var _a, _b;
        this.trace(`${method} ${uri}`);
        if (config.headers) {
          this.traceHeaders(config.headers);
        }
        this.traceContent(data);
        const traceResponse = (response) => {
          this.trace(`${response.status} ${response.statusText}`);
          this.traceHeaders(response.headers);
          this.traceContent(response.data);
        };
        let disposable;
        const abortController = new AbortController();
        let timeout = void 0;
        const newAbortSignal = () => {
          if (cancellation === null || cancellation === void 0 ? void 0 : cancellation.isCancellationRequested) {
            abortController.abort("Cancelled: CancellationToken cancel requested.");
          } else if (cancellation) {
            disposable = cancellation.onCancellationRequested(() => abortController.abort("Cancelled: CancellationToken cancel requested."));
          } else {
            timeout = setTimeout(() => abortController.abort("Cancelled: default request timeout reached."), defaultRequestTimeoutMS);
          }
          return abortController.signal;
        };
        try {
          config.url = uri;
          config.method = method;
          config.data = data;
          config.signal = newAbortSignal();
          config.timeout = defaultRequestTimeoutMS;
          const response = await this.axiosRequest(config, cancellation);
          traceResponse(response);
          return method === "DELETE" ? true : response.data;
        } catch (e) {
          if (!(e instanceof Error) || !e.isAxiosError)
            throw e;
          const requestError = e;
          if (requestError.response) {
            traceResponse(requestError.response);
            if (allowNotFound && requestError.response.status === 404) {
              return method === "DELETE" ? false : null;
            }
          }
          requestError.message = this.getResponseErrorMessage(requestError, abortController.signal);
          delete requestError.request;
          if (requestError.response) {
            (_a = requestError.config) === null || _a === void 0 ? true : delete _a.httpAgent;
            (_b = requestError.config) === null || _b === void 0 ? true : delete _b.httpsAgent;
            delete requestError.response.request;
          }
          throw requestError;
        } finally {
          if (timeout) {
            clearTimeout(timeout);
          }
          disposable === null || disposable === void 0 ? void 0 : disposable.dispose();
        }
      }
      traceHeaders(headers) {
        for (const [headerName, headerValue] of Object.entries(headers)) {
          if (headerName === "Authorization") {
            this.traceAuthorizationHeader(headerName, headerValue);
            return;
          }
          this.trace(`${headerName}: ${headerValue !== null && headerValue !== void 0 ? headerValue : ""}`);
        }
      }
      traceAuthorizationHeader(key, value) {
        if (typeof value !== "string")
          return;
        const spaceIndex = value.indexOf(" ");
        if (spaceIndex < 0) {
          this.trace(`${key}: [${value.length}]`);
          return;
        }
        const scheme = value.substring(0, spaceIndex);
        const token = value.substring(spaceIndex + 1);
        if (scheme.toLowerCase() === tunnelManagementClient_1.TunnelAuthenticationSchemes.tunnel.toLowerCase()) {
          const tokenProperties = tunnelAccessTokenProperties_1.TunnelAccessTokenProperties.tryParse(token);
          if (tokenProperties) {
            this.trace(`${key}: ${scheme} <${tokenProperties}>`);
            return;
          }
        }
        this.trace(`${key}: ${scheme} <token>`);
      }
      traceContent(data) {
        if (typeof data === "object") {
          data = JSON.stringify(data, void 0, "  ");
        }
        if (typeof data === "string") {
          this.trace(_TunnelManagementHttpClient.replaceTokensInContent(data));
        }
      }
      static replaceTokensInContent(content) {
        var _a;
        const tokenRegex = /"(eyJ[a-zA-z0-9\-_]+\.[a-zA-z0-9\-_]+\.[a-zA-z0-9\-_]+)"/;
        let match = tokenRegex.exec(content);
        while (match) {
          let token = match[1];
          const tokenProperties = tunnelAccessTokenProperties_1.TunnelAccessTokenProperties.tryParse(token);
          token = (_a = tokenProperties === null || tokenProperties === void 0 ? void 0 : tokenProperties.toString()) !== null && _a !== void 0 ? _a : "token";
          content = content.substring(0, match.index + 1) + "<" + token + ">" + content.substring(match.index + match[0].length - 1);
          match = tokenRegex.exec(content);
        }
        return content;
      }
      /**
       * Disposes the client and any background tasks.
       */
      async dispose() {
        this.isDisposed = true;
        this.eventsAvailableCompletion.resolve();
        if (this.eventsPromise) {
          await this.eventsPromise;
          this.eventsPromise = null;
        }
      }
    };
    exports2.TunnelManagementHttpClient = TunnelManagementHttpClient3;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-management/tunnelRequestOptions.js
var require_tunnelRequestOptions = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-management/tunnelRequestOptions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/@microsoft/dev-tunnels-management/index.js
var require_dev_tunnels_management = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-management/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_tunnelManagementHttpClient(), exports2);
    __exportStar(require_tunnelManagementClient(), exports2);
    __exportStar(require_tunnelRequestOptions(), exports2);
    __exportStar(require_tunnelAccessTokenProperties(), exports2);
  }
});

// ../../node_modules/@microsoft/dev-tunnels-connections/tunnelClient.js
var require_tunnelClient = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-connections/tunnelClient.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/@microsoft/dev-tunnels-connections/tunnelHost.js
var require_tunnelHost = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-connections/tunnelHost.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/@microsoft/dev-tunnels-connections/connectionStatus.js
var require_connectionStatus = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-connections/connectionStatus.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConnectionStatus = void 0;
    var ConnectionStatus;
    (function(ConnectionStatus2) {
      ConnectionStatus2["None"] = "none";
      ConnectionStatus2["Connecting"] = "connecting";
      ConnectionStatus2["RefreshingTunnelAccessToken"] = "refreshingTunnelAccessToken";
      ConnectionStatus2["Connected"] = "connected";
      ConnectionStatus2["Disconnected"] = "disconnected";
      ConnectionStatus2["RefreshingTunnelHostPublicKey"] = "refreshingTunnelHostPublicKey";
    })(ConnectionStatus = exports2.ConnectionStatus || (exports2.ConnectionStatus = {}));
  }
});

// ../../node_modules/@microsoft/dev-tunnels-connections/connectionStatusChangedEventArgs.js
var require_connectionStatusChangedEventArgs = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-connections/connectionStatusChangedEventArgs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConnectionStatusChangedEventArgs = void 0;
    var ConnectionStatusChangedEventArgs = class {
      /**
       * Creates a new instance of ConnectionStatusChangedEventArgs.
       */
      constructor(previousStatus, status, disconnectError) {
        this.previousStatus = previousStatus;
        this.status = status;
        this.disconnectError = disconnectError;
      }
    };
    exports2.ConnectionStatusChangedEventArgs = ConnectionStatusChangedEventArgs;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-connections/refreshingTunnelAccessTokenEventArgs.js
var require_refreshingTunnelAccessTokenEventArgs = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-connections/refreshingTunnelAccessTokenEventArgs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RefreshingTunnelAccessTokenEventArgs = void 0;
    var RefreshingTunnelAccessTokenEventArgs = class {
      /**
       * Creates a new instance of RefreshingTunnelAccessTokenEventArgs class.
       */
      constructor(tunnelAccessScope, cancellation) {
        this.tunnelAccessScope = tunnelAccessScope;
        this.cancellation = cancellation;
      }
    };
    exports2.RefreshingTunnelAccessTokenEventArgs = RefreshingTunnelAccessTokenEventArgs;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-connections/utils.js
var require_utils = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-connections/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TrackingEmitter = exports2.withCancellation = exports2.getError = exports2.getErrorMessage = exports2.delay = exports2.List = void 0;
    var dev_tunnels_ssh_1 = require_dev_tunnels_ssh();
    var vscode_jsonrpc_1 = require_main();
    var List = class {
      static groupBy(list, keyGetter) {
        const map = /* @__PURE__ */ new Map();
        list.forEach((item) => {
          const key = keyGetter(item);
          const collection = map.get(key);
          if (!collection) {
            map.set(key, [item]);
          } else {
            collection.push(item);
          }
        });
        return map;
      }
    };
    exports2.List = List;
    function delay(milliseconds, cancellation) {
      return new Promise((resolve3, reject) => {
        let cancellationDisposable;
        let timeout = void 0;
        if (cancellation) {
          if (cancellation.isCancellationRequested) {
            reject(new dev_tunnels_ssh_1.CancellationError());
            return;
          }
          cancellationDisposable = cancellation.onCancellationRequested(() => {
            if (timeout) {
              clearTimeout(timeout);
            }
            cancellationDisposable === null || cancellationDisposable === void 0 ? void 0 : cancellationDisposable.dispose();
            reject(new dev_tunnels_ssh_1.CancellationError());
          });
        }
        timeout = setTimeout(() => {
          cancellationDisposable === null || cancellationDisposable === void 0 ? void 0 : cancellationDisposable.dispose();
          resolve3();
        }, milliseconds);
      });
    }
    exports2.delay = delay;
    function getErrorMessage(e) {
      var _a;
      return String((_a = e === null || e === void 0 ? void 0 : e.message) !== null && _a !== void 0 ? _a : e);
    }
    exports2.getErrorMessage = getErrorMessage;
    function getError(e, messagePrefix) {
      return e instanceof Error ? e : new Error(`${messagePrefix !== null && messagePrefix !== void 0 ? messagePrefix : ""}${e}`);
    }
    exports2.getError = getError;
    function withCancellation(promise2, cancellation) {
      if (!cancellation) {
        return promise2;
      }
      return Promise.race([
        promise2,
        new Promise((resolve3, reject) => {
          if (cancellation.isCancellationRequested) {
            reject(new dev_tunnels_ssh_1.CancellationError());
          } else {
            cancellation.onCancellationRequested(() => {
              reject(new dev_tunnels_ssh_1.CancellationError());
            });
          }
        })
      ]);
    }
    exports2.withCancellation = withCancellation;
    var TrackingEmitter = class extends vscode_jsonrpc_1.Emitter {
      constructor() {
        super({
          onFirstListenerAdd: () => this.subscribed = true,
          onLastListenerRemove: () => this.subscribed = false
        });
        this.subscribed = false;
      }
      /**
       * A value indicating whether there event handlers subscribed to the event emitter.
       */
      get isSubscribed() {
        return this.subscribed;
      }
    };
    exports2.TrackingEmitter = TrackingEmitter;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-connections/sshKeepAliveEventArgs.js
var require_sshKeepAliveEventArgs = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-connections/sshKeepAliveEventArgs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SshKeepAliveEventArgs = void 0;
    var SshKeepAliveEventArgs = class {
      constructor(count) {
        this.count = count;
      }
    };
    exports2.SshKeepAliveEventArgs = SshKeepAliveEventArgs;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-connections/tunnelConnectionBase.js
var require_tunnelConnectionBase = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-connections/tunnelConnectionBase.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TunnelConnectionBase = void 0;
    var dev_tunnels_ssh_1 = require_dev_tunnels_ssh();
    var vscode_jsonrpc_1 = require_main();
    var connectionStatus_1 = require_connectionStatus();
    var connectionStatusChangedEventArgs_1 = require_connectionStatusChangedEventArgs();
    var refreshingTunnelAccessTokenEventArgs_1 = require_refreshingTunnelAccessTokenEventArgs();
    var utils_1 = require_utils();
    var sshKeepAliveEventArgs_1 = require_sshKeepAliveEventArgs();
    var TunnelConnectionBase = class {
      constructor(tunnelAccessScope) {
        this.tunnelAccessScope = tunnelAccessScope;
        this.disposeCts = new vscode_jsonrpc_1.CancellationTokenSource();
        this.status = connectionStatus_1.ConnectionStatus.None;
        this.refreshingTunnelAccessTokenEmitter = new utils_1.TrackingEmitter();
        this.connectionStatusChangedEmitter = new vscode_jsonrpc_1.Emitter();
        this.retryingTunnelConnectionEmitter = new vscode_jsonrpc_1.Emitter();
        this.forwardedPortConnectingEmitter = new vscode_jsonrpc_1.Emitter();
        this.keepAliveFailedEmitter = new vscode_jsonrpc_1.Emitter();
        this.keepAliveSucceededEmitter = new vscode_jsonrpc_1.Emitter();
        this.refreshingTunnelAccessToken = this.refreshingTunnelAccessTokenEmitter.event;
        this.connectionStatusChanged = this.connectionStatusChangedEmitter.event;
        this.retryingTunnelConnection = this.retryingTunnelConnectionEmitter.event;
        this.forwardedPortConnecting = this.forwardedPortConnectingEmitter.event;
        this.keepAliveFailed = this.keepAliveFailedEmitter.event;
        this.keepAliveSucceeded = this.keepAliveSucceededEmitter.event;
      }
      /**
       * Gets a value indicathing that this tunnel connection session is disposed.
       */
      get isDisposed() {
        return this.disposeCts.token.isCancellationRequested;
      }
      get isRefreshingTunnelAccessTokenEventHandled() {
        return this.refreshingTunnelAccessTokenEmitter.isSubscribed;
      }
      /**
       * Gets dispose cancellation token.
       */
      get disposeToken() {
        return this.disposeCts.token;
      }
      /**
       * Gets the connection status.
       */
      get connectionStatus() {
        return this.status;
      }
      /**
       * Sets the connection status.
       * Throws CancellationError if the session is disposed and the status being set is not ConnectionStatus.Disconnected.
       */
      set connectionStatus(value) {
        if (this.isDisposed && value !== connectionStatus_1.ConnectionStatus.Disconnected) {
          this.throwIfDisposed(`ConnectionStatus: ${value}`);
        }
        if (value === connectionStatus_1.ConnectionStatus.RefreshingTunnelAccessToken && this.status !== connectionStatus_1.ConnectionStatus.Connecting) {
          throw new Error("Refreshing tunnel access token is allowed only when connecting.");
        }
        if (value !== this.status) {
          const previousStatus = this.connectionStatus;
          this.status = value;
          this.onConnectionStatusChanged(previousStatus, value);
        }
      }
      /**
       * Gets the error that caused disconnection.
       * Undefined if not yet connected or disconnection was caused by disposing of this object.
       */
      get disconnectError() {
        return this.error;
      }
      /**
       * Sets the error that caused disconnection.
       */
      set disconnectError(e) {
        this.error = e;
      }
      onForwardedPortConnecting(e) {
        this.forwardedPortConnectingEmitter.fire(e);
      }
      /**
       * Raises the keep-alive failed event.
       */
      onKeepAliveFailed(count) {
        this.keepAliveFailedEmitter.fire(new sshKeepAliveEventArgs_1.SshKeepAliveEventArgs(count));
      }
      /**
       * Raises the keep-alive succeeded event.
       */
      onKeepAliveSucceeded(count) {
        this.keepAliveSucceededEmitter.fire(new sshKeepAliveEventArgs_1.SshKeepAliveEventArgs(count));
      }
      /**
       * Closes and disposes the tunnel session.
       */
      dispose() {
        this.disposeCts.cancel();
        this.connectionStatus = connectionStatus_1.ConnectionStatus.Disconnected;
        return Promise.resolve();
      }
      /**
       *  Notifies about a connection retry, giving the relay client a chance to delay or cancel it.
       */
      onRetrying(event) {
        this.retryingTunnelConnectionEmitter.fire(event);
      }
      /**
       * Gets the fresh tunnel access token or undefined if it cannot.
       */
      async getFreshTunnelAccessToken(cancellation) {
        const event = new refreshingTunnelAccessTokenEventArgs_1.RefreshingTunnelAccessTokenEventArgs(this.tunnelAccessScope, cancellation);
        this.refreshingTunnelAccessTokenEmitter.fire(event);
        return event.tunnelAccessToken ? await event.tunnelAccessToken : void 0;
      }
      /**
       * Event fired when the connection status has changed.
       */
      onConnectionStatusChanged(previousStatus, status) {
        const disconnectError = this.connectionStatus === connectionStatus_1.ConnectionStatus.Disconnected && !this.isDisposed ? this.disconnectError : void 0;
        const event = new connectionStatusChangedEventArgs_1.ConnectionStatusChangedEventArgs(previousStatus, status, disconnectError);
        this.connectionStatusChangedEmitter.fire(event);
      }
      /**
       * Throws CancellationError if the tunnel connection is disposed.
       */
      throwIfDisposed(message, stack) {
        if (this.isDisposed) {
          const error = new dev_tunnels_ssh_1.ObjectDisposedError(`The tunnel connection is disposed. ${message}`);
          if (stack) {
            error.stack = stack;
          }
          throw error;
        }
      }
    };
    exports2.TunnelConnectionBase = TunnelConnectionBase;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-connections/multiModeTunnelClient.js
var require_multiModeTunnelClient = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-connections/multiModeTunnelClient.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MultiModeTunnelClient = void 0;
    var dev_tunnels_contracts_1 = require_dev_tunnels_contracts();
    var tunnelConnectionBase_1 = require_tunnelConnectionBase();
    var MultiModeTunnelClient = class extends tunnelConnectionBase_1.TunnelConnectionBase {
      constructor() {
        super(dev_tunnels_contracts_1.TunnelAccessScopes.Connect);
        this.clients = [];
        this.connectionModes = this.clients ? [...new Set(...this.clients.map((c) => c.connectionModes))] : [];
      }
      /**
       * A value indicating whether local connections for forwarded ports are accepted.
       * Local connections are not accepted if the host process is not NodeJS (e.g. browser).
       */
      get acceptLocalConnectionsForForwardedPorts() {
        return !!this.clients.find((c) => c.acceptLocalConnectionsForForwardedPorts);
      }
      set acceptLocalConnectionsForForwardedPorts(value) {
        this.clients.forEach((c) => c.acceptLocalConnectionsForForwardedPorts = value);
      }
      get localForwardingHostAddress() {
        var _a;
        return (_a = this.clients[0]) === null || _a === void 0 ? void 0 : _a.localForwardingHostAddress;
      }
      set localForwardingHostAddress(value) {
        this.clients.forEach((c) => c.localForwardingHostAddress = value);
      }
      connect(tunnel, options, cancellation) {
        if (!tunnel) {
          throw new Error("Tunnel cannot be null");
        }
        return new Promise((resolve3) => {
        });
      }
      get portForwarding() {
        throw new Error("Not supported.");
      }
      connectToForwardedPort(fowardedPort, cancellation) {
        throw new Error("Method not implemented.");
      }
      waitForForwardedPort(forwardedPort, cancellation) {
        throw new Error("Method not implemented.");
      }
      async refreshPorts() {
        throw new Error("Method not implemented.");
      }
      async dispose() {
        await super.dispose();
        await Promise.all(this.clients.map((client) => client.dispose()));
      }
    };
    exports2.MultiModeTunnelClient = MultiModeTunnelClient;
  }
});

// ../../node_modules/uuid/lib/rng.js
var require_rng = __commonJS({
  "../../node_modules/uuid/lib/rng.js"(exports2, module2) {
    "use strict";
    var crypto2 = require("crypto");
    module2.exports = function nodeRNG() {
      return crypto2.randomBytes(16);
    };
  }
});

// ../../node_modules/uuid/lib/bytesToUuid.js
var require_bytesToUuid = __commonJS({
  "../../node_modules/uuid/lib/bytesToUuid.js"(exports2, module2) {
    "use strict";
    var byteToHex = [];
    for (i = 0; i < 256; ++i) {
      byteToHex[i] = (i + 256).toString(16).substr(1);
    }
    var i;
    function bytesToUuid(buf, offset) {
      var i2 = offset || 0;
      var bth = byteToHex;
      return [
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        "-",
        bth[buf[i2++]],
        bth[buf[i2++]],
        "-",
        bth[buf[i2++]],
        bth[buf[i2++]],
        "-",
        bth[buf[i2++]],
        bth[buf[i2++]],
        "-",
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]]
      ].join("");
    }
    module2.exports = bytesToUuid;
  }
});

// ../../node_modules/uuid/v1.js
var require_v1 = __commonJS({
  "../../node_modules/uuid/v1.js"(exports2, module2) {
    "use strict";
    var rng = require_rng();
    var bytesToUuid = require_bytesToUuid();
    var _nodeId;
    var _clockseq;
    var _lastMSecs = 0;
    var _lastNSecs = 0;
    function v1(options, buf, offset) {
      var i = buf && offset || 0;
      var b = buf || [];
      options = options || {};
      var node = options.node || _nodeId;
      var clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
      if (node == null || clockseq == null) {
        var seedBytes = rng();
        if (node == null) {
          node = _nodeId = [
            seedBytes[0] | 1,
            seedBytes[1],
            seedBytes[2],
            seedBytes[3],
            seedBytes[4],
            seedBytes[5]
          ];
        }
        if (clockseq == null) {
          clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
        }
      }
      var msecs = options.msecs !== void 0 ? options.msecs : (/* @__PURE__ */ new Date()).getTime();
      var nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
      var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
      if (dt < 0 && options.clockseq === void 0) {
        clockseq = clockseq + 1 & 16383;
      }
      if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
        nsecs = 0;
      }
      if (nsecs >= 1e4) {
        throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
      }
      _lastMSecs = msecs;
      _lastNSecs = nsecs;
      _clockseq = clockseq;
      msecs += 122192928e5;
      var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
      b[i++] = tl >>> 24 & 255;
      b[i++] = tl >>> 16 & 255;
      b[i++] = tl >>> 8 & 255;
      b[i++] = tl & 255;
      var tmh = msecs / 4294967296 * 1e4 & 268435455;
      b[i++] = tmh >>> 8 & 255;
      b[i++] = tmh & 255;
      b[i++] = tmh >>> 24 & 15 | 16;
      b[i++] = tmh >>> 16 & 255;
      b[i++] = clockseq >>> 8 | 128;
      b[i++] = clockseq & 255;
      for (var n = 0; n < 6; ++n) {
        b[i + n] = node[n];
      }
      return buf ? buf : bytesToUuid(b);
    }
    module2.exports = v1;
  }
});

// ../../node_modules/uuid/v4.js
var require_v4 = __commonJS({
  "../../node_modules/uuid/v4.js"(exports2, module2) {
    "use strict";
    var rng = require_rng();
    var bytesToUuid = require_bytesToUuid();
    function v4(options, buf, offset) {
      var i = buf && offset || 0;
      if (typeof options == "string") {
        buf = options === "binary" ? new Array(16) : null;
        options = null;
      }
      options = options || {};
      var rnds = options.random || (options.rng || rng)();
      rnds[6] = rnds[6] & 15 | 64;
      rnds[8] = rnds[8] & 63 | 128;
      if (buf) {
        for (var ii = 0; ii < 16; ++ii) {
          buf[i + ii] = rnds[ii];
        }
      }
      return buf || bytesToUuid(rnds);
    }
    module2.exports = v4;
  }
});

// ../../node_modules/uuid/index.js
var require_uuid = __commonJS({
  "../../node_modules/uuid/index.js"(exports2, module2) {
    "use strict";
    var v1 = require_v1();
    var v4 = require_v4();
    var uuid = v4;
    uuid.v1 = v1;
    uuid.v4 = v4;
    module2.exports = uuid;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-connections/multiModeTunnelHost.js
var require_multiModeTunnelHost = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-connections/multiModeTunnelHost.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MultiModeTunnelHost = void 0;
    var dev_tunnels_contracts_1 = require_dev_tunnels_contracts();
    var uuid_1 = require_uuid();
    var tunnelConnectionBase_1 = require_tunnelConnectionBase();
    var MultiModeTunnelHost = class extends tunnelConnectionBase_1.TunnelConnectionBase {
      constructor() {
        super(dev_tunnels_contracts_1.TunnelAccessScopes.Host);
        this.hosts = [];
      }
      /**
       * @deprecated Use `connect()` instead.
       */
      async start(tunnel) {
        await this.connect(tunnel);
      }
      async connect(tunnel, options, cancellation) {
        const startTasks = [];
        this.hosts.forEach((host) => {
          startTasks.push(host.connect(tunnel, options, cancellation));
        });
        await Promise.all(startTasks);
      }
      async refreshPorts() {
        const refreshTasks = [];
        this.hosts.forEach((host) => {
          refreshTasks.push(host.refreshPorts());
        });
        await Promise.all(refreshTasks);
      }
      async dispose() {
        await Promise.all(this.hosts.map((host) => host.dispose()));
        await super.dispose();
      }
    };
    exports2.MultiModeTunnelHost = MultiModeTunnelHost;
    MultiModeTunnelHost.hostId = (0, uuid_1.v4)();
  }
});

// ../../node_modules/@microsoft/dev-tunnels-connections/retryTcpListenerFactory.js
var require_retryTcpListenerFactory = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-connections/retryTcpListenerFactory.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RetryTcpListenerFactory = void 0;
    var net2 = require("net");
    var RetryTcpListenerFactory = class {
      constructor(localAddress) {
        this.localAddress = localAddress;
      }
      async createTcpListener(remotePort, localIPAddress, localPort, canChangeLocalPort, cancellation) {
        if (localIPAddress.indexOf(":") >= 0) {
          if (this.localAddress === "0.0.0.0") {
            localIPAddress = "::";
          } else if (this.localAddress === "127.0.0.1") {
            localIPAddress = "::1";
          }
        } else {
          localIPAddress = this.localAddress;
        }
        const maxOffset = 10;
        const listener = net2.createServer();
        for (let offset = 0; ; offset++) {
          const localPortNumber = offset === maxOffset ? 0 : localPort + offset;
          try {
            return await new Promise((resolve3, reject) => {
              listener.listen({
                host: localIPAddress,
                port: localPortNumber,
                ipv6Only: net2.isIPv6(localIPAddress)
              });
              listener.on("listening", () => {
                if (remotePort) {
                  const { address, port } = listener.address();
                  console.log(`Forwarding from ${address}:${port} to host port ${remotePort}.`);
                }
                resolve3(listener);
              });
              listener.on("error", (err) => {
                reject(err);
              });
            });
          } catch (err) {
            if (offset < maxOffset && canChangeLocalPort) {
              console.log("Listening on port " + localPortNumber + " failed: " + err);
              console.log("Incrementing port and trying again");
              continue;
            } else {
              throw err;
            }
          }
        }
      }
    };
    exports2.RetryTcpListenerFactory = RetryTcpListenerFactory;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-connections/sessionPortKey.js
var require_sessionPortKey = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-connections/sessionPortKey.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SessionPortKey = void 0;
    var SessionPortKey = class {
      constructor(sessionId, port) {
        this.sessionId = sessionId !== null && sessionId !== void 0 ? sessionId : null;
        this.port = port;
      }
      equals(other) {
        return this.port === other.port && (!this.sessionId && !other.sessionId || this.sessionId && other.sessionId && this.sessionId === other.sessionId);
      }
      toString() {
        return this.port + (this.sessionId ? "_" + this.sessionId.toString("base64") : "");
      }
    };
    exports2.SessionPortKey = SessionPortKey;
  }
});

// ../../node_modules/websocket/node_modules/ms/index.js
var require_ms2 = __commonJS({
  "../../node_modules/websocket/node_modules/ms/index.js"(exports2, module2) {
    "use strict";
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isNaN(val) === false) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      if (ms >= d) {
        return Math.round(ms / d) + "d";
      }
      if (ms >= h) {
        return Math.round(ms / h) + "h";
      }
      if (ms >= m) {
        return Math.round(ms / m) + "m";
      }
      if (ms >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      return plural(ms, d, "day") || plural(ms, h, "hour") || plural(ms, m, "minute") || plural(ms, s, "second") || ms + " ms";
    }
    function plural(ms, n, name) {
      if (ms < n) {
        return;
      }
      if (ms < n * 1.5) {
        return Math.floor(ms / n) + " " + name;
      }
      return Math.ceil(ms / n) + " " + name + "s";
    }
  }
});

// ../../node_modules/websocket/node_modules/debug/src/debug.js
var require_debug2 = __commonJS({
  "../../node_modules/websocket/node_modules/debug/src/debug.js"(exports2, module2) {
    "use strict";
    exports2 = module2.exports = createDebug.debug = createDebug["default"] = createDebug;
    exports2.coerce = coerce;
    exports2.disable = disable;
    exports2.enable = enable;
    exports2.enabled = enabled;
    exports2.humanize = require_ms2();
    exports2.names = [];
    exports2.skips = [];
    exports2.formatters = {};
    var prevTime;
    function selectColor(namespace) {
      var hash = 0, i;
      for (i in namespace) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return exports2.colors[Math.abs(hash) % exports2.colors.length];
    }
    function createDebug(namespace) {
      function debug() {
        if (!debug.enabled) return;
        var self2 = debug;
        var curr = +/* @__PURE__ */ new Date();
        var ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        args[0] = exports2.coerce(args[0]);
        if ("string" !== typeof args[0]) {
          args.unshift("%O");
        }
        var index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
          if (match === "%%") return match;
          index++;
          var formatter = exports2.formatters[format];
          if ("function" === typeof formatter) {
            var val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        exports2.formatArgs.call(self2, args);
        var logFn = debug.log || exports2.log || console.log.bind(console);
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.enabled = exports2.enabled(namespace);
      debug.useColors = exports2.useColors();
      debug.color = selectColor(namespace);
      if ("function" === typeof exports2.init) {
        exports2.init(debug);
      }
      return debug;
    }
    function enable(namespaces) {
      exports2.save(namespaces);
      exports2.names = [];
      exports2.skips = [];
      var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      var len = split.length;
      for (var i = 0; i < len; i++) {
        if (!split[i]) continue;
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          exports2.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          exports2.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      exports2.enable("");
    }
    function enabled(name) {
      var i, len;
      for (i = 0, len = exports2.skips.length; i < len; i++) {
        if (exports2.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = exports2.names.length; i < len; i++) {
        if (exports2.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error) return val.stack || val.message;
      return val;
    }
  }
});

// ../../node_modules/websocket/node_modules/debug/src/browser.js
var require_browser2 = __commonJS({
  "../../node_modules/websocket/node_modules/debug/src/browser.js"(exports2, module2) {
    "use strict";
    exports2 = module2.exports = require_debug2();
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = "undefined" != typeof chrome && "undefined" != typeof chrome.storage ? chrome.storage.local : localstorage();
    exports2.colors = [
      "lightseagreen",
      "forestgreen",
      "goldenrod",
      "dodgerblue",
      "darkorchid",
      "crimson"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
        return true;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    exports2.formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (err) {
        return "[UnexpectedJSONParseError]: " + err.message;
      }
    };
    function formatArgs(args) {
      var useColors2 = this.useColors;
      args[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args[0] + (useColors2 ? "%c " : " ") + "+" + exports2.humanize(this.diff);
      if (!useColors2) return;
      var c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      var index = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function(match) {
        if ("%%" === match) return;
        index++;
        if ("%c" === match) {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    function log() {
      return "object" === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
    }
    function save(namespaces) {
      try {
        if (null == namespaces) {
          exports2.storage.removeItem("debug");
        } else {
          exports2.storage.debug = namespaces;
        }
      } catch (e) {
      }
    }
    function load() {
      var r;
      try {
        r = exports2.storage.debug;
      } catch (e) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    exports2.enable(load());
    function localstorage() {
      try {
        return window.localStorage;
      } catch (e) {
      }
    }
  }
});

// ../../node_modules/websocket/node_modules/debug/src/node.js
var require_node2 = __commonJS({
  "../../node_modules/websocket/node_modules/debug/src/node.js"(exports2, module2) {
    "use strict";
    var tty = require("tty");
    var util = require("util");
    exports2 = module2.exports = require_debug2();
    exports2.init = init;
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.colors = [6, 2, 3, 4, 5, 1];
    exports2.inspectOpts = Object.keys(process.env).filter(function(key) {
      return /^debug_/i.test(key);
    }).reduce(function(obj, key) {
      var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function(_, k) {
        return k.toUpperCase();
      });
      var val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) val = true;
      else if (/^(no|off|false|disabled)$/i.test(val)) val = false;
      else if (val === "null") val = null;
      else val = Number(val);
      obj[prop] = val;
      return obj;
    }, {});
    var fd = parseInt(process.env.DEBUG_FD, 10) || 2;
    if (1 !== fd && 2 !== fd) {
      util.deprecate(function() {
      }, "except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)")();
    }
    var stream = 1 === fd ? process.stdout : 2 === fd ? process.stderr : createWritableStdioStream(fd);
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(fd);
    }
    exports2.formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map(function(str) {
        return str.trim();
      }).join(" ");
    };
    exports2.formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
    function formatArgs(args) {
      var name = this.namespace;
      var useColors2 = this.useColors;
      if (useColors2) {
        var c = this.color;
        var prefix = "  \x1B[3" + c + ";1m" + name + " \x1B[0m";
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push("\x1B[3" + c + "m+" + exports2.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = (/* @__PURE__ */ new Date()).toUTCString() + " " + name + " " + args[0];
      }
    }
    function log() {
      return stream.write(util.format.apply(util, arguments) + "\n");
    }
    function save(namespaces) {
      if (null == namespaces) {
        delete process.env.DEBUG;
      } else {
        process.env.DEBUG = namespaces;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function createWritableStdioStream(fd2) {
      var stream2;
      var tty_wrap = process.binding("tty_wrap");
      switch (tty_wrap.guessHandleType(fd2)) {
        case "TTY":
          stream2 = new tty.WriteStream(fd2);
          stream2._type = "tty";
          if (stream2._handle && stream2._handle.unref) {
            stream2._handle.unref();
          }
          break;
        case "FILE":
          var fs2 = require("fs");
          stream2 = new fs2.SyncWriteStream(fd2, { autoClose: false });
          stream2._type = "fs";
          break;
        case "PIPE":
        case "TCP":
          var net2 = require("net");
          stream2 = new net2.Socket({
            fd: fd2,
            readable: false,
            writable: true
          });
          stream2.readable = false;
          stream2.read = null;
          stream2._type = "pipe";
          if (stream2._handle && stream2._handle.unref) {
            stream2._handle.unref();
          }
          break;
        default:
          throw new Error("Implement me. Unknown stream file type!");
      }
      stream2.fd = fd2;
      stream2._isStdio = true;
      return stream2;
    }
    function init(debug) {
      debug.inspectOpts = {};
      var keys = Object.keys(exports2.inspectOpts);
      for (var i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    exports2.enable(load());
  }
});

// ../../node_modules/websocket/node_modules/debug/src/index.js
var require_src2 = __commonJS({
  "../../node_modules/websocket/node_modules/debug/src/index.js"(exports2, module2) {
    "use strict";
    if (typeof process !== "undefined" && process.type === "renderer") {
      module2.exports = require_browser2();
    } else {
      module2.exports = require_node2();
    }
  }
});

// ../../node_modules/websocket/lib/utils.js
var require_utils2 = __commonJS({
  "../../node_modules/websocket/lib/utils.js"(exports2) {
    "use strict";
    var noop = exports2.noop = function() {
    };
    exports2.extend = function extend(dest, source) {
      for (var prop in source) {
        dest[prop] = source[prop];
      }
    };
    exports2.eventEmitterListenerCount = require("events").EventEmitter.listenerCount || function(emitter, type) {
      return emitter.listeners(type).length;
    };
    exports2.bufferAllocUnsafe = Buffer.allocUnsafe ? Buffer.allocUnsafe : function oldBufferAllocUnsafe(size) {
      return new Buffer(size);
    };
    exports2.bufferFromString = Buffer.from ? Buffer.from : function oldBufferFromString(string, encoding) {
      return new Buffer(string, encoding);
    };
    exports2.BufferingLogger = function createBufferingLogger(identifier, uniqueID) {
      var logFunction = require_src2()(identifier);
      if (logFunction.enabled) {
        var logger = new BufferingLogger(identifier, uniqueID, logFunction);
        var debug = logger.log.bind(logger);
        debug.printOutput = logger.printOutput.bind(logger);
        debug.enabled = logFunction.enabled;
        return debug;
      }
      logFunction.printOutput = noop;
      return logFunction;
    };
    function BufferingLogger(identifier, uniqueID, logFunction) {
      this.logFunction = logFunction;
      this.identifier = identifier;
      this.uniqueID = uniqueID;
      this.buffer = [];
    }
    BufferingLogger.prototype.log = function() {
      this.buffer.push([/* @__PURE__ */ new Date(), Array.prototype.slice.call(arguments)]);
      return this;
    };
    BufferingLogger.prototype.clear = function() {
      this.buffer = [];
      return this;
    };
    BufferingLogger.prototype.printOutput = function(logFunction) {
      if (!logFunction) {
        logFunction = this.logFunction;
      }
      var uniqueID = this.uniqueID;
      this.buffer.forEach(function(entry) {
        var date = entry[0].toLocaleString();
        var args = entry[1].slice();
        var formatString = args[0];
        if (formatString !== void 0 && formatString !== null) {
          formatString = "%s - %s - " + formatString.toString();
          args.splice(0, 1, formatString, date, uniqueID);
          logFunction.apply(global, args);
        }
      });
    };
  }
});

// ../../node_modules/node-gyp-build/node-gyp-build.js
var require_node_gyp_build = __commonJS({
  "../../node_modules/node-gyp-build/node-gyp-build.js"(exports2, module2) {
    "use strict";
    var fs2 = require("fs");
    var path2 = require("path");
    var os3 = require("os");
    var runtimeRequire = typeof __webpack_require__ === "function" ? __non_webpack_require__ : require;
    var vars = process.config && process.config.variables || {};
    var prebuildsOnly = !!process.env.PREBUILDS_ONLY;
    var abi = process.versions.modules;
    var runtime = isElectron() ? "electron" : isNwjs() ? "node-webkit" : "node";
    var arch = process.env.npm_config_arch || os3.arch();
    var platform = process.env.npm_config_platform || os3.platform();
    var libc = process.env.LIBC || (isAlpine(platform) ? "musl" : "glibc");
    var armv = process.env.ARM_VERSION || (arch === "arm64" ? "8" : vars.arm_version) || "";
    var uv = (process.versions.uv || "").split(".")[0];
    module2.exports = load;
    function load(dir) {
      return runtimeRequire(load.resolve(dir));
    }
    load.resolve = load.path = function(dir) {
      dir = path2.resolve(dir || ".");
      try {
        var name = runtimeRequire(path2.join(dir, "package.json")).name.toUpperCase().replace(/-/g, "_");
        if (process.env[name + "_PREBUILD"]) dir = process.env[name + "_PREBUILD"];
      } catch (err) {
      }
      if (!prebuildsOnly) {
        var release = getFirst(path2.join(dir, "build/Release"), matchBuild);
        if (release) return release;
        var debug = getFirst(path2.join(dir, "build/Debug"), matchBuild);
        if (debug) return debug;
      }
      var prebuild = resolve3(dir);
      if (prebuild) return prebuild;
      var nearby = resolve3(path2.dirname(process.execPath));
      if (nearby) return nearby;
      var target = [
        "platform=" + platform,
        "arch=" + arch,
        "runtime=" + runtime,
        "abi=" + abi,
        "uv=" + uv,
        armv ? "armv=" + armv : "",
        "libc=" + libc,
        "node=" + process.versions.node,
        process.versions.electron ? "electron=" + process.versions.electron : "",
        typeof __webpack_require__ === "function" ? "webpack=true" : ""
        // eslint-disable-line
      ].filter(Boolean).join(" ");
      throw new Error("No native build was found for " + target + "\n    loaded from: " + dir + "\n");
      function resolve3(dir2) {
        var tuples = readdirSync(path2.join(dir2, "prebuilds")).map(parseTuple);
        var tuple = tuples.filter(matchTuple(platform, arch)).sort(compareTuples)[0];
        if (!tuple) return;
        var prebuilds = path2.join(dir2, "prebuilds", tuple.name);
        var parsed = readdirSync(prebuilds).map(parseTags);
        var candidates = parsed.filter(matchTags(runtime, abi));
        var winner = candidates.sort(compareTags(runtime))[0];
        if (winner) return path2.join(prebuilds, winner.file);
      }
    };
    function readdirSync(dir) {
      try {
        return fs2.readdirSync(dir);
      } catch (err) {
        return [];
      }
    }
    function getFirst(dir, filter) {
      var files = readdirSync(dir).filter(filter);
      return files[0] && path2.join(dir, files[0]);
    }
    function matchBuild(name) {
      return /\.node$/.test(name);
    }
    function parseTuple(name) {
      var arr = name.split("-");
      if (arr.length !== 2) return;
      var platform2 = arr[0];
      var architectures = arr[1].split("+");
      if (!platform2) return;
      if (!architectures.length) return;
      if (!architectures.every(Boolean)) return;
      return { name, platform: platform2, architectures };
    }
    function matchTuple(platform2, arch2) {
      return function(tuple) {
        if (tuple == null) return false;
        if (tuple.platform !== platform2) return false;
        return tuple.architectures.includes(arch2);
      };
    }
    function compareTuples(a, b) {
      return a.architectures.length - b.architectures.length;
    }
    function parseTags(file) {
      var arr = file.split(".");
      var extension = arr.pop();
      var tags = { file, specificity: 0 };
      if (extension !== "node") return;
      for (var i = 0; i < arr.length; i++) {
        var tag = arr[i];
        if (tag === "node" || tag === "electron" || tag === "node-webkit") {
          tags.runtime = tag;
        } else if (tag === "napi") {
          tags.napi = true;
        } else if (tag.slice(0, 3) === "abi") {
          tags.abi = tag.slice(3);
        } else if (tag.slice(0, 2) === "uv") {
          tags.uv = tag.slice(2);
        } else if (tag.slice(0, 4) === "armv") {
          tags.armv = tag.slice(4);
        } else if (tag === "glibc" || tag === "musl") {
          tags.libc = tag;
        } else {
          continue;
        }
        tags.specificity++;
      }
      return tags;
    }
    function matchTags(runtime2, abi2) {
      return function(tags) {
        if (tags == null) return false;
        if (tags.runtime && tags.runtime !== runtime2 && !runtimeAgnostic(tags)) return false;
        if (tags.abi && tags.abi !== abi2 && !tags.napi) return false;
        if (tags.uv && tags.uv !== uv) return false;
        if (tags.armv && tags.armv !== armv) return false;
        if (tags.libc && tags.libc !== libc) return false;
        return true;
      };
    }
    function runtimeAgnostic(tags) {
      return tags.runtime === "node" && tags.napi;
    }
    function compareTags(runtime2) {
      return function(a, b) {
        if (a.runtime !== b.runtime) {
          return a.runtime === runtime2 ? -1 : 1;
        } else if (a.abi !== b.abi) {
          return a.abi ? -1 : 1;
        } else if (a.specificity !== b.specificity) {
          return a.specificity > b.specificity ? -1 : 1;
        } else {
          return 0;
        }
      };
    }
    function isNwjs() {
      return !!(process.versions && process.versions.nw);
    }
    function isElectron() {
      if (process.versions && process.versions.electron) return true;
      if (process.env.ELECTRON_RUN_AS_NODE) return true;
      return typeof window !== "undefined" && window.process && window.process.type === "renderer";
    }
    function isAlpine(platform2) {
      return platform2 === "linux" && fs2.existsSync("/etc/alpine-release");
    }
    load.parseTags = parseTags;
    load.matchTags = matchTags;
    load.compareTags = compareTags;
    load.parseTuple = parseTuple;
    load.matchTuple = matchTuple;
    load.compareTuples = compareTuples;
  }
});

// ../../node_modules/node-gyp-build/index.js
var require_node_gyp_build2 = __commonJS({
  "../../node_modules/node-gyp-build/index.js"(exports2, module2) {
    "use strict";
    var runtimeRequire = typeof __webpack_require__ === "function" ? __non_webpack_require__ : require;
    if (typeof runtimeRequire.addon === "function") {
      module2.exports = runtimeRequire.addon.bind(runtimeRequire);
    } else {
      module2.exports = require_node_gyp_build();
    }
  }
});

// ../../node_modules/bufferutil/fallback.js
var require_fallback = __commonJS({
  "../../node_modules/bufferutil/fallback.js"(exports2, module2) {
    "use strict";
    var mask = (source, mask2, output, offset, length) => {
      for (var i = 0; i < length; i++) {
        output[offset + i] = source[i] ^ mask2[i & 3];
      }
    };
    var unmask = (buffer, mask2) => {
      const length = buffer.length;
      for (var i = 0; i < length; i++) {
        buffer[i] ^= mask2[i & 3];
      }
    };
    module2.exports = { mask, unmask };
  }
});

// ../../node_modules/bufferutil/index.js
var require_bufferutil = __commonJS({
  "../../node_modules/bufferutil/index.js"(exports2, module2) {
    "use strict";
    try {
      module2.exports = require_node_gyp_build2()(__dirname);
    } catch (e) {
      module2.exports = require_fallback();
    }
  }
});

// ../../node_modules/websocket/lib/WebSocketFrame.js
var require_WebSocketFrame = __commonJS({
  "../../node_modules/websocket/lib/WebSocketFrame.js"(exports2, module2) {
    "use strict";
    var bufferUtil = require_bufferutil();
    var bufferAllocUnsafe = require_utils2().bufferAllocUnsafe;
    var DECODE_HEADER = 1;
    var WAITING_FOR_16_BIT_LENGTH = 2;
    var WAITING_FOR_64_BIT_LENGTH = 3;
    var WAITING_FOR_MASK_KEY = 4;
    var WAITING_FOR_PAYLOAD = 5;
    var COMPLETE = 6;
    function WebSocketFrame(maskBytes, frameHeader, config) {
      this.maskBytes = maskBytes;
      this.frameHeader = frameHeader;
      this.config = config;
      this.maxReceivedFrameSize = config.maxReceivedFrameSize;
      this.protocolError = false;
      this.frameTooLarge = false;
      this.invalidCloseFrameLength = false;
      this.parseState = DECODE_HEADER;
      this.closeStatus = -1;
    }
    WebSocketFrame.prototype.addData = function(bufferList) {
      if (this.parseState === DECODE_HEADER) {
        if (bufferList.length >= 2) {
          bufferList.joinInto(this.frameHeader, 0, 0, 2);
          bufferList.advance(2);
          var firstByte = this.frameHeader[0];
          var secondByte = this.frameHeader[1];
          this.fin = Boolean(firstByte & 128);
          this.rsv1 = Boolean(firstByte & 64);
          this.rsv2 = Boolean(firstByte & 32);
          this.rsv3 = Boolean(firstByte & 16);
          this.mask = Boolean(secondByte & 128);
          this.opcode = firstByte & 15;
          this.length = secondByte & 127;
          if (this.opcode >= 8) {
            if (this.length > 125) {
              this.protocolError = true;
              this.dropReason = "Illegal control frame longer than 125 bytes.";
              return true;
            }
            if (!this.fin) {
              this.protocolError = true;
              this.dropReason = "Control frames must not be fragmented.";
              return true;
            }
          }
          if (this.length === 126) {
            this.parseState = WAITING_FOR_16_BIT_LENGTH;
          } else if (this.length === 127) {
            this.parseState = WAITING_FOR_64_BIT_LENGTH;
          } else {
            this.parseState = WAITING_FOR_MASK_KEY;
          }
        }
      }
      if (this.parseState === WAITING_FOR_16_BIT_LENGTH) {
        if (bufferList.length >= 2) {
          bufferList.joinInto(this.frameHeader, 2, 0, 2);
          bufferList.advance(2);
          this.length = this.frameHeader.readUInt16BE(2);
          this.parseState = WAITING_FOR_MASK_KEY;
        }
      } else if (this.parseState === WAITING_FOR_64_BIT_LENGTH) {
        if (bufferList.length >= 8) {
          bufferList.joinInto(this.frameHeader, 2, 0, 8);
          bufferList.advance(8);
          var lengthPair = [
            this.frameHeader.readUInt32BE(2),
            this.frameHeader.readUInt32BE(2 + 4)
          ];
          if (lengthPair[0] !== 0) {
            this.protocolError = true;
            this.dropReason = "Unsupported 64-bit length frame received";
            return true;
          }
          this.length = lengthPair[1];
          this.parseState = WAITING_FOR_MASK_KEY;
        }
      }
      if (this.parseState === WAITING_FOR_MASK_KEY) {
        if (this.mask) {
          if (bufferList.length >= 4) {
            bufferList.joinInto(this.maskBytes, 0, 0, 4);
            bufferList.advance(4);
            this.parseState = WAITING_FOR_PAYLOAD;
          }
        } else {
          this.parseState = WAITING_FOR_PAYLOAD;
        }
      }
      if (this.parseState === WAITING_FOR_PAYLOAD) {
        if (this.length > this.maxReceivedFrameSize) {
          this.frameTooLarge = true;
          this.dropReason = "Frame size of " + this.length.toString(10) + " bytes exceeds maximum accepted frame size";
          return true;
        }
        if (this.length === 0) {
          this.binaryPayload = bufferAllocUnsafe(0);
          this.parseState = COMPLETE;
          return true;
        }
        if (bufferList.length >= this.length) {
          this.binaryPayload = bufferList.take(this.length);
          bufferList.advance(this.length);
          if (this.mask) {
            bufferUtil.unmask(this.binaryPayload, this.maskBytes);
          }
          if (this.opcode === 8) {
            if (this.length === 1) {
              this.binaryPayload = bufferAllocUnsafe(0);
              this.invalidCloseFrameLength = true;
            }
            if (this.length >= 2) {
              this.closeStatus = this.binaryPayload.readUInt16BE(0);
              this.binaryPayload = this.binaryPayload.slice(2);
            }
          }
          this.parseState = COMPLETE;
          return true;
        }
      }
      return false;
    };
    WebSocketFrame.prototype.throwAwayPayload = function(bufferList) {
      if (bufferList.length >= this.length) {
        bufferList.advance(this.length);
        this.parseState = COMPLETE;
        return true;
      }
      return false;
    };
    WebSocketFrame.prototype.toBuffer = function(nullMask) {
      var maskKey;
      var headerLength = 2;
      var data;
      var outputPos;
      var firstByte = 0;
      var secondByte = 0;
      if (this.fin) {
        firstByte |= 128;
      }
      if (this.rsv1) {
        firstByte |= 64;
      }
      if (this.rsv2) {
        firstByte |= 32;
      }
      if (this.rsv3) {
        firstByte |= 16;
      }
      if (this.mask) {
        secondByte |= 128;
      }
      firstByte |= this.opcode & 15;
      if (this.opcode === 8) {
        this.length = 2;
        if (this.binaryPayload) {
          this.length += this.binaryPayload.length;
        }
        data = bufferAllocUnsafe(this.length);
        data.writeUInt16BE(this.closeStatus, 0);
        if (this.length > 2) {
          this.binaryPayload.copy(data, 2);
        }
      } else if (this.binaryPayload) {
        data = this.binaryPayload;
        this.length = data.length;
      } else {
        this.length = 0;
      }
      if (this.length <= 125) {
        secondByte |= this.length & 127;
      } else if (this.length > 125 && this.length <= 65535) {
        secondByte |= 126;
        headerLength += 2;
      } else if (this.length > 65535) {
        secondByte |= 127;
        headerLength += 8;
      }
      var output = bufferAllocUnsafe(this.length + headerLength + (this.mask ? 4 : 0));
      output[0] = firstByte;
      output[1] = secondByte;
      outputPos = 2;
      if (this.length > 125 && this.length <= 65535) {
        output.writeUInt16BE(this.length, outputPos);
        outputPos += 2;
      } else if (this.length > 65535) {
        output.writeUInt32BE(0, outputPos);
        output.writeUInt32BE(this.length, outputPos + 4);
        outputPos += 8;
      }
      if (this.mask) {
        maskKey = nullMask ? 0 : Math.random() * 4294967295 >>> 0;
        this.maskBytes.writeUInt32BE(maskKey, 0);
        this.maskBytes.copy(output, outputPos);
        outputPos += 4;
        if (data) {
          bufferUtil.mask(data, this.maskBytes, output, outputPos, this.length);
        }
      } else if (data) {
        data.copy(output, outputPos);
      }
      return output;
    };
    WebSocketFrame.prototype.toString = function() {
      return "Opcode: " + this.opcode + ", fin: " + this.fin + ", length: " + this.length + ", hasPayload: " + Boolean(this.binaryPayload) + ", masked: " + this.mask;
    };
    module2.exports = WebSocketFrame;
  }
});

// ../../node_modules/websocket/vendor/FastBufferList.js
var require_FastBufferList = __commonJS({
  "../../node_modules/websocket/vendor/FastBufferList.js"(exports2, module2) {
    "use strict";
    var Buffer2 = require("buffer").Buffer;
    var EventEmitter = require("events").EventEmitter;
    var bufferAllocUnsafe = require_utils2().bufferAllocUnsafe;
    module2.exports = BufferList;
    module2.exports.BufferList = BufferList;
    function BufferList(opts) {
      if (!(this instanceof BufferList)) return new BufferList(opts);
      EventEmitter.call(this);
      var self2 = this;
      if (typeof opts == "undefined") opts = {};
      self2.encoding = opts.encoding;
      var head = { next: null, buffer: null };
      var last = { next: null, buffer: null };
      var length = 0;
      self2.__defineGetter__("length", function() {
        return length;
      });
      var offset = 0;
      self2.write = function(buf) {
        if (!head.buffer) {
          head.buffer = buf;
          last = head;
        } else {
          last.next = { next: null, buffer: buf };
          last = last.next;
        }
        length += buf.length;
        self2.emit("write", buf);
        return true;
      };
      self2.end = function(buf) {
        if (Buffer2.isBuffer(buf)) self2.write(buf);
      };
      self2.push = function() {
        var args = [].concat.apply([], arguments);
        args.forEach(self2.write);
        return self2;
      };
      self2.forEach = function(fn) {
        if (!head.buffer) return bufferAllocUnsafe(0);
        if (head.buffer.length - offset <= 0) return self2;
        var firstBuf = head.buffer.slice(offset);
        var b = { buffer: firstBuf, next: head.next };
        while (b && b.buffer) {
          var r = fn(b.buffer);
          if (r) break;
          b = b.next;
        }
        return self2;
      };
      self2.join = function(start, end) {
        if (!head.buffer) return bufferAllocUnsafe(0);
        if (start == void 0) start = 0;
        if (end == void 0) end = self2.length;
        var big = bufferAllocUnsafe(end - start);
        var ix = 0;
        self2.forEach(function(buffer) {
          if (start < ix + buffer.length && ix < end) {
            buffer.copy(
              big,
              Math.max(0, ix - start),
              Math.max(0, start - ix),
              Math.min(buffer.length, end - ix)
            );
          }
          ix += buffer.length;
          if (ix > end) return true;
        });
        return big;
      };
      self2.joinInto = function(targetBuffer, targetStart, sourceStart, sourceEnd) {
        if (!head.buffer) return new bufferAllocUnsafe(0);
        if (sourceStart == void 0) sourceStart = 0;
        if (sourceEnd == void 0) sourceEnd = self2.length;
        var big = targetBuffer;
        if (big.length - targetStart < sourceEnd - sourceStart) {
          throw new Error("Insufficient space available in target Buffer.");
        }
        var ix = 0;
        self2.forEach(function(buffer) {
          if (sourceStart < ix + buffer.length && ix < sourceEnd) {
            buffer.copy(
              big,
              Math.max(targetStart, targetStart + ix - sourceStart),
              Math.max(0, sourceStart - ix),
              Math.min(buffer.length, sourceEnd - ix)
            );
          }
          ix += buffer.length;
          if (ix > sourceEnd) return true;
        });
        return big;
      };
      self2.advance = function(n) {
        offset += n;
        length -= n;
        while (head.buffer && offset >= head.buffer.length) {
          offset -= head.buffer.length;
          head = head.next ? head.next : { buffer: null, next: null };
        }
        if (head.buffer === null) last = { next: null, buffer: null };
        self2.emit("advance", n);
        return self2;
      };
      self2.take = function(n, encoding) {
        if (n == void 0) n = self2.length;
        else if (typeof n !== "number") {
          encoding = n;
          n = self2.length;
        }
        var b = head;
        if (!encoding) encoding = self2.encoding;
        if (encoding) {
          var acc = "";
          self2.forEach(function(buffer) {
            if (n <= 0) return true;
            acc += buffer.toString(
              encoding,
              0,
              Math.min(n, buffer.length)
            );
            n -= buffer.length;
          });
          return acc;
        } else {
          return self2.join(0, n);
        }
      };
      self2.toString = function() {
        return self2.take("binary");
      };
    }
    require("util").inherits(BufferList, EventEmitter);
  }
});

// ../../node_modules/utf-8-validate/fallback.js
var require_fallback2 = __commonJS({
  "../../node_modules/utf-8-validate/fallback.js"(exports2, module2) {
    "use strict";
    function isValidUTF8(buf) {
      const len = buf.length;
      let i = 0;
      while (i < len) {
        if ((buf[i] & 128) === 0) {
          i++;
        } else if ((buf[i] & 224) === 192) {
          if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {
            return false;
          }
          i += 2;
        } else if ((buf[i] & 240) === 224) {
          if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || // overlong
          buf[i] === 237 && (buf[i + 1] & 224) === 160) {
            return false;
          }
          i += 3;
        } else if ((buf[i] & 248) === 240) {
          if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || // overlong
          buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) {
            return false;
          }
          i += 4;
        } else {
          return false;
        }
      }
      return true;
    }
    module2.exports = isValidUTF8;
  }
});

// ../../node_modules/utf-8-validate/index.js
var require_utf_8_validate = __commonJS({
  "../../node_modules/utf-8-validate/index.js"(exports2, module2) {
    "use strict";
    try {
      module2.exports = require_node_gyp_build2()(__dirname);
    } catch (e) {
      module2.exports = require_fallback2();
    }
  }
});

// ../../node_modules/websocket/lib/WebSocketConnection.js
var require_WebSocketConnection = __commonJS({
  "../../node_modules/websocket/lib/WebSocketConnection.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var utils = require_utils2();
    var EventEmitter = require("events").EventEmitter;
    var WebSocketFrame = require_WebSocketFrame();
    var BufferList = require_FastBufferList();
    var isValidUTF8 = require_utf_8_validate();
    var bufferAllocUnsafe = utils.bufferAllocUnsafe;
    var bufferFromString = utils.bufferFromString;
    var STATE_OPEN = "open";
    var STATE_PEER_REQUESTED_CLOSE = "peer_requested_close";
    var STATE_ENDING = "ending";
    var STATE_CLOSED = "closed";
    var setImmediateImpl = "setImmediate" in global ? global.setImmediate.bind(global) : process.nextTick.bind(process);
    var idCounter = 0;
    function WebSocketConnection(socket, extensions, protocol, maskOutgoingPackets, config) {
      this._debug = utils.BufferingLogger("websocket:connection", ++idCounter);
      this._debug("constructor");
      if (this._debug.enabled) {
        instrumentSocketForDebugging(this, socket);
      }
      EventEmitter.call(this);
      this._pingListenerCount = 0;
      this.on("newListener", function(ev) {
        if (ev === "ping") {
          this._pingListenerCount++;
        }
      }).on("removeListener", function(ev) {
        if (ev === "ping") {
          this._pingListenerCount--;
        }
      });
      this.config = config;
      this.socket = socket;
      this.protocol = protocol;
      this.extensions = extensions;
      this.remoteAddress = socket.remoteAddress;
      this.closeReasonCode = -1;
      this.closeDescription = null;
      this.closeEventEmitted = false;
      this.maskOutgoingPackets = maskOutgoingPackets;
      this.maskBytes = bufferAllocUnsafe(4);
      this.frameHeader = bufferAllocUnsafe(10);
      this.bufferList = new BufferList();
      this.currentFrame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);
      this.fragmentationSize = 0;
      this.frameQueue = [];
      this.connected = true;
      this.state = STATE_OPEN;
      this.waitingForCloseResponse = false;
      this.receivedEnd = false;
      this.closeTimeout = this.config.closeTimeout;
      this.assembleFragments = this.config.assembleFragments;
      this.maxReceivedMessageSize = this.config.maxReceivedMessageSize;
      this.outputBufferFull = false;
      this.inputPaused = false;
      this.receivedDataHandler = this.processReceivedData.bind(this);
      this._closeTimerHandler = this.handleCloseTimer.bind(this);
      this.socket.setNoDelay(this.config.disableNagleAlgorithm);
      this.socket.setTimeout(0);
      if (this.config.keepalive && !this.config.useNativeKeepalive) {
        if (typeof this.config.keepaliveInterval !== "number") {
          throw new Error("keepaliveInterval must be specified and numeric if keepalive is true.");
        }
        this._keepaliveTimerHandler = this.handleKeepaliveTimer.bind(this);
        this.setKeepaliveTimer();
        if (this.config.dropConnectionOnKeepaliveTimeout) {
          if (typeof this.config.keepaliveGracePeriod !== "number") {
            throw new Error("keepaliveGracePeriod  must be specified and numeric if dropConnectionOnKeepaliveTimeout is true.");
          }
          this._gracePeriodTimerHandler = this.handleGracePeriodTimer.bind(this);
        }
      } else if (this.config.keepalive && this.config.useNativeKeepalive) {
        if (!("setKeepAlive" in this.socket)) {
          throw new Error("Unable to use native keepalive: unsupported by this version of Node.");
        }
        this.socket.setKeepAlive(true, this.config.keepaliveInterval);
      }
      this.socket.removeAllListeners("error");
    }
    WebSocketConnection.CLOSE_REASON_NORMAL = 1e3;
    WebSocketConnection.CLOSE_REASON_GOING_AWAY = 1001;
    WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR = 1002;
    WebSocketConnection.CLOSE_REASON_UNPROCESSABLE_INPUT = 1003;
    WebSocketConnection.CLOSE_REASON_RESERVED = 1004;
    WebSocketConnection.CLOSE_REASON_NOT_PROVIDED = 1005;
    WebSocketConnection.CLOSE_REASON_ABNORMAL = 1006;
    WebSocketConnection.CLOSE_REASON_INVALID_DATA = 1007;
    WebSocketConnection.CLOSE_REASON_POLICY_VIOLATION = 1008;
    WebSocketConnection.CLOSE_REASON_MESSAGE_TOO_BIG = 1009;
    WebSocketConnection.CLOSE_REASON_EXTENSION_REQUIRED = 1010;
    WebSocketConnection.CLOSE_REASON_INTERNAL_SERVER_ERROR = 1011;
    WebSocketConnection.CLOSE_REASON_TLS_HANDSHAKE_FAILED = 1015;
    WebSocketConnection.CLOSE_DESCRIPTIONS = {
      1e3: "Normal connection closure",
      1001: "Remote peer is going away",
      1002: "Protocol error",
      1003: "Unprocessable input",
      1004: "Reserved",
      1005: "Reason not provided",
      1006: "Abnormal closure, no further detail available",
      1007: "Invalid data received",
      1008: "Policy violation",
      1009: "Message too big",
      1010: "Extension requested by client is required",
      1011: "Internal Server Error",
      1015: "TLS Handshake Failed"
    };
    function validateCloseReason(code) {
      if (code < 1e3) {
        return false;
      }
      if (code >= 1e3 && code <= 2999) {
        return [1e3, 1001, 1002, 1003, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015].indexOf(code) !== -1;
      }
      if (code >= 3e3 && code <= 3999) {
        return true;
      }
      if (code >= 4e3 && code <= 4999) {
        return true;
      }
      if (code >= 5e3) {
        return false;
      }
    }
    util.inherits(WebSocketConnection, EventEmitter);
    WebSocketConnection.prototype._addSocketEventListeners = function() {
      this.socket.on("error", this.handleSocketError.bind(this));
      this.socket.on("end", this.handleSocketEnd.bind(this));
      this.socket.on("close", this.handleSocketClose.bind(this));
      this.socket.on("drain", this.handleSocketDrain.bind(this));
      this.socket.on("pause", this.handleSocketPause.bind(this));
      this.socket.on("resume", this.handleSocketResume.bind(this));
      this.socket.on("data", this.handleSocketData.bind(this));
    };
    WebSocketConnection.prototype.setKeepaliveTimer = function() {
      this._debug("setKeepaliveTimer");
      if (!this.config.keepalive || this.config.useNativeKeepalive) {
        return;
      }
      this.clearKeepaliveTimer();
      this.clearGracePeriodTimer();
      this._keepaliveTimeoutID = setTimeout(this._keepaliveTimerHandler, this.config.keepaliveInterval);
    };
    WebSocketConnection.prototype.clearKeepaliveTimer = function() {
      if (this._keepaliveTimeoutID) {
        clearTimeout(this._keepaliveTimeoutID);
      }
    };
    WebSocketConnection.prototype.handleKeepaliveTimer = function() {
      this._debug("handleKeepaliveTimer");
      this._keepaliveTimeoutID = null;
      this.ping();
      if (this.config.dropConnectionOnKeepaliveTimeout) {
        this.setGracePeriodTimer();
      } else {
        this.setKeepaliveTimer();
      }
    };
    WebSocketConnection.prototype.setGracePeriodTimer = function() {
      this._debug("setGracePeriodTimer");
      this.clearGracePeriodTimer();
      this._gracePeriodTimeoutID = setTimeout(this._gracePeriodTimerHandler, this.config.keepaliveGracePeriod);
    };
    WebSocketConnection.prototype.clearGracePeriodTimer = function() {
      if (this._gracePeriodTimeoutID) {
        clearTimeout(this._gracePeriodTimeoutID);
      }
    };
    WebSocketConnection.prototype.handleGracePeriodTimer = function() {
      this._debug("handleGracePeriodTimer");
      this._gracePeriodTimeoutID = null;
      this.drop(WebSocketConnection.CLOSE_REASON_ABNORMAL, "Peer not responding.", true);
    };
    WebSocketConnection.prototype.handleSocketData = function(data) {
      this._debug("handleSocketData");
      this.setKeepaliveTimer();
      this.bufferList.write(data);
      this.processReceivedData();
    };
    WebSocketConnection.prototype.processReceivedData = function() {
      this._debug("processReceivedData");
      if (!this.connected) {
        return;
      }
      if (this.inputPaused) {
        return;
      }
      var frame = this.currentFrame;
      if (!frame.addData(this.bufferList)) {
        this._debug("-- insufficient data for frame");
        return;
      }
      var self2 = this;
      if (frame.protocolError) {
        this._debug("-- protocol error");
        process.nextTick(function() {
          self2.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR, frame.dropReason);
        });
        return;
      } else if (frame.frameTooLarge) {
        this._debug("-- frame too large");
        process.nextTick(function() {
          self2.drop(WebSocketConnection.CLOSE_REASON_MESSAGE_TOO_BIG, frame.dropReason);
        });
        return;
      }
      if (frame.rsv1 || frame.rsv2 || frame.rsv3) {
        this._debug("-- illegal rsv flag");
        process.nextTick(function() {
          self2.drop(
            WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR,
            "Unsupported usage of rsv bits without negotiated extension."
          );
        });
        return;
      }
      if (!this.assembleFragments) {
        this._debug("-- emitting frame");
        process.nextTick(function() {
          self2.emit("frame", frame);
        });
      }
      process.nextTick(function() {
        self2.processFrame(frame);
      });
      this.currentFrame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);
      if (this.bufferList.length > 0) {
        setImmediateImpl(this.receivedDataHandler);
      }
    };
    WebSocketConnection.prototype.handleSocketError = function(error) {
      this._debug("handleSocketError: %j", error);
      if (this.state === STATE_CLOSED) {
        this._debug("  --- Socket 'error' after 'close'");
        return;
      }
      this.closeReasonCode = WebSocketConnection.CLOSE_REASON_ABNORMAL;
      this.closeDescription = "Socket Error: " + error.syscall + " " + error.code;
      this.connected = false;
      this.state = STATE_CLOSED;
      this.fragmentationSize = 0;
      if (utils.eventEmitterListenerCount(this, "error") > 0) {
        this.emit("error", error);
      }
      this.socket.destroy();
      this._debug.printOutput();
    };
    WebSocketConnection.prototype.handleSocketEnd = function() {
      this._debug("handleSocketEnd: received socket end.  state = %s", this.state);
      this.receivedEnd = true;
      if (this.state === STATE_CLOSED) {
        this._debug("  --- Socket 'end' after 'close'");
        return;
      }
      if (this.state !== STATE_PEER_REQUESTED_CLOSE && this.state !== STATE_ENDING) {
        this._debug("  --- UNEXPECTED socket end.");
        this.socket.end();
      }
    };
    WebSocketConnection.prototype.handleSocketClose = function(hadError) {
      this._debug("handleSocketClose: received socket close");
      this.socketHadError = hadError;
      this.connected = false;
      this.state = STATE_CLOSED;
      if (this.closeReasonCode === -1) {
        this.closeReasonCode = WebSocketConnection.CLOSE_REASON_ABNORMAL;
        this.closeDescription = "Connection dropped by remote peer.";
      }
      this.clearCloseTimer();
      this.clearKeepaliveTimer();
      this.clearGracePeriodTimer();
      if (!this.closeEventEmitted) {
        this.closeEventEmitted = true;
        this._debug("-- Emitting WebSocketConnection close event");
        this.emit("close", this.closeReasonCode, this.closeDescription);
      }
    };
    WebSocketConnection.prototype.handleSocketDrain = function() {
      this._debug("handleSocketDrain: socket drain event");
      this.outputBufferFull = false;
      this.emit("drain");
    };
    WebSocketConnection.prototype.handleSocketPause = function() {
      this._debug("handleSocketPause: socket pause event");
      this.inputPaused = true;
      this.emit("pause");
    };
    WebSocketConnection.prototype.handleSocketResume = function() {
      this._debug("handleSocketResume: socket resume event");
      this.inputPaused = false;
      this.emit("resume");
      this.processReceivedData();
    };
    WebSocketConnection.prototype.pause = function() {
      this._debug("pause: pause requested");
      this.socket.pause();
    };
    WebSocketConnection.prototype.resume = function() {
      this._debug("resume: resume requested");
      this.socket.resume();
    };
    WebSocketConnection.prototype.close = function(reasonCode, description) {
      if (this.connected) {
        this._debug("close: Initating clean WebSocket close sequence.");
        if ("number" !== typeof reasonCode) {
          reasonCode = WebSocketConnection.CLOSE_REASON_NORMAL;
        }
        if (!validateCloseReason(reasonCode)) {
          throw new Error("Close code " + reasonCode + " is not valid.");
        }
        if ("string" !== typeof description) {
          description = WebSocketConnection.CLOSE_DESCRIPTIONS[reasonCode];
        }
        this.closeReasonCode = reasonCode;
        this.closeDescription = description;
        this.setCloseTimer();
        this.sendCloseFrame(this.closeReasonCode, this.closeDescription);
        this.state = STATE_ENDING;
        this.connected = false;
      }
    };
    WebSocketConnection.prototype.drop = function(reasonCode, description, skipCloseFrame) {
      this._debug("drop");
      if (typeof reasonCode !== "number") {
        reasonCode = WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR;
      }
      if (typeof description !== "string") {
        description = WebSocketConnection.CLOSE_DESCRIPTIONS[reasonCode];
      }
      this._debug(
        "Forcefully dropping connection. skipCloseFrame: %s, code: %d, description: %s",
        skipCloseFrame,
        reasonCode,
        description
      );
      this.closeReasonCode = reasonCode;
      this.closeDescription = description;
      this.frameQueue = [];
      this.fragmentationSize = 0;
      if (!skipCloseFrame) {
        this.sendCloseFrame(reasonCode, description);
      }
      this.connected = false;
      this.state = STATE_CLOSED;
      this.clearCloseTimer();
      this.clearKeepaliveTimer();
      this.clearGracePeriodTimer();
      if (!this.closeEventEmitted) {
        this.closeEventEmitted = true;
        this._debug("Emitting WebSocketConnection close event");
        this.emit("close", this.closeReasonCode, this.closeDescription);
      }
      this._debug("Drop: destroying socket");
      this.socket.destroy();
    };
    WebSocketConnection.prototype.setCloseTimer = function() {
      this._debug("setCloseTimer");
      this.clearCloseTimer();
      this._debug("Setting close timer");
      this.waitingForCloseResponse = true;
      this.closeTimer = setTimeout(this._closeTimerHandler, this.closeTimeout);
    };
    WebSocketConnection.prototype.clearCloseTimer = function() {
      this._debug("clearCloseTimer");
      if (this.closeTimer) {
        this._debug("Clearing close timer");
        clearTimeout(this.closeTimer);
        this.waitingForCloseResponse = false;
        this.closeTimer = null;
      }
    };
    WebSocketConnection.prototype.handleCloseTimer = function() {
      this._debug("handleCloseTimer");
      this.closeTimer = null;
      if (this.waitingForCloseResponse) {
        this._debug("Close response not received from client.  Forcing socket end.");
        this.waitingForCloseResponse = false;
        this.state = STATE_CLOSED;
        this.socket.end();
      }
    };
    WebSocketConnection.prototype.processFrame = function(frame) {
      this._debug("processFrame");
      this._debug(" -- frame: %s", frame);
      if (this.frameQueue.length !== 0 && (frame.opcode > 0 && frame.opcode < 8)) {
        this.drop(
          WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR,
          "Illegal frame opcode 0x" + frame.opcode.toString(16) + " received in middle of fragmented message."
        );
        return;
      }
      switch (frame.opcode) {
        case 2:
          this._debug("-- Binary Frame");
          if (this.assembleFragments) {
            if (frame.fin) {
              this._debug("---- Emitting 'message' event");
              this.emit("message", {
                type: "binary",
                binaryData: frame.binaryPayload
              });
            } else {
              this.frameQueue.push(frame);
              this.fragmentationSize = frame.length;
            }
          }
          break;
        case 1:
          this._debug("-- Text Frame");
          if (this.assembleFragments) {
            if (frame.fin) {
              if (!isValidUTF8(frame.binaryPayload)) {
                this.drop(
                  WebSocketConnection.CLOSE_REASON_INVALID_DATA,
                  "Invalid UTF-8 Data Received"
                );
                return;
              }
              this._debug("---- Emitting 'message' event");
              this.emit("message", {
                type: "utf8",
                utf8Data: frame.binaryPayload.toString("utf8")
              });
            } else {
              this.frameQueue.push(frame);
              this.fragmentationSize = frame.length;
            }
          }
          break;
        case 0:
          this._debug("-- Continuation Frame");
          if (this.assembleFragments) {
            if (this.frameQueue.length === 0) {
              this.drop(
                WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR,
                "Unexpected Continuation Frame"
              );
              return;
            }
            this.fragmentationSize += frame.length;
            if (this.fragmentationSize > this.maxReceivedMessageSize) {
              this.drop(
                WebSocketConnection.CLOSE_REASON_MESSAGE_TOO_BIG,
                "Maximum message size exceeded."
              );
              return;
            }
            this.frameQueue.push(frame);
            if (frame.fin) {
              var bytesCopied = 0;
              var binaryPayload = bufferAllocUnsafe(this.fragmentationSize);
              var opcode = this.frameQueue[0].opcode;
              this.frameQueue.forEach(function(currentFrame) {
                currentFrame.binaryPayload.copy(binaryPayload, bytesCopied);
                bytesCopied += currentFrame.binaryPayload.length;
              });
              this.frameQueue = [];
              this.fragmentationSize = 0;
              switch (opcode) {
                case 2:
                  this.emit("message", {
                    type: "binary",
                    binaryData: binaryPayload
                  });
                  break;
                case 1:
                  if (!isValidUTF8(binaryPayload)) {
                    this.drop(
                      WebSocketConnection.CLOSE_REASON_INVALID_DATA,
                      "Invalid UTF-8 Data Received"
                    );
                    return;
                  }
                  this.emit("message", {
                    type: "utf8",
                    utf8Data: binaryPayload.toString("utf8")
                  });
                  break;
                default:
                  this.drop(
                    WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR,
                    "Unexpected first opcode in fragmentation sequence: 0x" + opcode.toString(16)
                  );
                  return;
              }
            }
          }
          break;
        case 9:
          this._debug("-- Ping Frame");
          if (this._pingListenerCount > 0) {
            var cancelled = false;
            var cancel = function() {
              cancelled = true;
            };
            this.emit("ping", cancel, frame.binaryPayload);
            if (!cancelled) {
              this.pong(frame.binaryPayload);
            }
          } else {
            this.pong(frame.binaryPayload);
          }
          break;
        case 10:
          this._debug("-- Pong Frame");
          this.emit("pong", frame.binaryPayload);
          break;
        case 8:
          this._debug("-- Close Frame");
          if (this.waitingForCloseResponse) {
            this._debug("---- Got close response from peer.  Completing closing handshake.");
            this.clearCloseTimer();
            this.waitingForCloseResponse = false;
            this.state = STATE_CLOSED;
            this.socket.end();
            return;
          }
          this._debug("---- Closing handshake initiated by peer.");
          this.state = STATE_PEER_REQUESTED_CLOSE;
          var respondCloseReasonCode;
          if (frame.invalidCloseFrameLength) {
            this.closeReasonCode = 1005;
            respondCloseReasonCode = WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR;
          } else if (frame.closeStatus === -1 || validateCloseReason(frame.closeStatus)) {
            this.closeReasonCode = frame.closeStatus;
            respondCloseReasonCode = WebSocketConnection.CLOSE_REASON_NORMAL;
          } else {
            this.closeReasonCode = frame.closeStatus;
            respondCloseReasonCode = WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR;
          }
          if (frame.binaryPayload.length > 1) {
            if (!isValidUTF8(frame.binaryPayload)) {
              this.drop(
                WebSocketConnection.CLOSE_REASON_INVALID_DATA,
                "Invalid UTF-8 Data Received"
              );
              return;
            }
            this.closeDescription = frame.binaryPayload.toString("utf8");
          } else {
            this.closeDescription = WebSocketConnection.CLOSE_DESCRIPTIONS[this.closeReasonCode];
          }
          this._debug(
            "------ Remote peer %s - code: %d - %s - close frame payload length: %d",
            this.remoteAddress,
            this.closeReasonCode,
            this.closeDescription,
            frame.length
          );
          this._debug("------ responding to remote peer's close request.");
          this.sendCloseFrame(respondCloseReasonCode, null);
          this.connected = false;
          break;
        default:
          this._debug("-- Unrecognized Opcode %d", frame.opcode);
          this.drop(
            WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR,
            "Unrecognized Opcode: 0x" + frame.opcode.toString(16)
          );
          break;
      }
    };
    WebSocketConnection.prototype.send = function(data, cb) {
      this._debug("send");
      if (Buffer.isBuffer(data)) {
        this.sendBytes(data, cb);
      } else if (typeof data["toString"] === "function") {
        this.sendUTF(data, cb);
      } else {
        throw new Error("Data provided must either be a Node Buffer or implement toString()");
      }
    };
    WebSocketConnection.prototype.sendUTF = function(data, cb) {
      data = bufferFromString(data.toString(), "utf8");
      this._debug("sendUTF: %d bytes", data.length);
      var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);
      frame.opcode = 1;
      frame.binaryPayload = data;
      this.fragmentAndSend(frame, cb);
    };
    WebSocketConnection.prototype.sendBytes = function(data, cb) {
      this._debug("sendBytes");
      if (!Buffer.isBuffer(data)) {
        throw new Error("You must pass a Node Buffer object to WebSocketConnection.prototype.sendBytes()");
      }
      var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);
      frame.opcode = 2;
      frame.binaryPayload = data;
      this.fragmentAndSend(frame, cb);
    };
    WebSocketConnection.prototype.ping = function(data) {
      this._debug("ping");
      var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);
      frame.opcode = 9;
      frame.fin = true;
      if (data) {
        if (!Buffer.isBuffer(data)) {
          data = bufferFromString(data.toString(), "utf8");
        }
        if (data.length > 125) {
          this._debug("WebSocket: Data for ping is longer than 125 bytes.  Truncating.");
          data = data.slice(0, 124);
        }
        frame.binaryPayload = data;
      }
      this.sendFrame(frame);
    };
    WebSocketConnection.prototype.pong = function(binaryPayload) {
      this._debug("pong");
      var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);
      frame.opcode = 10;
      if (Buffer.isBuffer(binaryPayload) && binaryPayload.length > 125) {
        this._debug("WebSocket: Data for pong is longer than 125 bytes.  Truncating.");
        binaryPayload = binaryPayload.slice(0, 124);
      }
      frame.binaryPayload = binaryPayload;
      frame.fin = true;
      this.sendFrame(frame);
    };
    WebSocketConnection.prototype.fragmentAndSend = function(frame, cb) {
      this._debug("fragmentAndSend");
      if (frame.opcode > 7) {
        throw new Error("You cannot fragment control frames.");
      }
      var threshold = this.config.fragmentationThreshold;
      var length = frame.binaryPayload.length;
      if (!this.config.fragmentOutgoingMessages || frame.binaryPayload && length <= threshold) {
        frame.fin = true;
        this.sendFrame(frame, cb);
        return;
      }
      var numFragments = Math.ceil(length / threshold);
      var sentFragments = 0;
      var sentCallback = function fragmentSentCallback(err) {
        if (err) {
          if (typeof cb === "function") {
            cb(err);
            cb = null;
          }
          return;
        }
        ++sentFragments;
        if (sentFragments === numFragments && typeof cb === "function") {
          cb();
        }
      };
      for (var i = 1; i <= numFragments; i++) {
        var currentFrame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);
        currentFrame.opcode = i === 1 ? frame.opcode : 0;
        currentFrame.fin = i === numFragments;
        var currentLength = i === numFragments ? length - threshold * (i - 1) : threshold;
        var sliceStart = threshold * (i - 1);
        currentFrame.binaryPayload = frame.binaryPayload.slice(sliceStart, sliceStart + currentLength);
        this.sendFrame(currentFrame, sentCallback);
      }
    };
    WebSocketConnection.prototype.sendCloseFrame = function(reasonCode, description, cb) {
      if (typeof reasonCode !== "number") {
        reasonCode = WebSocketConnection.CLOSE_REASON_NORMAL;
      }
      this._debug("sendCloseFrame state: %s, reasonCode: %d, description: %s", this.state, reasonCode, description);
      if (this.state !== STATE_OPEN && this.state !== STATE_PEER_REQUESTED_CLOSE) {
        return;
      }
      var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);
      frame.fin = true;
      frame.opcode = 8;
      frame.closeStatus = reasonCode;
      if (typeof description === "string") {
        frame.binaryPayload = bufferFromString(description, "utf8");
      }
      this.sendFrame(frame, cb);
      this.socket.end();
    };
    WebSocketConnection.prototype.sendFrame = function(frame, cb) {
      this._debug("sendFrame");
      frame.mask = this.maskOutgoingPackets;
      var flushed = this.socket.write(frame.toBuffer(), cb);
      this.outputBufferFull = !flushed;
      return flushed;
    };
    module2.exports = WebSocketConnection;
    function instrumentSocketForDebugging(connection, socket) {
      if (!connection._debug.enabled) {
        return;
      }
      var originalSocketEmit = socket.emit;
      socket.emit = function(event) {
        connection._debug("||| Socket Event  '%s'", event);
        originalSocketEmit.apply(this, arguments);
      };
      for (var key in socket) {
        if ("function" !== typeof socket[key]) {
          continue;
        }
        if (["emit"].indexOf(key) !== -1) {
          continue;
        }
        (function(key2) {
          var original = socket[key2];
          if (key2 === "on") {
            socket[key2] = function proxyMethod__EventEmitter__On() {
              connection._debug("||| Socket method called:  %s (%s)", key2, arguments[0]);
              return original.apply(this, arguments);
            };
            return;
          }
          socket[key2] = function proxyMethod() {
            connection._debug("||| Socket method called:  %s", key2);
            return original.apply(this, arguments);
          };
        })(key);
      }
    }
  }
});

// ../../node_modules/websocket/lib/WebSocketRequest.js
var require_WebSocketRequest = __commonJS({
  "../../node_modules/websocket/lib/WebSocketRequest.js"(exports2, module2) {
    "use strict";
    var crypto2 = require("crypto");
    var util = require("util");
    var url = require("url");
    var EventEmitter = require("events").EventEmitter;
    var WebSocketConnection = require_WebSocketConnection();
    var headerValueSplitRegExp = /,\s*/;
    var headerParamSplitRegExp = /;\s*/;
    var headerSanitizeRegExp = /[\r\n]/g;
    var xForwardedForSeparatorRegExp = /,\s*/;
    var separators = [
      "(",
      ")",
      "<",
      ">",
      "@",
      ",",
      ";",
      ":",
      "\\",
      '"',
      "/",
      "[",
      "]",
      "?",
      "=",
      "{",
      "}",
      " ",
      String.fromCharCode(9)
    ];
    var controlChars = [
      String.fromCharCode(127)
      /* DEL */
    ];
    for (i = 0; i < 31; i++) {
      controlChars.push(String.fromCharCode(i));
    }
    var i;
    var cookieNameValidateRegEx = /([\x00-\x20\x22\x28\x29\x2c\x2f\x3a-\x3f\x40\x5b-\x5e\x7b\x7d\x7f])/;
    var cookieValueValidateRegEx = /[^\x21\x23-\x2b\x2d-\x3a\x3c-\x5b\x5d-\x7e]/;
    var cookieValueDQuoteValidateRegEx = /^"[^"]*"$/;
    var controlCharsAndSemicolonRegEx = /[\x00-\x20\x3b]/g;
    var cookieSeparatorRegEx = /[;,] */;
    var httpStatusDescriptions = {
      100: "Continue",
      101: "Switching Protocols",
      200: "OK",
      201: "Created",
      203: "Non-Authoritative Information",
      204: "No Content",
      205: "Reset Content",
      206: "Partial Content",
      300: "Multiple Choices",
      301: "Moved Permanently",
      302: "Found",
      303: "See Other",
      304: "Not Modified",
      305: "Use Proxy",
      307: "Temporary Redirect",
      400: "Bad Request",
      401: "Unauthorized",
      402: "Payment Required",
      403: "Forbidden",
      404: "Not Found",
      406: "Not Acceptable",
      407: "Proxy Authorization Required",
      408: "Request Timeout",
      409: "Conflict",
      410: "Gone",
      411: "Length Required",
      412: "Precondition Failed",
      413: "Request Entity Too Long",
      414: "Request-URI Too Long",
      415: "Unsupported Media Type",
      416: "Requested Range Not Satisfiable",
      417: "Expectation Failed",
      426: "Upgrade Required",
      500: "Internal Server Error",
      501: "Not Implemented",
      502: "Bad Gateway",
      503: "Service Unavailable",
      504: "Gateway Timeout",
      505: "HTTP Version Not Supported"
    };
    function WebSocketRequest(socket, httpRequest, serverConfig) {
      EventEmitter.call(this);
      this.socket = socket;
      this.httpRequest = httpRequest;
      this.resource = httpRequest.url;
      this.remoteAddress = socket.remoteAddress;
      this.remoteAddresses = [this.remoteAddress];
      this.serverConfig = serverConfig;
      this._socketIsClosing = false;
      this._socketCloseHandler = this._handleSocketCloseBeforeAccept.bind(this);
      this.socket.on("end", this._socketCloseHandler);
      this.socket.on("close", this._socketCloseHandler);
      this._resolved = false;
    }
    util.inherits(WebSocketRequest, EventEmitter);
    WebSocketRequest.prototype.readHandshake = function() {
      var self2 = this;
      var request = this.httpRequest;
      this.resourceURL = url.parse(this.resource, true);
      this.host = request.headers["host"];
      if (!this.host) {
        throw new Error("Client must provide a Host header.");
      }
      this.key = request.headers["sec-websocket-key"];
      if (!this.key) {
        throw new Error("Client must provide a value for Sec-WebSocket-Key.");
      }
      this.webSocketVersion = parseInt(request.headers["sec-websocket-version"], 10);
      if (!this.webSocketVersion || isNaN(this.webSocketVersion)) {
        throw new Error("Client must provide a value for Sec-WebSocket-Version.");
      }
      switch (this.webSocketVersion) {
        case 8:
        case 13:
          break;
        default:
          var e = new Error("Unsupported websocket client version: " + this.webSocketVersion + "Only versions 8 and 13 are supported.");
          e.httpCode = 426;
          e.headers = {
            "Sec-WebSocket-Version": "13"
          };
          throw e;
      }
      if (this.webSocketVersion === 13) {
        this.origin = request.headers["origin"];
      } else if (this.webSocketVersion === 8) {
        this.origin = request.headers["sec-websocket-origin"];
      }
      var protocolString = request.headers["sec-websocket-protocol"];
      this.protocolFullCaseMap = {};
      this.requestedProtocols = [];
      if (protocolString) {
        var requestedProtocolsFullCase = protocolString.split(headerValueSplitRegExp);
        requestedProtocolsFullCase.forEach(function(protocol) {
          var lcProtocol = protocol.toLocaleLowerCase();
          self2.requestedProtocols.push(lcProtocol);
          self2.protocolFullCaseMap[lcProtocol] = protocol;
        });
      }
      if (!this.serverConfig.ignoreXForwardedFor && request.headers["x-forwarded-for"]) {
        var immediatePeerIP = this.remoteAddress;
        this.remoteAddresses = request.headers["x-forwarded-for"].split(xForwardedForSeparatorRegExp);
        this.remoteAddresses.push(immediatePeerIP);
        this.remoteAddress = this.remoteAddresses[0];
      }
      if (this.serverConfig.parseExtensions) {
        var extensionsString = request.headers["sec-websocket-extensions"];
        this.requestedExtensions = this.parseExtensions(extensionsString);
      } else {
        this.requestedExtensions = [];
      }
      if (this.serverConfig.parseCookies) {
        var cookieString = request.headers["cookie"];
        this.cookies = this.parseCookies(cookieString);
      } else {
        this.cookies = [];
      }
    };
    WebSocketRequest.prototype.parseExtensions = function(extensionsString) {
      if (!extensionsString || extensionsString.length === 0) {
        return [];
      }
      var extensions = extensionsString.toLocaleLowerCase().split(headerValueSplitRegExp);
      extensions.forEach(function(extension, index, array) {
        var params = extension.split(headerParamSplitRegExp);
        var extensionName = params[0];
        var extensionParams = params.slice(1);
        extensionParams.forEach(function(rawParam, index2, array2) {
          var arr = rawParam.split("=");
          var obj2 = {
            name: arr[0],
            value: arr[1]
          };
          array2.splice(index2, 1, obj2);
        });
        var obj = {
          name: extensionName,
          params: extensionParams
        };
        array.splice(index, 1, obj);
      });
      return extensions;
    };
    WebSocketRequest.prototype.parseCookies = function(str) {
      if (!str || typeof str !== "string") {
        return [];
      }
      var cookies = [];
      var pairs = str.split(cookieSeparatorRegEx);
      pairs.forEach(function(pair) {
        var eq_idx = pair.indexOf("=");
        if (eq_idx === -1) {
          cookies.push({
            name: pair,
            value: null
          });
          return;
        }
        var key = pair.substr(0, eq_idx).trim();
        var val = pair.substr(++eq_idx, pair.length).trim();
        if ('"' === val[0]) {
          val = val.slice(1, -1);
        }
        cookies.push({
          name: key,
          value: decodeURIComponent(val)
        });
      });
      return cookies;
    };
    WebSocketRequest.prototype.accept = function(acceptedProtocol, allowedOrigin, cookies) {
      this._verifyResolution();
      var protocolFullCase;
      if (acceptedProtocol) {
        protocolFullCase = this.protocolFullCaseMap[acceptedProtocol.toLocaleLowerCase()];
        if (typeof protocolFullCase === "undefined") {
          protocolFullCase = acceptedProtocol;
        }
      } else {
        protocolFullCase = acceptedProtocol;
      }
      this.protocolFullCaseMap = null;
      var sha1 = crypto2.createHash("sha1");
      sha1.update(this.key + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11");
      var acceptKey = sha1.digest("base64");
      var response = "HTTP/1.1 101 Switching Protocols\r\nUpgrade: websocket\r\nConnection: Upgrade\r\nSec-WebSocket-Accept: " + acceptKey + "\r\n";
      if (protocolFullCase) {
        for (var i2 = 0; i2 < protocolFullCase.length; i2++) {
          var charCode = protocolFullCase.charCodeAt(i2);
          var character = protocolFullCase.charAt(i2);
          if (charCode < 33 || charCode > 126 || separators.indexOf(character) !== -1) {
            this.reject(500);
            throw new Error('Illegal character "' + String.fromCharCode(character) + '" in subprotocol.');
          }
        }
        if (this.requestedProtocols.indexOf(acceptedProtocol) === -1) {
          this.reject(500);
          throw new Error("Specified protocol was not requested by the client.");
        }
        protocolFullCase = protocolFullCase.replace(headerSanitizeRegExp, "");
        response += "Sec-WebSocket-Protocol: " + protocolFullCase + "\r\n";
      }
      this.requestedProtocols = null;
      if (allowedOrigin) {
        allowedOrigin = allowedOrigin.replace(headerSanitizeRegExp, "");
        if (this.webSocketVersion === 13) {
          response += "Origin: " + allowedOrigin + "\r\n";
        } else if (this.webSocketVersion === 8) {
          response += "Sec-WebSocket-Origin: " + allowedOrigin + "\r\n";
        }
      }
      if (cookies) {
        if (!Array.isArray(cookies)) {
          this.reject(500);
          throw new Error('Value supplied for "cookies" argument must be an array.');
        }
        var seenCookies = {};
        cookies.forEach(function(cookie) {
          if (!cookie.name || !cookie.value) {
            this.reject(500);
            throw new Error('Each cookie to set must at least provide a "name" and "value"');
          }
          cookie.name = cookie.name.replace(controlCharsAndSemicolonRegEx, "");
          cookie.value = cookie.value.replace(controlCharsAndSemicolonRegEx, "");
          if (seenCookies[cookie.name]) {
            this.reject(500);
            throw new Error("You may not specify the same cookie name twice.");
          }
          seenCookies[cookie.name] = true;
          var invalidChar = cookie.name.match(cookieNameValidateRegEx);
          if (invalidChar) {
            this.reject(500);
            throw new Error("Illegal character " + invalidChar[0] + " in cookie name");
          }
          if (cookie.value.match(cookieValueDQuoteValidateRegEx)) {
            invalidChar = cookie.value.slice(1, -1).match(cookieValueValidateRegEx);
          } else {
            invalidChar = cookie.value.match(cookieValueValidateRegEx);
          }
          if (invalidChar) {
            this.reject(500);
            throw new Error("Illegal character " + invalidChar[0] + " in cookie value");
          }
          var cookieParts = [cookie.name + "=" + cookie.value];
          if (cookie.path) {
            invalidChar = cookie.path.match(controlCharsAndSemicolonRegEx);
            if (invalidChar) {
              this.reject(500);
              throw new Error("Illegal character " + invalidChar[0] + " in cookie path");
            }
            cookieParts.push("Path=" + cookie.path);
          }
          if (cookie.domain) {
            if (typeof cookie.domain !== "string") {
              this.reject(500);
              throw new Error("Domain must be specified and must be a string.");
            }
            invalidChar = cookie.domain.match(controlCharsAndSemicolonRegEx);
            if (invalidChar) {
              this.reject(500);
              throw new Error("Illegal character " + invalidChar[0] + " in cookie domain");
            }
            cookieParts.push("Domain=" + cookie.domain.toLowerCase());
          }
          if (cookie.expires) {
            if (!(cookie.expires instanceof Date)) {
              this.reject(500);
              throw new Error('Value supplied for cookie "expires" must be a vaild date object');
            }
            cookieParts.push("Expires=" + cookie.expires.toGMTString());
          }
          if (cookie.maxage) {
            var maxage = cookie.maxage;
            if (typeof maxage === "string") {
              maxage = parseInt(maxage, 10);
            }
            if (isNaN(maxage) || maxage <= 0) {
              this.reject(500);
              throw new Error('Value supplied for cookie "maxage" must be a non-zero number');
            }
            maxage = Math.round(maxage);
            cookieParts.push("Max-Age=" + maxage.toString(10));
          }
          if (cookie.secure) {
            if (typeof cookie.secure !== "boolean") {
              this.reject(500);
              throw new Error('Value supplied for cookie "secure" must be of type boolean');
            }
            cookieParts.push("Secure");
          }
          if (cookie.httponly) {
            if (typeof cookie.httponly !== "boolean") {
              this.reject(500);
              throw new Error('Value supplied for cookie "httponly" must be of type boolean');
            }
            cookieParts.push("HttpOnly");
          }
          response += "Set-Cookie: " + cookieParts.join(";") + "\r\n";
        }.bind(this));
      }
      this._resolved = true;
      this.emit("requestResolved", this);
      response += "\r\n";
      var connection = new WebSocketConnection(this.socket, [], acceptedProtocol, false, this.serverConfig);
      connection.webSocketVersion = this.webSocketVersion;
      connection.remoteAddress = this.remoteAddress;
      connection.remoteAddresses = this.remoteAddresses;
      var self2 = this;
      if (this._socketIsClosing) {
        cleanupFailedConnection(connection);
      } else {
        this.socket.write(response, "ascii", function(error) {
          if (error) {
            cleanupFailedConnection(connection);
            return;
          }
          self2._removeSocketCloseListeners();
          connection._addSocketEventListeners();
        });
      }
      this.emit("requestAccepted", connection);
      return connection;
    };
    WebSocketRequest.prototype.reject = function(status, reason, extraHeaders) {
      this._verifyResolution();
      this._resolved = true;
      this.emit("requestResolved", this);
      if (typeof status !== "number") {
        status = 403;
      }
      var response = "HTTP/1.1 " + status + " " + httpStatusDescriptions[status] + "\r\nConnection: close\r\n";
      if (reason) {
        reason = reason.replace(headerSanitizeRegExp, "");
        response += "X-WebSocket-Reject-Reason: " + reason + "\r\n";
      }
      if (extraHeaders) {
        for (var key in extraHeaders) {
          var sanitizedValue = extraHeaders[key].toString().replace(headerSanitizeRegExp, "");
          var sanitizedKey = key.replace(headerSanitizeRegExp, "");
          response += sanitizedKey + ": " + sanitizedValue + "\r\n";
        }
      }
      response += "\r\n";
      this.socket.end(response, "ascii");
      this.emit("requestRejected", this);
    };
    WebSocketRequest.prototype._handleSocketCloseBeforeAccept = function() {
      this._socketIsClosing = true;
      this._removeSocketCloseListeners();
    };
    WebSocketRequest.prototype._removeSocketCloseListeners = function() {
      this.socket.removeListener("end", this._socketCloseHandler);
      this.socket.removeListener("close", this._socketCloseHandler);
    };
    WebSocketRequest.prototype._verifyResolution = function() {
      if (this._resolved) {
        throw new Error("WebSocketRequest may only be accepted or rejected one time.");
      }
    };
    function cleanupFailedConnection(connection) {
      process.nextTick(function() {
        connection.drop(1006, "TCP connection lost before handshake completed.", true);
      });
    }
    module2.exports = WebSocketRequest;
  }
});

// ../../node_modules/websocket/lib/WebSocketServer.js
var require_WebSocketServer = __commonJS({
  "../../node_modules/websocket/lib/WebSocketServer.js"(exports2, module2) {
    "use strict";
    var extend = require_utils2().extend;
    var utils = require_utils2();
    var util = require("util");
    var debug = require_src2()("websocket:server");
    var EventEmitter = require("events").EventEmitter;
    var WebSocketRequest = require_WebSocketRequest();
    var WebSocketServer = function WebSocketServer2(config) {
      EventEmitter.call(this);
      this._handlers = {
        upgrade: this.handleUpgrade.bind(this),
        requestAccepted: this.handleRequestAccepted.bind(this),
        requestResolved: this.handleRequestResolved.bind(this)
      };
      this.connections = [];
      this.pendingRequests = [];
      if (config) {
        this.mount(config);
      }
    };
    util.inherits(WebSocketServer, EventEmitter);
    WebSocketServer.prototype.mount = function(config) {
      this.config = {
        // The http server instance to attach to.  Required.
        httpServer: null,
        // 64KiB max frame size.
        maxReceivedFrameSize: 65536,
        // 1MiB max message size, only applicable if
        // assembleFragments is true
        maxReceivedMessageSize: 1048576,
        // Outgoing messages larger than fragmentationThreshold will be
        // split into multiple fragments.
        fragmentOutgoingMessages: true,
        // Outgoing frames are fragmented if they exceed this threshold.
        // Default is 16KiB
        fragmentationThreshold: 16384,
        // If true, the server will automatically send a ping to all
        // clients every 'keepaliveInterval' milliseconds.  The timer is
        // reset on any received data from the client.
        keepalive: true,
        // The interval to send keepalive pings to connected clients if the
        // connection is idle.  Any received data will reset the counter.
        keepaliveInterval: 2e4,
        // If true, the server will consider any connection that has not
        // received any data within the amount of time specified by
        // 'keepaliveGracePeriod' after a keepalive ping has been sent to
        // be dead, and will drop the connection.
        // Ignored if keepalive is false.
        dropConnectionOnKeepaliveTimeout: true,
        // The amount of time to wait after sending a keepalive ping before
        // closing the connection if the connected peer does not respond.
        // Ignored if keepalive is false.
        keepaliveGracePeriod: 1e4,
        // Whether to use native TCP keep-alive instead of WebSockets ping
        // and pong packets.  Native TCP keep-alive sends smaller packets
        // on the wire and so uses bandwidth more efficiently.  This may
        // be more important when talking to mobile devices.
        // If this value is set to true, then these values will be ignored:
        //   keepaliveGracePeriod
        //   dropConnectionOnKeepaliveTimeout
        useNativeKeepalive: false,
        // If true, fragmented messages will be automatically assembled
        // and the full message will be emitted via a 'message' event.
        // If false, each frame will be emitted via a 'frame' event and
        // the application will be responsible for aggregating multiple
        // fragmented frames.  Single-frame messages will emit a 'message'
        // event in addition to the 'frame' event.
        // Most users will want to leave this set to 'true'
        assembleFragments: true,
        // If this is true, websocket connections will be accepted
        // regardless of the path and protocol specified by the client.
        // The protocol accepted will be the first that was requested
        // by the client.  Clients from any origin will be accepted.
        // This should only be used in the simplest of cases.  You should
        // probably leave this set to 'false' and inspect the request
        // object to make sure it's acceptable before accepting it.
        autoAcceptConnections: false,
        // Whether or not the X-Forwarded-For header should be respected.
        // It's important to set this to 'true' when accepting connections
        // from untrusted clients, as a malicious client could spoof its
        // IP address by simply setting this header.  It's meant to be added
        // by a trusted proxy or other intermediary within your own
        // infrastructure.
        // See:  http://en.wikipedia.org/wiki/X-Forwarded-For
        ignoreXForwardedFor: false,
        // If this is true, 'cookie' headers are parsed and exposed as WebSocketRequest.cookies
        parseCookies: true,
        // If this is true, 'sec-websocket-extensions' headers are parsed and exposed as WebSocketRequest.requestedExtensions
        parseExtensions: true,
        // The Nagle Algorithm makes more efficient use of network resources
        // by introducing a small delay before sending small packets so that
        // multiple messages can be batched together before going onto the
        // wire.  This however comes at the cost of latency, so the default
        // is to disable it.  If you don't need low latency and are streaming
        // lots of small messages, you can change this to 'false'
        disableNagleAlgorithm: true,
        // The number of milliseconds to wait after sending a close frame
        // for an acknowledgement to come back before giving up and just
        // closing the socket.
        closeTimeout: 5e3
      };
      extend(this.config, config);
      if (this.config.httpServer) {
        if (!Array.isArray(this.config.httpServer)) {
          this.config.httpServer = [this.config.httpServer];
        }
        var upgradeHandler = this._handlers.upgrade;
        this.config.httpServer.forEach(function(httpServer) {
          httpServer.on("upgrade", upgradeHandler);
        });
      } else {
        throw new Error("You must specify an httpServer on which to mount the WebSocket server.");
      }
    };
    WebSocketServer.prototype.unmount = function() {
      var upgradeHandler = this._handlers.upgrade;
      this.config.httpServer.forEach(function(httpServer) {
        httpServer.removeListener("upgrade", upgradeHandler);
      });
    };
    WebSocketServer.prototype.closeAllConnections = function() {
      this.connections.forEach(function(connection) {
        connection.close();
      });
      this.pendingRequests.forEach(function(request) {
        process.nextTick(function() {
          request.reject(503);
        });
      });
    };
    WebSocketServer.prototype.broadcast = function(data) {
      if (Buffer.isBuffer(data)) {
        this.broadcastBytes(data);
      } else if (typeof data.toString === "function") {
        this.broadcastUTF(data);
      }
    };
    WebSocketServer.prototype.broadcastUTF = function(utfData) {
      this.connections.forEach(function(connection) {
        connection.sendUTF(utfData);
      });
    };
    WebSocketServer.prototype.broadcastBytes = function(binaryData) {
      this.connections.forEach(function(connection) {
        connection.sendBytes(binaryData);
      });
    };
    WebSocketServer.prototype.shutDown = function() {
      this.unmount();
      this.closeAllConnections();
    };
    WebSocketServer.prototype.handleUpgrade = function(request, socket) {
      var self2 = this;
      var wsRequest = new WebSocketRequest(socket, request, this.config);
      try {
        wsRequest.readHandshake();
      } catch (e) {
        wsRequest.reject(
          e.httpCode ? e.httpCode : 400,
          e.message,
          e.headers
        );
        debug("Invalid handshake: %s", e.message);
        this.emit("upgradeError", e);
        return;
      }
      this.pendingRequests.push(wsRequest);
      wsRequest.once("requestAccepted", this._handlers.requestAccepted);
      wsRequest.once("requestResolved", this._handlers.requestResolved);
      socket.once("close", function() {
        self2._handlers.requestResolved(wsRequest);
      });
      if (!this.config.autoAcceptConnections && utils.eventEmitterListenerCount(this, "request") > 0) {
        this.emit("request", wsRequest);
      } else if (this.config.autoAcceptConnections) {
        wsRequest.accept(wsRequest.requestedProtocols[0], wsRequest.origin);
      } else {
        wsRequest.reject(404, "No handler is configured to accept the connection.");
      }
    };
    WebSocketServer.prototype.handleRequestAccepted = function(connection) {
      var self2 = this;
      connection.once("close", function(closeReason, description) {
        self2.handleConnectionClose(connection, closeReason, description);
      });
      this.connections.push(connection);
      this.emit("connect", connection);
    };
    WebSocketServer.prototype.handleConnectionClose = function(connection, closeReason, description) {
      var index = this.connections.indexOf(connection);
      if (index !== -1) {
        this.connections.splice(index, 1);
      }
      this.emit("close", connection, closeReason, description);
    };
    WebSocketServer.prototype.handleRequestResolved = function(request) {
      var index = this.pendingRequests.indexOf(request);
      if (index !== -1) {
        this.pendingRequests.splice(index, 1);
      }
    };
    module2.exports = WebSocketServer;
  }
});

// ../../node_modules/websocket/lib/WebSocketClient.js
var require_WebSocketClient = __commonJS({
  "../../node_modules/websocket/lib/WebSocketClient.js"(exports2, module2) {
    "use strict";
    var utils = require_utils2();
    var extend = utils.extend;
    var util = require("util");
    var EventEmitter = require("events").EventEmitter;
    var http = require("http");
    var https = require("https");
    var url = require("url");
    var crypto2 = require("crypto");
    var WebSocketConnection = require_WebSocketConnection();
    var bufferAllocUnsafe = utils.bufferAllocUnsafe;
    var protocolSeparators = [
      "(",
      ")",
      "<",
      ">",
      "@",
      ",",
      ";",
      ":",
      "\\",
      '"',
      "/",
      "[",
      "]",
      "?",
      "=",
      "{",
      "}",
      " ",
      String.fromCharCode(9)
    ];
    var excludedTlsOptions = ["hostname", "port", "method", "path", "headers"];
    function WebSocketClient(config) {
      EventEmitter.call(this);
      this.config = {
        // 1MiB max frame size.
        maxReceivedFrameSize: 1048576,
        // 8MiB max message size, only applicable if
        // assembleFragments is true
        maxReceivedMessageSize: 8388608,
        // Outgoing messages larger than fragmentationThreshold will be
        // split into multiple fragments.
        fragmentOutgoingMessages: true,
        // Outgoing frames are fragmented if they exceed this threshold.
        // Default is 16KiB
        fragmentationThreshold: 16384,
        // Which version of the protocol to use for this session.  This
        // option will be removed once the protocol is finalized by the IETF
        // It is only available to ease the transition through the
        // intermediate draft protocol versions.
        // At present, it only affects the name of the Origin header.
        webSocketVersion: 13,
        // If true, fragmented messages will be automatically assembled
        // and the full message will be emitted via a 'message' event.
        // If false, each frame will be emitted via a 'frame' event and
        // the application will be responsible for aggregating multiple
        // fragmented frames.  Single-frame messages will emit a 'message'
        // event in addition to the 'frame' event.
        // Most users will want to leave this set to 'true'
        assembleFragments: true,
        // The Nagle Algorithm makes more efficient use of network resources
        // by introducing a small delay before sending small packets so that
        // multiple messages can be batched together before going onto the
        // wire.  This however comes at the cost of latency, so the default
        // is to disable it.  If you don't need low latency and are streaming
        // lots of small messages, you can change this to 'false'
        disableNagleAlgorithm: true,
        // The number of milliseconds to wait after sending a close frame
        // for an acknowledgement to come back before giving up and just
        // closing the socket.
        closeTimeout: 5e3,
        // Options to pass to https.connect if connecting via TLS
        tlsOptions: {}
      };
      if (config) {
        var tlsOptions;
        if (config.tlsOptions) {
          tlsOptions = config.tlsOptions;
          delete config.tlsOptions;
        } else {
          tlsOptions = {};
        }
        extend(this.config, config);
        extend(this.config.tlsOptions, tlsOptions);
      }
      this._req = null;
      switch (this.config.webSocketVersion) {
        case 8:
        case 13:
          break;
        default:
          throw new Error("Requested webSocketVersion is not supported. Allowed values are 8 and 13.");
      }
    }
    util.inherits(WebSocketClient, EventEmitter);
    WebSocketClient.prototype.connect = function(requestUrl, protocols, origin, headers, extraRequestOptions) {
      var self2 = this;
      if (typeof protocols === "string") {
        if (protocols.length > 0) {
          protocols = [protocols];
        } else {
          protocols = [];
        }
      }
      if (!(protocols instanceof Array)) {
        protocols = [];
      }
      this.protocols = protocols;
      this.origin = origin;
      if (typeof requestUrl === "string") {
        this.url = url.parse(requestUrl);
      } else {
        this.url = requestUrl;
      }
      if (!this.url.protocol) {
        throw new Error("You must specify a full WebSocket URL, including protocol.");
      }
      if (!this.url.host) {
        throw new Error("You must specify a full WebSocket URL, including hostname. Relative URLs are not supported.");
      }
      this.secure = this.url.protocol === "wss:";
      this.protocols.forEach(function(protocol) {
        for (var i2 = 0; i2 < protocol.length; i2++) {
          var charCode = protocol.charCodeAt(i2);
          var character = protocol.charAt(i2);
          if (charCode < 33 || charCode > 126 || protocolSeparators.indexOf(character) !== -1) {
            throw new Error('Protocol list contains invalid character "' + String.fromCharCode(charCode) + '"');
          }
        }
      });
      var defaultPorts = {
        "ws:": "80",
        "wss:": "443"
      };
      if (!this.url.port) {
        this.url.port = defaultPorts[this.url.protocol];
      }
      var nonce = bufferAllocUnsafe(16);
      for (var i = 0; i < 16; i++) {
        nonce[i] = Math.round(Math.random() * 255);
      }
      this.base64nonce = nonce.toString("base64");
      var hostHeaderValue = this.url.hostname;
      if (this.url.protocol === "ws:" && this.url.port !== "80" || this.url.protocol === "wss:" && this.url.port !== "443") {
        hostHeaderValue += ":" + this.url.port;
      }
      var reqHeaders = {};
      if (this.secure && this.config.tlsOptions.hasOwnProperty("headers")) {
        extend(reqHeaders, this.config.tlsOptions.headers);
      }
      if (headers) {
        extend(reqHeaders, headers);
      }
      extend(reqHeaders, {
        "Upgrade": "websocket",
        "Connection": "Upgrade",
        "Sec-WebSocket-Version": this.config.webSocketVersion.toString(10),
        "Sec-WebSocket-Key": this.base64nonce,
        "Host": reqHeaders.Host || hostHeaderValue
      });
      if (this.protocols.length > 0) {
        reqHeaders["Sec-WebSocket-Protocol"] = this.protocols.join(", ");
      }
      if (this.origin) {
        if (this.config.webSocketVersion === 13) {
          reqHeaders["Origin"] = this.origin;
        } else if (this.config.webSocketVersion === 8) {
          reqHeaders["Sec-WebSocket-Origin"] = this.origin;
        }
      }
      var pathAndQuery;
      if (this.url.pathname) {
        pathAndQuery = this.url.path;
      } else if (this.url.path) {
        pathAndQuery = "/" + this.url.path;
      } else {
        pathAndQuery = "/";
      }
      function handleRequestError(error) {
        self2._req = null;
        self2.emit("connectFailed", error);
      }
      var requestOptions = {
        agent: false
      };
      if (extraRequestOptions) {
        extend(requestOptions, extraRequestOptions);
      }
      extend(requestOptions, {
        hostname: this.url.hostname,
        port: this.url.port,
        method: "GET",
        path: pathAndQuery,
        headers: reqHeaders
      });
      if (this.secure) {
        var tlsOptions = this.config.tlsOptions;
        for (var key in tlsOptions) {
          if (tlsOptions.hasOwnProperty(key) && excludedTlsOptions.indexOf(key) === -1) {
            requestOptions[key] = tlsOptions[key];
          }
        }
      }
      var req = this._req = (this.secure ? https : http).request(requestOptions);
      req.on("upgrade", function handleRequestUpgrade(response, socket, head) {
        self2._req = null;
        req.removeListener("error", handleRequestError);
        self2.socket = socket;
        self2.response = response;
        self2.firstDataChunk = head;
        self2.validateHandshake();
      });
      req.on("error", handleRequestError);
      req.on("response", function(response) {
        self2._req = null;
        if (utils.eventEmitterListenerCount(self2, "httpResponse") > 0) {
          self2.emit("httpResponse", response, self2);
          if (response.socket) {
            response.socket.end();
          }
        } else {
          var headerDumpParts = [];
          for (var headerName in response.headers) {
            headerDumpParts.push(headerName + ": " + response.headers[headerName]);
          }
          self2.failHandshake(
            "Server responded with a non-101 status: " + response.statusCode + " " + response.statusMessage + "\nResponse Headers Follow:\n" + headerDumpParts.join("\n") + "\n"
          );
        }
      });
      req.end();
    };
    WebSocketClient.prototype.validateHandshake = function() {
      var headers = this.response.headers;
      if (this.protocols.length > 0) {
        this.protocol = headers["sec-websocket-protocol"];
        if (this.protocol) {
          if (this.protocols.indexOf(this.protocol) === -1) {
            this.failHandshake("Server did not respond with a requested protocol.");
            return;
          }
        } else {
          this.failHandshake("Expected a Sec-WebSocket-Protocol header.");
          return;
        }
      }
      if (!(headers["connection"] && headers["connection"].toLocaleLowerCase() === "upgrade")) {
        this.failHandshake("Expected a Connection: Upgrade header from the server");
        return;
      }
      if (!(headers["upgrade"] && headers["upgrade"].toLocaleLowerCase() === "websocket")) {
        this.failHandshake("Expected an Upgrade: websocket header from the server");
        return;
      }
      var sha1 = crypto2.createHash("sha1");
      sha1.update(this.base64nonce + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11");
      var expectedKey = sha1.digest("base64");
      if (!headers["sec-websocket-accept"]) {
        this.failHandshake("Expected Sec-WebSocket-Accept header from server");
        return;
      }
      if (headers["sec-websocket-accept"] !== expectedKey) {
        this.failHandshake("Sec-WebSocket-Accept header from server didn't match expected value of " + expectedKey);
        return;
      }
      this.succeedHandshake();
    };
    WebSocketClient.prototype.failHandshake = function(errorDescription) {
      if (this.socket && this.socket.writable) {
        this.socket.end();
      }
      this.emit("connectFailed", new Error(errorDescription));
    };
    WebSocketClient.prototype.succeedHandshake = function() {
      var connection = new WebSocketConnection(this.socket, [], this.protocol, true, this.config);
      connection.webSocketVersion = this.config.webSocketVersion;
      connection._addSocketEventListeners();
      this.emit("connect", connection);
      if (this.firstDataChunk.length > 0) {
        connection.handleSocketData(this.firstDataChunk);
      }
      this.firstDataChunk = null;
    };
    WebSocketClient.prototype.abort = function() {
      if (this._req) {
        this._req.abort();
      }
    };
    module2.exports = WebSocketClient;
  }
});

// ../../node_modules/websocket/lib/WebSocketRouterRequest.js
var require_WebSocketRouterRequest = __commonJS({
  "../../node_modules/websocket/lib/WebSocketRouterRequest.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var EventEmitter = require("events").EventEmitter;
    function WebSocketRouterRequest(webSocketRequest, resolvedProtocol) {
      EventEmitter.call(this);
      this.webSocketRequest = webSocketRequest;
      if (resolvedProtocol === "____no_protocol____") {
        this.protocol = null;
      } else {
        this.protocol = resolvedProtocol;
      }
      this.origin = webSocketRequest.origin;
      this.resource = webSocketRequest.resource;
      this.resourceURL = webSocketRequest.resourceURL;
      this.httpRequest = webSocketRequest.httpRequest;
      this.remoteAddress = webSocketRequest.remoteAddress;
      this.webSocketVersion = webSocketRequest.webSocketVersion;
      this.requestedExtensions = webSocketRequest.requestedExtensions;
      this.cookies = webSocketRequest.cookies;
    }
    util.inherits(WebSocketRouterRequest, EventEmitter);
    WebSocketRouterRequest.prototype.accept = function(origin, cookies) {
      var connection = this.webSocketRequest.accept(this.protocol, origin, cookies);
      this.emit("requestAccepted", connection);
      return connection;
    };
    WebSocketRouterRequest.prototype.reject = function(status, reason, extraHeaders) {
      this.webSocketRequest.reject(status, reason, extraHeaders);
      this.emit("requestRejected", this);
    };
    module2.exports = WebSocketRouterRequest;
  }
});

// ../../node_modules/websocket/lib/WebSocketRouter.js
var require_WebSocketRouter = __commonJS({
  "../../node_modules/websocket/lib/WebSocketRouter.js"(exports2, module2) {
    "use strict";
    var extend = require_utils2().extend;
    var util = require("util");
    var EventEmitter = require("events").EventEmitter;
    var WebSocketRouterRequest = require_WebSocketRouterRequest();
    function WebSocketRouter(config) {
      EventEmitter.call(this);
      this.config = {
        // The WebSocketServer instance to attach to.
        server: null
      };
      if (config) {
        extend(this.config, config);
      }
      this.handlers = [];
      this._requestHandler = this.handleRequest.bind(this);
      if (this.config.server) {
        this.attachServer(this.config.server);
      }
    }
    util.inherits(WebSocketRouter, EventEmitter);
    WebSocketRouter.prototype.attachServer = function(server) {
      if (server) {
        this.server = server;
        this.server.on("request", this._requestHandler);
      } else {
        throw new Error("You must specify a WebSocketServer instance to attach to.");
      }
    };
    WebSocketRouter.prototype.detachServer = function() {
      if (this.server) {
        this.server.removeListener("request", this._requestHandler);
        this.server = null;
      } else {
        throw new Error("Cannot detach from server: not attached.");
      }
    };
    WebSocketRouter.prototype.mount = function(path2, protocol, callback2) {
      if (!path2) {
        throw new Error("You must specify a path for this handler.");
      }
      if (!protocol) {
        protocol = "____no_protocol____";
      }
      if (!callback2) {
        throw new Error("You must specify a callback for this handler.");
      }
      path2 = this.pathToRegExp(path2);
      if (!(path2 instanceof RegExp)) {
        throw new Error("Path must be specified as either a string or a RegExp.");
      }
      var pathString = path2.toString();
      protocol = protocol.toLocaleLowerCase();
      if (this.findHandlerIndex(pathString, protocol) !== -1) {
        throw new Error("You may only mount one handler per path/protocol combination.");
      }
      this.handlers.push({
        "path": path2,
        "pathString": pathString,
        "protocol": protocol,
        "callback": callback2
      });
    };
    WebSocketRouter.prototype.unmount = function(path2, protocol) {
      var index = this.findHandlerIndex(this.pathToRegExp(path2).toString(), protocol);
      if (index !== -1) {
        this.handlers.splice(index, 1);
      } else {
        throw new Error("Unable to find a route matching the specified path and protocol.");
      }
    };
    WebSocketRouter.prototype.findHandlerIndex = function(pathString, protocol) {
      protocol = protocol.toLocaleLowerCase();
      for (var i = 0, len = this.handlers.length; i < len; i++) {
        var handler = this.handlers[i];
        if (handler.pathString === pathString && handler.protocol === protocol) {
          return i;
        }
      }
      return -1;
    };
    WebSocketRouter.prototype.pathToRegExp = function(path2) {
      if (typeof path2 === "string") {
        if (path2 === "*") {
          path2 = /^.*$/;
        } else {
          path2 = path2.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
          path2 = new RegExp("^" + path2 + "$");
        }
      }
      return path2;
    };
    WebSocketRouter.prototype.handleRequest = function(request) {
      var requestedProtocols = request.requestedProtocols;
      if (requestedProtocols.length === 0) {
        requestedProtocols = ["____no_protocol____"];
      }
      for (var i = 0; i < requestedProtocols.length; i++) {
        var requestedProtocol = requestedProtocols[i].toLocaleLowerCase();
        for (var j = 0, len = this.handlers.length; j < len; j++) {
          var handler = this.handlers[j];
          if (handler.path.test(request.resourceURL.pathname)) {
            if (requestedProtocol === handler.protocol || handler.protocol === "*") {
              var routerRequest = new WebSocketRouterRequest(request, requestedProtocol);
              handler.callback(routerRequest);
              return;
            }
          }
        }
      }
      request.reject(404, "No handler is available for the given request.");
    };
    module2.exports = WebSocketRouter;
  }
});

// ../../node_modules/is-typedarray/index.js
var require_is_typedarray = __commonJS({
  "../../node_modules/is-typedarray/index.js"(exports2, module2) {
    "use strict";
    module2.exports = isTypedArray;
    isTypedArray.strict = isStrictTypedArray;
    isTypedArray.loose = isLooseTypedArray;
    var toString = Object.prototype.toString;
    var names = {
      "[object Int8Array]": true,
      "[object Int16Array]": true,
      "[object Int32Array]": true,
      "[object Uint8Array]": true,
      "[object Uint8ClampedArray]": true,
      "[object Uint16Array]": true,
      "[object Uint32Array]": true,
      "[object Float32Array]": true,
      "[object Float64Array]": true
    };
    function isTypedArray(arr) {
      return isStrictTypedArray(arr) || isLooseTypedArray(arr);
    }
    function isStrictTypedArray(arr) {
      return arr instanceof Int8Array || arr instanceof Int16Array || arr instanceof Int32Array || arr instanceof Uint8Array || arr instanceof Uint8ClampedArray || arr instanceof Uint16Array || arr instanceof Uint32Array || arr instanceof Float32Array || arr instanceof Float64Array;
    }
    function isLooseTypedArray(arr) {
      return names[toString.call(arr)];
    }
  }
});

// ../../node_modules/typedarray-to-buffer/index.js
var require_typedarray_to_buffer = __commonJS({
  "../../node_modules/typedarray-to-buffer/index.js"(exports2, module2) {
    "use strict";
    var isTypedArray = require_is_typedarray().strict;
    module2.exports = function typedarrayToBuffer(arr) {
      if (isTypedArray(arr)) {
        var buf = Buffer.from(arr.buffer);
        if (arr.byteLength !== arr.buffer.byteLength) {
          buf = buf.slice(arr.byteOffset, arr.byteOffset + arr.byteLength);
        }
        return buf;
      } else {
        return Buffer.from(arr);
      }
    };
  }
});

// ../../node_modules/yaeti/lib/EventTarget.js
var require_EventTarget = __commonJS({
  "../../node_modules/yaeti/lib/EventTarget.js"(exports2, module2) {
    "use strict";
    module2.exports = _EventTarget;
    function _EventTarget() {
      if (typeof this.addEventListener === "function") {
        return;
      }
      this._listeners = {};
      this.addEventListener = _addEventListener;
      this.removeEventListener = _removeEventListener;
      this.dispatchEvent = _dispatchEvent;
    }
    Object.defineProperties(_EventTarget.prototype, {
      listeners: {
        get: function() {
          return this._listeners;
        }
      }
    });
    function _addEventListener(type, newListener) {
      var listenersType, i, listener;
      if (!type || !newListener) {
        return;
      }
      listenersType = this._listeners[type];
      if (listenersType === void 0) {
        this._listeners[type] = listenersType = [];
      }
      for (i = 0; !!(listener = listenersType[i]); i++) {
        if (listener === newListener) {
          return;
        }
      }
      listenersType.push(newListener);
    }
    function _removeEventListener(type, oldListener) {
      var listenersType, i, listener;
      if (!type || !oldListener) {
        return;
      }
      listenersType = this._listeners[type];
      if (listenersType === void 0) {
        return;
      }
      for (i = 0; !!(listener = listenersType[i]); i++) {
        if (listener === oldListener) {
          listenersType.splice(i, 1);
          break;
        }
      }
      if (listenersType.length === 0) {
        delete this._listeners[type];
      }
    }
    function _dispatchEvent(event) {
      var type, listenersType, dummyListener, stopImmediatePropagation = false, i, listener;
      if (!event || typeof event.type !== "string") {
        throw new Error("`event` must have a valid `type` property");
      }
      if (event._yaeti) {
        event.target = this;
        event.cancelable = true;
      }
      try {
        event.stopImmediatePropagation = function() {
          stopImmediatePropagation = true;
        };
      } catch (error) {
      }
      type = event.type;
      listenersType = this._listeners[type] || [];
      dummyListener = this["on" + type];
      if (typeof dummyListener === "function") {
        dummyListener.call(this, event);
      }
      for (i = 0; !!(listener = listenersType[i]); i++) {
        if (stopImmediatePropagation) {
          break;
        }
        listener.call(this, event);
      }
      return !event.defaultPrevented;
    }
  }
});

// ../../node_modules/yaeti/lib/Event.js
var require_Event = __commonJS({
  "../../node_modules/yaeti/lib/Event.js"(exports2, module2) {
    "use strict";
    module2.exports = _Event;
    function _Event(type) {
      this.type = type;
      this.isTrusted = false;
      this._yaeti = true;
    }
  }
});

// ../../node_modules/yaeti/index.js
var require_yaeti = __commonJS({
  "../../node_modules/yaeti/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      EventTarget: require_EventTarget(),
      Event: require_Event()
    };
  }
});

// ../../node_modules/websocket/lib/W3CWebSocket.js
var require_W3CWebSocket = __commonJS({
  "../../node_modules/websocket/lib/W3CWebSocket.js"(exports2, module2) {
    "use strict";
    var WebSocketClient = require_WebSocketClient();
    var toBuffer = require_typedarray_to_buffer();
    var yaeti = require_yaeti();
    var CONNECTING = 0;
    var OPEN = 1;
    var CLOSING = 2;
    var CLOSED = 3;
    module2.exports = W3CWebSocket;
    function W3CWebSocket(url, protocols, origin, headers, requestOptions, clientConfig) {
      yaeti.EventTarget.call(this);
      clientConfig = clientConfig || {};
      clientConfig.assembleFragments = true;
      var self2 = this;
      this._url = url;
      this._readyState = CONNECTING;
      this._protocol = void 0;
      this._extensions = "";
      this._bufferedAmount = 0;
      this._binaryType = "arraybuffer";
      this._connection = void 0;
      this._client = new WebSocketClient(clientConfig);
      this._client.on("connect", function(connection) {
        onConnect.call(self2, connection);
      });
      this._client.on("connectFailed", function() {
        onConnectFailed.call(self2);
      });
      this._client.connect(url, protocols, origin, headers, requestOptions);
    }
    Object.defineProperties(W3CWebSocket.prototype, {
      url: { get: function() {
        return this._url;
      } },
      readyState: { get: function() {
        return this._readyState;
      } },
      protocol: { get: function() {
        return this._protocol;
      } },
      extensions: { get: function() {
        return this._extensions;
      } },
      bufferedAmount: { get: function() {
        return this._bufferedAmount;
      } }
    });
    Object.defineProperties(W3CWebSocket.prototype, {
      binaryType: {
        get: function() {
          return this._binaryType;
        },
        set: function(type) {
          if (type !== "arraybuffer") {
            throw new SyntaxError('just "arraybuffer" type allowed for "binaryType" attribute');
          }
          this._binaryType = type;
        }
      }
    });
    [["CONNECTING", CONNECTING], ["OPEN", OPEN], ["CLOSING", CLOSING], ["CLOSED", CLOSED]].forEach(function(property) {
      Object.defineProperty(W3CWebSocket.prototype, property[0], {
        get: function() {
          return property[1];
        }
      });
    });
    [["CONNECTING", CONNECTING], ["OPEN", OPEN], ["CLOSING", CLOSING], ["CLOSED", CLOSED]].forEach(function(property) {
      Object.defineProperty(W3CWebSocket, property[0], {
        get: function() {
          return property[1];
        }
      });
    });
    W3CWebSocket.prototype.send = function(data) {
      if (this._readyState !== OPEN) {
        throw new Error("cannot call send() while not connected");
      }
      if (typeof data === "string" || data instanceof String) {
        this._connection.sendUTF(data);
      } else {
        if (data instanceof Buffer) {
          this._connection.sendBytes(data);
        } else if (data.byteLength || data.byteLength === 0) {
          data = toBuffer(data);
          this._connection.sendBytes(data);
        } else {
          throw new Error("unknown binary data:", data);
        }
      }
    };
    W3CWebSocket.prototype.close = function(code, reason) {
      switch (this._readyState) {
        case CONNECTING:
          onConnectFailed.call(this);
          this._client.on("connect", function(connection) {
            if (code) {
              connection.close(code, reason);
            } else {
              connection.close();
            }
          });
          break;
        case OPEN:
          this._readyState = CLOSING;
          if (code) {
            this._connection.close(code, reason);
          } else {
            this._connection.close();
          }
          break;
        case CLOSING:
        case CLOSED:
          break;
      }
    };
    function createCloseEvent(code, reason) {
      var event = new yaeti.Event("close");
      event.code = code;
      event.reason = reason;
      event.wasClean = typeof code === "undefined" || code === 1e3;
      return event;
    }
    function createMessageEvent(data) {
      var event = new yaeti.Event("message");
      event.data = data;
      return event;
    }
    function onConnect(connection) {
      var self2 = this;
      this._readyState = OPEN;
      this._connection = connection;
      this._protocol = connection.protocol;
      this._extensions = connection.extensions;
      this._connection.on("close", function(code, reason) {
        onClose.call(self2, code, reason);
      });
      this._connection.on("message", function(msg) {
        onMessage.call(self2, msg);
      });
      this.dispatchEvent(new yaeti.Event("open"));
    }
    function onConnectFailed() {
      destroy.call(this);
      this._readyState = CLOSED;
      try {
        this.dispatchEvent(new yaeti.Event("error"));
      } finally {
        this.dispatchEvent(createCloseEvent(1006, "connection failed"));
      }
    }
    function onClose(code, reason) {
      destroy.call(this);
      this._readyState = CLOSED;
      this.dispatchEvent(createCloseEvent(code, reason || ""));
    }
    function onMessage(message) {
      if (message.utf8Data) {
        this.dispatchEvent(createMessageEvent(message.utf8Data));
      } else if (message.binaryData) {
        if (this.binaryType === "arraybuffer") {
          var buffer = message.binaryData;
          var arraybuffer = new ArrayBuffer(buffer.length);
          var view = new Uint8Array(arraybuffer);
          for (var i = 0, len = buffer.length; i < len; ++i) {
            view[i] = buffer[i];
          }
          this.dispatchEvent(createMessageEvent(arraybuffer));
        }
      }
    }
    function destroy() {
      this._client.removeAllListeners();
      if (this._connection) {
        this._connection.removeAllListeners();
      }
    }
  }
});

// ../../node_modules/websocket/lib/Deprecation.js
var require_Deprecation = __commonJS({
  "../../node_modules/websocket/lib/Deprecation.js"(exports2, module2) {
    "use strict";
    var Deprecation = {
      disableWarnings: false,
      deprecationWarningMap: {},
      warn: function(deprecationName) {
        if (!this.disableWarnings && this.deprecationWarningMap[deprecationName]) {
          console.warn("DEPRECATION WARNING: " + this.deprecationWarningMap[deprecationName]);
          this.deprecationWarningMap[deprecationName] = false;
        }
      }
    };
    module2.exports = Deprecation;
  }
});

// ../../node_modules/websocket/package.json
var require_package3 = __commonJS({
  "../../node_modules/websocket/package.json"(exports2, module2) {
    module2.exports = {
      name: "websocket",
      description: "Websocket Client & Server Library implementing the WebSocket protocol as specified in RFC 6455.",
      keywords: [
        "websocket",
        "websockets",
        "socket",
        "networking",
        "comet",
        "push",
        "RFC-6455",
        "realtime",
        "server",
        "client"
      ],
      author: "Brian McKelvey <theturtle32@gmail.com> (https://github.com/theturtle32)",
      contributors: [
        "I\xF1aki Baz Castillo <ibc@aliax.net> (http://dev.sipdoc.net)"
      ],
      version: "1.0.35",
      repository: {
        type: "git",
        url: "https://github.com/theturtle32/WebSocket-Node.git"
      },
      homepage: "https://github.com/theturtle32/WebSocket-Node",
      engines: {
        node: ">=4.0.0"
      },
      dependencies: {
        bufferutil: "^4.0.1",
        debug: "^2.2.0",
        "es5-ext": "^0.10.63",
        "typedarray-to-buffer": "^3.1.5",
        "utf-8-validate": "^5.0.2",
        yaeti: "^0.0.6"
      },
      devDependencies: {
        "buffer-equal": "^1.0.0",
        gulp: "^4.0.2",
        "gulp-jshint": "^2.0.4",
        "jshint-stylish": "^2.2.1",
        jshint: "^2.0.0",
        tape: "^4.9.1"
      },
      config: {
        verbose: false
      },
      scripts: {
        test: "tape test/unit/*.js",
        gulp: "gulp"
      },
      main: "index",
      directories: {
        lib: "./lib"
      },
      browser: "lib/browser.js",
      license: "Apache-2.0"
    };
  }
});

// ../../node_modules/websocket/lib/version.js
var require_version2 = __commonJS({
  "../../node_modules/websocket/lib/version.js"(exports2, module2) {
    "use strict";
    module2.exports = require_package3().version;
  }
});

// ../../node_modules/websocket/lib/websocket.js
var require_websocket = __commonJS({
  "../../node_modules/websocket/lib/websocket.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      "server": require_WebSocketServer(),
      "client": require_WebSocketClient(),
      "router": require_WebSocketRouter(),
      "frame": require_WebSocketFrame(),
      "request": require_WebSocketRequest(),
      "connection": require_WebSocketConnection(),
      "w3cwebsocket": require_W3CWebSocket(),
      "deprecation": require_Deprecation(),
      "version": require_version2()
    };
  }
});

// ../../node_modules/websocket/index.js
var require_websocket2 = __commonJS({
  "../../node_modules/websocket/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_websocket();
  }
});

// ../../node_modules/@microsoft/dev-tunnels-connections/sshHelpers.js
var require_sshHelpers = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-connections/sshHelpers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RelayConnectionError = exports2.RelayErrorType = exports2.isNode = exports2.SshHelpers = exports2.BrowserWebSocketRelayError = void 0;
    var ssh = require_dev_tunnels_ssh();
    var websocket_1 = require_websocket2();
    var BrowserWebSocketRelayError = class extends Error {
      constructor(message) {
        super(message);
      }
    };
    exports2.BrowserWebSocketRelayError = BrowserWebSocketRelayError;
    var SshHelpers = class _SshHelpers {
      /**
       * Open a connection to the relay uri depending on the running environment.
       * @param relayUri
       * @param protocols
       * @param headers
       * @param clientConfig
       * @returns
       */
      static openConnection(relayUri, protocols, headers, clientConfig) {
        if ((0, exports2.isNode)()) {
          return _SshHelpers.nodeSshStreamFactory(relayUri, protocols, headers, clientConfig);
        }
        return _SshHelpers.webSshStreamFactory(new WebSocket(relayUri, protocols));
      }
      /**
       * Creates a client SSH session with standard configuration for tunnels.
       * @param configure Optional callback for additional session configuration.
       * @returns The created SSH session.
       */
      static createSshClientSession(configure) {
        return _SshHelpers.createSshSession((config) => {
          if (configure)
            configure(config);
          return new ssh.SshClientSession(config);
        });
      }
      /**
       * Creates a SSH server session with standard configuration for tunnels.
       * @param reconnectableSessions Optional list that tracks reconnectable sessions.
       * @param configure Optional callback for additional session configuration.
       * @returns The created SSH session.
       */
      static createSshServerSession(reconnectableSessions, configure) {
        return _SshHelpers.createSshSession((config) => {
          if (configure)
            configure(config);
          return new ssh.SshServerSession(config, reconnectableSessions);
        });
      }
      /**
       * Create a websocketStream from a connection.
       * @param connection
       * @returns
       */
      static createWebSocketStreamAdapter(connection) {
        return new ssh.WebSocketStream(new WebsocketStreamAdapter(connection));
      }
      /**
       * Set up a web Ssh stream factory.
       * @param socket
       * @returns
       */
      static webSshStreamFactory(socket) {
        socket.binaryType = "arraybuffer";
        return new Promise((resolve3, reject) => {
          const relayError = "Failed to connect to relay url";
          socket.onopen = () => {
            resolve3(new ssh.WebSocketStream(socket));
          };
          socket.onerror = (e) => {
            setTimeout(() => reject(new BrowserWebSocketRelayError(relayError)), 100);
          };
          socket.onclose = (e) => {
            if (e.code !== 1e3) {
              reject(new BrowserWebSocketRelayError(`${relayError} Code: ${e.code} Reason: ${e.reason}`));
            }
          };
        });
      }
      static createSshSession(factoryCallback) {
        const config = new ssh.SshSessionConfiguration();
        config.keyExchangeAlgorithms.splice(0);
        config.keyExchangeAlgorithms.push(ssh.SshAlgorithms.keyExchange.ecdhNistp384Sha384);
        config.keyExchangeAlgorithms.push(ssh.SshAlgorithms.keyExchange.ecdhNistp256Sha256);
        config.keyExchangeAlgorithms.push(ssh.SshAlgorithms.keyExchange.dhGroup14Sha256);
        return factoryCallback(config);
      }
      static nodeSshStreamFactory(relayUri, protocols, headers, clientConfig) {
        const client = new websocket_1.client(clientConfig);
        return new Promise((resolve3, reject) => {
          client.on("connect", (connection) => {
            resolve3(new ssh.WebSocketStream(new WebsocketStreamAdapter(connection)));
          });
          client.on("httpResponse", ({ statusCode, statusMessage }) => {
            var _a;
            const errorContext = (_a = webSocketClientContexts.find((c) => c.statusCode === statusCode)) !== null && _a !== void 0 ? _a : {
              statusCode,
              errorType: RelayErrorType.ServerError,
              error: `relayConnectionError Server responded with a non-101 status: ${statusCode} ${statusMessage}`
            };
            reject(new RelayConnectionError(`error.${errorContext.error}`, errorContext));
          });
          client.on("connectFailed", ({ message }) => {
            var _a;
            if (message && message.startsWith("Error: ")) {
              message = message.substr(7);
            }
            const errorContext = (_a = webSocketClientContexts.find((c) => c.regex && c.regex.test(message))) !== null && _a !== void 0 ? _a : {
              // Other errors are most likely connectivity issues.
              // The original error message may have additional helpful details.
              errorType: RelayErrorType.ServerError,
              error: `relayConnectionError ${message}`
            };
            reject(new RelayConnectionError(`error.${errorContext.error}`, errorContext));
          });
          client.connect(relayUri, protocols, void 0, headers);
        });
      }
    };
    exports2.SshHelpers = SshHelpers;
    var WebsocketStreamAdapter = class {
      constructor(connection) {
        this.connection = connection;
      }
      get protocol() {
        return this.connection.protocol;
      }
      set onmessage(messageHandler) {
        if (messageHandler) {
          this.connection.on("message", (message) => {
            messageHandler({ data: message.binaryData });
          });
        } else {
        }
      }
      set onclose(closeHandler) {
        if (closeHandler) {
          this.connection.on("close", (code, reason) => {
            closeHandler({ code, reason, wasClean: !(code || reason) });
          });
        } else {
        }
      }
      send(data) {
        if (Buffer.isBuffer(data)) {
          this.connection.sendBytes(data);
        } else {
          this.connection.sendBytes(Buffer.from(data));
        }
      }
      close(code, reason) {
        if (code || reason) {
          this.connection.drop(code, reason);
        } else {
          this.connection.close();
        }
      }
    };
    var isNode = () => typeof process !== "undefined" && typeof process.release !== "undefined" && process.release.name === "node";
    exports2.isNode = isNode;
    var RelayErrorType;
    (function(RelayErrorType2) {
      RelayErrorType2[RelayErrorType2["ConnectionError"] = 1] = "ConnectionError";
      RelayErrorType2[RelayErrorType2["Unauthorized"] = 2] = "Unauthorized";
      RelayErrorType2[RelayErrorType2["EndpointNotFound"] = 3] = "EndpointNotFound";
      RelayErrorType2[RelayErrorType2["ListenerOffline"] = 4] = "ListenerOffline";
      RelayErrorType2[RelayErrorType2["ServerError"] = 5] = "ServerError";
      RelayErrorType2[RelayErrorType2["TunnelPortNotFound"] = 6] = "TunnelPortNotFound";
      RelayErrorType2[RelayErrorType2["TooManyRequests"] = 7] = "TooManyRequests";
      RelayErrorType2[RelayErrorType2["ServiceUnavailable"] = 8] = "ServiceUnavailable";
      RelayErrorType2[RelayErrorType2["BadGateway"] = 9] = "BadGateway";
    })(RelayErrorType = exports2.RelayErrorType || (exports2.RelayErrorType = {}));
    var RelayConnectionError = class extends Error {
      constructor(message, errorContext) {
        super(message);
        this.errorContext = errorContext;
      }
    };
    exports2.RelayConnectionError = RelayConnectionError;
    var webSocketClientContexts = [
      {
        regex: /status: 401/,
        statusCode: 401,
        error: "relayClientUnauthorized",
        errorType: RelayErrorType.Unauthorized
      },
      {
        regex: /status: 403/,
        statusCode: 403,
        error: "relayClientForbidden",
        errorType: RelayErrorType.Unauthorized
      },
      {
        regex: /status: 404/,
        statusCode: 404,
        error: "tunnelPortNotFound",
        errorType: RelayErrorType.TunnelPortNotFound
      },
      {
        regex: /status: 429/,
        statusCode: 429,
        error: "tooManyRequests",
        errorType: RelayErrorType.TooManyRequests
      },
      {
        regex: /status: 500/,
        statusCode: 500,
        error: "relayServerError",
        errorType: RelayErrorType.ServerError
      },
      {
        regex: /status: 502/,
        statusCode: 502,
        error: "badGateway",
        errorType: RelayErrorType.BadGateway
      },
      {
        regex: /status: 503/,
        statusCode: 503,
        error: "serviceUnavailable",
        errorType: RelayErrorType.ServiceUnavailable
      }
    ];
  }
});

// ../../node_modules/@microsoft/dev-tunnels-connections/tunnelRelayStreamFactory.js
var require_tunnelRelayStreamFactory = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-connections/tunnelRelayStreamFactory.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/@microsoft/dev-tunnels-connections/defaultTunnelRelayStreamFactory.js
var require_defaultTunnelRelayStreamFactory = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-connections/defaultTunnelRelayStreamFactory.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DefaultTunnelRelayStreamFactory = void 0;
    var sshHelpers_1 = require_sshHelpers();
    var DefaultTunnelRelayStreamFactory = class {
      async createRelayStream(relayUri, protocols, accessToken, clientConfig) {
        if ((0, sshHelpers_1.isNode)()) {
          const stream = await sshHelpers_1.SshHelpers.openConnection(relayUri, protocols, Object.assign({}, accessToken && { Authorization: `tunnel ${accessToken}` }), clientConfig);
          return { stream, protocol: stream.protocol };
        } else {
          if (accessToken) {
            protocols = [...protocols, accessToken];
          }
          const stream = await sshHelpers_1.SshHelpers.openConnection(relayUri, protocols);
          return { stream, protocol: stream.protocol };
        }
      }
    };
    exports2.DefaultTunnelRelayStreamFactory = DefaultTunnelRelayStreamFactory;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh-tcp/sshClient.js
var require_sshClient = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh-tcp/sshClient.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SshClient = void 0;
    var net2 = require("net");
    var dev_tunnels_ssh_1 = require_dev_tunnels_ssh();
    var SshClient = class _SshClient {
      constructor(config) {
        this.config = config;
        this.sessions = [];
        this.trace = (level, eventId, msg, err) => {
        };
        if (!config)
          throw new TypeError("SshSessionConfiguration is required.");
      }
      async openSession(serverHost, serverPort, cancellation) {
        if (!serverHost)
          throw new TypeError("Server host is reqiured.");
        const stream = await this.openConnection(serverHost, serverPort, cancellation);
        const session = new dev_tunnels_ssh_1.SshClientSession(this.config);
        session.trace = this.trace;
        await session.connect(stream, cancellation);
        this.sessions.push(session);
        return session;
      }
      async openConnection(serverHost, serverPort, cancellation) {
        const socket = new net2.Socket();
        await new Promise((resolve3, reject) => {
          socket.on("connect", resolve3);
          socket.on("error", reject);
          if (cancellation) {
            if (cancellation.isCancellationRequested) {
              reject(new dev_tunnels_ssh_1.CancellationError());
              return;
            }
            cancellation.onCancellationRequested(reject);
          }
          socket.connect(serverPort || _SshClient.defaultServerPort, serverHost);
        });
        return new dev_tunnels_ssh_1.NodeStream(socket);
      }
      async reconnectSession(session, serverHost, serverPort, cancellation) {
        const stream = await this.openConnection(serverHost, serverPort, cancellation);
        await session.reconnect(stream, cancellation);
      }
      dispose() {
        while (this.sessions.length > 0) {
          const session = this.sessions.shift();
          session.dispose();
        }
      }
    };
    exports2.SshClient = SshClient;
    SshClient.defaultServerPort = 22;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh-tcp/tcpListenerFactory.js
var require_tcpListenerFactory = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh-tcp/tcpListenerFactory.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DefaultTcpListenerFactory = void 0;
    var net2 = require("net");
    var DefaultTcpListenerFactory = class {
      async createTcpListener(remotePort, localIPAddress, localPort, canChangeLocalPort, cancellation) {
        if (!localIPAddress)
          throw new TypeError("Local IP address is required.");
        if (!Number.isInteger(localPort) || localPort < 0)
          throw new TypeError("Local port must be a non-negative integer.");
        const listener = net2.createServer();
        await new Promise((resolve3, reject) => {
          listener.listen({
            host: localIPAddress,
            port: localPort,
            ipv6Only: net2.isIPv6(localIPAddress),
            exclusive: false
          });
          listener.on("listening", resolve3);
          listener.on("error", reject);
        });
        return listener;
      }
    };
    exports2.DefaultTcpListenerFactory = DefaultTcpListenerFactory;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh-tcp/sshServer.js
var require_sshServer = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh-tcp/sshServer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SshServer = void 0;
    var vscode_jsonrpc_1 = require_main();
    var dev_tunnels_ssh_1 = require_dev_tunnels_ssh();
    var tcpListenerFactory_1 = require_tcpListenerFactory();
    var SshServer = class {
      constructor(config) {
        this.config = config;
        this.sessions = [];
        this.trace = (level, eventId, msg, err) => {
        };
        this.errorEmitter = new vscode_jsonrpc_1.Emitter();
        this.onError = this.errorEmitter.event;
        this.sessionOpenedEmitter = new vscode_jsonrpc_1.Emitter();
        this.onSessionOpened = this.sessionOpenedEmitter.event;
        this.credentials = { publicKeys: [] };
        this.tcpListenerFactory = new tcpListenerFactory_1.DefaultTcpListenerFactory();
        if (!config)
          throw new TypeError("SshSessionConfiguration is required.");
        if (config.protocolExtensions.includes(dev_tunnels_ssh_1.SshProtocolExtensionNames.sessionReconnect)) {
          this.reconnectableSessions = [];
        }
      }
      async acceptSessions(localPort, localAddress) {
        if (!localAddress) {
          localAddress = "0.0.0.0";
        }
        const portPrefix = localAddress === "0.0.0.0" ? "port " : localAddress + ":";
        try {
          this.tcpListener = await this.tcpListenerFactory.createTcpListener(
            void 0,
            // remotePort
            localAddress,
            localPort,
            false
          );
        } catch (e) {
          if (!(e instanceof Error))
            throw e;
          this.trace(dev_tunnels_ssh_1.TraceLevel.Error, dev_tunnels_ssh_1.SshTraceEventIds.serverListenFailed, `SshServer failed to listen on ${portPrefix}${localPort}: ${e.message}`, e);
          throw e;
        }
        this.tcpListener.addListener("connection", this.acceptSession.bind(this));
        this.trace(dev_tunnels_ssh_1.TraceLevel.Info, dev_tunnels_ssh_1.SshTraceEventIds.serverListening, `SshServer listening on ${portPrefix}${localPort}.`);
      }
      async acceptConnection(socket) {
        socket.setNoDelay(true);
        return new dev_tunnels_ssh_1.NodeStream(socket);
      }
      async acceptSession(socket) {
        this.trace(dev_tunnels_ssh_1.TraceLevel.Info, dev_tunnels_ssh_1.SshTraceEventIds.serverClientConnected, "SshServer client connected.");
        const stream = await this.acceptConnection(socket);
        const session = new dev_tunnels_ssh_1.SshServerSession(this.config, this.reconnectableSessions);
        session.trace = this.trace;
        session.credentials = this.credentials;
        this.sessions.push(session);
        session.onClosed((e) => {
          const sessionIndex = this.sessions.indexOf(session);
          if (sessionIndex >= 0) {
            this.sessions.splice(sessionIndex, 1);
          }
        });
        this.sessionOpenedEmitter.fire(session);
        try {
          await session.connect(stream);
        } catch (e) {
          if (!(e instanceof Error))
            throw e;
          if (e instanceof dev_tunnels_ssh_1.SshConnectionError) {
            await session.close(e.reason || dev_tunnels_ssh_1.SshDisconnectReason.connectionLost, e.message, e);
          } else {
            await session.close(dev_tunnels_ssh_1.SshDisconnectReason.protocolError, e.message, e);
          }
          this.errorEmitter.fire(e);
        }
      }
      dispose() {
        var _a;
        (_a = this.tcpListener) === null || _a === void 0 ? void 0 : _a.close();
      }
    };
    exports2.SshServer = SshServer;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh-tcp/events/forwardedPort.js
var require_forwardedPort = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh-tcp/events/forwardedPort.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ForwardedPort = void 0;
    var ForwardedPort = class {
      /** @internal */
      constructor(localPort, remotePort, isRemote) {
        if (localPort === null && remotePort === null) {
          throw new TypeError("Local and remote ports cannot both be null.");
        } else if (!isRemote && remotePort === null) {
          throw new TypeError("The report port number must not be null for locally forwarded ports.");
        }
        if (localPort !== null && (typeof localPort !== "number" || localPort <= 0)) {
          throw new TypeError("Local port must be a positive integer.");
        } else if (remotePort !== null && (typeof remotePort !== "number" || remotePort <= 0)) {
          throw new TypeError("Remote port must be a positive integer: " + remotePort);
        }
        this.localPort = localPort;
        this.remotePort = remotePort;
        const arrow = isRemote ? "->" : "<-";
        if (this.localPort === null) {
          this.str = `${arrow}${this.remotePort}`;
        } else if (this.remotePort == null) {
          this.str = `${this.localPort}${arrow}`;
        } else {
          this.str = `${this.localPort}${arrow}${this.remotePort}`;
        }
      }
      /**
       * Gets a string representation of the forwarded port, which includes both
       * local and remote port numbers if present.
       *
       * An arrow shows the direction of connections (channel open requests).
       * Once connections are opened, data may flow in both directions.
       */
      toString() {
        return this.str;
      }
    };
    exports2.ForwardedPort = ForwardedPort;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh-tcp/events/forwardedPortEventArgs.js
var require_forwardedPortEventArgs = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh-tcp/events/forwardedPortEventArgs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ForwardedPortConnectingEventArgs = exports2.ForwardedPortChannelEventArgs = exports2.ForwardedPortEventArgs = void 0;
    var ForwardedPortEventArgs = class {
      constructor(port) {
        this.port = port;
      }
      toString() {
        return this.port.toString();
      }
    };
    exports2.ForwardedPortEventArgs = ForwardedPortEventArgs;
    var ForwardedPortChannelEventArgs = class extends ForwardedPortEventArgs {
      constructor(port, channel) {
        super(port);
        this.port = port;
        this.channel = channel;
      }
      toString() {
        return `${this.port} ${this.channel}`;
      }
    };
    exports2.ForwardedPortChannelEventArgs = ForwardedPortChannelEventArgs;
    var ForwardedPortConnectingEventArgs = class {
      constructor(port, isIncoming, stream, cancellation) {
        this.port = port;
        this.isIncoming = isIncoming;
        this.stream = stream;
        this.cancellation = cancellation;
      }
      toString() {
        return `${this.port} isIncoming=${this.isIncoming}`;
      }
    };
    exports2.ForwardedPortConnectingEventArgs = ForwardedPortConnectingEventArgs;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh-tcp/events/forwardedPortsCollection.js
var require_forwardedPortsCollection = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh-tcp/events/forwardedPortsCollection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ForwardedPortsCollection = void 0;
    var vscode_jsonrpc_1 = require_main();
    var forwardedPortEventArgs_1 = require_forwardedPortEventArgs();
    var ForwardedPortsCollection = class {
      constructor() {
        this.portChannelMap = /* @__PURE__ */ new Map();
        this.portAddedEmitter = new vscode_jsonrpc_1.Emitter();
        this.onPortAdded = this.portAddedEmitter.event;
        this.portUpdatedEmitter = new vscode_jsonrpc_1.Emitter();
        this.onPortUpdated = this.portUpdatedEmitter.event;
        this.portRemovedEmitter = new vscode_jsonrpc_1.Emitter();
        this.onPortRemoved = this.portRemovedEmitter.event;
        this.portChannelAddedEmitter = new vscode_jsonrpc_1.Emitter();
        this.onPortChannelAdded = this.portChannelAddedEmitter.event;
        this.portChannelRemovedEmitter = new vscode_jsonrpc_1.Emitter();
        this.onPortChannelRemoved = this.portChannelRemovedEmitter.event;
      }
      /** Gets the number of ports in the collection. */
      get size() {
        return this.portChannelMap.size;
      }
      /** Checks whether a port is in the collection. */
      has(port) {
        return this.portChannelMap.has(port.toString());
      }
      /** Lists all the ports in the collection. */
      *values() {
        for (const [port, channels] of this.portChannelMap.values()) {
          yield port;
        }
      }
      /** Iterates over all the ports in the collection. */
      [Symbol.iterator]() {
        return this.values();
      }
      /** Lists all the ports in the collection. */
      *entries() {
        for (const [port, channels] of this.portChannelMap.values()) {
          yield [port, port];
        }
      }
      /**
       * Lists all the ports in the collection.
       * (In a set, the keys are the same as the values.)
       */
      keys() {
        return this.values();
      }
      /** Iterates over all the ports in the collection, invoking a callback function on each. */
      forEach(callbackfn, thisArg) {
        for (const [port, channels] of this.portChannelMap.values()) {
          callbackfn.apply(thisArg, [port, port, this]);
        }
      }
      getChannels(port) {
        const portAndChannels = this.portChannelMap.get(port.toString());
        if (!portAndChannels) {
          throw new Error(`Port ${port} is not in the collection.`);
        }
        return portAndChannels[1];
      }
      /** Finds the first port in the collection that matches a predicate. */
      find(predicate) {
        for (const port of this.values()) {
          if (predicate(port)) {
            return port;
          }
        }
        return void 0;
      }
      /* @internal */
      addOrUpdatePort(port) {
        if (this.has(port)) {
          this.portUpdatedEmitter.fire(new forwardedPortEventArgs_1.ForwardedPortEventArgs(port));
        }
        this.portChannelMap.set(port.toString(), [port, []]);
        this.portAddedEmitter.fire(new forwardedPortEventArgs_1.ForwardedPortEventArgs(port));
      }
      /* @internal */
      removePort(port) {
        if (!this.has(port)) {
          return false;
        }
        this.portChannelMap.delete(port.toString());
        this.portRemovedEmitter.fire(new forwardedPortEventArgs_1.ForwardedPortEventArgs(port));
        return true;
      }
      /* @internal */
      addChannel(port, channel) {
        const portAndChannels = this.portChannelMap.get(port.toString());
        if (!portAndChannels) {
          throw new Error(`Port ${port} is not in the collection.`);
        }
        const portChannels = portAndChannels[1];
        if (portChannels.find((c) => c.channelId === channel.channelId)) {
          throw new Error(`Channel ${channel.channelId} is already in the collection for port ${port}`);
        }
        portChannels.push(channel);
        channel.onClosed(() => this.tryRemoveChannel(port, channel));
        this.portChannelAddedEmitter.fire(new forwardedPortEventArgs_1.ForwardedPortChannelEventArgs(port, channel));
      }
      tryRemoveChannel(port, channel) {
        const portAndChannels = this.portChannelMap.get(port.toString());
        if (portAndChannels) {
          const portChannels = portAndChannels[1];
          const index = portChannels.findIndex((c) => c.channelId === channel.channelId);
          if (index >= 0) {
            portChannels.splice(index, 1);
            this.portChannelRemovedEmitter.fire(new forwardedPortEventArgs_1.ForwardedPortChannelEventArgs(port, channel));
          }
        }
      }
      toString() {
        return [...this].join(", ");
      }
    };
    exports2.ForwardedPortsCollection = ForwardedPortsCollection;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh-tcp/ipAddressConversions.js
var require_ipAddressConversions = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh-tcp/ipAddressConversions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IPAddressConversions = void 0;
    var IPAddressConversions = class {
      /**
       * Converts from an SSH-protocol address string to an IP address string.
       */
      static fromSshAddress(address) {
        if (!address) {
          return "0.0.0.0";
        } else if (address === "localhost") {
          return "127.0.0.1";
        } else {
          return address;
        }
      }
      /**
       * Converts from an IP Address to an SSH-protocol address string.
       */
      static toSshAddress(ipAddress) {
        if (!ipAddress) {
          return null;
        } else if (ipAddress === "0.0.0.0") {
          return "";
        } else if (ipAddress === "127.0.0.1") {
          return "localhost";
        } else {
          return ipAddress;
        }
      }
    };
    exports2.IPAddressConversions = IPAddressConversions;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh-tcp/messages/portForwardChannelOpenMessage.js
var require_portForwardChannelOpenMessage = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh-tcp/messages/portForwardChannelOpenMessage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PortForwardChannelOpenMessage = void 0;
    var dev_tunnels_ssh_1 = require_dev_tunnels_ssh();
    var PortForwardChannelOpenMessage = class extends dev_tunnels_ssh_1.ChannelOpenMessage {
      constructor() {
        super(...arguments);
        this.host = "";
        this.port = 0;
        this.originatorIPAddress = "";
        this.originatorPort = 0;
      }
      onRead(reader) {
        super.onRead(reader);
        this.host = reader.readString("ascii");
        this.port = reader.readUInt32();
        this.originatorIPAddress = reader.readString("ascii");
        this.originatorPort = reader.readUInt32();
      }
      onWrite(writer) {
        super.onWrite(writer);
        writer.writeString(this.validateField(this.host, "host"), "ascii");
        writer.writeUInt32(this.validateField(this.port, "port"));
        writer.writeString(this.originatorIPAddress || "", "ascii");
        writer.writeUInt32(this.originatorPort || 0);
      }
      toString() {
        return `${super.toString()} (host=${this.host} port=${this.port})`;
      }
    };
    exports2.PortForwardChannelOpenMessage = PortForwardChannelOpenMessage;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh-tcp/messages/portForwardRequestMessage.js
var require_portForwardRequestMessage = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh-tcp/messages/portForwardRequestMessage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PortForwardRequestMessage = void 0;
    var dev_tunnels_ssh_1 = require_dev_tunnels_ssh();
    var portForwardingService_1 = require_portForwardingService();
    var PortForwardRequestMessage = class extends dev_tunnels_ssh_1.SessionRequestMessage {
      constructor() {
        super();
        this.addressToBind = "";
        this.port = 0;
        this.requestType = portForwardingService_1.PortForwardingService.portForwardRequestType;
        this.wantReply = true;
      }
      onRead(reader) {
        super.onRead(reader);
        this.addressToBind = reader.readString("ascii");
        this.port = reader.readUInt32();
      }
      onWrite(writer) {
        super.onWrite(writer);
        writer.writeString(this.validateField(this.addressToBind, "address"), "ascii");
        writer.writeUInt32(this.validateField(this.port, "port"));
      }
      toString() {
        return `${super.toString()} (addressToBind=${this.addressToBind} port=${this.port})`;
      }
    };
    exports2.PortForwardRequestMessage = PortForwardRequestMessage;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh-tcp/messages/portForwardSuccessMessage.js
var require_portForwardSuccessMessage = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh-tcp/messages/portForwardSuccessMessage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PortForwardSuccessMessage = void 0;
    var dev_tunnels_ssh_1 = require_dev_tunnels_ssh();
    var PortForwardSuccessMessage = class extends dev_tunnels_ssh_1.SessionRequestSuccessMessage {
      constructor() {
        super(...arguments);
        this.port = 0;
      }
      onRead(reader) {
        super.onRead(reader);
        if (reader.available >= 4) {
          this.port = reader.readUInt32();
        }
      }
      onWrite(writer) {
        super.onWrite(writer);
        writer.writeUInt32(this.validateField(this.port, "port"));
      }
      toString() {
        return `${super.toString()} (port=${this.port})`;
      }
    };
    exports2.PortForwardSuccessMessage = PortForwardSuccessMessage;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh-tcp/portForwardMessageFactory.js
var require_portForwardMessageFactory = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh-tcp/portForwardMessageFactory.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DefaultPortForwardMessageFactory = void 0;
    var portForwardChannelOpenMessage_1 = require_portForwardChannelOpenMessage();
    var portForwardRequestMessage_1 = require_portForwardRequestMessage();
    var portForwardSuccessMessage_1 = require_portForwardSuccessMessage();
    var DefaultPortForwardMessageFactory = class {
      createRequestMessageAsync(port) {
        return Promise.resolve(new portForwardRequestMessage_1.PortForwardRequestMessage());
      }
      createSuccessMessageAsync(port) {
        return Promise.resolve(new portForwardSuccessMessage_1.PortForwardSuccessMessage());
      }
      createChannelOpenMessageAsync(port) {
        return Promise.resolve(new portForwardChannelOpenMessage_1.PortForwardChannelOpenMessage());
      }
    };
    exports2.DefaultPortForwardMessageFactory = DefaultPortForwardMessageFactory;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh-tcp/services/streamForwarder.js
var require_streamForwarder = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh-tcp/services/streamForwarder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StreamForwarder = void 0;
    var dev_tunnels_ssh_1 = require_dev_tunnels_ssh();
    var net_1 = require("net");
    var StreamForwarder = class {
      /* @internal */
      constructor(localStream, remoteStream, trace) {
        this.localStream = localStream;
        this.remoteStream = remoteStream;
        this.trace = trace;
        this.disposed = false;
        if (!localStream)
          throw new TypeError("Local stream is required.");
        if (!remoteStream)
          throw new TypeError("Remote stream is required.");
        localStream.pipe(remoteStream);
        remoteStream.pipe(localStream);
      }
      close(abort, errorMessage) {
        try {
          if (abort && this.localStream instanceof net_1.Socket) {
            this.localStream.destroy();
          } else {
            this.localStream.end();
          }
          if (this.remoteStream instanceof dev_tunnels_ssh_1.SshStream) {
            this.remoteStream.channel.close("SIGABRT", errorMessage).catch((e) => {
            });
          } else {
            this.remoteStream.end();
          }
          this.trace(dev_tunnels_ssh_1.TraceLevel.Verbose, dev_tunnels_ssh_1.SshTraceEventIds.portForwardChannelClosed, `Stream forwarder ${abort ? "aborted" : "closed"} connection.`);
        } catch (e) {
          if (!(e instanceof Error))
            throw e;
          this.trace(dev_tunnels_ssh_1.TraceLevel.Warning, dev_tunnels_ssh_1.SshTraceEventIds.unknownError, `Stream forwarder unexpected error closing connection:  ${e.message}`);
        }
      }
      dispose() {
        if (!this.disposed) {
          this.disposed = true;
          this.close(true);
        }
      }
    };
    exports2.StreamForwarder = StreamForwarder;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh-tcp/services/localPortForwarder.js
var require_localPortForwarder = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh-tcp/services/localPortForwarder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LocalPortForwarder = void 0;
    var dev_tunnels_ssh_1 = require_dev_tunnels_ssh();
    var streamForwarder_1 = require_streamForwarder();
    var LocalPortForwarder = class extends dev_tunnels_ssh_1.SshService {
      /* @internal */
      constructor(pfs, session, channelType, localIPAddress, localPort, remoteHost, remotePort) {
        super(session);
        this.pfs = pfs;
        this.channelType = channelType;
        this.localIPAddress = localIPAddress;
        this.port = localPort;
        this.remoteHost = remoteHost;
        this.remotePort = remotePort !== null && remotePort !== void 0 ? remotePort : localPort !== 0 ? localPort : void 0;
      }
      /**
       * Local port that the forwarder is listening on.
       */
      get localPort() {
        return this.port;
      }
      /* @internal */
      async startForwarding(cancellation) {
        var _a;
        let listenAddress = this.localIPAddress;
        try {
          this.tcpListener = await this.pfs.tcpListenerFactory.createTcpListener(this.remotePort, listenAddress, this.port, true);
          const serverAddress = this.tcpListener.address();
          if (!(serverAddress.port > 0)) {
            this.tcpListener.close();
            throw new Error("Could not get server port.");
          }
          this.port = serverAddress.port;
          if (this.localIPAddress === "127.0.0.1" || this.localIPAddress === "0.0.0.0") {
            listenAddress = this.localIPAddress === "0.0.0.0" ? "::" : "::1";
            try {
              this.tcpListener2 = await this.pfs.tcpListenerFactory.createTcpListener(this.remotePort, listenAddress, this.port, false);
            } catch (e) {
              if (!(e instanceof Error) || e.code !== "EADDRNOTAVAIL") {
                throw e;
              }
              this.trace(dev_tunnels_ssh_1.TraceLevel.Warning, dev_tunnels_ssh_1.SshTraceEventIds.portForwardServerListenFailed, `PortForwardingService failed to listen on ${listenAddress}:{this.port}: ${e.message}`, e);
            }
          }
        } catch (e) {
          if (!(e instanceof Error))
            throw e;
          this.trace(dev_tunnels_ssh_1.TraceLevel.Error, dev_tunnels_ssh_1.SshTraceEventIds.portForwardServerListenFailed, `PortForwardingService failed to listen on ${listenAddress}:${this.port}: ${e.message}`, e);
          throw e;
        }
        this.tcpListener.on("connection", this.acceptConnection.bind(this));
        (_a = this.tcpListener2) === null || _a === void 0 ? void 0 : _a.on("connection", this.acceptConnection.bind(this));
        this.trace(dev_tunnels_ssh_1.TraceLevel.Info, dev_tunnels_ssh_1.SshTraceEventIds.portForwardServerListening, `PortForwardingService listening on ${this.localIPAddress}:${this.port}.`);
        if (this.tcpListener2) {
          this.trace(dev_tunnels_ssh_1.TraceLevel.Info, dev_tunnels_ssh_1.SshTraceEventIds.portForwardServerListening, `PortForwardingService also listening on ${listenAddress}:${this.port}.`);
        }
      }
      async acceptConnection(socket) {
        var _a, _b, _c, _d, _e;
        this.trace(dev_tunnels_ssh_1.TraceLevel.Info, dev_tunnels_ssh_1.SshTraceEventIds.portForwardConnectionAccepted, `PortForwardingService accepted connection from: ${socket.remoteAddress} on port ${this.port}`);
        let channel;
        try {
          channel = await this.pfs.openChannel(this.session, this.channelType, (_a = socket.remoteAddress) !== null && _a !== void 0 ? _a : null, (_b = socket.remotePort) !== null && _b !== void 0 ? _b : null, (_c = this.remoteHost) !== null && _c !== void 0 ? _c : this.localIPAddress, (_d = this.remotePort) !== null && _d !== void 0 ? _d : this.localPort);
        } catch (e) {
          if (!(e instanceof Error))
            throw e;
          socket.destroy();
          return;
        }
        const forwardedStream = await this.pfs.forwardedPortConnecting((_e = this.remotePort) !== null && _e !== void 0 ? _e : this.localPort, false, new dev_tunnels_ssh_1.SshStream(channel));
        if (!forwardedStream) {
          return;
        }
        const forwarder = new streamForwarder_1.StreamForwarder(socket, forwardedStream, channel.session.trace);
        this.pfs.streamForwarders.push(forwarder);
      }
      dispose() {
        var _a, _b;
        (_a = this.tcpListener) === null || _a === void 0 ? void 0 : _a.close();
        (_b = this.tcpListener2) === null || _b === void 0 ? void 0 : _b.close();
        this.trace(dev_tunnels_ssh_1.TraceLevel.Info, dev_tunnels_ssh_1.SshTraceEventIds.portForwardServerListening, `PortForwardingService stopped listening on ${this.localIPAddress}:${this.port}.`);
        super.dispose();
      }
    };
    exports2.LocalPortForwarder = LocalPortForwarder;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh-tcp/services/remotePortConnector.js
var require_remotePortConnector = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh-tcp/services/remotePortConnector.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RemotePortConnector = void 0;
    var dev_tunnels_ssh_1 = require_dev_tunnels_ssh();
    var portForwardRequestMessage_1 = require_portForwardRequestMessage();
    var portForwardSuccessMessage_1 = require_portForwardSuccessMessage();
    var portForwardingService_1 = require_portForwardingService();
    var RemotePortConnector = class extends dev_tunnels_ssh_1.SshService {
      /* @internal */
      constructor(session, remoteIPAddress, remotePort) {
        super(session);
        this.forwarding = false;
        this.remoteIPAddress = remoteIPAddress;
        this.port = remotePort;
      }
      /**
       * Port that the remote server is listening on. If the request specified port 0, this
       * property returns the actual available port that was chosen by the server.
       */
      get remotePort() {
        return this.port;
      }
      /* @internal */
      async request(request, cancellation) {
        if (this.forwarding) {
          throw new Error("Already forwarding.");
        }
        request.addressToBind = this.remoteIPAddress;
        request.port = this.remotePort;
        request.wantReply = true;
        const response = await this.session.requestResponse(request, portForwardSuccessMessage_1.PortForwardSuccessMessage, dev_tunnels_ssh_1.SessionRequestFailureMessage, cancellation);
        let result = false;
        if (response instanceof portForwardSuccessMessage_1.PortForwardSuccessMessage) {
          if (response.port !== 0) {
            this.port = response.port;
          }
          result = true;
        }
        this.forwarding = result;
        return result;
      }
      dispose() {
        if (this.forwarding) {
          this.forwarding = false;
          const request = new portForwardRequestMessage_1.PortForwardRequestMessage();
          request.requestType = portForwardingService_1.PortForwardingService.cancelPortForwardRequestType;
          request.addressToBind = this.remoteIPAddress;
          request.port = this.remotePort;
          request.wantReply = false;
          try {
            this.session.request(request).catch((e) => {
            });
          } catch (e) {
          }
        }
        super.dispose();
      }
    };
    exports2.RemotePortConnector = RemotePortConnector;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh-tcp/services/remotePortForwarder.js
var require_remotePortForwarder = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh-tcp/services/remotePortForwarder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RemotePortForwarder = void 0;
    var net2 = require("net");
    var dev_tunnels_ssh_1 = require_dev_tunnels_ssh();
    var streamForwarder_1 = require_streamForwarder();
    var remotePortConnector_1 = require_remotePortConnector();
    var RemotePortForwarder = class _RemotePortForwarder extends remotePortConnector_1.RemotePortConnector {
      /* @internal */
      constructor(pfs, session, remoteIPAddress, remotePort, localHost, localPort) {
        super(session, remoteIPAddress, remotePort);
        this.pfs = pfs;
        this.localHost = localHost;
        this.localPort = localPort;
      }
      /* @internal */
      async onPortChannelOpening(request, cancellation) {
        await _RemotePortForwarder.forwardChannel(this.pfs, request, this.localHost, this.localPort, this.remotePort, this.trace, cancellation);
      }
      /* @internal */
      static async forwardChannel(pfs, request, localHost, localPort, remotePort, trace, cancellation) {
        const channel = request.channel;
        const forwardedStream = await pfs.forwardedPortConnecting(remotePort !== null && remotePort !== void 0 ? remotePort : localPort, true, new dev_tunnels_ssh_1.SshStream(channel), cancellation);
        if (!forwardedStream) {
          request.failureReason = dev_tunnels_ssh_1.SshChannelOpenFailureReason.connectFailed;
          return;
        }
        const socket = net2.createConnection({
          host: localHost,
          port: localPort,
          // This option enables connection attempts for multiple resolved IP addresses,
          // aka "Happy Eyeballs" as described in https://datatracker.ietf.org/doc/html/rfc8305.
          // Effectively this enables fast connections to either 127.0.0.1 or ::1 when 'localhost'
          // is specified as the hostname. Note this option is available starting with Node.js
          // v18.13 and is enabled by default starting with Node.js v20.0.
          autoSelectFamily: true,
          // Use the minimum supported connection attempt delay when connecting to 'localhost'.
          // See https://nodejs.org/api/net.html#socketconnectoptions-connectlistener
          autoSelectFamilyAttemptTimeout: localHost === "localhost" ? 10 : 250
        });
        const connectCompletion = new dev_tunnels_ssh_1.PromiseCompletionSource();
        const cancellationRegistration = cancellation ? cancellation.onCancellationRequested(() => socket.destroy(new Error("Cancelled."))) : null;
        try {
          socket.once("connect", () => {
            connectCompletion.resolve();
          });
          socket.once("error", (e) => {
            connectCompletion.reject(e);
          });
          await connectCompletion.promise;
        } catch (e) {
          if (!(e instanceof Error) || (cancellation === null || cancellation === void 0 ? void 0 : cancellation.isCancellationRequested)) {
            throw e;
          }
          trace(dev_tunnels_ssh_1.TraceLevel.Warning, dev_tunnels_ssh_1.SshTraceEventIds.portForwardConnectionFailed, `PortForwardingService connection to ${localHost}:${localPort} failed: ${e.message}`, e);
          request.failureReason = dev_tunnels_ssh_1.SshChannelOpenFailureReason.connectFailed;
          request.failureDescription = e.message;
        } finally {
          cancellationRegistration === null || cancellationRegistration === void 0 ? void 0 : cancellationRegistration.dispose();
        }
        const streamForwarder = new streamForwarder_1.StreamForwarder(socket, forwardedStream, channel.session.trace);
        trace(dev_tunnels_ssh_1.TraceLevel.Info, dev_tunnels_ssh_1.SshTraceEventIds.portForwardConnectionOpened, `${channel.session} PortForwardingService forwarded channel #${channel.channelId} connection to ${localHost}:${localPort}.`);
        pfs.streamForwarders.push(streamForwarder);
      }
    };
    exports2.RemotePortForwarder = RemotePortForwarder;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh-tcp/services/remotePortStreamer.js
var require_remotePortStreamer = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh-tcp/services/remotePortStreamer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RemotePortStreamer = void 0;
    var vscode_jsonrpc_1 = require_main();
    var dev_tunnels_ssh_1 = require_dev_tunnels_ssh();
    var remotePortConnector_1 = require_remotePortConnector();
    var RemotePortStreamer = class extends remotePortConnector_1.RemotePortConnector {
      /* @internal */
      constructor(session, remoteIPAddress, remotePort) {
        super(session, remoteIPAddress, remotePort);
        this.streamOpenedEmitter = new vscode_jsonrpc_1.Emitter();
        this.onStreamOpened = this.streamOpenedEmitter.event;
      }
      /* @internal */
      async onPortChannelOpening(request, cancellation) {
        const stream = new dev_tunnels_ssh_1.SshStream(request.channel);
        this.streamOpenedEmitter.fire(stream);
      }
    };
    exports2.RemotePortStreamer = RemotePortStreamer;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh-tcp/services/portForwardingService.js
var require_portForwardingService = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh-tcp/services/portForwardingService.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var PortForwardingService_1;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PortForwardingService = void 0;
    var dev_tunnels_ssh_1 = require_dev_tunnels_ssh();
    var vscode_jsonrpc_1 = require_main();
    var forwardedPort_1 = require_forwardedPort();
    var forwardedPortsCollection_1 = require_forwardedPortsCollection();
    var ipAddressConversions_1 = require_ipAddressConversions();
    var portForwardChannelOpenMessage_1 = require_portForwardChannelOpenMessage();
    var portForwardRequestMessage_1 = require_portForwardRequestMessage();
    var portForwardSuccessMessage_1 = require_portForwardSuccessMessage();
    var tcpListenerFactory_1 = require_tcpListenerFactory();
    var portForwardMessageFactory_1 = require_portForwardMessageFactory();
    var localPortForwarder_1 = require_localPortForwarder();
    var remotePortForwarder_1 = require_remotePortForwarder();
    var remotePortStreamer_1 = require_remotePortStreamer();
    var forwardedPortEventArgs_1 = require_forwardedPortEventArgs();
    var PortForwardingService = PortForwardingService_1 = class PortForwardingService extends dev_tunnels_ssh_1.SshService {
      /* @internal */
      constructor(session) {
        super(session);
        this.localForwarders = /* @__PURE__ */ new Map();
        this.remoteConnectors = /* @__PURE__ */ new Map();
        this.streamForwarders = [];
        this.acceptLocalConnectionsForForwardedPorts = true;
        this.forwardConnectionsToLocalPorts = true;
        this.acceptRemoteConnectionsForNonForwardedPorts = true;
        this.localForwardedPorts = new forwardedPortsCollection_1.ForwardedPortsCollection();
        this.remoteForwardedPorts = new forwardedPortsCollection_1.ForwardedPortsCollection();
        this.tcpListenerFactory = new tcpListenerFactory_1.DefaultTcpListenerFactory();
        this.messageFactory = new portForwardMessageFactory_1.DefaultPortForwardMessageFactory();
        this.forwardedPortConnectingEmitter = new vscode_jsonrpc_1.Emitter();
        this.onForwardedPortConnecting = this.forwardedPortConnectingEmitter.event;
      }
      /* @internal */
      async forwardedPortConnecting(port, isIncoming, stream, cancellation) {
        try {
          const args = new forwardedPortEventArgs_1.ForwardedPortConnectingEventArgs(port, isIncoming, stream, cancellation);
          this.forwardedPortConnectingEmitter.fire(args);
          if (args.transformPromise) {
            return await args.transformPromise;
          }
        } catch (e) {
          if (!(e instanceof Error))
            throw e;
          this.trace(dev_tunnels_ssh_1.TraceLevel.Warning, dev_tunnels_ssh_1.SshTraceEventIds.portForwardConnectionFailed, `Forwarded port connecting event-handler failed: ${e.message}`);
          return null;
        }
        return stream;
      }
      async forwardFromRemotePort(remoteIPAddress, remotePort, localHostOrCancellation, localPort, cancellation) {
        const localHost = typeof localHostOrCancellation === "string" ? localHostOrCancellation : "127.0.0.1";
        if (typeof localPort === "undefined")
          localPort = remotePort;
        if (!remoteIPAddress)
          throw new TypeError("Remote IP address is required.");
        if (!Number.isInteger(remotePort) || remotePort < 0) {
          throw new TypeError("Remote port must be a non-negative integer.");
        }
        if (!localHost)
          throw new TypeError("Local host is required.");
        if (!Number.isInteger(localPort) || localPort <= 0) {
          throw new TypeError("Local port must be a positive integer.");
        }
        if (this.localForwardedPorts.find((p) => p.localPort === localPort)) {
          throw new Error(`Local port ${localPort} is already forwarded.`);
        } else if (remotePort > 0 && this.localForwardedPorts.find((p) => p.remotePort === remotePort)) {
          throw new Error(`Remote port ${remotePort} is already forwarded.`);
        }
        const forwarder = new remotePortForwarder_1.RemotePortForwarder(this, this.session, remoteIPAddress, remotePort, localHost, localPort);
        const request = await this.messageFactory.createRequestMessageAsync(remotePort);
        if (!await forwarder.request(request, cancellation)) {
          return null;
        }
        remotePort = forwarder.remotePort;
        if (this.remoteConnectors.has(remotePort)) {
          return null;
        }
        this.remoteConnectors.set(remotePort, forwarder);
        const forwardedPort = new forwardedPort_1.ForwardedPort(localPort, remotePort, false);
        this.localForwardedPorts.addOrUpdatePort(forwardedPort);
        forwarder.onDisposed(() => {
          this.localForwardedPorts.removePort(forwardedPort);
          this.remoteConnectors.delete(remotePort);
        });
        return forwarder;
      }
      async forwardToRemotePort(localIPAddress, localPort, remoteHostOrCancellation, remotePort, cancellation) {
        const remoteHost = typeof remoteHostOrCancellation === "string" ? remoteHostOrCancellation : "127.0.0.1";
        if (typeof remotePort === "undefined")
          remotePort = localPort;
        if (!localIPAddress)
          throw new TypeError("Local IP address is required.");
        if (!Number.isInteger(localPort) || localPort < 0) {
          throw new TypeError("Local port must be a non-negative integer.");
        }
        if (!remoteHost)
          throw new TypeError("Remote host is required.");
        if (!Number.isInteger(remotePort) || remotePort <= 0) {
          throw new TypeError("Remote port must be a positive integer.");
        }
        if (this.localForwarders.has(remotePort)) {
          throw new Error(`Port ${remotePort} is already forwarded.`);
        }
        const forwarder = new localPortForwarder_1.LocalPortForwarder(this, this.session, PortForwardingService_1.reversePortForwardChannelType, localIPAddress, localPort, remoteHost, remotePort);
        await forwarder.startForwarding(cancellation);
        this.localForwarders.set(remotePort, forwarder);
        forwarder.onDisposed(() => {
          this.localForwarders.delete(remotePort);
        });
        return forwarder;
      }
      /**
       * Sends a request to the remote side to listen on a port and forward incoming connections as
       * SSH channels of type 'forwarded-tcpip', which will then be relayed as local streams.
       *
       * @param remoteIPAddress IP address of the interface to bind to on the remote side.
       * @param remotePort The remote port to listen on, or 0 to choose an available port.
       * (The chosen port can then be obtained via the `remotePort` property on the returned object.)
       * @param cancellation Cancellation token for the request; note this cannot cancel forwarding
       * once it has started; use the returned disposable do do that.
       * @returns A disposable object that when disposed will cancel forwarding the port, or `null`
       * if the request was rejected by the remote side, possibly because the remote port was already
       * in use. Handle the `onStreamOpened` event on this object to receive streams.
       */
      async streamFromRemotePort(remoteIPAddress, remotePort, cancellation) {
        if (!remoteIPAddress)
          throw new TypeError("Remote IP address is required.");
        if (!Number.isInteger(remotePort) || remotePort < 0) {
          throw new TypeError("Remote port must be a non-negative integer.");
        }
        const streamer = new remotePortStreamer_1.RemotePortStreamer(this.session, remoteIPAddress, remotePort);
        const request = await this.messageFactory.createRequestMessageAsync(remotePort);
        if (!await streamer.request(request, cancellation)) {
          streamer.dispose();
          return null;
        }
        remotePort = streamer.remotePort;
        this.remoteConnectors.set(remotePort, streamer);
        const forwardedPort = new forwardedPort_1.ForwardedPort(null, remotePort, false);
        this.localForwardedPorts.addOrUpdatePort(forwardedPort);
        streamer.onDisposed(() => {
          this.localForwardedPorts.removePort(forwardedPort);
          this.remoteConnectors.delete(remotePort);
        });
        return streamer;
      }
      /**
       * Opens a stream for an SSH channel of type 'direct-tcpip' that is relayed to remote port,
       * regardless of whether the remote side has explicitly forwarded that port.
       *
       * @param remoteHost The destination hostname or IP address for forwarded connections, to be
       * resolved on the remote side. WARNING: Avoid using the hostname `localhost` as the destination
       * host; use `127.0.0.1` or `::1` instead. (OpenSSH does not recognize `localhost` as a valid
       * destination host.)
       * @param remotePort The destination port for the forwarded stream. (Must not be 0.)
       * @param cancellation Cancellation token for the request; note this cannot cancel streaming
       * once it has started; dipose the returned stream for that.
       * @returns A stream that is relayed to the remote port.
       * @throws `SshChannelError` if the streaming channel could not be opened, either because it
       * was rejected by the remote side, or the remote connection failed.
       */
      async streamToRemotePort(remoteHost, remotePort, cancellation) {
        if (!remoteHost)
          throw new TypeError("Remote host is required.");
        if (!Number.isInteger(remotePort) || remotePort <= 0) {
          throw new TypeError("Remote port must be a positive integer.");
        }
        const channel = await this.openChannel(this.session, PortForwardingService_1.reversePortForwardChannelType, null, null, remoteHost, remotePort, cancellation);
        return new dev_tunnels_ssh_1.SshStream(channel);
      }
      /**
       * Opens a stream for an SSH channel of type 'forwarded-tcpip' that is relayed to a remote
       * port. The port must have been explicitly forwarded by the remote side.
       *
       * It may be necessary to call `waitForForwardedPort` before this method
       * to ensure the port is ready for connections.
       *
       * An error is thrown if the requested port could not be forwarded, possibly because it was
       * rejected by the remote side, or the remote connection failed.
       *
       * @param forwardedPort Remote port number that was forwarded.
       * @param cancellation Cancellation token for the request; note this cannot
       * cancel streaming once it has started; dipose the returned stream for that.
       * @returns A stream that is relayed to the remote forwarded port.
       */
      async connectToForwardedPort(forwardedPort, cancellation) {
        if (!Number.isInteger(forwardedPort) || forwardedPort <= 0) {
          throw new TypeError("Forwarded port must be a positive integer.");
        }
        const channel = await this.openChannel(this.session, PortForwardingService_1.portForwardChannelType, null, null, "127.0.0.1", forwardedPort, cancellation);
        const forwardedStream = await this.forwardedPortConnecting(forwardedPort, false, new dev_tunnels_ssh_1.SshStream(channel), cancellation);
        if (!forwardedStream) {
          channel.close().catch((e) => {
          });
          throw new dev_tunnels_ssh_1.SshChannelError("The connection to the forwarded port was rejected by the connecting event-handler.");
        }
        return forwardedStream;
      }
      /**
       * Waits asynchronously for the remote side to forward an expected port number.
       *
       * A common pattern for some applications may be to call this method just before
       * `ConnectToForwardedPortAsync`.
       *
       * @param forwardedPort Port number that is expected to be forwarded.
       * @param cancellation Token that can be used to cancel waiting.
       * @returns A promise that completes when the expected port number has been forwarded.
       */
      async waitForForwardedPort(forwardedPort, cancellation) {
        if (this.remoteForwardedPorts.find((p) => p.remotePort === forwardedPort)) {
          return;
        }
        const waitCompletion = new dev_tunnels_ssh_1.PromiseCompletionSource();
        let cancellationRegistration;
        if (cancellation) {
          cancellationRegistration = cancellation.onCancellationRequested(() => waitCompletion.reject(new dev_tunnels_ssh_1.CancellationError()));
        }
        let portAddedRegistration;
        let sessionClosedRegistration;
        try {
          portAddedRegistration = this.remoteForwardedPorts.onPortAdded((e) => {
            if (e.port.remotePort === forwardedPort) {
              waitCompletion.resolve();
            }
          });
          sessionClosedRegistration = this.session.onClosed(() => {
            waitCompletion.reject(new dev_tunnels_ssh_1.ObjectDisposedError("The session was closed."));
          });
          await waitCompletion.promise;
        } finally {
          portAddedRegistration === null || portAddedRegistration === void 0 ? void 0 : portAddedRegistration.dispose();
          sessionClosedRegistration === null || sessionClosedRegistration === void 0 ? void 0 : sessionClosedRegistration.dispose();
          cancellationRegistration === null || cancellationRegistration === void 0 ? void 0 : cancellationRegistration.dispose();
        }
      }
      async onSessionRequest(request, cancellation) {
        if (!request)
          throw new TypeError("Request is required.");
        else if (request.requestType !== PortForwardingService_1.portForwardRequestType && request.requestType !== PortForwardingService_1.cancelPortForwardRequestType) {
          throw new Error(`Unexpected request type: ${request.requestType}`);
        }
        const portForwardRequest = request.request.convertTo(new portForwardRequestMessage_1.PortForwardRequestMessage());
        const localIPAddress = ipAddressConversions_1.IPAddressConversions.fromSshAddress(portForwardRequest.addressToBind);
        if (request.requestType === PortForwardingService_1.portForwardRequestType && portForwardRequest.port !== 0 && this.localForwarders.has(portForwardRequest.port)) {
          const message = `PortForwardingService port ${portForwardRequest.port} is already forwarded.`;
          this.session.trace(dev_tunnels_ssh_1.TraceLevel.Verbose, dev_tunnels_ssh_1.SshTraceEventIds.portForwardRequestInvalid, message);
          request.isAuthorized = false;
          return;
        }
        const args = new dev_tunnels_ssh_1.SshRequestEventArgs(request.requestType, portForwardRequest, this.session.principal);
        await super.onSessionRequest(args, cancellation);
        let response;
        let localPort = null;
        if (args.isAuthorized) {
          if (request.requestType === PortForwardingService_1.portForwardRequestType) {
            try {
              localPort = await this.startForwarding(localIPAddress, portForwardRequest.port, cancellation);
            } catch (e) {
            }
            if (localPort !== null) {
              const forwardedPort = portForwardRequest.port === 0 ? localPort : portForwardRequest.port;
              const portResponse = await this.messageFactory.createSuccessMessageAsync(forwardedPort);
              portResponse.port = forwardedPort;
              response = portResponse;
            }
          } else if (request.requestType === PortForwardingService_1.cancelPortForwardRequestType) {
            if (await this.cancelForwarding(portForwardRequest.port, cancellation)) {
              response = new dev_tunnels_ssh_1.SessionRequestSuccessMessage();
            }
          }
        }
        request.responsePromise = Promise.resolve(response !== null && response !== void 0 ? response : new dev_tunnels_ssh_1.SessionRequestFailureMessage());
        if (response instanceof portForwardSuccessMessage_1.PortForwardSuccessMessage) {
          const forwardedPort = new forwardedPort_1.ForwardedPort(localPort !== null && localPort !== void 0 ? localPort : response.port, response.port, true);
          this.remoteForwardedPorts.addOrUpdatePort(forwardedPort);
        }
      }
      async startForwarding(localIPAddress, remotePort, cancellation) {
        if (typeof remotePort !== "number")
          throw new TypeError("Remote port must be an integer.");
        if (this.acceptLocalConnectionsForForwardedPorts) {
          let localPort = remotePort;
          const forwarder = new localPortForwarder_1.LocalPortForwarder(this, this.session, PortForwardingService_1.portForwardChannelType, localIPAddress, localPort, void 0, remotePort === 0 ? void 0 : remotePort);
          await forwarder.startForwarding(cancellation);
          localPort = forwarder.localPort;
          if (remotePort === 0) {
            remotePort = localPort;
          }
          if (this.localForwarders.has(remotePort)) {
            forwarder.dispose();
            return null;
          }
          this.localForwarders.set(remotePort, forwarder);
          localPort = forwarder.localPort;
          forwarder.onDisposed(() => {
            const forwardedPort = new forwardedPort_1.ForwardedPort(localPort, remotePort, true);
            this.remoteForwardedPorts.removePort(forwardedPort);
            this.localForwarders.delete(remotePort);
          });
          return localPort;
        } else if (remotePort !== 0) {
          return remotePort;
        } else {
          return null;
        }
      }
      async cancelForwarding(forwardedPort, cancellation) {
        const forwarder = this.localForwarders.get(forwardedPort);
        if (forwarder) {
          this.localForwarders.delete(forwardedPort);
          forwarder.dispose();
          return true;
        }
        const port = new forwardedPort_1.ForwardedPort(forwardedPort, forwardedPort, true);
        if (this.remoteForwardedPorts.removePort(port)) {
          return true;
        }
        return false;
      }
      async onChannelOpening(request, cancellation) {
        var _a;
        if (!request)
          throw new TypeError("Request is required.");
        const channelType = request.request.channelType;
        if (channelType !== PortForwardingService_1.portForwardChannelType && channelType !== PortForwardingService_1.reversePortForwardChannelType) {
          request.failureReason = dev_tunnels_ssh_1.SshChannelOpenFailureReason.unknownChannelType;
          return;
        }
        let remoteConnector = null;
        const portForwardMessage = request.request instanceof portForwardChannelOpenMessage_1.PortForwardChannelOpenMessage ? request.request : request.request.convertTo(new portForwardChannelOpenMessage_1.PortForwardChannelOpenMessage());
        if (request.isRemoteRequest) {
          if (channelType === PortForwardingService_1.portForwardChannelType) {
            const remoteIPAddress = ipAddressConversions_1.IPAddressConversions.fromSshAddress(portForwardMessage.host);
            const remoteEndPoint = `${remoteIPAddress}:${portForwardMessage.port}`;
            remoteConnector = (_a = this.remoteConnectors.get(portForwardMessage.port)) !== null && _a !== void 0 ? _a : null;
            if (!remoteConnector) {
              this.trace(dev_tunnels_ssh_1.TraceLevel.Error, dev_tunnels_ssh_1.SshTraceEventIds.portForwardRequestInvalid, `PortForwardingService received forwarding channel for ${remoteEndPoint} that was not requested.`);
              request.failureReason = dev_tunnels_ssh_1.SshChannelOpenFailureReason.connectFailed;
              request.failureDescription = "Forwarding channel was not requested.";
              return;
            }
          } else if (!this.acceptRemoteConnectionsForNonForwardedPorts) {
            const errorMessage = "The session has disabled connections to non-forwarded ports.";
            this.session.trace(dev_tunnels_ssh_1.TraceLevel.Warning, dev_tunnels_ssh_1.SshTraceEventIds.portForwardChannelOpenFailed, errorMessage);
            request.failureReason = dev_tunnels_ssh_1.SshChannelOpenFailureReason.administrativelyProhibited;
            request.failureDescription = errorMessage;
            return;
          }
        }
        const portForwardRequest = new dev_tunnels_ssh_1.SshChannelOpeningEventArgs(portForwardMessage, request.channel, request.isRemoteRequest);
        await super.onChannelOpening(portForwardRequest, cancellation);
        request.failureReason = portForwardRequest.failureReason;
        request.failureDescription = portForwardRequest.failureDescription;
        request.openingPromise = portForwardRequest.openingPromise;
        if (request.failureReason === dev_tunnels_ssh_1.SshChannelOpenFailureReason.none && request.isRemoteRequest && this.forwardConnectionsToLocalPorts) {
          if (remoteConnector) {
            await remoteConnector.onPortChannelOpening(request, cancellation);
            const localPort = remoteConnector instanceof remotePortForwarder_1.RemotePortForwarder ? remoteConnector.localPort : null;
            const remotePort = remoteConnector instanceof remotePortForwarder_1.RemotePortForwarder ? remoteConnector.remotePort : portForwardMessage.port;
            const forwardedPort = new forwardedPort_1.ForwardedPort(localPort, remotePort, false);
            this.localForwardedPorts.addChannel(forwardedPort, request.channel);
          } else {
            await remotePortForwarder_1.RemotePortForwarder.forwardChannel(this, request, portForwardMessage.host, portForwardMessage.port, portForwardMessage.port, this.trace, cancellation);
            if (request.failureReason !== dev_tunnels_ssh_1.SshChannelOpenFailureReason.none) {
              await request.channel.close(cancellation);
            }
          }
        }
      }
      /* @internal */
      async openChannel(session, channelType, originatorIPAddress, originatorPort, host, port, cancellation) {
        let forwardedPort = void 0;
        if (channelType === PortForwardingService_1.portForwardChannelType) {
          forwardedPort = this.remoteForwardedPorts.find((p) => p.remotePort === port || p.remotePort === null && p.localPort === port);
          if (!forwardedPort) {
            throw new Error(`Port ${port} is not being forwarded.`);
          }
        }
        const openMessage = await this.messageFactory.createChannelOpenMessageAsync(port);
        openMessage.channelType = channelType;
        openMessage.originatorIPAddress = originatorIPAddress !== null && originatorIPAddress !== void 0 ? originatorIPAddress : "";
        openMessage.originatorPort = originatorPort !== null && originatorPort !== void 0 ? originatorPort : 0;
        openMessage.host = host;
        openMessage.port = port;
        const trace = this.session.trace;
        let channel;
        try {
          channel = await session.openChannel(openMessage, null, cancellation);
          trace(dev_tunnels_ssh_1.TraceLevel.Info, dev_tunnels_ssh_1.SshTraceEventIds.portForwardChannelOpened, `PortForwardingService opened ${channelType} channel #${channel.channelId} for ${host}:${port}.`);
        } catch (e) {
          if (!(e instanceof Error))
            throw e;
          trace(dev_tunnels_ssh_1.TraceLevel.Error, dev_tunnels_ssh_1.SshTraceEventIds.portForwardChannelOpenFailed, `PortForwardingService failed to open ${channelType} channel for ${host}:${port}: ${e.message}`, e);
          throw e;
        }
        if (channelType === PortForwardingService_1.portForwardChannelType) {
          this.remoteForwardedPorts.addChannel(forwardedPort, channel);
        }
        return channel;
      }
      dispose() {
        const disposables = [
          ...this.localForwarders.values(),
          ...this.remoteConnectors.values()
        ];
        this.streamForwarders.splice(0, this.streamForwarders.length);
        this.localForwarders.clear();
        this.remoteConnectors.clear();
        for (const disposable of disposables) {
          disposable.dispose();
        }
        super.dispose();
      }
    };
    PortForwardingService.portForwardRequestType = "tcpip-forward";
    PortForwardingService.cancelPortForwardRequestType = "cancel-tcpip-forward";
    PortForwardingService.portForwardChannelType = "forwarded-tcpip";
    PortForwardingService.reversePortForwardChannelType = "direct-tcpip";
    PortForwardingService = PortForwardingService_1 = __decorate([
      (0, dev_tunnels_ssh_1.serviceActivation)({ sessionRequest: PortForwardingService_1.portForwardRequestType }),
      (0, dev_tunnels_ssh_1.serviceActivation)({ sessionRequest: PortForwardingService_1.cancelPortForwardRequestType }),
      (0, dev_tunnels_ssh_1.serviceActivation)({ channelType: PortForwardingService_1.portForwardChannelType }),
      (0, dev_tunnels_ssh_1.serviceActivation)({ channelType: PortForwardingService_1.reversePortForwardChannelType })
    ], PortForwardingService);
    exports2.PortForwardingService = PortForwardingService;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh-tcp/index.js
var require_dev_tunnels_ssh_tcp = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh-tcp/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ForwardedPortConnectingEventArgs = exports2.ForwardedPortChannelEventArgs = exports2.ForwardedPortEventArgs = exports2.ForwardedPortsCollection = exports2.ForwardedPort = exports2.PortForwardChannelOpenMessage = exports2.PortForwardSuccessMessage = exports2.PortForwardRequestMessage = exports2.RemotePortStreamer = exports2.RemotePortForwarder = exports2.LocalPortForwarder = exports2.PortForwardingService = exports2.SshServer = exports2.SshClient = void 0;
    var sshClient_1 = require_sshClient();
    Object.defineProperty(exports2, "SshClient", { enumerable: true, get: function() {
      return sshClient_1.SshClient;
    } });
    var sshServer_1 = require_sshServer();
    Object.defineProperty(exports2, "SshServer", { enumerable: true, get: function() {
      return sshServer_1.SshServer;
    } });
    var portForwardingService_1 = require_portForwardingService();
    Object.defineProperty(exports2, "PortForwardingService", { enumerable: true, get: function() {
      return portForwardingService_1.PortForwardingService;
    } });
    var localPortForwarder_1 = require_localPortForwarder();
    Object.defineProperty(exports2, "LocalPortForwarder", { enumerable: true, get: function() {
      return localPortForwarder_1.LocalPortForwarder;
    } });
    var remotePortForwarder_1 = require_remotePortForwarder();
    Object.defineProperty(exports2, "RemotePortForwarder", { enumerable: true, get: function() {
      return remotePortForwarder_1.RemotePortForwarder;
    } });
    var remotePortStreamer_1 = require_remotePortStreamer();
    Object.defineProperty(exports2, "RemotePortStreamer", { enumerable: true, get: function() {
      return remotePortStreamer_1.RemotePortStreamer;
    } });
    var portForwardRequestMessage_1 = require_portForwardRequestMessage();
    Object.defineProperty(exports2, "PortForwardRequestMessage", { enumerable: true, get: function() {
      return portForwardRequestMessage_1.PortForwardRequestMessage;
    } });
    var portForwardSuccessMessage_1 = require_portForwardSuccessMessage();
    Object.defineProperty(exports2, "PortForwardSuccessMessage", { enumerable: true, get: function() {
      return portForwardSuccessMessage_1.PortForwardSuccessMessage;
    } });
    var portForwardChannelOpenMessage_1 = require_portForwardChannelOpenMessage();
    Object.defineProperty(exports2, "PortForwardChannelOpenMessage", { enumerable: true, get: function() {
      return portForwardChannelOpenMessage_1.PortForwardChannelOpenMessage;
    } });
    var forwardedPort_1 = require_forwardedPort();
    Object.defineProperty(exports2, "ForwardedPort", { enumerable: true, get: function() {
      return forwardedPort_1.ForwardedPort;
    } });
    var forwardedPortsCollection_1 = require_forwardedPortsCollection();
    Object.defineProperty(exports2, "ForwardedPortsCollection", { enumerable: true, get: function() {
      return forwardedPortsCollection_1.ForwardedPortsCollection;
    } });
    var forwardedPortEventArgs_1 = require_forwardedPortEventArgs();
    Object.defineProperty(exports2, "ForwardedPortEventArgs", { enumerable: true, get: function() {
      return forwardedPortEventArgs_1.ForwardedPortEventArgs;
    } });
    Object.defineProperty(exports2, "ForwardedPortChannelEventArgs", { enumerable: true, get: function() {
      return forwardedPortEventArgs_1.ForwardedPortChannelEventArgs;
    } });
    Object.defineProperty(exports2, "ForwardedPortConnectingEventArgs", { enumerable: true, get: function() {
      return forwardedPortEventArgs_1.ForwardedPortConnectingEventArgs;
    } });
  }
});

// ../../node_modules/@microsoft/dev-tunnels-connections/messages/portRelayConnectResponseMessage.js
var require_portRelayConnectResponseMessage = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-connections/messages/portRelayConnectResponseMessage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PortRelayConnectResponseMessage = void 0;
    var dev_tunnels_ssh_1 = require_dev_tunnels_ssh();
    var PortRelayConnectResponseMessage = class extends dev_tunnels_ssh_1.ChannelOpenConfirmationMessage {
      constructor() {
        super(...arguments);
        this.isE2EEncryptionEnabled = false;
      }
      onWrite(writer) {
        super.onWrite(writer);
        writer.writeBoolean(this.isE2EEncryptionEnabled);
      }
      onRead(reader) {
        super.onRead(reader);
        this.isE2EEncryptionEnabled = reader.readBoolean();
      }
    };
    exports2.PortRelayConnectResponseMessage = PortRelayConnectResponseMessage;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-connections/retryingTunnelConnectionEventArgs.js
var require_retryingTunnelConnectionEventArgs = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-connections/retryingTunnelConnectionEventArgs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RetryingTunnelConnectionEventArgs = void 0;
    var RetryingTunnelConnectionEventArgs = class {
      constructor(error, delayMs) {
        this.error = error;
        this.delayMs = delayMs;
        this.retry = true;
      }
    };
    exports2.RetryingTunnelConnectionEventArgs = RetryingTunnelConnectionEventArgs;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-connections/relayTunnelConnector.js
var require_relayTunnelConnector = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-connections/relayTunnelConnector.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RelayTunnelConnector = exports2.maxReconnectDelayMs = void 0;
    var dev_tunnels_ssh_1 = require_dev_tunnels_ssh();
    var utils_1 = require_utils();
    var sshHelpers_1 = require_sshHelpers();
    var retryingTunnelConnectionEventArgs_1 = require_retryingTunnelConnectionEventArgs();
    exports2.maxReconnectDelayMs = 13e3;
    var reconnectInitialDelayMs = 1e3;
    var maxBrowserReconnectAttempts = 5;
    var RelayTunnelConnector = class {
      constructor(tunnelSession) {
        this.tunnelSession = tunnelSession;
      }
      get trace() {
        return this.tunnelSession.trace;
      }
      /**
       * Connect or reconnect tunnel SSH session.
       * @param isReconnect A value indicating if this is a reconnect (true) or regular connect (false).
       * @param cancellation Cancellation token.
       */
      async connectSession(isReconnect, options, cancellation) {
        var _a, _b;
        let disconnectReason;
        let error;
        function throwIfCancellation(e) {
          if (e instanceof dev_tunnels_ssh_1.CancellationError && (cancellation === null || cancellation === void 0 ? void 0 : cancellation.isCancellationRequested) || e instanceof dev_tunnels_ssh_1.ObjectDisposedError) {
            error = void 0;
            disconnectReason = dev_tunnels_ssh_1.SshDisconnectReason.byApplication;
            throw e;
          }
        }
        function throwError(message) {
          if (error) {
            error.message = message;
          } else {
            error = new Error(message);
          }
          throw error;
        }
        let browserReconnectAttempt = 0;
        let attemptDelayMs = reconnectInitialDelayMs;
        let isTunnelAccessTokenRefreshed = false;
        let isDelayNeeded = true;
        let errorDescription;
        this.tunnelSession.startConnecting();
        try {
          for (let attempt = 0; ; attempt++) {
            if (cancellation === null || cancellation === void 0 ? void 0 : cancellation.isCancellationRequested) {
              throw new dev_tunnels_ssh_1.CancellationError();
            }
            if (attempt > 0) {
              if (error) {
                if (!((_a = options === null || options === void 0 ? void 0 : options.enableRetry) !== null && _a !== void 0 ? _a : true)) {
                  throw error;
                }
                const args = new retryingTunnelConnectionEventArgs_1.RetryingTunnelConnectionEventArgs(error, attemptDelayMs);
                this.tunnelSession.onRetrying(args);
                if (!args.retry) {
                  throw error;
                }
                if (args.delayMs >= reconnectInitialDelayMs) {
                  attemptDelayMs = args.delayMs;
                } else {
                  isDelayNeeded = false;
                }
              }
              const retryTiming = isDelayNeeded ? ` in ${attemptDelayMs < 1e3 ? `0.${attemptDelayMs / 100}s` : `${attemptDelayMs / 1e3}s`}` : "";
              this.trace(dev_tunnels_ssh_1.TraceLevel.Verbose, 0, `Error connecting to tunnel SSH session, retrying${retryTiming}${errorDescription ? `: ${errorDescription}` : ""}`);
              if (isDelayNeeded) {
                try {
                  await (0, utils_1.delay)(attemptDelayMs, cancellation);
                } catch (e) {
                  throwIfCancellation(e);
                  throw e;
                }
                if (attemptDelayMs < exports2.maxReconnectDelayMs) {
                  attemptDelayMs = attemptDelayMs << 1;
                }
              }
            }
            isDelayNeeded = true;
            let stream = void 0;
            errorDescription = void 0;
            disconnectReason = dev_tunnels_ssh_1.SshDisconnectReason.connectionLost;
            error = void 0;
            try {
              const streamAndProtocol = await this.tunnelSession.createSessionStream(options, cancellation);
              stream = streamAndProtocol.stream;
              await this.tunnelSession.configureSession(stream, streamAndProtocol.protocol, isReconnect, cancellation);
              stream = void 0;
              disconnectReason = void 0;
              return;
            } catch (e) {
              if (!(e instanceof Error)) {
                throwError(`Failed to connect to the tunnel service and start tunnel SSH session: ${e}`);
              }
              throwIfCancellation(e);
              error = e;
              errorDescription = error.message;
              if (e instanceof sshHelpers_1.BrowserWebSocketRelayError) {
                if (browserReconnectAttempt++ >= maxBrowserReconnectAttempts) {
                  throw e;
                }
                continue;
              }
              if (e instanceof dev_tunnels_ssh_1.SshReconnectError) {
                disconnectReason = dev_tunnels_ssh_1.SshDisconnectReason.protocolError;
                isDelayNeeded = false;
                isReconnect = false;
                continue;
              }
              if (e instanceof dev_tunnels_ssh_1.SshConnectionError) {
                const reason = e.reason;
                if (reason === dev_tunnels_ssh_1.SshDisconnectReason.connectionLost) {
                  continue;
                }
                disconnectReason = reason || dev_tunnels_ssh_1.SshDisconnectReason.byApplication;
                throwError(`Failed to start tunnel SSH session: ${errorDescription}`);
              }
              if (e instanceof sshHelpers_1.RelayConnectionError) {
                const statusCode = (_b = e.errorContext) === null || _b === void 0 ? void 0 : _b.statusCode;
                const statusCodeText = statusCode ? ` (${statusCode})` : "";
                switch (errorDescription) {
                  case "error.relayClientUnauthorized": {
                    const notAuthorizedText = "Not authorized" + statusCodeText;
                    disconnectReason = dev_tunnels_ssh_1.SshDisconnectReason.authCancelledByUser;
                    if (isTunnelAccessTokenRefreshed) {
                      throwError(`${notAuthorizedText}. Refreshed tunnel access token also does not work.`);
                    }
                    try {
                      isTunnelAccessTokenRefreshed = await this.tunnelSession.refreshTunnelAccessToken(cancellation);
                    } catch (refreshError) {
                      throwIfCancellation(refreshError);
                      throwError(`${notAuthorizedText}. Refreshing tunnel access token failed with error ${(0, utils_1.getErrorMessage)(refreshError)}`);
                    }
                    if (!isTunnelAccessTokenRefreshed) {
                      throwError(`${notAuthorizedText}. Provide a fresh tunnel access token with '${this.tunnelSession.tunnelAccessScope}' scope.`);
                    }
                    isDelayNeeded = false;
                    errorDescription = "The tunnel access token was no longer valid and had just been refreshed.";
                    continue;
                  }
                  case "error.relayClientForbidden":
                    disconnectReason = dev_tunnels_ssh_1.SshDisconnectReason.authCancelledByUser;
                    throwError(`Forbidden${statusCodeText}. Provide a fresh tunnel access token with '${this.tunnelSession.tunnelAccessScope}' scope.`);
                    break;
                  case "error.tunnelPortNotFound":
                    throwError(`The tunnel or port is not found${statusCodeText}`);
                    break;
                  // Normally nginx choses another healthy pod when it cannot establish connection to a pod.
                  // However, if there are no other pods, it may returns 502 (Bad Gateway) to the client.
                  // This rare case may happen when the cluster recovers from a failure
                  // and the nginx controller has started but Relay service has not yet.
                  // 503 (Service Unavailable) can happen when Relay calls control plane to authenticate the request,
                  // control plane hits 429s from Cosmos DB and replies back with 503.
                  // 429 (Too Many Requests) can happen if client exceeds request rate limits.
                  case "error.badGateway":
                  case "error.serviceUnavailable":
                  case "error.tooManyRequests":
                    errorDescription = errorDescription === "error.tooManyRequests" ? `Rate limit exceeded${statusCodeText}. Too many requests in a given amount of time.` : `Service temporarily unavailable${statusCodeText}`;
                    disconnectReason = dev_tunnels_ssh_1.SshDisconnectReason.serviceNotAvailable;
                    if (attempt > 3) {
                      throwError(errorDescription);
                    }
                    if (attemptDelayMs < exports2.maxReconnectDelayMs / 2) {
                      attemptDelayMs = exports2.maxReconnectDelayMs / 2;
                    }
                    continue;
                  default:
                    if (errorDescription === null || errorDescription === void 0 ? void 0 : errorDescription.startsWith("error.relayConnectionError ")) {
                      const recoverableError = recoverableNetworkErrors.find((s) => errorDescription.includes(s));
                      if (recoverableError) {
                        errorDescription = `Failed to connect to Relay server: ${recoverableError}`;
                        continue;
                      }
                    }
                }
              }
              throw e;
            } finally {
              if (error && disconnectReason && !error.reason) {
                error.reason = disconnectReason;
              }
              if (disconnectReason) {
                await this.tunnelSession.closeSession(disconnectReason, error);
              }
              if (stream) {
                await stream.close(error);
              }
            }
          }
        } finally {
          this.tunnelSession.finishConnecting(disconnectReason, error);
        }
      }
    };
    exports2.RelayTunnelConnector = RelayTunnelConnector;
    var recoverableNetworkErrors = [
      "ECONNRESET",
      "ENOTFOUND",
      "ESOCKETTIMEDOUT",
      "ETIMEDOUT",
      "ECONNREFUSED",
      "EHOSTUNREACH",
      "EPIPE",
      "EAI_AGAIN",
      "EBUSY"
    ];
  }
});

// ../../node_modules/@microsoft/dev-tunnels-connections/messages/portRelayRequestMessage.js
var require_portRelayRequestMessage = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-connections/messages/portRelayRequestMessage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PortRelayRequestMessage = void 0;
    var dev_tunnels_ssh_tcp_1 = require_dev_tunnels_ssh_tcp();
    var PortRelayRequestMessage = class extends dev_tunnels_ssh_tcp_1.PortForwardRequestMessage {
      onWrite(writer) {
        super.onWrite(writer);
        if (!this.accessToken) {
          throw new Error("An access token is required.");
        }
        writer.writeString(this.accessToken, "utf8");
      }
      onRead(reader) {
        super.onRead(reader);
        this.accessToken = reader.readString("utf8");
      }
    };
    exports2.PortRelayRequestMessage = PortRelayRequestMessage;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-connections/messages/portRelayConnectRequestMessage.js
var require_portRelayConnectRequestMessage = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-connections/messages/portRelayConnectRequestMessage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PortRelayConnectRequestMessage = void 0;
    var dev_tunnels_ssh_tcp_1 = require_dev_tunnels_ssh_tcp();
    var PortRelayConnectRequestMessage = class extends dev_tunnels_ssh_tcp_1.PortForwardChannelOpenMessage {
      constructor() {
        super(...arguments);
        this.isE2EEncryptionRequested = false;
      }
      onWrite(writer) {
        var _a;
        super.onWrite(writer);
        writer.writeString((_a = this.accessToken) !== null && _a !== void 0 ? _a : "", "utf8");
        writer.writeBoolean(this.isE2EEncryptionRequested);
      }
      onRead(reader) {
        super.onRead(reader);
        this.accessToken = reader.readString("utf8");
        this.isE2EEncryptionRequested = reader.readBoolean();
      }
    };
    exports2.PortRelayConnectRequestMessage = PortRelayConnectRequestMessage;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-connections/refreshingTunnelEventArgs.js
var require_refreshingTunnelEventArgs = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-connections/refreshingTunnelEventArgs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RefreshingTunnelEventArgs = void 0;
    var RefreshingTunnelEventArgs = class {
      /**
       * Creates a new instance of RefreshingTunnelAccessTokenEventArgs class.
       */
      constructor(tunnelAccessScope, tunnel, includePorts, managementClient, cancellation) {
        this.tunnelAccessScope = tunnelAccessScope;
        this.tunnel = tunnel;
        this.includePorts = includePorts;
        this.managementClient = managementClient;
        this.cancellation = cancellation;
      }
    };
    exports2.RefreshingTunnelEventArgs = RefreshingTunnelEventArgs;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-connections/tunnelConnectionSession.js
var require_tunnelConnectionSession = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-connections/tunnelConnectionSession.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TunnelConnectionSession = void 0;
    var dev_tunnels_contracts_1 = require_dev_tunnels_contracts();
    var dev_tunnels_management_1 = require_dev_tunnels_management();
    var dev_tunnels_ssh_1 = require_dev_tunnels_ssh();
    var vscode_jsonrpc_1 = require_main();
    var connectionStatus_1 = require_connectionStatus();
    var relayTunnelConnector_1 = require_relayTunnelConnector();
    var utils_1 = require_utils();
    var tunnelConnectionBase_1 = require_tunnelConnectionBase();
    var dev_tunnels_ssh_tcp_1 = require_dev_tunnels_ssh_tcp();
    var portRelayRequestMessage_1 = require_portRelayRequestMessage();
    var portRelayConnectRequestMessage_1 = require_portRelayConnectRequestMessage();
    var refreshingTunnelEventArgs_1 = require_refreshingTunnelEventArgs();
    var defaultTunnelRelayStreamFactory_1 = require_defaultTunnelRelayStreamFactory();
    var uuid_1 = require_uuid();
    var TunnelConnectionSession = class extends tunnelConnectionBase_1.TunnelConnectionBase {
      /**
       * Name of the protocol used to connect to the tunnel.
       */
      get connectionProtocol() {
        return this.connectionProtocolValue;
      }
      set connectionProtocol(value) {
        this.connectionProtocolValue = value;
      }
      /**
       * Gets an ID that is unique to this instance of `TunnelConnectionSession`,
       * useful for correlating connection events over time.
       */
      get connectionId() {
        return this.uniqueConnectionId;
      }
      /**
       * A value indicating if this is a client tunnel connection (as opposed to host connection).
       */
      get isClientConnection() {
        return this.tunnelAccessScope === dev_tunnels_contracts_1.TunnelAccessScopes.Connect;
      }
      /**
       * tunnel connection role, either "client", or "host", depending on @link tunnelAccessScope.
       */
      get connectionRole() {
        return this.isClientConnection ? "client" : "host";
      }
      /**
       * @internal onRetrying override to report tunnel events.
       */
      onRetrying(event) {
        var _a;
        if (this.tunnel && this.managementClient) {
          const retryingEvent = {
            name: `${this.connectionRole}_connect_retrying`,
            severity: dev_tunnels_contracts_1.TunnelEvent.warning,
            details: (_a = event.error) === null || _a === void 0 ? void 0 : _a.toString(),
            properties: {
              "Retry": event.retry.toString(),
              "Delay": event.delayMs.toString()
            }
          };
          this.managementClient.reportEvent(this.tunnel, retryingEvent);
        }
        super.onRetrying(event);
      }
      /**
       * @internal onConnectionStatusChanged override to report tunnel events.
       */
      onConnectionStatusChanged(previousStatus, status) {
        if (this.tunnel && this.managementClient) {
          const statusEvent = {
            name: `${this.connectionRole}_connection_status`,
            severity: dev_tunnels_contracts_1.TunnelEvent.info,
            details: void 0,
            properties: {
              ConnectionStatus: status.toString(),
              PreviousConnectionStatus: previousStatus.toString()
            }
          };
          if (previousStatus !== connectionStatus_1.ConnectionStatus.None) {
            const duration = Date.now() - this.connectionStartTime;
            const formattedDuration = new Date(duration).toISOString().substring(11, 23);
            statusEvent.properties[`${previousStatus}Duration`] = formattedDuration;
          }
          if (this.isClientConnection) {
            statusEvent.properties.ClientSessionId = this.getShortSessionId(this.sshSession);
          } else {
            statusEvent.properties.HostSessionId = this.connectionId;
          }
          this.managementClient.reportEvent(this.tunnel, statusEvent);
        }
        this.connectionStartTime = Date.now();
        super.onConnectionStatusChanged(previousStatus, status);
      }
      constructor(tunnelAccessScope, connectionProtocols, managementClient, trace) {
        super(tunnelAccessScope);
        this.connectionProtocols = connectionProtocols;
        this.managementClient = managementClient;
        this.connectedTunnel = null;
        this.connectionStartTime = Date.now();
        this.uniqueConnectionId = (0, uuid_1.v4)();
        this.refreshingTunnelEmitter = new utils_1.TrackingEmitter();
        this.reportProgressEmitter = new vscode_jsonrpc_1.Emitter();
        this.onReportProgress = this.reportProgressEmitter.event;
        this.streamFactory = new defaultTunnelRelayStreamFactory_1.DefaultTunnelRelayStreamFactory();
        this.sshSessionDisposables = [];
        this.refreshingTunnel = this.refreshingTunnelEmitter.event;
        this.enableE2EEncryption = true;
        this.trace = trace !== null && trace !== void 0 ? trace : (() => {
        });
        this.httpAgent = managementClient === null || managementClient === void 0 ? void 0 : managementClient.httpsAgent;
      }
      /* @internal */
      raiseReportProgress(progress, sessionNumber) {
        const args = {
          progress,
          sessionNumber
        };
        this.reportProgressEmitter.fire(args);
      }
      /**
       * Get the tunnel of this tunnel connection.
       */
      get tunnel() {
        return this.connectedTunnel;
      }
      set tunnel(value) {
        if (value !== this.connectedTunnel) {
          this.connectedTunnel = value;
          this.tunnelChanged();
        }
      }
      /**
       * Tunnel has been assigned to or changed.
       */
      tunnelChanged() {
        if (this.tunnel) {
          this.accessToken = dev_tunnels_management_1.TunnelAccessTokenProperties.getTunnelAccessToken(this.tunnel, this.tunnelAccessScope);
        } else {
          this.accessToken = void 0;
        }
      }
      /**
       * Gets a value indicating that this connection has already created its connector
       * and so can be reconnected if needed.
       */
      get isReconnectable() {
        return !!this.connector;
      }
      /**
       * Gets the disconnection reason.
       * {@link SshDisconnectReason.none } if not yet disconnected.
       * {@link SshDisconnectReason.connectionLost} if network connection was lost and reconnects are not enabled or unsuccesfull.
       * {@link SshDisconnectReason.byApplication} if connection was disposed.
       * {@link SshDisconnectReason.tooManyConnections} if host connection was disconnected because another host connected for the same tunnel.
       */
      get disconnectReason() {
        return this.disconnectionReason;
      }
      /**
       * Sets the disconnect reason that caused disconnection.
       */
      set disconnectReason(reason) {
        this.disconnectionReason = reason;
      }
      /**
       * @internal Creates a stream to the tunnel.
       */
      async createSessionStream(options, cancellation) {
        if (!this.relayUri) {
          throw new Error("Cannot create tunnel session stream. Tunnel relay endpoint URI is missing");
        }
        if (this.isClientConnection) {
          this.raiseReportProgress(dev_tunnels_ssh_1.Progress.OpeningClientConnectionToRelay);
        } else {
          this.raiseReportProgress(dev_tunnels_ssh_1.Progress.OpeningHostConnectionToRelay);
        }
        this.trace(dev_tunnels_ssh_1.TraceLevel.Info, 0, `Connecting to ${this.connectionRole} tunnel relay ${this.relayUri}`);
        this.trace(dev_tunnels_ssh_1.TraceLevel.Verbose, 0, `Sec-WebSocket-Protocol: ${this.connectionProtocols.join(", ")}`);
        if (this.accessToken) {
          const tokenTrace = dev_tunnels_management_1.TunnelAccessTokenProperties.getTokenTrace(this.accessToken);
          this.trace(dev_tunnels_ssh_1.TraceLevel.Verbose, 0, `Authorization: tunnel <${tokenTrace}>`);
        }
        const clientConfig = {
          tlsOptions: {
            agent: this.httpAgent
          }
        };
        const streamAndProtocol = await this.streamFactory.createRelayStream(this.relayUri, this.connectionProtocols, this.accessToken, clientConfig);
        this.trace(dev_tunnels_ssh_1.TraceLevel.Verbose, 0, `Connected with subprotocol '${streamAndProtocol.protocol}'`);
        if (this.isClientConnection) {
          this.raiseReportProgress(dev_tunnels_ssh_1.Progress.OpenedClientConnectionToRelay);
        } else {
          this.raiseReportProgress(dev_tunnels_ssh_1.Progress.OpenedHostConnectionToRelay);
        }
        return streamAndProtocol;
      }
      /**
       * @internal Configures the tunnel session with the given stream.
       */
      configureSession(stream, protocol, isReconnect, cancellation) {
        throw new Error("Not implemented");
      }
      /**
       * @internal Closes the tunnel session due to an error.
       */
      async closeSession(reason, error) {
        this.unsubscribeSessionEvents();
        const session = this.sshSession;
        if (!session) {
          return;
        }
        if (!session.isClosed) {
          await session.close(reason || dev_tunnels_ssh_1.SshDisconnectReason.none, void 0, error);
        } else {
          this.sshSession = void 0;
        }
        session.dispose();
      }
      /**
       * Disposes this tunnel session, closing the SSH session used for it.
       */
      async dispose() {
        if (this.disconnectReason === dev_tunnels_ssh_1.SshDisconnectReason.none || this.disconnectReason === void 0) {
          this.disconnectReason = dev_tunnels_ssh_1.SshDisconnectReason.byApplication;
        }
        await super.dispose();
        try {
          await this.closeSession(this.disconnectReason, this.disconnectError);
        } catch (e) {
          if (!(e instanceof dev_tunnels_ssh_1.ObjectDisposedError))
            throw e;
        }
      }
      /**
       * Refreshes the tunnel access token. This may be useful when the Relay service responds with 401 Unauthorized.
       * Does nothing if the object is disposed, or there is no way to refresh the token.
       * @internal
       */
      async refreshTunnelAccessToken(cancellation) {
        var _a;
        if (this.isDisposed) {
          return false;
        }
        if (!this.isRefreshingTunnelAccessTokenEventHandled && !this.canRefreshTunnel) {
          return false;
        }
        this.connectionStatus = connectionStatus_1.ConnectionStatus.RefreshingTunnelAccessToken;
        try {
          this.traceVerbose(`Refreshing tunnel access token. Current token: ${dev_tunnels_management_1.TunnelAccessTokenProperties.getTokenTrace(this.accessToken)}`);
          if (this.isRefreshingTunnelAccessTokenEventHandled) {
            this.accessToken = (_a = await this.getFreshTunnelAccessToken(cancellation)) !== null && _a !== void 0 ? _a : void 0;
          } else {
            await this.refreshTunnel(false, cancellation);
          }
          this.traceVerbose(`Refreshed tunnel access token. New token: ${dev_tunnels_management_1.TunnelAccessTokenProperties.getTokenTrace(this.accessToken)}`);
          return true;
        } finally {
          this.connectionStatus = connectionStatus_1.ConnectionStatus.Connecting;
        }
      }
      /**
       * @internal Start connecting relay client.
       */
      startConnecting() {
        this.connectionStatus = connectionStatus_1.ConnectionStatus.Connecting;
      }
      /**
       * @internal Finish connecting relay client.
       */
      finishConnecting(reason, disconnectError) {
        if (reason === void 0 || reason === dev_tunnels_ssh_1.SshDisconnectReason.none) {
          if (this.connectionStatus === connectionStatus_1.ConnectionStatus.Connecting) {
            this.disconnectError = void 0;
            this.disconnectReason = void 0;
          }
          this.connectionStatus = connectionStatus_1.ConnectionStatus.Connected;
        } else if (this.connectionStatus !== connectionStatus_1.ConnectionStatus.Disconnected) {
          this.disconnectReason = reason;
          if (disconnectError) {
            this.disconnectError = disconnectError;
          }
          this.connectionStatus = connectionStatus_1.ConnectionStatus.Disconnected;
        }
      }
      /**
       * Get a value indicating whether this session can attempt refreshing tunnel.
       * Note: tunnel refresh may still fail if the tunnel doesn't exist in the service,
       * tunnel access has changed, or tunnel access token has expired.
       */
      get canRefreshTunnel() {
        return this.tunnel && this.managementClient || this.refreshingTunnelEmitter.isSubscribed;
      }
      /**
       * Fetch the tunnel from the service if {@link managementClient} and {@link tunnel} are set.
       */
      async refreshTunnel(includePorts, cancellation) {
        this.traceInfo("Refreshing tunnel.");
        let isRefreshed = false;
        const e = new refreshingTunnelEventArgs_1.RefreshingTunnelEventArgs(this.tunnelAccessScope, this.tunnel, !!includePorts, this.managementClient, cancellation);
        this.refreshingTunnelEmitter.fire(e);
        if (e.tunnelPromise) {
          this.tunnel = await e.tunnelPromise;
          isRefreshed = true;
        }
        if (!isRefreshed && this.tunnel && this.managementClient) {
          const options = {
            tokenScopes: [this.tunnelAccessScope],
            includePorts
          };
          this.tunnel = await (0, utils_1.withCancellation)(this.managementClient.getTunnel(this.tunnel, options), cancellation);
          isRefreshed = true;
        }
        if (isRefreshed) {
          if (this.tunnel) {
            this.traceInfo("Refreshed tunnel.");
          } else {
            this.traceInfo("Tunnel not found.");
          }
        }
        return true;
      }
      /**
       * Creates a tunnel connector
       */
      createTunnelConnector() {
        return new relayTunnelConnector_1.RelayTunnelConnector(this);
      }
      /**
       * Trace info message.
       */
      traceInfo(msg) {
        this.trace(dev_tunnels_ssh_1.TraceLevel.Info, 0, msg);
      }
      /**
       * Trace verbose message.
       */
      traceVerbose(msg) {
        this.trace(dev_tunnels_ssh_1.TraceLevel.Verbose, 0, msg);
      }
      /**
       * Trace warning message.
       */
      traceWarning(msg, err) {
        this.trace(dev_tunnels_ssh_1.TraceLevel.Warning, 0, msg, err);
      }
      /**
       * Trace error message.
       */
      traceError(msg, err) {
        this.trace(dev_tunnels_ssh_1.TraceLevel.Error, 0, msg, err);
      }
      /**
       * SSH session closed event handler. Child classes may use it unsubscribe session events and maybe start reconnecting.
       */
      onSshSessionClosed(e) {
        this.unsubscribeSessionEvents();
        this.sshSession = void 0;
        this.maybeStartReconnecting(e.reason, e.message, e.error);
      }
      /**
       * Start reconnecting if the tunnel connection is not yet disposed.
       */
      maybeStartReconnecting(reason, message, error) {
        var _a, _b, _c, _d;
        const traceMessage = `Connection to ${this.connectionRole} tunnel relay closed.${this.getDisconnectReason(reason, message, error)}`;
        if (this.isDisposed || this.connectionStatus === connectionStatus_1.ConnectionStatus.Disconnected) {
          this.traceInfo(traceMessage);
          return;
        }
        if (error) {
          this.disconnectError = error;
          this.disconnectReason = reason;
        }
        if (this.connectionStatus !== connectionStatus_1.ConnectionStatus.Connected || this.reconnectPromise) {
          this.traceInfo(traceMessage);
          return;
        }
        if (((_b = (_a = this.connectionOptions) === null || _a === void 0 ? void 0 : _a.enableReconnect) !== null && _b !== void 0 ? _b : true) && reason === dev_tunnels_ssh_1.SshDisconnectReason.connectionLost && this.connector) {
          if (this.tunnel && this.managementClient) {
            const reconnectEvent = {
              name: `${this.connectionRole}_reconnect`,
              severity: dev_tunnels_contracts_1.TunnelEvent.warning,
              details: (_c = error === null || error === void 0 ? void 0 : error.toString()) !== null && _c !== void 0 ? _c : message,
              properties: {
                ClientSessionId: this.getShortSessionId(this.sshSession)
              }
            };
            this.managementClient.reportEvent(this.tunnel, reconnectEvent);
          }
          this.traceInfo(`${traceMessage} Reconnecting.`);
          this.reconnectPromise = (async () => {
            try {
              await this.connectTunnelSession();
            } catch (ex) {
              if (this.tunnel && this.managementClient) {
                const reconnectFailedEvent = {
                  name: `${this.connectionRole}_reconnect_failed`,
                  severity: dev_tunnels_contracts_1.TunnelEvent.error,
                  details: ex instanceof Error ? ex.toString() : String(ex),
                  properties: {
                    ClientSessionId: this.getShortSessionId(this.sshSession)
                  }
                };
                this.managementClient.reportEvent(this.tunnel, reconnectFailedEvent);
              }
            }
            this.reconnectPromise = void 0;
          })();
        } else {
          if (this.tunnel && this.managementClient) {
            const disconnectEvent = {
              name: `${this.connectionRole}_disconnect`,
              severity: dev_tunnels_contracts_1.TunnelEvent.warning,
              details: (_d = error === null || error === void 0 ? void 0 : error.toString()) !== null && _d !== void 0 ? _d : message,
              properties: {
                ClientSessionId: this.getShortSessionId(this.sshSession)
              }
            };
            this.managementClient.reportEvent(this.tunnel, disconnectEvent);
          }
          this.traceInfo(traceMessage);
          this.connectionStatus = connectionStatus_1.ConnectionStatus.Disconnected;
        }
      }
      /**
       * Get a user-readable reason for SSH session disconnection, or an empty string.
       */
      getDisconnectReason(reason, message, error) {
        switch (reason) {
          case dev_tunnels_ssh_1.SshDisconnectReason.connectionLost:
            return ` ${message || (error === null || error === void 0 ? void 0 : error.message) || "Connection lost."}`;
          case dev_tunnels_ssh_1.SshDisconnectReason.authCancelledByUser:
          case dev_tunnels_ssh_1.SshDisconnectReason.noMoreAuthMethodsAvailable:
          case dev_tunnels_ssh_1.SshDisconnectReason.hostNotAllowedToConnect:
          case dev_tunnels_ssh_1.SshDisconnectReason.illegalUserName:
            return " Not authorized.";
          case dev_tunnels_ssh_1.SshDisconnectReason.serviceNotAvailable:
            return " Service not available.";
          case dev_tunnels_ssh_1.SshDisconnectReason.compressionError:
          case dev_tunnels_ssh_1.SshDisconnectReason.keyExchangeFailed:
          case dev_tunnels_ssh_1.SshDisconnectReason.macError:
          case dev_tunnels_ssh_1.SshDisconnectReason.protocolError:
            return " Protocol error.";
          case dev_tunnels_ssh_1.SshDisconnectReason.tooManyConnections:
            return this.isClientConnection ? " Too many client connections." : " Another host for the tunnel has connected.";
          default:
            return "";
        }
      }
      /**
       * Connect to the tunnel session by running the provided {@link action}.
       */
      async connectSession(action) {
        try {
          await action();
        } catch (e) {
          if (!(e instanceof dev_tunnels_ssh_1.CancellationError)) {
            if (e instanceof Error) {
              this.traceError(`Error connecting ${this.connectionRole} tunnel session: ${e.message}`, e);
            } else {
              const message = `Error connecting ${this.connectionRole} tunnel session: ${e}`;
              this.traceError(message);
            }
            if (this.tunnel && this.managementClient) {
              const connectFailedEvent = {
                name: `${this.connectionRole}_connect_failed`,
                severity: dev_tunnels_contracts_1.TunnelEvent.error,
                details: e instanceof Error ? e.toString() : String(e)
              };
              this.managementClient.reportEvent(this.tunnel, connectFailedEvent);
            }
          }
          throw e;
        }
      }
      /**
       * Connect to the tunnel session with the tunnel connector.
       * @param tunnel Tunnel to use for the connection.
       *     Undefined if the connection information is already known and the tunnel is not needed.
       *     Tunnel object to get the connection information from that tunnel.
       */
      async connectTunnelSession(tunnel, options, cancellation) {
        var _a;
        if (tunnel) {
          this.tunnel = tunnel;
        }
        if (options) {
          this.connectionOptions = options;
          (_a = this.httpAgent) !== null && _a !== void 0 ? _a : this.httpAgent = options === null || options === void 0 ? void 0 : options.httpAgent;
        }
        await this.connectSession(async () => {
          const isReconnect = this.isReconnectable && !tunnel;
          await this.onConnectingToTunnel();
          if (!this.connector) {
            this.connector = this.createTunnelConnector();
          }
          const disposables = [];
          if (cancellation) {
            const linkedCancellationSource = new vscode_jsonrpc_1.CancellationTokenSource();
            disposables.push(linkedCancellationSource, cancellation.onCancellationRequested(() => linkedCancellationSource.cancel()), this.disposeToken.onCancellationRequested(() => linkedCancellationSource.cancel()));
            cancellation = linkedCancellationSource.token;
          } else {
            cancellation = this.disposeToken;
          }
          try {
            await this.connector.connectSession(isReconnect, options, cancellation);
          } catch (e) {
            if (e instanceof dev_tunnels_ssh_1.CancellationError) {
              this.throwIfDisposed(`CancelationError: ${e.message}`, e.stack);
            }
            throw e;
          } finally {
            for (const disposable of disposables)
              disposable.dispose();
          }
        });
      }
      /**
       * Validate the {@link tunnel} and get data needed to connect to it, if the tunnel is provided;
       * otherwise, ensure that there is already sufficient data to connect to a tunnel.
       */
      onConnectingToTunnel() {
        return Promise.resolve();
      }
      /**
       * Validates tunnel access token if it's present. Returns the token.
       * Note: uses client's system time for the validation.
       */
      validateAccessToken() {
        if (this.accessToken) {
          dev_tunnels_management_1.TunnelAccessTokenProperties.validateTokenExpiration(this.accessToken);
          return this.accessToken;
        }
      }
      /** @internal */
      createRequestMessageAsync(port) {
        const message = new portRelayRequestMessage_1.PortRelayRequestMessage();
        message.accessToken = this.accessToken;
        return Promise.resolve(message);
      }
      /** @internal */
      createSuccessMessageAsync(port) {
        const message = new dev_tunnels_ssh_tcp_1.PortForwardSuccessMessage();
        return Promise.resolve(message);
      }
      /** @internal */
      createChannelOpenMessageAsync(port) {
        const message = new portRelayConnectRequestMessage_1.PortRelayConnectRequestMessage();
        message.accessToken = this.accessToken;
        message.isE2EEncryptionRequested = this.enableE2EEncryption;
        return Promise.resolve(message);
      }
      /**
       * Unsubscribe SSH session events in @link TunnelSshConnectionSession.sshSessionDisposables
       */
      unsubscribeSessionEvents() {
        this.sshSessionDisposables.forEach((d) => d.dispose());
        this.sshSessionDisposables = [];
      }
      /** @internal */
      getShortSessionId(session) {
        const b = session === null || session === void 0 ? void 0 : session.sessionId;
        if (!b || b.length < 16) {
          return "";
        }
        return b.subarray(0, 4).toString("hex") + "-" + b.subarray(4, 6).toString("hex") + "-" + b.subarray(6, 8).toString("hex") + "-" + b.subarray(8, 10).toString("hex") + "-" + b.subarray(10, 16).toString("hex");
      }
    };
    exports2.TunnelConnectionSession = TunnelConnectionSession;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-connections/portForwardingEventArgs.js
var require_portForwardingEventArgs = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-connections/portForwardingEventArgs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PortForwardingEventArgs = void 0;
    var PortForwardingEventArgs = class {
      /**
       * Creates a new instance of PortForwardingEventArgs.
       */
      constructor(portNumber) {
        this.portNumber = portNumber;
        this.cancel = false;
      }
    };
    exports2.PortForwardingEventArgs = PortForwardingEventArgs;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-connections/tunnelRelayTunnelClient.js
var require_tunnelRelayTunnelClient = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-connections/tunnelRelayTunnelClient.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TunnelRelayTunnelClient = exports2.webSocketSubProtocolv2 = exports2.webSocketSubProtocol = void 0;
    var dev_tunnels_contracts_1 = require_dev_tunnels_contracts();
    var dev_tunnels_ssh_1 = require_dev_tunnels_ssh();
    var dev_tunnels_ssh_tcp_1 = require_dev_tunnels_ssh_tcp();
    var retryTcpListenerFactory_1 = require_retryTcpListenerFactory();
    var sshHelpers_1 = require_sshHelpers();
    var utils_1 = require_utils();
    var vscode_jsonrpc_1 = require_main();
    var portRelayConnectResponseMessage_1 = require_portRelayConnectResponseMessage();
    var tunnelConnectionSession_1 = require_tunnelConnectionSession();
    var portForwardingEventArgs_1 = require_portForwardingEventArgs();
    exports2.webSocketSubProtocol = "tunnel-relay-client";
    exports2.webSocketSubProtocolv2 = "tunnel-relay-client-v2-dev";
    var protocolVersion = (process === null || process === void 0 ? void 0 : process.env) && process.env.DEVTUNNELS_PROTOCOL_VERSION;
    var connectionProtocols = protocolVersion === "1" ? [exports2.webSocketSubProtocol] : protocolVersion === "2" ? [exports2.webSocketSubProtocolv2] : [exports2.webSocketSubProtocolv2, exports2.webSocketSubProtocol];
    var TunnelRelayTunnelClient = class extends tunnelConnectionSession_1.TunnelConnectionSession {
      constructor(managementClient, trace) {
        super(dev_tunnels_contracts_1.TunnelAccessScopes.Connect, connectionProtocols, managementClient, trace);
        this.portForwardingEmitter = new vscode_jsonrpc_1.Emitter();
        this.sshSessionClosedEmitter = new vscode_jsonrpc_1.Emitter();
        this.acceptLocalConnectionsForForwardedPortsValue = (0, sshHelpers_1.isNode)();
        this.localForwardingHostAddressValue = "127.0.0.1";
        this.disconnectedStreams = /* @__PURE__ */ new Map();
        this.connectionModes = [];
        this.portForwarding = this.portForwardingEmitter.event;
        this.sshSessionClosed = this.sshSessionClosedEmitter.event;
      }
      get isSshSessionActive() {
        var _a;
        return !!((_a = this.sshSession) === null || _a === void 0 ? void 0 : _a.isConnected);
      }
      /**
       * Get a value indicating if remote port is forwarded and has any channels open on the client,
       * whether used by local tcp listener if {AcceptLocalConnectionsForForwardedPorts} is true, or
       * streamed via <see cref="ConnectToForwardedPortAsync(int, CancellationToken)"/>.
       */
      hasForwardedChannels(port) {
        var _a;
        if (!this.isSshSessionActive) {
          return false;
        }
        const pfs = (_a = this.sshSession) === null || _a === void 0 ? void 0 : _a.activateService(dev_tunnels_ssh_tcp_1.PortForwardingService);
        const remoteForwardedPorts = pfs === null || pfs === void 0 ? void 0 : pfs.remoteForwardedPorts;
        const forwardedPort = remoteForwardedPorts === null || remoteForwardedPorts === void 0 ? void 0 : remoteForwardedPorts.find((p) => p.remotePort === port);
        return !!forwardedPort && remoteForwardedPorts.getChannels(forwardedPort).length > 0;
      }
      /**
       * A value indicating whether local connections for forwarded ports are accepted.
       * Local connections are not accepted if the host is not NodeJS (e.g. browser).
       */
      get acceptLocalConnectionsForForwardedPorts() {
        return this.acceptLocalConnectionsForForwardedPortsValue;
      }
      set acceptLocalConnectionsForForwardedPorts(value) {
        if (value === this.acceptLocalConnectionsForForwardedPortsValue) {
          return;
        }
        if (value && !(0, sshHelpers_1.isNode)()) {
          throw new Error("Cannot accept local connections for forwarded ports on this platform.");
        }
        this.acceptLocalConnectionsForForwardedPortsValue = value;
        this.configurePortForwardingService();
      }
      /**
       * Gets the local network interface address that the tunnel client listens on when
       * accepting connections for forwarded ports.
       */
      get localForwardingHostAddress() {
        return this.localForwardingHostAddressValue;
      }
      set localForwardingHostAddress(value) {
        if (value !== this.localForwardingHostAddressValue) {
          this.localForwardingHostAddressValue = value;
          this.configurePortForwardingService();
        }
      }
      get forwardedPorts() {
        var _a;
        const pfs = (_a = this.sshSession) === null || _a === void 0 ? void 0 : _a.activateService(dev_tunnels_ssh_tcp_1.PortForwardingService);
        return pfs === null || pfs === void 0 ? void 0 : pfs.remoteForwardedPorts;
      }
      async connect(tunnel, options, cancellation) {
        this.hostId = options === null || options === void 0 ? void 0 : options.hostId;
        await this.connectTunnelSession(tunnel, options, cancellation);
      }
      tunnelChanged() {
        var _a;
        super.tunnelChanged();
        this.endpoints = void 0;
        if (this.tunnel) {
          if (!this.tunnel.endpoints) {
            throw new Error("Tunnel endpoints cannot be null");
          }
          if (this.tunnel.endpoints.length === 0) {
            throw new Error("No hosts are currently accepting connections for the tunnel.");
          }
          const endpointGroups = utils_1.List.groupBy(this.tunnel.endpoints, (ep) => ep.hostId);
          if (this.hostId) {
            this.endpoints = endpointGroups.get(this.hostId);
            if (!this.endpoints) {
              throw new Error("The specified host is not currently accepting connections to the tunnel.");
            }
          } else if (endpointGroups.size > 1) {
            throw new Error("There are multiple hosts for the tunnel. Specify a host ID to connect to.");
          } else {
            this.endpoints = (_a = endpointGroups.entries().next().value) === null || _a === void 0 ? void 0 : _a[1];
          }
          const tunnelEndpoints = this.endpoints.filter((ep) => ep.connectionMode === dev_tunnels_contracts_1.TunnelConnectionMode.TunnelRelay);
          if (tunnelEndpoints.length === 0) {
            throw new Error("The host is not currently accepting Tunnel relay connections.");
          }
          const endpoint = tunnelEndpoints[0];
          this.hostPublicKeys = endpoint.hostPublicKeys;
          this.relayUri = endpoint.clientRelayUri;
        } else {
          this.relayUri = void 0;
        }
      }
      onRequest(e) {
        if (e.request.requestType === dev_tunnels_ssh_tcp_1.PortForwardingService.portForwardRequestType) {
          const request = e.request;
          const args = new portForwardingEventArgs_1.PortForwardingEventArgs(request.port);
          this.portForwardingEmitter.fire(args);
          e.isAuthorized = !args.cancel;
        } else if (e.request.requestType === dev_tunnels_ssh_tcp_1.PortForwardingService.cancelPortForwardRequestType) {
          e.isAuthorized = true;
        }
      }
      /**
       * Configures the tunnel session with the given stream.
       * @internal
       */
      async configureSession(stream, protocol, isReconnect, cancellation) {
        this.connectionProtocol = protocol;
        if (isReconnect && this.sshSession && !this.sshSession.isClosed) {
          await this.sshSession.reconnect(stream, cancellation);
        } else {
          await this.startSshSession(stream, cancellation);
        }
      }
      startSshSession(stream, cancellation) {
        return this.connectSession(async () => {
          this.sshSession = sshHelpers_1.SshHelpers.createSshClientSession((config) => {
            var _a;
            config.addService(dev_tunnels_ssh_tcp_1.PortForwardingService);
            if (this.connectionProtocol === exports2.webSocketSubProtocol) {
              config.protocolExtensions.push(dev_tunnels_ssh_1.SshProtocolExtensionNames.sessionReconnect);
            } else {
              config.keyExchangeAlgorithms.splice(0, 0, dev_tunnels_ssh_1.SshAlgorithms.keyExchange.none);
            }
            const keepAliveInterval = (_a = this.connectionOptions) === null || _a === void 0 ? void 0 : _a.keepAliveIntervalInSeconds;
            if (keepAliveInterval && keepAliveInterval > 0) {
              config.keepAliveTimeoutInSeconds = keepAliveInterval;
            }
          });
          this.sshSession.trace = this.trace;
          this.sshSession.onReportProgress((args) => this.raiseReportProgress(args.progress, args.sessionNumber), this, this.sshSessionDisposables);
          this.sshSession.onClosed(this.onSshSessionClosed, this, this.sshSessionDisposables);
          this.sshSession.onAuthenticating(this.onSshServerAuthenticating, this, this.sshSessionDisposables);
          this.sshSession.onDisconnected(this.onSshSessionDisconnected, this, this.sshSessionDisposables);
          this.sshSession.onRequest(this.onRequest, this, this.sshSessionDisposables);
          this.sshSession.onKeepAliveFailed((count) => this.onKeepAliveFailed(count));
          this.sshSession.onKeepAliveSucceeded((count) => this.onKeepAliveSucceeded(count));
          const pfs = this.sshSession.activateService(dev_tunnels_ssh_tcp_1.PortForwardingService);
          if (this.connectionProtocol === exports2.webSocketSubProtocolv2) {
            pfs.messageFactory = this;
            pfs.onForwardedPortConnecting(this.onForwardedPortConnecting, this, this.sshSessionDisposables);
            pfs.remoteForwardedPorts.onPortAdded((e) => this.onForwardedPortAdded(pfs, e), this, this.sshSessionDisposables);
            pfs.remoteForwardedPorts.onPortUpdated((e) => this.onForwardedPortAdded(pfs, e), this, this.sshSessionDisposables);
          }
          this.configurePortForwardingService();
          await this.sshSession.connect(stream, cancellation);
          if (this.sshSession.sessionId) {
            const session = this.sshSession;
            const clientCredentials = { username: "tunnel" };
            if (!await session.authenticate(clientCredentials, cancellation)) {
              throw new Error(session.principal ? "SSH client authentication failed." : "SSH server authentication failed.");
            }
          }
        });
      }
      configurePortForwardingService() {
        const pfs = this.getSshSessionPfs();
        if (!pfs) {
          return;
        }
        if (this.acceptLocalConnectionsForForwardedPortsValue && (0, sshHelpers_1.isNode)()) {
          pfs.tcpListenerFactory = new retryTcpListenerFactory_1.RetryTcpListenerFactory(this.localForwardingHostAddressValue);
        } else {
          pfs.acceptLocalConnectionsForForwardedPorts = false;
        }
      }
      onForwardedPortAdded(pfs, e) {
        var _a, _b;
        const port = e.port.remotePort;
        if (typeof port !== "number") {
          return;
        }
        const disconnectedStreamsCount = (_b = (_a = this.disconnectedStreams.get(port)) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
        for (let i = 0; i < disconnectedStreamsCount; i++) {
          pfs.connectToForwardedPort(port).then(() => {
            this.trace(dev_tunnels_ssh_1.TraceLevel.Verbose, 0, `Reconnected stream to fowarded port ${port}`);
          }).catch((error) => {
            this.trace(dev_tunnels_ssh_1.TraceLevel.Warning, 0, `Failed to reconnect to forwarded port ${port}: ${error}`);
            const streams = this.disconnectedStreams.get(port);
            if (streams) {
              while (streams.length > 0) {
                streams.pop().dispose();
              }
            }
          });
        }
      }
      /**
       * Invoked when a forwarded port is connecting. (Only for V2 protocol.)
       */
      onForwardedPortConnecting(e) {
        const channel = e.stream.channel;
        const relayResponseMessage = channel.openConfirmationMessage.convertTo(new portRelayConnectResponseMessage_1.PortRelayConnectResponseMessage());
        if (relayResponseMessage.isE2EEncryptionEnabled) {
          const clientCredentials = { username: "tunnel" };
          e.transformPromise = new Promise((resolve3, reject) => {
            var _a;
            let secureStream = (_a = this.disconnectedStreams.get(e.port)) === null || _a === void 0 ? void 0 : _a.shift();
            if (secureStream) {
              this.trace(dev_tunnels_ssh_1.TraceLevel.Verbose, 0, `Reconnecting encrypted stream for port ${e.port}...`);
              secureStream.reconnect(e.stream).then(() => {
                this.trace(dev_tunnels_ssh_1.TraceLevel.Verbose, 0, `Reconnecting encrypted stream for port ${e.port} succeeded.`);
                resolve3(secureStream);
              }).catch(reject);
            } else {
              secureStream = new dev_tunnels_ssh_1.SecureStream(e.stream, clientCredentials);
              secureStream.trace = this.trace;
              secureStream.onAuthenticating((authEvent) => authEvent.authenticationPromise = this.onHostAuthenticating(authEvent).catch());
              secureStream.onDisconnected(() => this.onSecureStreamDisconnected(e.port, secureStream));
              secureStream.connect().then(() => resolve3(secureStream)).catch(reject);
            }
          });
        }
        super.onForwardedPortConnecting(e);
      }
      onSecureStreamDisconnected(port, secureStream) {
        this.trace(dev_tunnels_ssh_1.TraceLevel.Verbose, 0, `Encrypted stream for port ${port} disconnected.`);
        const streams = this.disconnectedStreams.get(port);
        if (streams) {
          streams.push(secureStream);
        } else {
          this.disconnectedStreams.set(port, [secureStream]);
        }
      }
      async onHostAuthenticating(e) {
        var _a, _b;
        if (e.authenticationType !== dev_tunnels_ssh_1.SshAuthenticationType.serverPublicKey || !e.publicKey) {
          this.traceWarning("Invalid host authenticating event.");
          return null;
        }
        const hostKey = (_b = (_a = await e.publicKey.getPublicKeyBytes(e.publicKey.keyAlgorithmName)) === null || _a === void 0 ? void 0 : _a.toString("base64")) !== null && _b !== void 0 ? _b : "";
        if (!this.hostPublicKeys) {
          this.traceWarning("Host identity could not be verified because no public keys were provided.");
          this.traceVerbose(`Host key: ${hostKey}`);
          return {};
        }
        if (this.hostPublicKeys.includes(hostKey)) {
          this.traceVerbose(`Verified host identity with public key ${hostKey}`);
          return {};
        }
        if (!this.disposeToken.isCancellationRequested && await this.refreshTunnel(false, this.disposeToken) && this.hostPublicKeys.includes(hostKey)) {
          this.traceVerbose("Verified host identity with public key " + hostKey);
          return {};
        }
        this.traceError("Host public key verification failed.");
        this.traceVerbose(`Host key: ${hostKey}`);
        this.traceVerbose(`Expected key(s): ${this.hostPublicKeys.join(", ")}`);
        return null;
      }
      onSshServerAuthenticating(e) {
        if (this.connectionProtocol === exports2.webSocketSubProtocol) {
          e.authenticationPromise = this.onHostAuthenticating(e);
        } else {
          e.authenticationPromise = Promise.resolve({});
        }
      }
      async connectToForwardedPort(fowardedPort, cancellation) {
        const pfs = this.getSshSessionPfs();
        if (!pfs) {
          throw new Error("Failed to connect to remote port. Ensure that the client has connected by calling connectClient.");
        }
        return pfs.connectToForwardedPort(fowardedPort, cancellation);
      }
      async waitForForwardedPort(forwardedPort, cancellation) {
        const pfs = this.getSshSessionPfs();
        if (!pfs) {
          throw new Error("Port forwarding has not been started. Ensure that the client has connected by calling connectClient.");
        }
        this.trace(dev_tunnels_ssh_1.TraceLevel.Verbose, 0, "Waiting for forwarded port " + forwardedPort);
        await pfs.waitForForwardedPort(forwardedPort, cancellation);
        this.trace(dev_tunnels_ssh_1.TraceLevel.Verbose, 0, "Forwarded port " + forwardedPort + " is ready.");
      }
      getSshSessionPfs() {
        var _a, _b;
        return (_b = (_a = this.sshSession) === null || _a === void 0 ? void 0 : _a.getService(dev_tunnels_ssh_tcp_1.PortForwardingService)) !== null && _b !== void 0 ? _b : void 0;
      }
      async refreshPorts() {
        if (!this.sshSession || this.sshSession.isClosed) {
          throw new Error("Not connected.");
        }
        const request = new dev_tunnels_ssh_1.SessionRequestMessage();
        request.requestType = "RefreshPorts";
        request.wantReply = true;
        await this.sshSession.request(request);
      }
      /**
       * @internal Closes the tunnel session due to an error.
       */
      async closeSession(reason, error) {
        if (this.isSshSessionActive) {
          this.sshSessionClosedEmitter.fire(this);
        }
        await super.closeSession(reason, error);
      }
      /**
       * SSH session closed event handler.
       */
      onSshSessionClosed(e) {
        this.sshSessionClosedEmitter.fire(this);
        super.onSshSessionClosed(e);
      }
      onSshSessionDisconnected() {
        this.sshSessionClosedEmitter.fire(this);
        const reason = dev_tunnels_ssh_1.SshDisconnectReason.connectionLost;
        const error = new dev_tunnels_ssh_1.SshConnectionError("Connection lost.", dev_tunnels_ssh_1.SshDisconnectReason.connectionLost);
        this.maybeStartReconnecting(reason, void 0, error);
      }
      /**
       * Connect to the tunnel session on the relay service using the given access token for authorization.
       */
      async connectClientToRelayServer(clientRelayUri, accessToken) {
        if (!clientRelayUri) {
          throw new Error("Client relay URI must be a non-empty string");
        }
        this.relayUri = clientRelayUri;
        this.accessToken = accessToken;
        await this.connectTunnelSession();
      }
    };
    exports2.TunnelRelayTunnelClient = TunnelRelayTunnelClient;
    TunnelRelayTunnelClient.webSocketSubProtocol = exports2.webSocketSubProtocol;
    TunnelRelayTunnelClient.webSocketSubProtocolv2 = exports2.webSocketSubProtocolv2;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-connections/tunnelRelayTunnelHost.js
var require_tunnelRelayTunnelHost = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-connections/tunnelRelayTunnelHost.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TunnelRelayTunnelHost = void 0;
    var dev_tunnels_contracts_1 = require_dev_tunnels_contracts();
    var dev_tunnels_ssh_1 = require_dev_tunnels_ssh();
    var dev_tunnels_ssh_tcp_1 = require_dev_tunnels_ssh_tcp();
    var sshHelpers_1 = require_sshHelpers();
    var multiModeTunnelHost_1 = require_multiModeTunnelHost();
    var sessionPortKey_1 = require_sessionPortKey();
    var portRelayConnectRequestMessage_1 = require_portRelayConnectRequestMessage();
    var portRelayConnectResponseMessage_1 = require_portRelayConnectResponseMessage();
    var uuid_1 = require_uuid();
    var sshHelpers_2 = require_sshHelpers();
    var tunnelConnectionSession_1 = require_tunnelConnectionSession();
    var webSocketSubProtocol = "tunnel-relay-host";
    var webSocketSubProtocolv2 = "tunnel-relay-host-v2-dev";
    var protocolVersion = (process === null || process === void 0 ? void 0 : process.env) && process.env.DEVTUNNELS_PROTOCOL_VERSION;
    var connectionProtocols = protocolVersion === "1" ? [webSocketSubProtocol] : protocolVersion === "2" ? [webSocketSubProtocolv2] : [webSocketSubProtocolv2, webSocketSubProtocol];
    var TunnelRelayTunnelHost2 = class _TunnelRelayTunnelHost extends tunnelConnectionSession_1.TunnelConnectionSession {
      constructor(managementClient, trace) {
        super(dev_tunnels_contracts_1.TunnelAccessScopes.Host, connectionProtocols, managementClient, trace);
        this.clientSessionPromises = [];
        this.reconnectableSessions = [];
        this.sshSessions = [];
        this.remoteForwarders = /* @__PURE__ */ new Map();
        this.loopbackIp = "127.0.0.1";
        this.forwardConnectionsToLocalPortsValue = (0, sshHelpers_2.isNode)();
        const publicKey = dev_tunnels_ssh_1.SshAlgorithms.publicKey.ecdsaSha2Nistp384;
        if (publicKey) {
          this.hostPrivateKeyPromise = publicKey.generateKeyPair();
        }
        this.hostId = multiModeTunnelHost_1.MultiModeTunnelHost.hostId;
        this.id = (0, uuid_1.v4)() + "-relay";
      }
      get connectionId() {
        return this.hostId;
      }
      /**
       * A value indicating whether the port-forwarding service forwards connections to local TCP sockets.
       * Forwarded connections are not possible if the host is not NodeJS (e.g. browser).
       * The default value for NodeJS hosts is true.
       */
      get forwardConnectionsToLocalPorts() {
        return this.forwardConnectionsToLocalPortsValue;
      }
      set forwardConnectionsToLocalPorts(value) {
        if (value === this.forwardConnectionsToLocalPortsValue) {
          return;
        }
        if (value && !(0, sshHelpers_2.isNode)()) {
          throw new Error("Cannot forward connections to local TCP sockets on this platform.");
        }
        this.forwardConnectionsToLocalPortsValue = value;
      }
      /**
       * Connects to a tunnel as a host and starts accepting incoming connections
       * to local ports as defined on the tunnel.
       * @deprecated Use `connect()` instead.
       */
      async start(tunnel) {
        await this.connect(tunnel);
      }
      /**
       * Connects to a tunnel as a host and starts accepting incoming connections
       * to local ports as defined on the tunnel.
       */
      async connect(tunnel, options, cancellation) {
        await this.connectTunnelSession(tunnel, options, cancellation);
      }
      /**
       * Connect to the tunnel session with the tunnel connector.
       * @param tunnel Tunnel to use for the connection.
       *     Undefined if the connection information is already known and the tunnel is not needed.
       *     Tunnel object to get the connection information from that tunnel.
       */
      async connectTunnelSession(tunnel, options, cancellation) {
        if (this.disconnectReason === dev_tunnels_ssh_1.SshDisconnectReason.tooManyConnections) {
          throw new dev_tunnels_ssh_1.SshConnectionError("Cannot retry connection because another host for this tunnel has connected. Only one host connection at a time is supported.", dev_tunnels_ssh_1.SshDisconnectReason.tooManyConnections);
        }
        await super.connectTunnelSession(tunnel, options, cancellation);
      }
      /**
       * Configures the tunnel session with the given stream.
       * @internal
       */
      async configureSession(stream, protocol, isReconnect, cancellation) {
        this.connectionProtocol = protocol;
        let session;
        if (this.connectionProtocol === webSocketSubProtocol) {
          session = new dev_tunnels_ssh_1.SshClientSession(new dev_tunnels_ssh_1.SshSessionConfiguration(false));
        } else {
          session = sshHelpers_1.SshHelpers.createSshClientSession((config) => {
            config.keyExchangeAlgorithms.splice(0, 0, dev_tunnels_ssh_1.SshAlgorithms.keyExchange.none);
            config.addService(dev_tunnels_ssh_tcp_1.PortForwardingService);
          });
          const hostPfs = session.activateService(dev_tunnels_ssh_tcp_1.PortForwardingService);
          hostPfs.messageFactory = this;
          hostPfs.onForwardedPortConnecting(this.onForwardedPortConnecting, this, this.sshSessionDisposables);
        }
        session.onChannelOpening(this.hostSession_ChannelOpening, this, this.sshSessionDisposables);
        session.onClosed(this.onSshSessionClosed, this, this.sshSessionDisposables);
        session.trace = this.trace;
        session.onReportProgress((args) => this.raiseReportProgress(args.progress, args.sessionNumber), this, this.sshSessionDisposables);
        this.sshSession = session;
        await session.connect(stream, cancellation);
        if (session.sessionId) {
          await session.authenticate({ username: "tunnel" });
        }
        if (this.connectionProtocol === webSocketSubProtocolv2) {
          await this.startForwardingExistingPorts(session);
        }
      }
      /**
       * Validate the {@link tunnel} and get data needed to connect to it, if the tunnel is provided;
       * otherwise, ensure that there is already sufficient data to connect to a tunnel.
       * @internal
       */
      async onConnectingToTunnel() {
        var _a, _b, _c, _d, _e;
        if (!this.hostPrivateKey || !this.hostPublicKeys) {
          if (!this.hostPrivateKeyPromise) {
            throw new Error("Cannot create host keys");
          }
          this.hostPrivateKey = await this.hostPrivateKeyPromise;
          const buffer = await this.hostPrivateKey.getPublicKeyBytes(this.hostPrivateKey.keyAlgorithmName);
          if (!buffer) {
            throw new Error("Host private key public key bytes is not initialized");
          }
          this.hostPublicKeys = [buffer.toString("base64")];
        }
        const tunnelHasSshPort = ((_a = this.tunnel) === null || _a === void 0 ? void 0 : _a.ports) != null && this.tunnel.ports.find((v) => v.protocol === dev_tunnels_contracts_1.TunnelProtocol.Ssh);
        const endpointSignature = `${(_b = this.tunnel) === null || _b === void 0 ? void 0 : _b.tunnelId}.${(_c = this.tunnel) === null || _c === void 0 ? void 0 : _c.clusterId}:${(_d = this.tunnel) === null || _d === void 0 ? void 0 : _d.name}.${(_e = this.tunnel) === null || _e === void 0 ? void 0 : _e.domain}:${tunnelHasSshPort}:${this.hostId}:${this.hostPublicKeys}`;
        if (!this.relayUri || this.endpointSignature !== endpointSignature) {
          if (!this.tunnel) {
            throw new Error("Tunnel is required");
          }
          let endpoint = {
            id: this.id,
            hostId: this.hostId,
            hostPublicKeys: this.hostPublicKeys,
            connectionMode: dev_tunnels_contracts_1.TunnelConnectionMode.TunnelRelay
          };
          let additionalQueryParameters = void 0;
          if (tunnelHasSshPort) {
            additionalQueryParameters = { includeSshGatewayPublicKey: "true" };
          }
          endpoint = await this.managementClient.updateTunnelEndpoint(this.tunnel, endpoint, {
            additionalQueryParameters
          });
          this.relayUri = endpoint.hostRelayUri;
          this.endpointSignature = endpointSignature;
        }
      }
      /**
       * Disposes this tunnel session, closing all client connections, the host SSH session, and deleting the endpoint.
       */
      async dispose() {
        await super.dispose();
        const promises = Object.assign([], this.clientSessionPromises);
        this.clientSessionPromises.length = 0;
        if (this.tunnel && this.endpointSignature && this.disconnectReason !== dev_tunnels_ssh_1.SshDisconnectReason.tooManyConnections) {
          const promise2 = this.managementClient.deleteTunnelEndpoints(this.tunnel, this.id);
          promises.push(promise2);
        }
        for (const forwarder of this.remoteForwarders.values()) {
          forwarder.dispose();
        }
        await Promise.all(promises);
      }
      hostSession_ChannelOpening(e) {
        if (!e.isRemoteRequest) {
          return;
        }
        if (this.connectionProtocol === webSocketSubProtocolv2 && e.channel.channelType === "forwarded-tcpip") {
          const relayRequestMessage = e.channel.openMessage.convertTo(new portRelayConnectRequestMessage_1.PortRelayConnectRequestMessage());
          const responseMessage = new portRelayConnectResponseMessage_1.PortRelayConnectResponseMessage();
          responseMessage.isE2EEncryptionEnabled = this.enableE2EEncryption && relayRequestMessage.isE2EEncryptionRequested;
          e.openingPromise = Promise.resolve(responseMessage);
          return;
        } else if (e.channel.channelType !== _TunnelRelayTunnelHost.clientStreamChannelType) {
          e.failureDescription = `Unknown channel type: ${e.channel.channelType}`;
          e.failureReason = dev_tunnels_ssh_1.SshChannelOpenFailureReason.unknownChannelType;
          return;
        }
        e.channel.maxWindowSize = dev_tunnels_ssh_1.SshChannel.defaultMaxWindowSize * 5;
        if (this.isDisposed) {
          e.failureDescription = "The host is disconnecting.";
          e.failureReason = dev_tunnels_ssh_1.SshChannelOpenFailureReason.connectFailed;
          return;
        }
        const promise2 = this.acceptClientSession(e.channel, this.disposeToken);
        this.clientSessionPromises.push(promise2);
        promise2.then(() => {
          const index = this.clientSessionPromises.indexOf(promise2);
          this.clientSessionPromises.splice(index, 1);
        });
      }
      onForwardedPortConnecting(e) {
        const channel = e.stream.channel;
        const relayRequestMessage = channel.openMessage.convertTo(new portRelayConnectRequestMessage_1.PortRelayConnectRequestMessage());
        const isE2EEncryptionEnabled = this.enableE2EEncryption && relayRequestMessage.isE2EEncryptionRequested;
        if (isE2EEncryptionEnabled) {
          channel.maxWindowSize = dev_tunnels_ssh_1.SshChannel.defaultMaxWindowSize * 2;
          const serverCredentials = {
            publicKeys: [this.hostPrivateKey]
          };
          const secureStream = new dev_tunnels_ssh_1.SecureStream(e.stream, serverCredentials, this.reconnectableSessions);
          secureStream.trace = this.trace;
          secureStream.onAuthenticating((authEvent) => authEvent.authenticationPromise = Promise.resolve({}));
          secureStream.connect().catch((err) => {
            this.trace(dev_tunnels_ssh_1.TraceLevel.Error, 0, `Error connecting encrypted channel: ${err}`);
          });
          e.transformPromise = Promise.resolve(secureStream);
        }
        super.onForwardedPortConnecting(e);
      }
      async acceptClientSession(clientSessionChannel, cancellation) {
        try {
          const stream = new dev_tunnels_ssh_1.SshStream(clientSessionChannel);
          await this.connectAndRunClientSession(stream, cancellation);
        } catch (ex) {
          if (!(ex instanceof dev_tunnels_ssh_1.CancellationError) || !cancellation.isCancellationRequested) {
            this.trace(dev_tunnels_ssh_1.TraceLevel.Error, 0, `Error running client SSH session: ${ex}`);
          }
        }
      }
      /**
       * Creates an SSH server session for a client (V1 protocol), runs the session,
       * and waits for it to close.
       */
      async connectAndRunClientSession(stream, cancellation) {
        if (cancellation.isCancellationRequested) {
          stream.destroy();
          throw new dev_tunnels_ssh_1.CancellationError();
        }
        const clientChannelId = stream.channel.channelId;
        const session = sshHelpers_1.SshHelpers.createSshServerSession(this.reconnectableSessions, (config) => {
          var _a;
          config.protocolExtensions.push(dev_tunnels_ssh_1.SshProtocolExtensionNames.sessionReconnect);
          config.addService(dev_tunnels_ssh_tcp_1.PortForwardingService);
          const keepAliveInterval = (_a = this.connectionOptions) === null || _a === void 0 ? void 0 : _a.keepAliveIntervalInSeconds;
          if (keepAliveInterval && keepAliveInterval > 0) {
            config.keepAliveTimeoutInSeconds = keepAliveInterval;
          }
        });
        session.trace = this.trace;
        session.onReportProgress((args) => this.raiseReportProgress(args.progress, args.sessionNumber), this, this.sshSessionDisposables);
        session.credentials = {
          publicKeys: [this.hostPrivateKey]
        };
        const tcs = new dev_tunnels_ssh_1.PromiseCompletionSource();
        const authenticatingEventRegistration = session.onAuthenticating((e) => {
          this.onSshClientAuthenticating(e);
        });
        session.onClientAuthenticated(() => {
          void this.onSshClientAuthenticated(session);
        });
        const requestRegistration = session.onRequest((e) => {
          this.onClientSessionRequest(e, session);
        });
        const channelOpeningEventRegistration = session.onChannelOpening((e) => {
          this.onSshChannelOpening(e, session);
        });
        const reconnectedEventRegistration = session.onReconnected(() => {
          this.onClientSessionReconnecting(session, clientChannelId);
        });
        const closedEventRegistration = session.onClosed((e) => {
          this.onClientSessionClosed(session, e, clientChannelId, cancellation);
          tcs.resolve();
        });
        session.onKeepAliveFailed((count) => this.onKeepAliveFailed(count));
        session.onKeepAliveSucceeded((count) => this.onKeepAliveSucceeded(count));
        try {
          const nodeStream = new dev_tunnels_ssh_1.NodeStream(stream);
          await session.connect(nodeStream);
          this.sshSessions.push(session);
          cancellation.onCancellationRequested((e) => {
            tcs.reject(new dev_tunnels_ssh_1.CancellationError());
          });
          if (this.tunnel && this.managementClient) {
            const connectedEvent = {
              name: "host_client_connect",
              properties: {
                ClientChannelId: clientChannelId.toString(),
                ClientSessionId: this.getShortSessionId(session),
                HostSessionId: this.connectionId
              }
            };
            this.managementClient.reportEvent(this.tunnel, connectedEvent);
          }
          await tcs.promise;
        } finally {
          authenticatingEventRegistration.dispose();
          requestRegistration.dispose();
          channelOpeningEventRegistration.dispose();
          reconnectedEventRegistration.dispose();
          closedEventRegistration.dispose();
          await session.close(dev_tunnels_ssh_1.SshDisconnectReason.byApplication);
          session.dispose();
        }
      }
      onSshClientAuthenticating(e) {
        if (e.authenticationType === dev_tunnels_ssh_1.SshAuthenticationType.clientNone) {
          e.authenticationPromise = Promise.resolve({});
        } else {
        }
      }
      async onSshClientAuthenticated(session) {
        void this.startForwardingExistingPorts(session);
      }
      async startForwardingExistingPorts(session) {
        var _a, _b;
        const pfs = session.activateService(dev_tunnels_ssh_tcp_1.PortForwardingService);
        pfs.forwardConnectionsToLocalPorts = this.forwardConnectionsToLocalPorts;
        for (const port of (_b = (_a = this.tunnel) === null || _a === void 0 ? void 0 : _a.ports) !== null && _b !== void 0 ? _b : []) {
          this.trace(dev_tunnels_ssh_1.TraceLevel.Verbose, 0, `Forwarding port ${port.portNumber}`);
          try {
            await this.forwardPort(pfs, port);
          } catch (ex) {
            this.traceError(`Error forwarding port ${port.portNumber}: ${ex}`);
          }
        }
      }
      onClientSessionRequest(e, session) {
        if (e.requestType === "RefreshPorts") {
          e.responsePromise = (async () => {
            await this.refreshPorts();
            return new dev_tunnels_ssh_1.SessionRequestSuccessMessage();
          })();
        }
      }
      onSshChannelOpening(e, session) {
        if (!(e.request instanceof dev_tunnels_ssh_tcp_1.PortForwardChannelOpenMessage)) {
          if (e.request.channelType === dev_tunnels_ssh_1.SshChannel.sessionChannelType) {
            return;
          }
          this.trace(dev_tunnels_ssh_1.TraceLevel.Warning, 0, "Rejecting request to open non-portforwarding channel.");
          e.failureReason = dev_tunnels_ssh_1.SshChannelOpenFailureReason.administrativelyProhibited;
          return;
        }
        const portForwardRequest = e.request;
        if (portForwardRequest.channelType === "direct-tcpip") {
          if (!this.tunnel.ports.some((p) => p.portNumber === portForwardRequest.port)) {
            this.trace(dev_tunnels_ssh_1.TraceLevel.Warning, 0, "Rejecting request to connect to non-forwarded port:" + portForwardRequest.port);
            e.failureReason = dev_tunnels_ssh_1.SshChannelOpenFailureReason.administrativelyProhibited;
          }
        } else if (portForwardRequest.channelType === "forwarded-tcpip") {
          const eventArgs = new dev_tunnels_ssh_tcp_1.ForwardedPortConnectingEventArgs(portForwardRequest.port, false, new dev_tunnels_ssh_1.SshStream(e.channel));
          super.onForwardedPortConnecting(eventArgs);
        } else {
          this.trace(dev_tunnels_ssh_1.TraceLevel.Warning, 0, "Nonrecognized channel type " + portForwardRequest.channelType);
          e.failureReason = dev_tunnels_ssh_1.SshChannelOpenFailureReason.unknownChannelType;
        }
      }
      onClientSessionReconnecting(session, clientChannelId) {
        if (this.tunnel && this.managementClient) {
          const reconnectedEvent = {
            name: "host_client_reconnect",
            properties: {
              ClientChannelId: clientChannelId.toString(),
              ClientSessionId: this.getShortSessionId(session),
              HostSessionId: this.connectionId
            }
          };
          this.managementClient.reportEvent(this.tunnel, reconnectedEvent);
        }
      }
      onClientSessionClosed(session, e, clientChannelId, cancellation) {
        let severity;
        let details;
        if (e.reason === dev_tunnels_ssh_1.SshDisconnectReason.byApplication) {
          details = "Client ssh session closed by application.";
          this.traceInfo(details);
        } else if (cancellation.isCancellationRequested) {
          details = "Client ssh session cancelled.";
          this.traceInfo(details);
        } else if (e.reason !== dev_tunnels_ssh_1.SshDisconnectReason.none) {
          severity = dev_tunnels_contracts_1.TunnelEvent.error;
          details = `Client ssh session closed unexpectedly due to ${e.reason}, "${e.message}"
${e.error}`;
          this.traceError(details);
        } else {
          details = "Client ssh session closed.";
        }
        if (this.tunnel && this.managementClient) {
          const disconnectedEvent = {
            timestamp: /* @__PURE__ */ new Date(),
            name: "host_client_disconnect",
            severity,
            details,
            properties: {
              ClientChannelId: clientChannelId.toString(),
              ClientSessionId: this.getShortSessionId(session),
              HostSessionId: this.connectionId
            }
          };
          this.managementClient.reportEvent(this.tunnel, disconnectedEvent);
        }
        for (const [key, forwarder] of this.remoteForwarders.entries()) {
          if (forwarder.session === session) {
            forwarder.dispose();
            this.remoteForwarders.delete(key);
          }
        }
        const index = this.sshSessions.indexOf(session);
        if (index >= 0) {
          this.sshSessions.splice(index, 1);
        }
      }
      async refreshPorts(cancellation) {
        var _a, _b;
        this.raiseReportProgress(dev_tunnels_contracts_1.TunnelProgress.StartingRefreshPorts);
        if (!await this.refreshTunnel(true, cancellation)) {
          return;
        }
        const ports = (_b = (_a = this.tunnel) === null || _a === void 0 ? void 0 : _a.ports) !== null && _b !== void 0 ? _b : [];
        let sessions = this.sshSessions;
        if (this.connectionProtocol === webSocketSubProtocolv2 && this.sshSession) {
          sessions = [...sessions, this.sshSession];
        }
        const forwardPromises = [];
        for (const port of ports) {
          for (const session of sessions.filter((s) => s.isConnected && (!s.sessionId || s.principal))) {
            const key = new sessionPortKey_1.SessionPortKey(session.sessionId, Number(port.portNumber));
            const forwarder = this.remoteForwarders.get(key.toString());
            if (!forwarder) {
              const pfs = session.getService(dev_tunnels_ssh_tcp_1.PortForwardingService);
              forwardPromises.push(this.forwardPort(pfs, port));
            }
          }
        }
        for (const [key, forwarder] of Object.entries(this.remoteForwarders)) {
          if (!ports.some((p) => p.portNumber === forwarder.localPort)) {
            this.remoteForwarders.delete(key);
            forwarder.dispose();
          }
        }
        await Promise.all(forwardPromises);
        this.raiseReportProgress(dev_tunnels_contracts_1.TunnelProgress.CompletedRefreshPorts);
      }
      async forwardPort(pfs, port) {
        const portNumber = Number(port.portNumber);
        if (pfs.localForwardedPorts.find((p) => p.localPort === portNumber)) {
          return;
        }
        const forwarder = await pfs.forwardFromRemotePort(this.loopbackIp, portNumber, "localhost", portNumber);
        if (!forwarder) {
          return;
        }
        const key = new sessionPortKey_1.SessionPortKey(pfs.session.sessionId, Number(forwarder.localPort));
        this.remoteForwarders.set(key.toString(), forwarder);
      }
    };
    exports2.TunnelRelayTunnelHost = TunnelRelayTunnelHost2;
    TunnelRelayTunnelHost2.webSocketSubProtocol = webSocketSubProtocol;
    TunnelRelayTunnelHost2.webSocketSubProtocolv2 = webSocketSubProtocolv2;
    TunnelRelayTunnelHost2.clientStreamChannelType = "client-ssh-session-stream";
  }
});

// ../../node_modules/@microsoft/dev-tunnels-connections/tunnelConnection.js
var require_tunnelConnection = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-connections/tunnelConnection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/@microsoft/dev-tunnels-connections/tunnelConnectionOptions.js
var require_tunnelConnectionOptions = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-connections/tunnelConnectionOptions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/@microsoft/dev-tunnels-connections/tunnelConnector.js
var require_tunnelConnector = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-connections/tunnelConnector.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/@microsoft/dev-tunnels-connections/index.js
var require_dev_tunnels_connections = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-connections/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.maxReconnectDelayMs = void 0;
    __exportStar(require_tunnelClient(), exports2);
    __exportStar(require_tunnelHost(), exports2);
    __exportStar(require_multiModeTunnelClient(), exports2);
    __exportStar(require_multiModeTunnelHost(), exports2);
    __exportStar(require_retryTcpListenerFactory(), exports2);
    __exportStar(require_sessionPortKey(), exports2);
    __exportStar(require_sshHelpers(), exports2);
    __exportStar(require_tunnelClient(), exports2);
    __exportStar(require_tunnelHost(), exports2);
    __exportStar(require_tunnelRelayStreamFactory(), exports2);
    __exportStar(require_defaultTunnelRelayStreamFactory(), exports2);
    __exportStar(require_tunnelRelayTunnelClient(), exports2);
    __exportStar(require_tunnelRelayTunnelHost(), exports2);
    __exportStar(require_tunnelConnection(), exports2);
    __exportStar(require_tunnelConnectionBase(), exports2);
    __exportStar(require_tunnelConnectionOptions(), exports2);
    __exportStar(require_sshKeepAliveEventArgs(), exports2);
    __exportStar(require_connectionStatus(), exports2);
    __exportStar(require_connectionStatusChangedEventArgs(), exports2);
    var relayTunnelConnector_1 = require_relayTunnelConnector();
    Object.defineProperty(exports2, "maxReconnectDelayMs", { enumerable: true, get: function() {
      return relayTunnelConnector_1.maxReconnectDelayMs;
    } });
    __exportStar(require_refreshingTunnelAccessTokenEventArgs(), exports2);
    __exportStar(require_refreshingTunnelEventArgs(), exports2);
    __exportStar(require_retryingTunnelConnectionEventArgs(), exports2);
    __exportStar(require_portForwardingEventArgs(), exports2);
    __exportStar(require_tunnelConnector(), exports2);
  }
});

// ../../node_modules/@github/copilot-sdk/node_modules/vscode-jsonrpc/lib/common/is.js
var require_is2 = __commonJS({
  "../../node_modules/@github/copilot-sdk/node_modules/vscode-jsonrpc/lib/common/is.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.stringArray = exports2.array = exports2.func = exports2.error = exports2.number = exports2.string = exports2.boolean = void 0;
    function boolean(value) {
      return value === true || value === false;
    }
    exports2.boolean = boolean;
    function string(value) {
      return typeof value === "string" || value instanceof String;
    }
    exports2.string = string;
    function number(value) {
      return typeof value === "number" || value instanceof Number;
    }
    exports2.number = number;
    function error(value) {
      return value instanceof Error;
    }
    exports2.error = error;
    function func(value) {
      return typeof value === "function";
    }
    exports2.func = func;
    function array(value) {
      return Array.isArray(value);
    }
    exports2.array = array;
    function stringArray(value) {
      return array(value) && value.every((elem) => string(elem));
    }
    exports2.stringArray = stringArray;
  }
});

// ../../node_modules/@github/copilot-sdk/node_modules/vscode-jsonrpc/lib/common/messages.js
var require_messages2 = __commonJS({
  "../../node_modules/@github/copilot-sdk/node_modules/vscode-jsonrpc/lib/common/messages.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Message = exports2.NotificationType9 = exports2.NotificationType8 = exports2.NotificationType7 = exports2.NotificationType6 = exports2.NotificationType5 = exports2.NotificationType4 = exports2.NotificationType3 = exports2.NotificationType2 = exports2.NotificationType1 = exports2.NotificationType0 = exports2.NotificationType = exports2.RequestType9 = exports2.RequestType8 = exports2.RequestType7 = exports2.RequestType6 = exports2.RequestType5 = exports2.RequestType4 = exports2.RequestType3 = exports2.RequestType2 = exports2.RequestType1 = exports2.RequestType = exports2.RequestType0 = exports2.AbstractMessageSignature = exports2.ParameterStructures = exports2.ResponseError = exports2.ErrorCodes = void 0;
    var is = require_is2();
    var ErrorCodes;
    (function(ErrorCodes2) {
      ErrorCodes2.ParseError = -32700;
      ErrorCodes2.InvalidRequest = -32600;
      ErrorCodes2.MethodNotFound = -32601;
      ErrorCodes2.InvalidParams = -32602;
      ErrorCodes2.InternalError = -32603;
      ErrorCodes2.jsonrpcReservedErrorRangeStart = -32099;
      ErrorCodes2.serverErrorStart = -32099;
      ErrorCodes2.MessageWriteError = -32099;
      ErrorCodes2.MessageReadError = -32098;
      ErrorCodes2.PendingResponseRejected = -32097;
      ErrorCodes2.ConnectionInactive = -32096;
      ErrorCodes2.ServerNotInitialized = -32002;
      ErrorCodes2.UnknownErrorCode = -32001;
      ErrorCodes2.jsonrpcReservedErrorRangeEnd = -32e3;
      ErrorCodes2.serverErrorEnd = -32e3;
    })(ErrorCodes || (exports2.ErrorCodes = ErrorCodes = {}));
    var ResponseError = class _ResponseError extends Error {
      constructor(code, message, data) {
        super(message);
        this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;
        this.data = data;
        Object.setPrototypeOf(this, _ResponseError.prototype);
      }
      toJson() {
        const result = {
          code: this.code,
          message: this.message
        };
        if (this.data !== void 0) {
          result.data = this.data;
        }
        return result;
      }
    };
    exports2.ResponseError = ResponseError;
    var ParameterStructures = class _ParameterStructures {
      constructor(kind) {
        this.kind = kind;
      }
      static is(value) {
        return value === _ParameterStructures.auto || value === _ParameterStructures.byName || value === _ParameterStructures.byPosition;
      }
      toString() {
        return this.kind;
      }
    };
    exports2.ParameterStructures = ParameterStructures;
    ParameterStructures.auto = new ParameterStructures("auto");
    ParameterStructures.byPosition = new ParameterStructures("byPosition");
    ParameterStructures.byName = new ParameterStructures("byName");
    var AbstractMessageSignature = class {
      constructor(method, numberOfParams) {
        this.method = method;
        this.numberOfParams = numberOfParams;
      }
      get parameterStructures() {
        return ParameterStructures.auto;
      }
    };
    exports2.AbstractMessageSignature = AbstractMessageSignature;
    var RequestType0 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 0);
      }
    };
    exports2.RequestType0 = RequestType0;
    var RequestType = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports2.RequestType = RequestType;
    var RequestType1 = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports2.RequestType1 = RequestType1;
    var RequestType2 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 2);
      }
    };
    exports2.RequestType2 = RequestType2;
    var RequestType3 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 3);
      }
    };
    exports2.RequestType3 = RequestType3;
    var RequestType4 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 4);
      }
    };
    exports2.RequestType4 = RequestType4;
    var RequestType5 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 5);
      }
    };
    exports2.RequestType5 = RequestType5;
    var RequestType6 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 6);
      }
    };
    exports2.RequestType6 = RequestType6;
    var RequestType7 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 7);
      }
    };
    exports2.RequestType7 = RequestType7;
    var RequestType8 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 8);
      }
    };
    exports2.RequestType8 = RequestType8;
    var RequestType9 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 9);
      }
    };
    exports2.RequestType9 = RequestType9;
    var NotificationType = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports2.NotificationType = NotificationType;
    var NotificationType0 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 0);
      }
    };
    exports2.NotificationType0 = NotificationType0;
    var NotificationType1 = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports2.NotificationType1 = NotificationType1;
    var NotificationType2 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 2);
      }
    };
    exports2.NotificationType2 = NotificationType2;
    var NotificationType3 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 3);
      }
    };
    exports2.NotificationType3 = NotificationType3;
    var NotificationType4 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 4);
      }
    };
    exports2.NotificationType4 = NotificationType4;
    var NotificationType5 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 5);
      }
    };
    exports2.NotificationType5 = NotificationType5;
    var NotificationType6 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 6);
      }
    };
    exports2.NotificationType6 = NotificationType6;
    var NotificationType7 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 7);
      }
    };
    exports2.NotificationType7 = NotificationType7;
    var NotificationType8 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 8);
      }
    };
    exports2.NotificationType8 = NotificationType8;
    var NotificationType9 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 9);
      }
    };
    exports2.NotificationType9 = NotificationType9;
    var Message;
    (function(Message2) {
      function isRequest(message) {
        const candidate = message;
        return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
      }
      Message2.isRequest = isRequest;
      function isNotification(message) {
        const candidate = message;
        return candidate && is.string(candidate.method) && message.id === void 0;
      }
      Message2.isNotification = isNotification;
      function isResponse(message) {
        const candidate = message;
        return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
      }
      Message2.isResponse = isResponse;
    })(Message || (exports2.Message = Message = {}));
  }
});

// ../../node_modules/@github/copilot-sdk/node_modules/vscode-jsonrpc/lib/common/linkedMap.js
var require_linkedMap2 = __commonJS({
  "../../node_modules/@github/copilot-sdk/node_modules/vscode-jsonrpc/lib/common/linkedMap.js"(exports2) {
    "use strict";
    var _a;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LRUCache = exports2.LinkedMap = exports2.Touch = void 0;
    var Touch;
    (function(Touch2) {
      Touch2.None = 0;
      Touch2.First = 1;
      Touch2.AsOld = Touch2.First;
      Touch2.Last = 2;
      Touch2.AsNew = Touch2.Last;
    })(Touch || (exports2.Touch = Touch = {}));
    var LinkedMap = class {
      constructor() {
        this[_a] = "LinkedMap";
        this._map = /* @__PURE__ */ new Map();
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
        this._state = 0;
      }
      clear() {
        this._map.clear();
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
        this._state++;
      }
      isEmpty() {
        return !this._head && !this._tail;
      }
      get size() {
        return this._size;
      }
      get first() {
        return this._head?.value;
      }
      get last() {
        return this._tail?.value;
      }
      has(key) {
        return this._map.has(key);
      }
      get(key, touch = Touch.None) {
        const item = this._map.get(key);
        if (!item) {
          return void 0;
        }
        if (touch !== Touch.None) {
          this.touch(item, touch);
        }
        return item.value;
      }
      set(key, value, touch = Touch.None) {
        let item = this._map.get(key);
        if (item) {
          item.value = value;
          if (touch !== Touch.None) {
            this.touch(item, touch);
          }
        } else {
          item = { key, value, next: void 0, previous: void 0 };
          switch (touch) {
            case Touch.None:
              this.addItemLast(item);
              break;
            case Touch.First:
              this.addItemFirst(item);
              break;
            case Touch.Last:
              this.addItemLast(item);
              break;
            default:
              this.addItemLast(item);
              break;
          }
          this._map.set(key, item);
          this._size++;
        }
        return this;
      }
      delete(key) {
        return !!this.remove(key);
      }
      remove(key) {
        const item = this._map.get(key);
        if (!item) {
          return void 0;
        }
        this._map.delete(key);
        this.removeItem(item);
        this._size--;
        return item.value;
      }
      shift() {
        if (!this._head && !this._tail) {
          return void 0;
        }
        if (!this._head || !this._tail) {
          throw new Error("Invalid list");
        }
        const item = this._head;
        this._map.delete(item.key);
        this.removeItem(item);
        this._size--;
        return item.value;
      }
      forEach(callbackfn, thisArg) {
        const state = this._state;
        let current = this._head;
        while (current) {
          if (thisArg) {
            callbackfn.bind(thisArg)(current.value, current.key, this);
          } else {
            callbackfn(current.value, current.key, this);
          }
          if (this._state !== state) {
            throw new Error(`LinkedMap got modified during iteration.`);
          }
          current = current.next;
        }
      }
      keys() {
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]: () => {
            return iterator;
          },
          next: () => {
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: current.key, done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      values() {
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]: () => {
            return iterator;
          },
          next: () => {
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: current.value, done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      entries() {
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]: () => {
            return iterator;
          },
          next: () => {
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: [current.key, current.value], done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      [(_a = Symbol.toStringTag, Symbol.iterator)]() {
        return this.entries();
      }
      trimOld(newSize) {
        if (newSize >= this.size) {
          return;
        }
        if (newSize === 0) {
          this.clear();
          return;
        }
        let current = this._head;
        let currentSize = this.size;
        while (current && currentSize > newSize) {
          this._map.delete(current.key);
          current = current.next;
          currentSize--;
        }
        this._head = current;
        this._size = currentSize;
        if (current) {
          current.previous = void 0;
        }
        this._state++;
      }
      addItemFirst(item) {
        if (!this._head && !this._tail) {
          this._tail = item;
        } else if (!this._head) {
          throw new Error("Invalid list");
        } else {
          item.next = this._head;
          this._head.previous = item;
        }
        this._head = item;
        this._state++;
      }
      addItemLast(item) {
        if (!this._head && !this._tail) {
          this._head = item;
        } else if (!this._tail) {
          throw new Error("Invalid list");
        } else {
          item.previous = this._tail;
          this._tail.next = item;
        }
        this._tail = item;
        this._state++;
      }
      removeItem(item) {
        if (item === this._head && item === this._tail) {
          this._head = void 0;
          this._tail = void 0;
        } else if (item === this._head) {
          if (!item.next) {
            throw new Error("Invalid list");
          }
          item.next.previous = void 0;
          this._head = item.next;
        } else if (item === this._tail) {
          if (!item.previous) {
            throw new Error("Invalid list");
          }
          item.previous.next = void 0;
          this._tail = item.previous;
        } else {
          const next = item.next;
          const previous = item.previous;
          if (!next || !previous) {
            throw new Error("Invalid list");
          }
          next.previous = previous;
          previous.next = next;
        }
        item.next = void 0;
        item.previous = void 0;
        this._state++;
      }
      touch(item, touch) {
        if (!this._head || !this._tail) {
          throw new Error("Invalid list");
        }
        if (touch !== Touch.First && touch !== Touch.Last) {
          return;
        }
        if (touch === Touch.First) {
          if (item === this._head) {
            return;
          }
          const next = item.next;
          const previous = item.previous;
          if (item === this._tail) {
            previous.next = void 0;
            this._tail = previous;
          } else {
            next.previous = previous;
            previous.next = next;
          }
          item.previous = void 0;
          item.next = this._head;
          this._head.previous = item;
          this._head = item;
          this._state++;
        } else if (touch === Touch.Last) {
          if (item === this._tail) {
            return;
          }
          const next = item.next;
          const previous = item.previous;
          if (item === this._head) {
            next.previous = void 0;
            this._head = next;
          } else {
            next.previous = previous;
            previous.next = next;
          }
          item.next = void 0;
          item.previous = this._tail;
          this._tail.next = item;
          this._tail = item;
          this._state++;
        }
      }
      toJSON() {
        const data = [];
        this.forEach((value, key) => {
          data.push([key, value]);
        });
        return data;
      }
      fromJSON(data) {
        this.clear();
        for (const [key, value] of data) {
          this.set(key, value);
        }
      }
    };
    exports2.LinkedMap = LinkedMap;
    var LRUCache = class extends LinkedMap {
      constructor(limit, ratio = 1) {
        super();
        this._limit = limit;
        this._ratio = Math.min(Math.max(0, ratio), 1);
      }
      get limit() {
        return this._limit;
      }
      set limit(limit) {
        this._limit = limit;
        this.checkTrim();
      }
      get ratio() {
        return this._ratio;
      }
      set ratio(ratio) {
        this._ratio = Math.min(Math.max(0, ratio), 1);
        this.checkTrim();
      }
      get(key, touch = Touch.AsNew) {
        return super.get(key, touch);
      }
      peek(key) {
        return super.get(key, Touch.None);
      }
      set(key, value) {
        super.set(key, value, Touch.Last);
        this.checkTrim();
        return this;
      }
      checkTrim() {
        if (this.size > this._limit) {
          this.trimOld(Math.round(this._limit * this._ratio));
        }
      }
    };
    exports2.LRUCache = LRUCache;
  }
});

// ../../node_modules/@github/copilot-sdk/node_modules/vscode-jsonrpc/lib/common/disposable.js
var require_disposable = __commonJS({
  "../../node_modules/@github/copilot-sdk/node_modules/vscode-jsonrpc/lib/common/disposable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Disposable = void 0;
    var Disposable;
    (function(Disposable2) {
      function create(func) {
        return {
          dispose: func
        };
      }
      Disposable2.create = create;
    })(Disposable || (exports2.Disposable = Disposable = {}));
  }
});

// ../../node_modules/@github/copilot-sdk/node_modules/vscode-jsonrpc/lib/common/ral.js
var require_ral = __commonJS({
  "../../node_modules/@github/copilot-sdk/node_modules/vscode-jsonrpc/lib/common/ral.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var _ral;
    function RAL() {
      if (_ral === void 0) {
        throw new Error(`No runtime abstraction layer installed`);
      }
      return _ral;
    }
    (function(RAL2) {
      function install(ral) {
        if (ral === void 0) {
          throw new Error(`No runtime abstraction layer provided`);
        }
        _ral = ral;
      }
      RAL2.install = install;
    })(RAL || (RAL = {}));
    exports2.default = RAL;
  }
});

// ../../node_modules/@github/copilot-sdk/node_modules/vscode-jsonrpc/lib/common/events.js
var require_events2 = __commonJS({
  "../../node_modules/@github/copilot-sdk/node_modules/vscode-jsonrpc/lib/common/events.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Emitter = exports2.Event = void 0;
    var ral_1 = require_ral();
    var Event;
    (function(Event2) {
      const _disposable = { dispose() {
      } };
      Event2.None = function() {
        return _disposable;
      };
    })(Event || (exports2.Event = Event = {}));
    var CallbackList = class {
      add(callback2, context = null, bucket) {
        if (!this._callbacks) {
          this._callbacks = [];
          this._contexts = [];
        }
        this._callbacks.push(callback2);
        this._contexts.push(context);
        if (Array.isArray(bucket)) {
          bucket.push({ dispose: () => this.remove(callback2, context) });
        }
      }
      remove(callback2, context = null) {
        if (!this._callbacks) {
          return;
        }
        let foundCallbackWithDifferentContext = false;
        for (let i = 0, len = this._callbacks.length; i < len; i++) {
          if (this._callbacks[i] === callback2) {
            if (this._contexts[i] === context) {
              this._callbacks.splice(i, 1);
              this._contexts.splice(i, 1);
              return;
            } else {
              foundCallbackWithDifferentContext = true;
            }
          }
        }
        if (foundCallbackWithDifferentContext) {
          throw new Error("When adding a listener with a context, you should remove it with the same context");
        }
      }
      invoke(...args) {
        if (!this._callbacks) {
          return [];
        }
        const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
        for (let i = 0, len = callbacks.length; i < len; i++) {
          try {
            ret.push(callbacks[i].apply(contexts[i], args));
          } catch (e) {
            (0, ral_1.default)().console.error(e);
          }
        }
        return ret;
      }
      isEmpty() {
        return !this._callbacks || this._callbacks.length === 0;
      }
      dispose() {
        this._callbacks = void 0;
        this._contexts = void 0;
      }
    };
    var Emitter = class _Emitter {
      constructor(_options) {
        this._options = _options;
      }
      /**
       * For the public to allow to subscribe
       * to events from this Emitter
       */
      get event() {
        if (!this._event) {
          this._event = (listener, thisArgs, disposables) => {
            if (!this._callbacks) {
              this._callbacks = new CallbackList();
            }
            if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
              this._options.onFirstListenerAdd(this);
            }
            this._callbacks.add(listener, thisArgs);
            const result = {
              dispose: () => {
                if (!this._callbacks) {
                  return;
                }
                this._callbacks.remove(listener, thisArgs);
                result.dispose = _Emitter._noop;
                if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                  this._options.onLastListenerRemove(this);
                }
              }
            };
            if (Array.isArray(disposables)) {
              disposables.push(result);
            }
            return result;
          };
        }
        return this._event;
      }
      /**
       * To be kept private to fire an event to
       * subscribers
       */
      fire(event) {
        if (this._callbacks) {
          this._callbacks.invoke.call(this._callbacks, event);
        }
      }
      dispose() {
        if (this._callbacks) {
          this._callbacks.dispose();
          this._callbacks = void 0;
        }
      }
    };
    exports2.Emitter = Emitter;
    Emitter._noop = function() {
    };
  }
});

// ../../node_modules/@github/copilot-sdk/node_modules/vscode-jsonrpc/lib/common/cancellation.js
var require_cancellation3 = __commonJS({
  "../../node_modules/@github/copilot-sdk/node_modules/vscode-jsonrpc/lib/common/cancellation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CancellationTokenSource = exports2.CancellationToken = void 0;
    var ral_1 = require_ral();
    var Is = require_is2();
    var events_1 = require_events2();
    var CancellationToken;
    (function(CancellationToken2) {
      CancellationToken2.None = Object.freeze({
        isCancellationRequested: false,
        onCancellationRequested: events_1.Event.None
      });
      CancellationToken2.Cancelled = Object.freeze({
        isCancellationRequested: true,
        onCancellationRequested: events_1.Event.None
      });
      function is(value) {
        const candidate = value;
        return candidate && (candidate === CancellationToken2.None || candidate === CancellationToken2.Cancelled || Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested);
      }
      CancellationToken2.is = is;
    })(CancellationToken || (exports2.CancellationToken = CancellationToken = {}));
    var shortcutEvent = Object.freeze(function(callback2, context) {
      const handle = (0, ral_1.default)().timer.setTimeout(callback2.bind(context), 0);
      return { dispose() {
        handle.dispose();
      } };
    });
    var MutableToken = class {
      constructor() {
        this._isCancelled = false;
      }
      cancel() {
        if (!this._isCancelled) {
          this._isCancelled = true;
          if (this._emitter) {
            this._emitter.fire(void 0);
            this.dispose();
          }
        }
      }
      get isCancellationRequested() {
        return this._isCancelled;
      }
      get onCancellationRequested() {
        if (this._isCancelled) {
          return shortcutEvent;
        }
        if (!this._emitter) {
          this._emitter = new events_1.Emitter();
        }
        return this._emitter.event;
      }
      dispose() {
        if (this._emitter) {
          this._emitter.dispose();
          this._emitter = void 0;
        }
      }
    };
    var CancellationTokenSource = class {
      get token() {
        if (!this._token) {
          this._token = new MutableToken();
        }
        return this._token;
      }
      cancel() {
        if (!this._token) {
          this._token = CancellationToken.Cancelled;
        } else {
          this._token.cancel();
        }
      }
      dispose() {
        if (!this._token) {
          this._token = CancellationToken.None;
        } else if (this._token instanceof MutableToken) {
          this._token.dispose();
        }
      }
    };
    exports2.CancellationTokenSource = CancellationTokenSource;
  }
});

// ../../node_modules/@github/copilot-sdk/node_modules/vscode-jsonrpc/lib/common/sharedArrayCancellation.js
var require_sharedArrayCancellation = __commonJS({
  "../../node_modules/@github/copilot-sdk/node_modules/vscode-jsonrpc/lib/common/sharedArrayCancellation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SharedArrayReceiverStrategy = exports2.SharedArraySenderStrategy = void 0;
    var cancellation_1 = require_cancellation3();
    var CancellationState;
    (function(CancellationState2) {
      CancellationState2.Continue = 0;
      CancellationState2.Cancelled = 1;
    })(CancellationState || (CancellationState = {}));
    var SharedArraySenderStrategy = class {
      constructor() {
        this.buffers = /* @__PURE__ */ new Map();
      }
      enableCancellation(request) {
        if (request.id === null) {
          return;
        }
        const buffer = new SharedArrayBuffer(4);
        const data = new Int32Array(buffer, 0, 1);
        data[0] = CancellationState.Continue;
        this.buffers.set(request.id, buffer);
        request.$cancellationData = buffer;
      }
      async sendCancellation(_conn, id) {
        const buffer = this.buffers.get(id);
        if (buffer === void 0) {
          return;
        }
        const data = new Int32Array(buffer, 0, 1);
        Atomics.store(data, 0, CancellationState.Cancelled);
      }
      cleanup(id) {
        this.buffers.delete(id);
      }
      dispose() {
        this.buffers.clear();
      }
    };
    exports2.SharedArraySenderStrategy = SharedArraySenderStrategy;
    var SharedArrayBufferCancellationToken = class {
      constructor(buffer) {
        this.data = new Int32Array(buffer, 0, 1);
      }
      get isCancellationRequested() {
        return Atomics.load(this.data, 0) === CancellationState.Cancelled;
      }
      get onCancellationRequested() {
        throw new Error(`Cancellation over SharedArrayBuffer doesn't support cancellation events`);
      }
    };
    var SharedArrayBufferCancellationTokenSource = class {
      constructor(buffer) {
        this.token = new SharedArrayBufferCancellationToken(buffer);
      }
      cancel() {
      }
      dispose() {
      }
    };
    var SharedArrayReceiverStrategy = class {
      constructor() {
        this.kind = "request";
      }
      createCancellationTokenSource(request) {
        const buffer = request.$cancellationData;
        if (buffer === void 0) {
          return new cancellation_1.CancellationTokenSource();
        }
        return new SharedArrayBufferCancellationTokenSource(buffer);
      }
    };
    exports2.SharedArrayReceiverStrategy = SharedArrayReceiverStrategy;
  }
});

// ../../node_modules/@github/copilot-sdk/node_modules/vscode-jsonrpc/lib/common/semaphore.js
var require_semaphore2 = __commonJS({
  "../../node_modules/@github/copilot-sdk/node_modules/vscode-jsonrpc/lib/common/semaphore.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Semaphore = void 0;
    var ral_1 = require_ral();
    var Semaphore = class {
      constructor(capacity = 1) {
        if (capacity <= 0) {
          throw new Error("Capacity must be greater than 0");
        }
        this._capacity = capacity;
        this._active = 0;
        this._waiting = [];
      }
      lock(thunk) {
        return new Promise((resolve3, reject) => {
          this._waiting.push({ thunk, resolve: resolve3, reject });
          this.runNext();
        });
      }
      get active() {
        return this._active;
      }
      runNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
          return;
        }
        (0, ral_1.default)().timer.setImmediate(() => this.doRunNext());
      }
      doRunNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
          return;
        }
        const next = this._waiting.shift();
        this._active++;
        if (this._active > this._capacity) {
          throw new Error(`To many thunks active`);
        }
        try {
          const result = next.thunk();
          if (result instanceof Promise) {
            result.then((value) => {
              this._active--;
              next.resolve(value);
              this.runNext();
            }, (err) => {
              this._active--;
              next.reject(err);
              this.runNext();
            });
          } else {
            this._active--;
            next.resolve(result);
            this.runNext();
          }
        } catch (err) {
          this._active--;
          next.reject(err);
          this.runNext();
        }
      }
    };
    exports2.Semaphore = Semaphore;
  }
});

// ../../node_modules/@github/copilot-sdk/node_modules/vscode-jsonrpc/lib/common/messageReader.js
var require_messageReader2 = __commonJS({
  "../../node_modules/@github/copilot-sdk/node_modules/vscode-jsonrpc/lib/common/messageReader.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ReadableStreamMessageReader = exports2.AbstractMessageReader = exports2.MessageReader = void 0;
    var ral_1 = require_ral();
    var Is = require_is2();
    var events_1 = require_events2();
    var semaphore_1 = require_semaphore2();
    var MessageReader;
    (function(MessageReader2) {
      function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.listen) && Is.func(candidate.dispose) && Is.func(candidate.onError) && Is.func(candidate.onClose) && Is.func(candidate.onPartialMessage);
      }
      MessageReader2.is = is;
    })(MessageReader || (exports2.MessageReader = MessageReader = {}));
    var AbstractMessageReader = class {
      constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
        this.partialMessageEmitter = new events_1.Emitter();
      }
      dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
      }
      get onError() {
        return this.errorEmitter.event;
      }
      fireError(error) {
        this.errorEmitter.fire(this.asError(error));
      }
      get onClose() {
        return this.closeEmitter.event;
      }
      fireClose() {
        this.closeEmitter.fire(void 0);
      }
      get onPartialMessage() {
        return this.partialMessageEmitter.event;
      }
      firePartialMessage(info) {
        this.partialMessageEmitter.fire(info);
      }
      asError(error) {
        if (error instanceof Error) {
          return error;
        } else {
          return new Error(`Reader received error. Reason: ${Is.string(error.message) ? error.message : "unknown"}`);
        }
      }
    };
    exports2.AbstractMessageReader = AbstractMessageReader;
    var ResolvedMessageReaderOptions;
    (function(ResolvedMessageReaderOptions2) {
      function fromOptions(options) {
        let charset;
        let result;
        let contentDecoder;
        const contentDecoders = /* @__PURE__ */ new Map();
        let contentTypeDecoder;
        const contentTypeDecoders = /* @__PURE__ */ new Map();
        if (options === void 0 || typeof options === "string") {
          charset = options ?? "utf-8";
        } else {
          charset = options.charset ?? "utf-8";
          if (options.contentDecoder !== void 0) {
            contentDecoder = options.contentDecoder;
            contentDecoders.set(contentDecoder.name, contentDecoder);
          }
          if (options.contentDecoders !== void 0) {
            for (const decoder of options.contentDecoders) {
              contentDecoders.set(decoder.name, decoder);
            }
          }
          if (options.contentTypeDecoder !== void 0) {
            contentTypeDecoder = options.contentTypeDecoder;
            contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
          }
          if (options.contentTypeDecoders !== void 0) {
            for (const decoder of options.contentTypeDecoders) {
              contentTypeDecoders.set(decoder.name, decoder);
            }
          }
        }
        if (contentTypeDecoder === void 0) {
          contentTypeDecoder = (0, ral_1.default)().applicationJson.decoder;
          contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
        }
        return { charset, contentDecoder, contentDecoders, contentTypeDecoder, contentTypeDecoders };
      }
      ResolvedMessageReaderOptions2.fromOptions = fromOptions;
    })(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));
    var ReadableStreamMessageReader = class extends AbstractMessageReader {
      constructor(readable, options) {
        super();
        this.readable = readable;
        this.options = ResolvedMessageReaderOptions.fromOptions(options);
        this.buffer = (0, ral_1.default)().messageBuffer.create(this.options.charset);
        this._partialMessageTimeout = 1e4;
        this.nextMessageLength = -1;
        this.messageToken = 0;
        this.readSemaphore = new semaphore_1.Semaphore(1);
      }
      set partialMessageTimeout(timeout) {
        this._partialMessageTimeout = timeout;
      }
      get partialMessageTimeout() {
        return this._partialMessageTimeout;
      }
      listen(callback2) {
        this.nextMessageLength = -1;
        this.messageToken = 0;
        this.partialMessageTimer = void 0;
        this.callback = callback2;
        const result = this.readable.onData((data) => {
          this.onData(data);
        });
        this.readable.onError((error) => this.fireError(error));
        this.readable.onClose(() => this.fireClose());
        return result;
      }
      onData(data) {
        try {
          this.buffer.append(data);
          while (true) {
            if (this.nextMessageLength === -1) {
              const headers = this.buffer.tryReadHeaders(true);
              if (!headers) {
                return;
              }
              const contentLength = headers.get("content-length");
              if (!contentLength) {
                this.fireError(new Error(`Header must provide a Content-Length property.
${JSON.stringify(Object.fromEntries(headers))}`));
                return;
              }
              const length = parseInt(contentLength);
              if (isNaN(length)) {
                this.fireError(new Error(`Content-Length value must be a number. Got ${contentLength}`));
                return;
              }
              this.nextMessageLength = length;
            }
            const body = this.buffer.tryReadBody(this.nextMessageLength);
            if (body === void 0) {
              this.setPartialMessageTimer();
              return;
            }
            this.clearPartialMessageTimer();
            this.nextMessageLength = -1;
            this.readSemaphore.lock(async () => {
              const bytes = this.options.contentDecoder !== void 0 ? await this.options.contentDecoder.decode(body) : body;
              const message = await this.options.contentTypeDecoder.decode(bytes, this.options);
              this.callback(message);
            }).catch((error) => {
              this.fireError(error);
            });
          }
        } catch (error) {
          this.fireError(error);
        }
      }
      clearPartialMessageTimer() {
        if (this.partialMessageTimer) {
          this.partialMessageTimer.dispose();
          this.partialMessageTimer = void 0;
        }
      }
      setPartialMessageTimer() {
        this.clearPartialMessageTimer();
        if (this._partialMessageTimeout <= 0) {
          return;
        }
        this.partialMessageTimer = (0, ral_1.default)().timer.setTimeout((token, timeout) => {
          this.partialMessageTimer = void 0;
          if (token === this.messageToken) {
            this.firePartialMessage({ messageToken: token, waitingTime: timeout });
            this.setPartialMessageTimer();
          }
        }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
      }
    };
    exports2.ReadableStreamMessageReader = ReadableStreamMessageReader;
  }
});

// ../../node_modules/@github/copilot-sdk/node_modules/vscode-jsonrpc/lib/common/messageWriter.js
var require_messageWriter2 = __commonJS({
  "../../node_modules/@github/copilot-sdk/node_modules/vscode-jsonrpc/lib/common/messageWriter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WriteableStreamMessageWriter = exports2.AbstractMessageWriter = exports2.MessageWriter = void 0;
    var ral_1 = require_ral();
    var Is = require_is2();
    var semaphore_1 = require_semaphore2();
    var events_1 = require_events2();
    var ContentLength = "Content-Length: ";
    var CRLF = "\r\n";
    var MessageWriter;
    (function(MessageWriter2) {
      function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.dispose) && Is.func(candidate.onClose) && Is.func(candidate.onError) && Is.func(candidate.write);
      }
      MessageWriter2.is = is;
    })(MessageWriter || (exports2.MessageWriter = MessageWriter = {}));
    var AbstractMessageWriter = class {
      constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
      }
      dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
      }
      get onError() {
        return this.errorEmitter.event;
      }
      fireError(error, message, count) {
        this.errorEmitter.fire([this.asError(error), message, count]);
      }
      get onClose() {
        return this.closeEmitter.event;
      }
      fireClose() {
        this.closeEmitter.fire(void 0);
      }
      asError(error) {
        if (error instanceof Error) {
          return error;
        } else {
          return new Error(`Writer received error. Reason: ${Is.string(error.message) ? error.message : "unknown"}`);
        }
      }
    };
    exports2.AbstractMessageWriter = AbstractMessageWriter;
    var ResolvedMessageWriterOptions;
    (function(ResolvedMessageWriterOptions2) {
      function fromOptions(options) {
        if (options === void 0 || typeof options === "string") {
          return { charset: options ?? "utf-8", contentTypeEncoder: (0, ral_1.default)().applicationJson.encoder };
        } else {
          return { charset: options.charset ?? "utf-8", contentEncoder: options.contentEncoder, contentTypeEncoder: options.contentTypeEncoder ?? (0, ral_1.default)().applicationJson.encoder };
        }
      }
      ResolvedMessageWriterOptions2.fromOptions = fromOptions;
    })(ResolvedMessageWriterOptions || (ResolvedMessageWriterOptions = {}));
    var WriteableStreamMessageWriter = class extends AbstractMessageWriter {
      constructor(writable, options) {
        super();
        this.writable = writable;
        this.options = ResolvedMessageWriterOptions.fromOptions(options);
        this.errorCount = 0;
        this.writeSemaphore = new semaphore_1.Semaphore(1);
        this.writable.onError((error) => this.fireError(error));
        this.writable.onClose(() => this.fireClose());
      }
      async write(msg) {
        return this.writeSemaphore.lock(async () => {
          const payload = this.options.contentTypeEncoder.encode(msg, this.options).then((buffer) => {
            if (this.options.contentEncoder !== void 0) {
              return this.options.contentEncoder.encode(buffer);
            } else {
              return buffer;
            }
          });
          return payload.then((buffer) => {
            const headers = [];
            headers.push(ContentLength, buffer.byteLength.toString(), CRLF);
            headers.push(CRLF);
            return this.doWrite(msg, headers, buffer);
          }, (error) => {
            this.fireError(error);
            throw error;
          });
        });
      }
      async doWrite(msg, headers, data) {
        try {
          await this.writable.write(headers.join(""), "ascii");
          return this.writable.write(data);
        } catch (error) {
          this.handleError(error, msg);
          return Promise.reject(error);
        }
      }
      handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
      }
      end() {
        this.writable.end();
      }
    };
    exports2.WriteableStreamMessageWriter = WriteableStreamMessageWriter;
  }
});

// ../../node_modules/@github/copilot-sdk/node_modules/vscode-jsonrpc/lib/common/messageBuffer.js
var require_messageBuffer = __commonJS({
  "../../node_modules/@github/copilot-sdk/node_modules/vscode-jsonrpc/lib/common/messageBuffer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AbstractMessageBuffer = void 0;
    var CR = 13;
    var LF = 10;
    var CRLF = "\r\n";
    var AbstractMessageBuffer = class {
      constructor(encoding = "utf-8") {
        this._encoding = encoding;
        this._chunks = [];
        this._totalLength = 0;
      }
      get encoding() {
        return this._encoding;
      }
      append(chunk) {
        const toAppend = typeof chunk === "string" ? this.fromString(chunk, this._encoding) : chunk;
        this._chunks.push(toAppend);
        this._totalLength += toAppend.byteLength;
      }
      tryReadHeaders(lowerCaseKeys = false) {
        if (this._chunks.length === 0) {
          return void 0;
        }
        let state = 0;
        let chunkIndex = 0;
        let offset = 0;
        let chunkBytesRead = 0;
        row: while (chunkIndex < this._chunks.length) {
          const chunk = this._chunks[chunkIndex];
          offset = 0;
          column: while (offset < chunk.length) {
            const value = chunk[offset];
            switch (value) {
              case CR:
                switch (state) {
                  case 0:
                    state = 1;
                    break;
                  case 2:
                    state = 3;
                    break;
                  default:
                    state = 0;
                }
                break;
              case LF:
                switch (state) {
                  case 1:
                    state = 2;
                    break;
                  case 3:
                    state = 4;
                    offset++;
                    break row;
                  default:
                    state = 0;
                }
                break;
              default:
                state = 0;
            }
            offset++;
          }
          chunkBytesRead += chunk.byteLength;
          chunkIndex++;
        }
        if (state !== 4) {
          return void 0;
        }
        const buffer = this._read(chunkBytesRead + offset);
        const result = /* @__PURE__ */ new Map();
        const headers = this.toString(buffer, "ascii").split(CRLF);
        if (headers.length < 2) {
          return result;
        }
        for (let i = 0; i < headers.length - 2; i++) {
          const header = headers[i];
          const index = header.indexOf(":");
          if (index === -1) {
            throw new Error(`Message header must separate key and value using ':'
${header}`);
          }
          const key = header.substr(0, index);
          const value = header.substr(index + 1).trim();
          result.set(lowerCaseKeys ? key.toLowerCase() : key, value);
        }
        return result;
      }
      tryReadBody(length) {
        if (this._totalLength < length) {
          return void 0;
        }
        return this._read(length);
      }
      get numberOfBytes() {
        return this._totalLength;
      }
      _read(byteCount) {
        if (byteCount === 0) {
          return this.emptyBuffer();
        }
        if (byteCount > this._totalLength) {
          throw new Error(`Cannot read so many bytes!`);
        }
        if (this._chunks[0].byteLength === byteCount) {
          const chunk = this._chunks[0];
          this._chunks.shift();
          this._totalLength -= byteCount;
          return this.asNative(chunk);
        }
        if (this._chunks[0].byteLength > byteCount) {
          const chunk = this._chunks[0];
          const result2 = this.asNative(chunk, byteCount);
          this._chunks[0] = chunk.slice(byteCount);
          this._totalLength -= byteCount;
          return result2;
        }
        const result = this.allocNative(byteCount);
        let resultOffset = 0;
        let chunkIndex = 0;
        while (byteCount > 0) {
          const chunk = this._chunks[chunkIndex];
          if (chunk.byteLength > byteCount) {
            const chunkPart = chunk.slice(0, byteCount);
            result.set(chunkPart, resultOffset);
            resultOffset += byteCount;
            this._chunks[chunkIndex] = chunk.slice(byteCount);
            this._totalLength -= byteCount;
            byteCount -= byteCount;
          } else {
            result.set(chunk, resultOffset);
            resultOffset += chunk.byteLength;
            this._chunks.shift();
            this._totalLength -= chunk.byteLength;
            byteCount -= chunk.byteLength;
          }
        }
        return result;
      }
    };
    exports2.AbstractMessageBuffer = AbstractMessageBuffer;
  }
});

// ../../node_modules/@github/copilot-sdk/node_modules/vscode-jsonrpc/lib/common/connection.js
var require_connection = __commonJS({
  "../../node_modules/@github/copilot-sdk/node_modules/vscode-jsonrpc/lib/common/connection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createMessageConnection = exports2.ConnectionOptions = exports2.MessageStrategy = exports2.CancellationStrategy = exports2.CancellationSenderStrategy = exports2.CancellationReceiverStrategy = exports2.RequestCancellationReceiverStrategy = exports2.IdCancellationReceiverStrategy = exports2.ConnectionStrategy = exports2.ConnectionError = exports2.ConnectionErrors = exports2.LogTraceNotification = exports2.SetTraceNotification = exports2.TraceFormat = exports2.TraceValues = exports2.Trace = exports2.NullLogger = exports2.ProgressType = exports2.ProgressToken = void 0;
    var ral_1 = require_ral();
    var Is = require_is2();
    var messages_1 = require_messages2();
    var linkedMap_1 = require_linkedMap2();
    var events_1 = require_events2();
    var cancellation_1 = require_cancellation3();
    var CancelNotification;
    (function(CancelNotification2) {
      CancelNotification2.type = new messages_1.NotificationType("$/cancelRequest");
    })(CancelNotification || (CancelNotification = {}));
    var ProgressToken;
    (function(ProgressToken2) {
      function is(value) {
        return typeof value === "string" || typeof value === "number";
      }
      ProgressToken2.is = is;
    })(ProgressToken || (exports2.ProgressToken = ProgressToken = {}));
    var ProgressNotification;
    (function(ProgressNotification2) {
      ProgressNotification2.type = new messages_1.NotificationType("$/progress");
    })(ProgressNotification || (ProgressNotification = {}));
    var ProgressType = class {
      constructor() {
      }
    };
    exports2.ProgressType = ProgressType;
    var StarRequestHandler;
    (function(StarRequestHandler2) {
      function is(value) {
        return Is.func(value);
      }
      StarRequestHandler2.is = is;
    })(StarRequestHandler || (StarRequestHandler = {}));
    exports2.NullLogger = Object.freeze({
      error: () => {
      },
      warn: () => {
      },
      info: () => {
      },
      log: () => {
      }
    });
    var Trace;
    (function(Trace2) {
      Trace2[Trace2["Off"] = 0] = "Off";
      Trace2[Trace2["Messages"] = 1] = "Messages";
      Trace2[Trace2["Compact"] = 2] = "Compact";
      Trace2[Trace2["Verbose"] = 3] = "Verbose";
    })(Trace || (exports2.Trace = Trace = {}));
    var TraceValues;
    (function(TraceValues2) {
      TraceValues2.Off = "off";
      TraceValues2.Messages = "messages";
      TraceValues2.Compact = "compact";
      TraceValues2.Verbose = "verbose";
    })(TraceValues || (exports2.TraceValues = TraceValues = {}));
    (function(Trace2) {
      function fromString(value) {
        if (!Is.string(value)) {
          return Trace2.Off;
        }
        value = value.toLowerCase();
        switch (value) {
          case "off":
            return Trace2.Off;
          case "messages":
            return Trace2.Messages;
          case "compact":
            return Trace2.Compact;
          case "verbose":
            return Trace2.Verbose;
          default:
            return Trace2.Off;
        }
      }
      Trace2.fromString = fromString;
      function toString(value) {
        switch (value) {
          case Trace2.Off:
            return "off";
          case Trace2.Messages:
            return "messages";
          case Trace2.Compact:
            return "compact";
          case Trace2.Verbose:
            return "verbose";
          default:
            return "off";
        }
      }
      Trace2.toString = toString;
    })(Trace || (exports2.Trace = Trace = {}));
    var TraceFormat;
    (function(TraceFormat2) {
      TraceFormat2["Text"] = "text";
      TraceFormat2["JSON"] = "json";
    })(TraceFormat || (exports2.TraceFormat = TraceFormat = {}));
    (function(TraceFormat2) {
      function fromString(value) {
        if (!Is.string(value)) {
          return TraceFormat2.Text;
        }
        value = value.toLowerCase();
        if (value === "json") {
          return TraceFormat2.JSON;
        } else {
          return TraceFormat2.Text;
        }
      }
      TraceFormat2.fromString = fromString;
    })(TraceFormat || (exports2.TraceFormat = TraceFormat = {}));
    var SetTraceNotification;
    (function(SetTraceNotification2) {
      SetTraceNotification2.type = new messages_1.NotificationType("$/setTrace");
    })(SetTraceNotification || (exports2.SetTraceNotification = SetTraceNotification = {}));
    var LogTraceNotification;
    (function(LogTraceNotification2) {
      LogTraceNotification2.type = new messages_1.NotificationType("$/logTrace");
    })(LogTraceNotification || (exports2.LogTraceNotification = LogTraceNotification = {}));
    var ConnectionErrors;
    (function(ConnectionErrors2) {
      ConnectionErrors2[ConnectionErrors2["Closed"] = 1] = "Closed";
      ConnectionErrors2[ConnectionErrors2["Disposed"] = 2] = "Disposed";
      ConnectionErrors2[ConnectionErrors2["AlreadyListening"] = 3] = "AlreadyListening";
    })(ConnectionErrors || (exports2.ConnectionErrors = ConnectionErrors = {}));
    var ConnectionError = class _ConnectionError extends Error {
      constructor(code, message) {
        super(message);
        this.code = code;
        Object.setPrototypeOf(this, _ConnectionError.prototype);
      }
    };
    exports2.ConnectionError = ConnectionError;
    var ConnectionStrategy;
    (function(ConnectionStrategy2) {
      function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.cancelUndispatched);
      }
      ConnectionStrategy2.is = is;
    })(ConnectionStrategy || (exports2.ConnectionStrategy = ConnectionStrategy = {}));
    var IdCancellationReceiverStrategy;
    (function(IdCancellationReceiverStrategy2) {
      function is(value) {
        const candidate = value;
        return candidate && (candidate.kind === void 0 || candidate.kind === "id") && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === void 0 || Is.func(candidate.dispose));
      }
      IdCancellationReceiverStrategy2.is = is;
    })(IdCancellationReceiverStrategy || (exports2.IdCancellationReceiverStrategy = IdCancellationReceiverStrategy = {}));
    var RequestCancellationReceiverStrategy;
    (function(RequestCancellationReceiverStrategy2) {
      function is(value) {
        const candidate = value;
        return candidate && candidate.kind === "request" && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === void 0 || Is.func(candidate.dispose));
      }
      RequestCancellationReceiverStrategy2.is = is;
    })(RequestCancellationReceiverStrategy || (exports2.RequestCancellationReceiverStrategy = RequestCancellationReceiverStrategy = {}));
    var CancellationReceiverStrategy;
    (function(CancellationReceiverStrategy2) {
      CancellationReceiverStrategy2.Message = Object.freeze({
        createCancellationTokenSource(_) {
          return new cancellation_1.CancellationTokenSource();
        }
      });
      function is(value) {
        return IdCancellationReceiverStrategy.is(value) || RequestCancellationReceiverStrategy.is(value);
      }
      CancellationReceiverStrategy2.is = is;
    })(CancellationReceiverStrategy || (exports2.CancellationReceiverStrategy = CancellationReceiverStrategy = {}));
    var CancellationSenderStrategy;
    (function(CancellationSenderStrategy2) {
      CancellationSenderStrategy2.Message = Object.freeze({
        sendCancellation(conn, id) {
          return conn.sendNotification(CancelNotification.type, { id });
        },
        cleanup(_) {
        }
      });
      function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.sendCancellation) && Is.func(candidate.cleanup);
      }
      CancellationSenderStrategy2.is = is;
    })(CancellationSenderStrategy || (exports2.CancellationSenderStrategy = CancellationSenderStrategy = {}));
    var CancellationStrategy;
    (function(CancellationStrategy2) {
      CancellationStrategy2.Message = Object.freeze({
        receiver: CancellationReceiverStrategy.Message,
        sender: CancellationSenderStrategy.Message
      });
      function is(value) {
        const candidate = value;
        return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);
      }
      CancellationStrategy2.is = is;
    })(CancellationStrategy || (exports2.CancellationStrategy = CancellationStrategy = {}));
    var MessageStrategy;
    (function(MessageStrategy2) {
      function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.handleMessage);
      }
      MessageStrategy2.is = is;
    })(MessageStrategy || (exports2.MessageStrategy = MessageStrategy = {}));
    var ConnectionOptions;
    (function(ConnectionOptions2) {
      function is(value) {
        const candidate = value;
        return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy) || MessageStrategy.is(candidate.messageStrategy));
      }
      ConnectionOptions2.is = is;
    })(ConnectionOptions || (exports2.ConnectionOptions = ConnectionOptions = {}));
    var ConnectionState;
    (function(ConnectionState2) {
      ConnectionState2[ConnectionState2["New"] = 1] = "New";
      ConnectionState2[ConnectionState2["Listening"] = 2] = "Listening";
      ConnectionState2[ConnectionState2["Closed"] = 3] = "Closed";
      ConnectionState2[ConnectionState2["Disposed"] = 4] = "Disposed";
    })(ConnectionState || (ConnectionState = {}));
    function createMessageConnection2(messageReader, messageWriter, _logger, options) {
      const logger = _logger !== void 0 ? _logger : exports2.NullLogger;
      let sequenceNumber = 0;
      let notificationSequenceNumber = 0;
      let unknownResponseSequenceNumber = 0;
      const version = "2.0";
      let starRequestHandler = void 0;
      const requestHandlers = /* @__PURE__ */ new Map();
      let starNotificationHandler = void 0;
      const notificationHandlers = /* @__PURE__ */ new Map();
      const progressHandlers = /* @__PURE__ */ new Map();
      let timer;
      let messageQueue = new linkedMap_1.LinkedMap();
      let responsePromises = /* @__PURE__ */ new Map();
      let knownCanceledRequests = /* @__PURE__ */ new Set();
      let requestTokens = /* @__PURE__ */ new Map();
      let trace = Trace.Off;
      let traceFormat = TraceFormat.Text;
      let tracer;
      let state = ConnectionState.New;
      const errorEmitter = new events_1.Emitter();
      const closeEmitter = new events_1.Emitter();
      const unhandledNotificationEmitter = new events_1.Emitter();
      const unhandledProgressEmitter = new events_1.Emitter();
      const disposeEmitter = new events_1.Emitter();
      const cancellationStrategy = options && options.cancellationStrategy ? options.cancellationStrategy : CancellationStrategy.Message;
      function createRequestQueueKey(id) {
        if (id === null) {
          throw new Error(`Can't send requests with id null since the response can't be correlated.`);
        }
        return "req-" + id.toString();
      }
      function createResponseQueueKey(id) {
        if (id === null) {
          return "res-unknown-" + (++unknownResponseSequenceNumber).toString();
        } else {
          return "res-" + id.toString();
        }
      }
      function createNotificationQueueKey() {
        return "not-" + (++notificationSequenceNumber).toString();
      }
      function addMessageToQueue(queue, message) {
        if (messages_1.Message.isRequest(message)) {
          queue.set(createRequestQueueKey(message.id), message);
        } else if (messages_1.Message.isResponse(message)) {
          queue.set(createResponseQueueKey(message.id), message);
        } else {
          queue.set(createNotificationQueueKey(), message);
        }
      }
      function cancelUndispatched(_message) {
        return void 0;
      }
      function isListening() {
        return state === ConnectionState.Listening;
      }
      function isClosed() {
        return state === ConnectionState.Closed;
      }
      function isDisposed() {
        return state === ConnectionState.Disposed;
      }
      function closeHandler() {
        if (state === ConnectionState.New || state === ConnectionState.Listening) {
          state = ConnectionState.Closed;
          closeEmitter.fire(void 0);
        }
      }
      function readErrorHandler(error) {
        errorEmitter.fire([error, void 0, void 0]);
      }
      function writeErrorHandler(data) {
        errorEmitter.fire(data);
      }
      messageReader.onClose(closeHandler);
      messageReader.onError(readErrorHandler);
      messageWriter.onClose(closeHandler);
      messageWriter.onError(writeErrorHandler);
      function triggerMessageQueue() {
        if (timer || messageQueue.size === 0) {
          return;
        }
        timer = (0, ral_1.default)().timer.setImmediate(() => {
          timer = void 0;
          processMessageQueue();
        });
      }
      function handleMessage(message) {
        if (messages_1.Message.isRequest(message)) {
          handleRequest(message);
        } else if (messages_1.Message.isNotification(message)) {
          handleNotification(message);
        } else if (messages_1.Message.isResponse(message)) {
          handleResponse(message);
        } else {
          handleInvalidMessage(message);
        }
      }
      function processMessageQueue() {
        if (messageQueue.size === 0) {
          return;
        }
        const message = messageQueue.shift();
        try {
          const messageStrategy = options?.messageStrategy;
          if (MessageStrategy.is(messageStrategy)) {
            messageStrategy.handleMessage(message, handleMessage);
          } else {
            handleMessage(message);
          }
        } finally {
          triggerMessageQueue();
        }
      }
      const callback2 = (message) => {
        try {
          if (messages_1.Message.isNotification(message) && message.method === CancelNotification.type.method) {
            const cancelId = message.params.id;
            const key = createRequestQueueKey(cancelId);
            const toCancel = messageQueue.get(key);
            if (messages_1.Message.isRequest(toCancel)) {
              const strategy = options?.connectionStrategy;
              const response = strategy && strategy.cancelUndispatched ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
              if (response && (response.error !== void 0 || response.result !== void 0)) {
                messageQueue.delete(key);
                requestTokens.delete(cancelId);
                response.id = toCancel.id;
                traceSendingResponse(response, message.method, Date.now());
                messageWriter.write(response).catch(() => logger.error(`Sending response for canceled message failed.`));
                return;
              }
            }
            const cancellationToken = requestTokens.get(cancelId);
            if (cancellationToken !== void 0) {
              cancellationToken.cancel();
              traceReceivedNotification(message);
              return;
            } else {
              knownCanceledRequests.add(cancelId);
            }
          }
          addMessageToQueue(messageQueue, message);
        } finally {
          triggerMessageQueue();
        }
      };
      function handleRequest(requestMessage) {
        if (isDisposed()) {
          return;
        }
        function reply(resultOrError, method, startTime2) {
          const message = {
            jsonrpc: version,
            id: requestMessage.id
          };
          if (resultOrError instanceof messages_1.ResponseError) {
            message.error = resultOrError.toJson();
          } else {
            message.result = resultOrError === void 0 ? null : resultOrError;
          }
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
        }
        function replyError(error, method, startTime2) {
          const message = {
            jsonrpc: version,
            id: requestMessage.id,
            error: error.toJson()
          };
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
        }
        function replySuccess(result, method, startTime2) {
          if (result === void 0) {
            result = null;
          }
          const message = {
            jsonrpc: version,
            id: requestMessage.id,
            result
          };
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
        }
        traceReceivedRequest(requestMessage);
        const element = requestHandlers.get(requestMessage.method);
        let type;
        let requestHandler;
        if (element) {
          type = element.type;
          requestHandler = element.handler;
        }
        const startTime = Date.now();
        if (requestHandler || starRequestHandler) {
          const tokenKey = requestMessage.id ?? String(Date.now());
          const cancellationSource = IdCancellationReceiverStrategy.is(cancellationStrategy.receiver) ? cancellationStrategy.receiver.createCancellationTokenSource(tokenKey) : cancellationStrategy.receiver.createCancellationTokenSource(requestMessage);
          if (requestMessage.id !== null && knownCanceledRequests.has(requestMessage.id)) {
            cancellationSource.cancel();
          }
          if (requestMessage.id !== null) {
            requestTokens.set(tokenKey, cancellationSource);
          }
          try {
            let handlerResult;
            if (requestHandler) {
              if (requestMessage.params === void 0) {
                if (type !== void 0 && type.numberOfParams !== 0) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but received none.`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(cancellationSource.token);
              } else if (Array.isArray(requestMessage.params)) {
                if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byName) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);
              } else {
                if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(requestMessage.params, cancellationSource.token);
              }
            } else if (starRequestHandler) {
              handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
            }
            const promise2 = handlerResult;
            if (!handlerResult) {
              requestTokens.delete(tokenKey);
              replySuccess(handlerResult, requestMessage.method, startTime);
            } else if (promise2.then) {
              promise2.then((resultOrError) => {
                requestTokens.delete(tokenKey);
                reply(resultOrError, requestMessage.method, startTime);
              }, (error) => {
                requestTokens.delete(tokenKey);
                if (error instanceof messages_1.ResponseError) {
                  replyError(error, requestMessage.method, startTime);
                } else if (error && Is.string(error.message)) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                } else {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                }
              });
            } else {
              requestTokens.delete(tokenKey);
              reply(handlerResult, requestMessage.method, startTime);
            }
          } catch (error) {
            requestTokens.delete(tokenKey);
            if (error instanceof messages_1.ResponseError) {
              reply(error, requestMessage.method, startTime);
            } else if (error && Is.string(error.message)) {
              replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
            } else {
              replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
            }
          }
        } else {
          replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
        }
      }
      function handleResponse(responseMessage) {
        if (isDisposed()) {
          return;
        }
        if (responseMessage.id === null) {
          if (responseMessage.error) {
            logger.error(`Received response message without id: Error is: 
${JSON.stringify(responseMessage.error, void 0, 4)}`);
          } else {
            logger.error(`Received response message without id. No further error information provided.`);
          }
        } else {
          const key = responseMessage.id;
          const responsePromise = responsePromises.get(key);
          traceReceivedResponse(responseMessage, responsePromise);
          if (responsePromise !== void 0) {
            responsePromises.delete(key);
            try {
              if (responseMessage.error) {
                const error = responseMessage.error;
                responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
              } else if (responseMessage.result !== void 0) {
                responsePromise.resolve(responseMessage.result);
              } else {
                throw new Error("Should never happen.");
              }
            } catch (error) {
              if (error.message) {
                logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
              } else {
                logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
              }
            }
          }
        }
      }
      function handleNotification(message) {
        if (isDisposed()) {
          return;
        }
        let type = void 0;
        let notificationHandler;
        if (message.method === CancelNotification.type.method) {
          const cancelId = message.params.id;
          knownCanceledRequests.delete(cancelId);
          traceReceivedNotification(message);
          return;
        } else {
          const element = notificationHandlers.get(message.method);
          if (element) {
            notificationHandler = element.handler;
            type = element.type;
          }
        }
        if (notificationHandler || starNotificationHandler) {
          try {
            traceReceivedNotification(message);
            if (notificationHandler) {
              if (message.params === void 0) {
                if (type !== void 0) {
                  if (type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName) {
                    logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received none.`);
                  }
                }
                notificationHandler();
              } else if (Array.isArray(message.params)) {
                const params = message.params;
                if (message.method === ProgressNotification.type.method && params.length === 2 && ProgressToken.is(params[0])) {
                  notificationHandler({ token: params[0], value: params[1] });
                } else {
                  if (type !== void 0) {
                    if (type.parameterStructures === messages_1.ParameterStructures.byName) {
                      logger.error(`Notification ${message.method} defines parameters by name but received parameters by position`);
                    }
                    if (type.numberOfParams !== message.params.length) {
                      logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received ${params.length} arguments`);
                    }
                  }
                  notificationHandler(...params);
                }
              } else {
                if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                  logger.error(`Notification ${message.method} defines parameters by position but received parameters by name`);
                }
                notificationHandler(message.params);
              }
            } else if (starNotificationHandler) {
              starNotificationHandler(message.method, message.params);
            }
          } catch (error) {
            if (error.message) {
              logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
            } else {
              logger.error(`Notification handler '${message.method}' failed unexpectedly.`);
            }
          }
        } else {
          unhandledNotificationEmitter.fire(message);
        }
      }
      function handleInvalidMessage(message) {
        if (!message) {
          logger.error("Received empty message.");
          return;
        }
        logger.error(`Received message which is neither a response nor a notification message:
${JSON.stringify(message, null, 4)}`);
        const responseMessage = message;
        if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {
          const key = responseMessage.id;
          const responseHandler = responsePromises.get(key);
          if (responseHandler) {
            responseHandler.reject(new Error("The received response has neither a result nor an error property."));
          }
        }
      }
      function stringifyTrace(params) {
        if (params === void 0 || params === null) {
          return void 0;
        }
        switch (trace) {
          case Trace.Verbose:
            return JSON.stringify(params, null, 4);
          case Trace.Compact:
            return JSON.stringify(params);
          default:
            return void 0;
        }
      }
      function traceSendingRequest(message) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
            data = `Params: ${stringifyTrace(message.params)}

`;
          }
          tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
        } else {
          logLSPMessage("send-request", message);
        }
      }
      function traceSendingNotification(message) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose || trace === Trace.Compact) {
            if (message.params) {
              data = `Params: ${stringifyTrace(message.params)}

`;
            } else {
              data = "No parameters provided.\n\n";
            }
          }
          tracer.log(`Sending notification '${message.method}'.`, data);
        } else {
          logLSPMessage("send-notification", message);
        }
      }
      function traceSendingResponse(message, method, startTime) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose || trace === Trace.Compact) {
            if (message.error && message.error.data) {
              data = `Error data: ${stringifyTrace(message.error.data)}

`;
            } else {
              if (message.result) {
                data = `Result: ${stringifyTrace(message.result)}

`;
              } else if (message.error === void 0) {
                data = "No result returned.\n\n";
              }
            }
          }
          tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
        } else {
          logLSPMessage("send-response", message);
        }
      }
      function traceReceivedRequest(message) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
            data = `Params: ${stringifyTrace(message.params)}

`;
          }
          tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
        } else {
          logLSPMessage("receive-request", message);
        }
      }
      function traceReceivedNotification(message) {
        if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose || trace === Trace.Compact) {
            if (message.params) {
              data = `Params: ${stringifyTrace(message.params)}

`;
            } else {
              data = "No parameters provided.\n\n";
            }
          }
          tracer.log(`Received notification '${message.method}'.`, data);
        } else {
          logLSPMessage("receive-notification", message);
        }
      }
      function traceReceivedResponse(message, responsePromise) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose || trace === Trace.Compact) {
            if (message.error && message.error.data) {
              data = `Error data: ${stringifyTrace(message.error.data)}

`;
            } else {
              if (message.result) {
                data = `Result: ${stringifyTrace(message.result)}

`;
              } else if (message.error === void 0) {
                data = "No result returned.\n\n";
              }
            }
          }
          if (responsePromise) {
            const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : "";
            tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
          } else {
            tracer.log(`Received response ${message.id} without active response promise.`, data);
          }
        } else {
          logLSPMessage("receive-response", message);
        }
      }
      function logLSPMessage(type, message) {
        if (!tracer || trace === Trace.Off) {
          return;
        }
        const lspMessage = {
          isLSPMessage: true,
          type,
          message,
          timestamp: Date.now()
        };
        tracer.log(lspMessage);
      }
      function throwIfClosedOrDisposed() {
        if (isClosed()) {
          throw new ConnectionError(ConnectionErrors.Closed, "Connection is closed.");
        }
        if (isDisposed()) {
          throw new ConnectionError(ConnectionErrors.Disposed, "Connection is disposed.");
        }
      }
      function throwIfListening() {
        if (isListening()) {
          throw new ConnectionError(ConnectionErrors.AlreadyListening, "Connection is already listening");
        }
      }
      function throwIfNotListening() {
        if (!isListening()) {
          throw new Error("Call listen() first.");
        }
      }
      function undefinedToNull(param) {
        if (param === void 0) {
          return null;
        } else {
          return param;
        }
      }
      function nullToUndefined(param) {
        if (param === null) {
          return void 0;
        } else {
          return param;
        }
      }
      function isNamedParam(param) {
        return param !== void 0 && param !== null && !Array.isArray(param) && typeof param === "object";
      }
      function computeSingleParam(parameterStructures, param) {
        switch (parameterStructures) {
          case messages_1.ParameterStructures.auto:
            if (isNamedParam(param)) {
              return nullToUndefined(param);
            } else {
              return [undefinedToNull(param)];
            }
          case messages_1.ParameterStructures.byName:
            if (!isNamedParam(param)) {
              throw new Error(`Received parameters by name but param is not an object literal.`);
            }
            return nullToUndefined(param);
          case messages_1.ParameterStructures.byPosition:
            return [undefinedToNull(param)];
          default:
            throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);
        }
      }
      function computeMessageParams(type, params) {
        let result;
        const numberOfParams = type.numberOfParams;
        switch (numberOfParams) {
          case 0:
            result = void 0;
            break;
          case 1:
            result = computeSingleParam(type.parameterStructures, params[0]);
            break;
          default:
            result = [];
            for (let i = 0; i < params.length && i < numberOfParams; i++) {
              result.push(undefinedToNull(params[i]));
            }
            if (params.length < numberOfParams) {
              for (let i = params.length; i < numberOfParams; i++) {
                result.push(null);
              }
            }
            break;
        }
        return result;
      }
      const connection = {
        sendNotification: (type, ...args) => {
          throwIfClosedOrDisposed();
          let method;
          let messageParams;
          if (Is.string(type)) {
            method = type;
            const first = args[0];
            let paramStart = 0;
            let parameterStructures = messages_1.ParameterStructures.auto;
            if (messages_1.ParameterStructures.is(first)) {
              paramStart = 1;
              parameterStructures = first;
            }
            let paramEnd = args.length;
            const numberOfParams = paramEnd - paramStart;
            switch (numberOfParams) {
              case 0:
                messageParams = void 0;
                break;
              case 1:
                messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                break;
              default:
                if (parameterStructures === messages_1.ParameterStructures.byName) {
                  throw new Error(`Received ${numberOfParams} parameters for 'by Name' notification parameter structure.`);
                }
                messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
                break;
            }
          } else {
            const params = args;
            method = type.method;
            messageParams = computeMessageParams(type, params);
          }
          const notificationMessage = {
            jsonrpc: version,
            method,
            params: messageParams
          };
          traceSendingNotification(notificationMessage);
          return messageWriter.write(notificationMessage).catch((error) => {
            logger.error(`Sending notification failed.`);
            throw error;
          });
        },
        onNotification: (type, handler) => {
          throwIfClosedOrDisposed();
          let method;
          if (Is.func(type)) {
            starNotificationHandler = type;
          } else if (handler) {
            if (Is.string(type)) {
              method = type;
              notificationHandlers.set(type, { type: void 0, handler });
            } else {
              method = type.method;
              notificationHandlers.set(type.method, { type, handler });
            }
          }
          return {
            dispose: () => {
              if (method !== void 0) {
                notificationHandlers.delete(method);
              } else {
                starNotificationHandler = void 0;
              }
            }
          };
        },
        onProgress: (_type, token, handler) => {
          if (progressHandlers.has(token)) {
            throw new Error(`Progress handler for token ${token} already registered`);
          }
          progressHandlers.set(token, handler);
          return {
            dispose: () => {
              progressHandlers.delete(token);
            }
          };
        },
        sendProgress: (_type, token, value) => {
          return connection.sendNotification(ProgressNotification.type, { token, value });
        },
        onUnhandledProgress: unhandledProgressEmitter.event,
        sendRequest: (type, ...args) => {
          throwIfClosedOrDisposed();
          throwIfNotListening();
          let method;
          let messageParams;
          let token = void 0;
          if (Is.string(type)) {
            method = type;
            const first = args[0];
            const last = args[args.length - 1];
            let paramStart = 0;
            let parameterStructures = messages_1.ParameterStructures.auto;
            if (messages_1.ParameterStructures.is(first)) {
              paramStart = 1;
              parameterStructures = first;
            }
            let paramEnd = args.length;
            if (cancellation_1.CancellationToken.is(last)) {
              paramEnd = paramEnd - 1;
              token = last;
            }
            const numberOfParams = paramEnd - paramStart;
            switch (numberOfParams) {
              case 0:
                messageParams = void 0;
                break;
              case 1:
                messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                break;
              default:
                if (parameterStructures === messages_1.ParameterStructures.byName) {
                  throw new Error(`Received ${numberOfParams} parameters for 'by Name' request parameter structure.`);
                }
                messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
                break;
            }
          } else {
            const params = args;
            method = type.method;
            messageParams = computeMessageParams(type, params);
            const numberOfParams = type.numberOfParams;
            token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : void 0;
          }
          const id = sequenceNumber++;
          let disposable;
          if (token) {
            disposable = token.onCancellationRequested(() => {
              const p = cancellationStrategy.sender.sendCancellation(connection, id);
              if (p === void 0) {
                logger.log(`Received no promise from cancellation strategy when cancelling id ${id}`);
                return Promise.resolve();
              } else {
                return p.catch(() => {
                  logger.log(`Sending cancellation messages for id ${id} failed`);
                });
              }
            });
          }
          const requestMessage = {
            jsonrpc: version,
            id,
            method,
            params: messageParams
          };
          traceSendingRequest(requestMessage);
          if (typeof cancellationStrategy.sender.enableCancellation === "function") {
            cancellationStrategy.sender.enableCancellation(requestMessage);
          }
          return new Promise(async (resolve3, reject) => {
            const resolveWithCleanup = (r) => {
              resolve3(r);
              cancellationStrategy.sender.cleanup(id);
              disposable?.dispose();
            };
            const rejectWithCleanup = (r) => {
              reject(r);
              cancellationStrategy.sender.cleanup(id);
              disposable?.dispose();
            };
            const responsePromise = { method, timerStart: Date.now(), resolve: resolveWithCleanup, reject: rejectWithCleanup };
            try {
              responsePromises.set(id, responsePromise);
              await messageWriter.write(requestMessage);
            } catch (error) {
              responsePromises.delete(id);
              responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, error.message ? error.message : "Unknown reason"));
              logger.error(`Sending request failed.`);
              throw error;
            }
          });
        },
        onRequest: (type, handler) => {
          throwIfClosedOrDisposed();
          let method = null;
          if (StarRequestHandler.is(type)) {
            method = void 0;
            starRequestHandler = type;
          } else if (Is.string(type)) {
            method = null;
            if (handler !== void 0) {
              method = type;
              requestHandlers.set(type, { handler, type: void 0 });
            }
          } else {
            if (handler !== void 0) {
              method = type.method;
              requestHandlers.set(type.method, { type, handler });
            }
          }
          return {
            dispose: () => {
              if (method === null) {
                return;
              }
              if (method !== void 0) {
                requestHandlers.delete(method);
              } else {
                starRequestHandler = void 0;
              }
            }
          };
        },
        hasPendingResponse: () => {
          return responsePromises.size > 0;
        },
        trace: async (_value, _tracer, sendNotificationOrTraceOptions) => {
          let _sendNotification = false;
          let _traceFormat = TraceFormat.Text;
          if (sendNotificationOrTraceOptions !== void 0) {
            if (Is.boolean(sendNotificationOrTraceOptions)) {
              _sendNotification = sendNotificationOrTraceOptions;
            } else {
              _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
              _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;
            }
          }
          trace = _value;
          traceFormat = _traceFormat;
          if (trace === Trace.Off) {
            tracer = void 0;
          } else {
            tracer = _tracer;
          }
          if (_sendNotification && !isClosed() && !isDisposed()) {
            await connection.sendNotification(SetTraceNotification.type, { value: Trace.toString(_value) });
          }
        },
        onError: errorEmitter.event,
        onClose: closeEmitter.event,
        onUnhandledNotification: unhandledNotificationEmitter.event,
        onDispose: disposeEmitter.event,
        end: () => {
          messageWriter.end();
        },
        dispose: () => {
          if (isDisposed()) {
            return;
          }
          state = ConnectionState.Disposed;
          disposeEmitter.fire(void 0);
          const error = new messages_1.ResponseError(messages_1.ErrorCodes.PendingResponseRejected, "Pending response rejected since connection got disposed");
          for (const promise2 of responsePromises.values()) {
            promise2.reject(error);
          }
          responsePromises = /* @__PURE__ */ new Map();
          requestTokens = /* @__PURE__ */ new Map();
          knownCanceledRequests = /* @__PURE__ */ new Set();
          messageQueue = new linkedMap_1.LinkedMap();
          if (Is.func(messageWriter.dispose)) {
            messageWriter.dispose();
          }
          if (Is.func(messageReader.dispose)) {
            messageReader.dispose();
          }
        },
        listen: () => {
          throwIfClosedOrDisposed();
          throwIfListening();
          state = ConnectionState.Listening;
          messageReader.listen(callback2);
        },
        inspect: () => {
          (0, ral_1.default)().console.log("inspect");
        }
      };
      connection.onNotification(LogTraceNotification.type, (params) => {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        const verbose = trace === Trace.Verbose || trace === Trace.Compact;
        tracer.log(params.message, verbose ? params.verbose : void 0);
      });
      connection.onNotification(ProgressNotification.type, (params) => {
        const handler = progressHandlers.get(params.token);
        if (handler) {
          handler(params.value);
        } else {
          unhandledProgressEmitter.fire(params);
        }
      });
      return connection;
    }
    exports2.createMessageConnection = createMessageConnection2;
  }
});

// ../../node_modules/@github/copilot-sdk/node_modules/vscode-jsonrpc/lib/common/api.js
var require_api = __commonJS({
  "../../node_modules/@github/copilot-sdk/node_modules/vscode-jsonrpc/lib/common/api.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProgressType = exports2.ProgressToken = exports2.createMessageConnection = exports2.NullLogger = exports2.ConnectionOptions = exports2.ConnectionStrategy = exports2.AbstractMessageBuffer = exports2.WriteableStreamMessageWriter = exports2.AbstractMessageWriter = exports2.MessageWriter = exports2.ReadableStreamMessageReader = exports2.AbstractMessageReader = exports2.MessageReader = exports2.SharedArrayReceiverStrategy = exports2.SharedArraySenderStrategy = exports2.CancellationToken = exports2.CancellationTokenSource = exports2.Emitter = exports2.Event = exports2.Disposable = exports2.LRUCache = exports2.Touch = exports2.LinkedMap = exports2.ParameterStructures = exports2.NotificationType9 = exports2.NotificationType8 = exports2.NotificationType7 = exports2.NotificationType6 = exports2.NotificationType5 = exports2.NotificationType4 = exports2.NotificationType3 = exports2.NotificationType2 = exports2.NotificationType1 = exports2.NotificationType0 = exports2.NotificationType = exports2.ErrorCodes = exports2.ResponseError = exports2.RequestType9 = exports2.RequestType8 = exports2.RequestType7 = exports2.RequestType6 = exports2.RequestType5 = exports2.RequestType4 = exports2.RequestType3 = exports2.RequestType2 = exports2.RequestType1 = exports2.RequestType0 = exports2.RequestType = exports2.Message = exports2.RAL = void 0;
    exports2.MessageStrategy = exports2.CancellationStrategy = exports2.CancellationSenderStrategy = exports2.CancellationReceiverStrategy = exports2.ConnectionError = exports2.ConnectionErrors = exports2.LogTraceNotification = exports2.SetTraceNotification = exports2.TraceFormat = exports2.TraceValues = exports2.Trace = void 0;
    var messages_1 = require_messages2();
    Object.defineProperty(exports2, "Message", { enumerable: true, get: function() {
      return messages_1.Message;
    } });
    Object.defineProperty(exports2, "RequestType", { enumerable: true, get: function() {
      return messages_1.RequestType;
    } });
    Object.defineProperty(exports2, "RequestType0", { enumerable: true, get: function() {
      return messages_1.RequestType0;
    } });
    Object.defineProperty(exports2, "RequestType1", { enumerable: true, get: function() {
      return messages_1.RequestType1;
    } });
    Object.defineProperty(exports2, "RequestType2", { enumerable: true, get: function() {
      return messages_1.RequestType2;
    } });
    Object.defineProperty(exports2, "RequestType3", { enumerable: true, get: function() {
      return messages_1.RequestType3;
    } });
    Object.defineProperty(exports2, "RequestType4", { enumerable: true, get: function() {
      return messages_1.RequestType4;
    } });
    Object.defineProperty(exports2, "RequestType5", { enumerable: true, get: function() {
      return messages_1.RequestType5;
    } });
    Object.defineProperty(exports2, "RequestType6", { enumerable: true, get: function() {
      return messages_1.RequestType6;
    } });
    Object.defineProperty(exports2, "RequestType7", { enumerable: true, get: function() {
      return messages_1.RequestType7;
    } });
    Object.defineProperty(exports2, "RequestType8", { enumerable: true, get: function() {
      return messages_1.RequestType8;
    } });
    Object.defineProperty(exports2, "RequestType9", { enumerable: true, get: function() {
      return messages_1.RequestType9;
    } });
    Object.defineProperty(exports2, "ResponseError", { enumerable: true, get: function() {
      return messages_1.ResponseError;
    } });
    Object.defineProperty(exports2, "ErrorCodes", { enumerable: true, get: function() {
      return messages_1.ErrorCodes;
    } });
    Object.defineProperty(exports2, "NotificationType", { enumerable: true, get: function() {
      return messages_1.NotificationType;
    } });
    Object.defineProperty(exports2, "NotificationType0", { enumerable: true, get: function() {
      return messages_1.NotificationType0;
    } });
    Object.defineProperty(exports2, "NotificationType1", { enumerable: true, get: function() {
      return messages_1.NotificationType1;
    } });
    Object.defineProperty(exports2, "NotificationType2", { enumerable: true, get: function() {
      return messages_1.NotificationType2;
    } });
    Object.defineProperty(exports2, "NotificationType3", { enumerable: true, get: function() {
      return messages_1.NotificationType3;
    } });
    Object.defineProperty(exports2, "NotificationType4", { enumerable: true, get: function() {
      return messages_1.NotificationType4;
    } });
    Object.defineProperty(exports2, "NotificationType5", { enumerable: true, get: function() {
      return messages_1.NotificationType5;
    } });
    Object.defineProperty(exports2, "NotificationType6", { enumerable: true, get: function() {
      return messages_1.NotificationType6;
    } });
    Object.defineProperty(exports2, "NotificationType7", { enumerable: true, get: function() {
      return messages_1.NotificationType7;
    } });
    Object.defineProperty(exports2, "NotificationType8", { enumerable: true, get: function() {
      return messages_1.NotificationType8;
    } });
    Object.defineProperty(exports2, "NotificationType9", { enumerable: true, get: function() {
      return messages_1.NotificationType9;
    } });
    Object.defineProperty(exports2, "ParameterStructures", { enumerable: true, get: function() {
      return messages_1.ParameterStructures;
    } });
    var linkedMap_1 = require_linkedMap2();
    Object.defineProperty(exports2, "LinkedMap", { enumerable: true, get: function() {
      return linkedMap_1.LinkedMap;
    } });
    Object.defineProperty(exports2, "LRUCache", { enumerable: true, get: function() {
      return linkedMap_1.LRUCache;
    } });
    Object.defineProperty(exports2, "Touch", { enumerable: true, get: function() {
      return linkedMap_1.Touch;
    } });
    var disposable_1 = require_disposable();
    Object.defineProperty(exports2, "Disposable", { enumerable: true, get: function() {
      return disposable_1.Disposable;
    } });
    var events_1 = require_events2();
    Object.defineProperty(exports2, "Event", { enumerable: true, get: function() {
      return events_1.Event;
    } });
    Object.defineProperty(exports2, "Emitter", { enumerable: true, get: function() {
      return events_1.Emitter;
    } });
    var cancellation_1 = require_cancellation3();
    Object.defineProperty(exports2, "CancellationTokenSource", { enumerable: true, get: function() {
      return cancellation_1.CancellationTokenSource;
    } });
    Object.defineProperty(exports2, "CancellationToken", { enumerable: true, get: function() {
      return cancellation_1.CancellationToken;
    } });
    var sharedArrayCancellation_1 = require_sharedArrayCancellation();
    Object.defineProperty(exports2, "SharedArraySenderStrategy", { enumerable: true, get: function() {
      return sharedArrayCancellation_1.SharedArraySenderStrategy;
    } });
    Object.defineProperty(exports2, "SharedArrayReceiverStrategy", { enumerable: true, get: function() {
      return sharedArrayCancellation_1.SharedArrayReceiverStrategy;
    } });
    var messageReader_1 = require_messageReader2();
    Object.defineProperty(exports2, "MessageReader", { enumerable: true, get: function() {
      return messageReader_1.MessageReader;
    } });
    Object.defineProperty(exports2, "AbstractMessageReader", { enumerable: true, get: function() {
      return messageReader_1.AbstractMessageReader;
    } });
    Object.defineProperty(exports2, "ReadableStreamMessageReader", { enumerable: true, get: function() {
      return messageReader_1.ReadableStreamMessageReader;
    } });
    var messageWriter_1 = require_messageWriter2();
    Object.defineProperty(exports2, "MessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.MessageWriter;
    } });
    Object.defineProperty(exports2, "AbstractMessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.AbstractMessageWriter;
    } });
    Object.defineProperty(exports2, "WriteableStreamMessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.WriteableStreamMessageWriter;
    } });
    var messageBuffer_1 = require_messageBuffer();
    Object.defineProperty(exports2, "AbstractMessageBuffer", { enumerable: true, get: function() {
      return messageBuffer_1.AbstractMessageBuffer;
    } });
    var connection_1 = require_connection();
    Object.defineProperty(exports2, "ConnectionStrategy", { enumerable: true, get: function() {
      return connection_1.ConnectionStrategy;
    } });
    Object.defineProperty(exports2, "ConnectionOptions", { enumerable: true, get: function() {
      return connection_1.ConnectionOptions;
    } });
    Object.defineProperty(exports2, "NullLogger", { enumerable: true, get: function() {
      return connection_1.NullLogger;
    } });
    Object.defineProperty(exports2, "createMessageConnection", { enumerable: true, get: function() {
      return connection_1.createMessageConnection;
    } });
    Object.defineProperty(exports2, "ProgressToken", { enumerable: true, get: function() {
      return connection_1.ProgressToken;
    } });
    Object.defineProperty(exports2, "ProgressType", { enumerable: true, get: function() {
      return connection_1.ProgressType;
    } });
    Object.defineProperty(exports2, "Trace", { enumerable: true, get: function() {
      return connection_1.Trace;
    } });
    Object.defineProperty(exports2, "TraceValues", { enumerable: true, get: function() {
      return connection_1.TraceValues;
    } });
    Object.defineProperty(exports2, "TraceFormat", { enumerable: true, get: function() {
      return connection_1.TraceFormat;
    } });
    Object.defineProperty(exports2, "SetTraceNotification", { enumerable: true, get: function() {
      return connection_1.SetTraceNotification;
    } });
    Object.defineProperty(exports2, "LogTraceNotification", { enumerable: true, get: function() {
      return connection_1.LogTraceNotification;
    } });
    Object.defineProperty(exports2, "ConnectionErrors", { enumerable: true, get: function() {
      return connection_1.ConnectionErrors;
    } });
    Object.defineProperty(exports2, "ConnectionError", { enumerable: true, get: function() {
      return connection_1.ConnectionError;
    } });
    Object.defineProperty(exports2, "CancellationReceiverStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationReceiverStrategy;
    } });
    Object.defineProperty(exports2, "CancellationSenderStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationSenderStrategy;
    } });
    Object.defineProperty(exports2, "CancellationStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationStrategy;
    } });
    Object.defineProperty(exports2, "MessageStrategy", { enumerable: true, get: function() {
      return connection_1.MessageStrategy;
    } });
    var ral_1 = require_ral();
    exports2.RAL = ral_1.default;
  }
});

// ../../node_modules/@github/copilot-sdk/node_modules/vscode-jsonrpc/lib/node/ril.js
var require_ril = __commonJS({
  "../../node_modules/@github/copilot-sdk/node_modules/vscode-jsonrpc/lib/node/ril.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var util_1 = require("util");
    var api_1 = require_api();
    var MessageBuffer = class _MessageBuffer extends api_1.AbstractMessageBuffer {
      constructor(encoding = "utf-8") {
        super(encoding);
      }
      emptyBuffer() {
        return _MessageBuffer.emptyBuffer;
      }
      fromString(value, encoding) {
        return Buffer.from(value, encoding);
      }
      toString(value, encoding) {
        if (value instanceof Buffer) {
          return value.toString(encoding);
        } else {
          return new util_1.TextDecoder(encoding).decode(value);
        }
      }
      asNative(buffer, length) {
        if (length === void 0) {
          return buffer instanceof Buffer ? buffer : Buffer.from(buffer);
        } else {
          return buffer instanceof Buffer ? buffer.slice(0, length) : Buffer.from(buffer, 0, length);
        }
      }
      allocNative(length) {
        return Buffer.allocUnsafe(length);
      }
    };
    MessageBuffer.emptyBuffer = Buffer.allocUnsafe(0);
    var ReadableStreamWrapper = class {
      constructor(stream) {
        this.stream = stream;
      }
      onClose(listener) {
        this.stream.on("close", listener);
        return api_1.Disposable.create(() => this.stream.off("close", listener));
      }
      onError(listener) {
        this.stream.on("error", listener);
        return api_1.Disposable.create(() => this.stream.off("error", listener));
      }
      onEnd(listener) {
        this.stream.on("end", listener);
        return api_1.Disposable.create(() => this.stream.off("end", listener));
      }
      onData(listener) {
        this.stream.on("data", listener);
        return api_1.Disposable.create(() => this.stream.off("data", listener));
      }
    };
    var WritableStreamWrapper = class {
      constructor(stream) {
        this.stream = stream;
      }
      onClose(listener) {
        this.stream.on("close", listener);
        return api_1.Disposable.create(() => this.stream.off("close", listener));
      }
      onError(listener) {
        this.stream.on("error", listener);
        return api_1.Disposable.create(() => this.stream.off("error", listener));
      }
      onEnd(listener) {
        this.stream.on("end", listener);
        return api_1.Disposable.create(() => this.stream.off("end", listener));
      }
      write(data, encoding) {
        return new Promise((resolve3, reject) => {
          const callback2 = (error) => {
            if (error === void 0 || error === null) {
              resolve3();
            } else {
              reject(error);
            }
          };
          if (typeof data === "string") {
            this.stream.write(data, encoding, callback2);
          } else {
            this.stream.write(data, callback2);
          }
        });
      }
      end() {
        this.stream.end();
      }
    };
    var _ril = Object.freeze({
      messageBuffer: Object.freeze({
        create: (encoding) => new MessageBuffer(encoding)
      }),
      applicationJson: Object.freeze({
        encoder: Object.freeze({
          name: "application/json",
          encode: (msg, options) => {
            try {
              return Promise.resolve(Buffer.from(JSON.stringify(msg, void 0, 0), options.charset));
            } catch (err) {
              return Promise.reject(err);
            }
          }
        }),
        decoder: Object.freeze({
          name: "application/json",
          decode: (buffer, options) => {
            try {
              if (buffer instanceof Buffer) {
                return Promise.resolve(JSON.parse(buffer.toString(options.charset)));
              } else {
                return Promise.resolve(JSON.parse(new util_1.TextDecoder(options.charset).decode(buffer)));
              }
            } catch (err) {
              return Promise.reject(err);
            }
          }
        })
      }),
      stream: Object.freeze({
        asReadableStream: (stream) => new ReadableStreamWrapper(stream),
        asWritableStream: (stream) => new WritableStreamWrapper(stream)
      }),
      console,
      timer: Object.freeze({
        setTimeout(callback2, ms, ...args) {
          const handle = setTimeout(callback2, ms, ...args);
          return { dispose: () => clearTimeout(handle) };
        },
        setImmediate(callback2, ...args) {
          const handle = setImmediate(callback2, ...args);
          return { dispose: () => clearImmediate(handle) };
        },
        setInterval(callback2, ms, ...args) {
          const handle = setInterval(callback2, ms, ...args);
          return { dispose: () => clearInterval(handle) };
        }
      })
    });
    function RIL() {
      return _ril;
    }
    (function(RIL2) {
      function install() {
        api_1.RAL.install(_ril);
      }
      RIL2.install = install;
    })(RIL || (RIL = {}));
    exports2.default = RIL;
  }
});

// ../../node_modules/@github/copilot-sdk/node_modules/vscode-jsonrpc/lib/node/main.js
var require_main2 = __commonJS({
  "../../node_modules/@github/copilot-sdk/node_modules/vscode-jsonrpc/lib/node/main.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createMessageConnection = exports2.createServerSocketTransport = exports2.createClientSocketTransport = exports2.createServerPipeTransport = exports2.createClientPipeTransport = exports2.generateRandomPipeName = exports2.StreamMessageWriter = exports2.StreamMessageReader = exports2.SocketMessageWriter = exports2.SocketMessageReader = exports2.PortMessageWriter = exports2.PortMessageReader = exports2.IPCMessageWriter = exports2.IPCMessageReader = void 0;
    var ril_1 = require_ril();
    ril_1.default.install();
    var path2 = require("path");
    var os3 = require("os");
    var crypto_1 = require("crypto");
    var net_1 = require("net");
    var api_1 = require_api();
    __exportStar(require_api(), exports2);
    var IPCMessageReader = class extends api_1.AbstractMessageReader {
      constructor(process2) {
        super();
        this.process = process2;
        let eventEmitter = this.process;
        eventEmitter.on("error", (error) => this.fireError(error));
        eventEmitter.on("close", () => this.fireClose());
      }
      listen(callback2) {
        this.process.on("message", callback2);
        return api_1.Disposable.create(() => this.process.off("message", callback2));
      }
    };
    exports2.IPCMessageReader = IPCMessageReader;
    var IPCMessageWriter = class extends api_1.AbstractMessageWriter {
      constructor(process2) {
        super();
        this.process = process2;
        this.errorCount = 0;
        const eventEmitter = this.process;
        eventEmitter.on("error", (error) => this.fireError(error));
        eventEmitter.on("close", () => this.fireClose);
      }
      write(msg) {
        try {
          if (typeof this.process.send === "function") {
            this.process.send(msg, void 0, void 0, (error) => {
              if (error) {
                this.errorCount++;
                this.handleError(error, msg);
              } else {
                this.errorCount = 0;
              }
            });
          }
          return Promise.resolve();
        } catch (error) {
          this.handleError(error, msg);
          return Promise.reject(error);
        }
      }
      handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
      }
      end() {
      }
    };
    exports2.IPCMessageWriter = IPCMessageWriter;
    var PortMessageReader = class extends api_1.AbstractMessageReader {
      constructor(port) {
        super();
        this.onData = new api_1.Emitter();
        port.on("close", () => this.fireClose);
        port.on("error", (error) => this.fireError(error));
        port.on("message", (message) => {
          this.onData.fire(message);
        });
      }
      listen(callback2) {
        return this.onData.event(callback2);
      }
    };
    exports2.PortMessageReader = PortMessageReader;
    var PortMessageWriter = class extends api_1.AbstractMessageWriter {
      constructor(port) {
        super();
        this.port = port;
        this.errorCount = 0;
        port.on("close", () => this.fireClose());
        port.on("error", (error) => this.fireError(error));
      }
      write(msg) {
        try {
          this.port.postMessage(msg);
          return Promise.resolve();
        } catch (error) {
          this.handleError(error, msg);
          return Promise.reject(error);
        }
      }
      handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
      }
      end() {
      }
    };
    exports2.PortMessageWriter = PortMessageWriter;
    var SocketMessageReader = class extends api_1.ReadableStreamMessageReader {
      constructor(socket, encoding = "utf-8") {
        super((0, ril_1.default)().stream.asReadableStream(socket), encoding);
      }
    };
    exports2.SocketMessageReader = SocketMessageReader;
    var SocketMessageWriter = class extends api_1.WriteableStreamMessageWriter {
      constructor(socket, options) {
        super((0, ril_1.default)().stream.asWritableStream(socket), options);
        this.socket = socket;
      }
      dispose() {
        super.dispose();
        this.socket.destroy();
      }
    };
    exports2.SocketMessageWriter = SocketMessageWriter;
    var StreamMessageReader2 = class extends api_1.ReadableStreamMessageReader {
      constructor(readable, encoding) {
        super((0, ril_1.default)().stream.asReadableStream(readable), encoding);
      }
    };
    exports2.StreamMessageReader = StreamMessageReader2;
    var StreamMessageWriter2 = class extends api_1.WriteableStreamMessageWriter {
      constructor(writable, options) {
        super((0, ril_1.default)().stream.asWritableStream(writable), options);
      }
    };
    exports2.StreamMessageWriter = StreamMessageWriter2;
    var XDG_RUNTIME_DIR = process.env["XDG_RUNTIME_DIR"];
    var safeIpcPathLengths = /* @__PURE__ */ new Map([
      ["linux", 107],
      ["darwin", 103]
    ]);
    function generateRandomPipeName() {
      const randomSuffix = (0, crypto_1.randomBytes)(21).toString("hex");
      if (process.platform === "win32") {
        return `\\\\.\\pipe\\vscode-jsonrpc-${randomSuffix}-sock`;
      }
      let result;
      if (XDG_RUNTIME_DIR) {
        result = path2.join(XDG_RUNTIME_DIR, `vscode-ipc-${randomSuffix}.sock`);
      } else {
        result = path2.join(os3.tmpdir(), `vscode-${randomSuffix}.sock`);
      }
      const limit = safeIpcPathLengths.get(process.platform);
      if (limit !== void 0 && result.length > limit) {
        (0, ril_1.default)().console.warn(`WARNING: IPC handle "${result}" is longer than ${limit} characters.`);
      }
      return result;
    }
    exports2.generateRandomPipeName = generateRandomPipeName;
    function createClientPipeTransport(pipeName, encoding = "utf-8") {
      let connectResolve;
      const connected = new Promise((resolve3, _reject) => {
        connectResolve = resolve3;
      });
      return new Promise((resolve3, reject) => {
        let server = (0, net_1.createServer)((socket) => {
          server.close();
          connectResolve([
            new SocketMessageReader(socket, encoding),
            new SocketMessageWriter(socket, encoding)
          ]);
        });
        server.on("error", reject);
        server.listen(pipeName, () => {
          server.removeListener("error", reject);
          resolve3({
            onConnected: () => {
              return connected;
            }
          });
        });
      });
    }
    exports2.createClientPipeTransport = createClientPipeTransport;
    function createServerPipeTransport(pipeName, encoding = "utf-8") {
      const socket = (0, net_1.createConnection)(pipeName);
      return [
        new SocketMessageReader(socket, encoding),
        new SocketMessageWriter(socket, encoding)
      ];
    }
    exports2.createServerPipeTransport = createServerPipeTransport;
    function createClientSocketTransport(port, encoding = "utf-8") {
      let connectResolve;
      const connected = new Promise((resolve3, _reject) => {
        connectResolve = resolve3;
      });
      return new Promise((resolve3, reject) => {
        const server = (0, net_1.createServer)((socket) => {
          server.close();
          connectResolve([
            new SocketMessageReader(socket, encoding),
            new SocketMessageWriter(socket, encoding)
          ]);
        });
        server.on("error", reject);
        server.listen(port, "127.0.0.1", () => {
          server.removeListener("error", reject);
          resolve3({
            onConnected: () => {
              return connected;
            }
          });
        });
      });
    }
    exports2.createClientSocketTransport = createClientSocketTransport;
    function createServerSocketTransport(port, encoding = "utf-8") {
      const socket = (0, net_1.createConnection)(port, "127.0.0.1");
      return [
        new SocketMessageReader(socket, encoding),
        new SocketMessageWriter(socket, encoding)
      ];
    }
    exports2.createServerSocketTransport = createServerSocketTransport;
    function isReadableStream(value) {
      const candidate = value;
      return candidate.read !== void 0 && candidate.addListener !== void 0;
    }
    function isWritableStream(value) {
      const candidate = value;
      return candidate.write !== void 0 && candidate.addListener !== void 0;
    }
    function createMessageConnection2(input, output, logger, options) {
      if (!logger) {
        logger = api_1.NullLogger;
      }
      const reader = isReadableStream(input) ? new StreamMessageReader2(input) : input;
      const writer = isWritableStream(output) ? new StreamMessageWriter2(output) : output;
      if (api_1.ConnectionStrategy.is(options)) {
        options = { connectionStrategy: options };
      }
      return (0, api_1.createMessageConnection)(reader, writer, logger, options);
    }
    exports2.createMessageConnection = createMessageConnection2;
  }
});

// ../../node_modules/@github/copilot-sdk/node_modules/vscode-jsonrpc/node.js
var require_node3 = __commonJS({
  "../../node_modules/@github/copilot-sdk/node_modules/vscode-jsonrpc/node.js"(exports2, module2) {
    "use strict";
    module2.exports = require_main2();
  }
});

// ../../node_modules/picomatch/lib/constants.js
var require_constants = __commonJS({
  "../../node_modules/picomatch/lib/constants.js"(exports2, module2) {
    "use strict";
    var WIN_SLASH = "\\\\/";
    var WIN_NO_SLASH = `[^${WIN_SLASH}]`;
    var DOT_LITERAL = "\\.";
    var PLUS_LITERAL = "\\+";
    var QMARK_LITERAL = "\\?";
    var SLASH_LITERAL = "\\/";
    var ONE_CHAR = "(?=.)";
    var QMARK = "[^/]";
    var END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
    var START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
    var DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
    var NO_DOT = `(?!${DOT_LITERAL})`;
    var NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
    var NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
    var NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
    var QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
    var STAR = `${QMARK}*?`;
    var SEP = "/";
    var POSIX_CHARS = {
      DOT_LITERAL,
      PLUS_LITERAL,
      QMARK_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      QMARK,
      END_ANCHOR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOTS,
      NO_DOT_SLASH,
      NO_DOTS_SLASH,
      QMARK_NO_DOT,
      STAR,
      START_ANCHOR,
      SEP
    };
    var WINDOWS_CHARS = {
      ...POSIX_CHARS,
      SLASH_LITERAL: `[${WIN_SLASH}]`,
      QMARK: WIN_NO_SLASH,
      STAR: `${WIN_NO_SLASH}*?`,
      DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
      NO_DOT: `(?!${DOT_LITERAL})`,
      NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
      NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
      START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
      END_ANCHOR: `(?:[${WIN_SLASH}]|$)`,
      SEP: "\\"
    };
    var POSIX_REGEX_SOURCE = {
      alnum: "a-zA-Z0-9",
      alpha: "a-zA-Z",
      ascii: "\\x00-\\x7F",
      blank: " \\t",
      cntrl: "\\x00-\\x1F\\x7F",
      digit: "0-9",
      graph: "\\x21-\\x7E",
      lower: "a-z",
      print: "\\x20-\\x7E ",
      punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
      space: " \\t\\r\\n\\v\\f",
      upper: "A-Z",
      word: "A-Za-z0-9_",
      xdigit: "A-Fa-f0-9"
    };
    module2.exports = {
      MAX_LENGTH: 1024 * 64,
      POSIX_REGEX_SOURCE,
      // regular expressions
      REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
      REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
      REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
      REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
      REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
      REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
      // Replace globs with equivalent patterns to reduce parsing time.
      REPLACEMENTS: {
        __proto__: null,
        "***": "*",
        "**/**": "**",
        "**/**/**": "**"
      },
      // Digits
      CHAR_0: 48,
      /* 0 */
      CHAR_9: 57,
      /* 9 */
      // Alphabet chars.
      CHAR_UPPERCASE_A: 65,
      /* A */
      CHAR_LOWERCASE_A: 97,
      /* a */
      CHAR_UPPERCASE_Z: 90,
      /* Z */
      CHAR_LOWERCASE_Z: 122,
      /* z */
      CHAR_LEFT_PARENTHESES: 40,
      /* ( */
      CHAR_RIGHT_PARENTHESES: 41,
      /* ) */
      CHAR_ASTERISK: 42,
      /* * */
      // Non-alphabetic chars.
      CHAR_AMPERSAND: 38,
      /* & */
      CHAR_AT: 64,
      /* @ */
      CHAR_BACKWARD_SLASH: 92,
      /* \ */
      CHAR_CARRIAGE_RETURN: 13,
      /* \r */
      CHAR_CIRCUMFLEX_ACCENT: 94,
      /* ^ */
      CHAR_COLON: 58,
      /* : */
      CHAR_COMMA: 44,
      /* , */
      CHAR_DOT: 46,
      /* . */
      CHAR_DOUBLE_QUOTE: 34,
      /* " */
      CHAR_EQUAL: 61,
      /* = */
      CHAR_EXCLAMATION_MARK: 33,
      /* ! */
      CHAR_FORM_FEED: 12,
      /* \f */
      CHAR_FORWARD_SLASH: 47,
      /* / */
      CHAR_GRAVE_ACCENT: 96,
      /* ` */
      CHAR_HASH: 35,
      /* # */
      CHAR_HYPHEN_MINUS: 45,
      /* - */
      CHAR_LEFT_ANGLE_BRACKET: 60,
      /* < */
      CHAR_LEFT_CURLY_BRACE: 123,
      /* { */
      CHAR_LEFT_SQUARE_BRACKET: 91,
      /* [ */
      CHAR_LINE_FEED: 10,
      /* \n */
      CHAR_NO_BREAK_SPACE: 160,
      /* \u00A0 */
      CHAR_PERCENT: 37,
      /* % */
      CHAR_PLUS: 43,
      /* + */
      CHAR_QUESTION_MARK: 63,
      /* ? */
      CHAR_RIGHT_ANGLE_BRACKET: 62,
      /* > */
      CHAR_RIGHT_CURLY_BRACE: 125,
      /* } */
      CHAR_RIGHT_SQUARE_BRACKET: 93,
      /* ] */
      CHAR_SEMICOLON: 59,
      /* ; */
      CHAR_SINGLE_QUOTE: 39,
      /* ' */
      CHAR_SPACE: 32,
      /*   */
      CHAR_TAB: 9,
      /* \t */
      CHAR_UNDERSCORE: 95,
      /* _ */
      CHAR_VERTICAL_LINE: 124,
      /* | */
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
      /* \uFEFF */
      /**
       * Create EXTGLOB_CHARS
       */
      extglobChars(chars) {
        return {
          "!": { type: "negate", open: "(?:(?!(?:", close: `))${chars.STAR})` },
          "?": { type: "qmark", open: "(?:", close: ")?" },
          "+": { type: "plus", open: "(?:", close: ")+" },
          "*": { type: "star", open: "(?:", close: ")*" },
          "@": { type: "at", open: "(?:", close: ")" }
        };
      },
      /**
       * Create GLOB_CHARS
       */
      globChars(win32) {
        return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
      }
    };
  }
});

// ../../node_modules/picomatch/lib/utils.js
var require_utils3 = __commonJS({
  "../../node_modules/picomatch/lib/utils.js"(exports2) {
    "use strict";
    var {
      REGEX_BACKSLASH,
      REGEX_REMOVE_BACKSLASH,
      REGEX_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_GLOBAL
    } = require_constants();
    exports2.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    exports2.hasRegexChars = (str) => REGEX_SPECIAL_CHARS.test(str);
    exports2.isRegexChar = (str) => str.length === 1 && exports2.hasRegexChars(str);
    exports2.escapeRegex = (str) => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
    exports2.toPosixSlashes = (str) => str.replace(REGEX_BACKSLASH, "/");
    exports2.isWindows = () => {
      if (typeof navigator !== "undefined" && navigator.platform) {
        const platform = navigator.platform.toLowerCase();
        return platform === "win32" || platform === "windows";
      }
      if (typeof process !== "undefined" && process.platform) {
        return process.platform === "win32";
      }
      return false;
    };
    exports2.removeBackslashes = (str) => {
      return str.replace(REGEX_REMOVE_BACKSLASH, (match) => {
        return match === "\\" ? "" : match;
      });
    };
    exports2.escapeLast = (input, char, lastIdx) => {
      const idx = input.lastIndexOf(char, lastIdx);
      if (idx === -1) return input;
      if (input[idx - 1] === "\\") return exports2.escapeLast(input, char, idx - 1);
      return `${input.slice(0, idx)}\\${input.slice(idx)}`;
    };
    exports2.removePrefix = (input, state = {}) => {
      let output = input;
      if (output.startsWith("./")) {
        output = output.slice(2);
        state.prefix = "./";
      }
      return output;
    };
    exports2.wrapOutput = (input, state = {}, options = {}) => {
      const prepend = options.contains ? "" : "^";
      const append = options.contains ? "" : "$";
      let output = `${prepend}(?:${input})${append}`;
      if (state.negated === true) {
        output = `(?:^(?!${output}).*$)`;
      }
      return output;
    };
    exports2.basename = (path2, { windows } = {}) => {
      const segs = path2.split(windows ? /[\\/]/ : "/");
      const last = segs[segs.length - 1];
      if (last === "") {
        return segs[segs.length - 2];
      }
      return last;
    };
  }
});

// ../../node_modules/picomatch/lib/scan.js
var require_scan = __commonJS({
  "../../node_modules/picomatch/lib/scan.js"(exports2, module2) {
    "use strict";
    var utils = require_utils3();
    var {
      CHAR_ASTERISK,
      /* * */
      CHAR_AT,
      /* @ */
      CHAR_BACKWARD_SLASH,
      /* \ */
      CHAR_COMMA,
      /* , */
      CHAR_DOT,
      /* . */
      CHAR_EXCLAMATION_MARK,
      /* ! */
      CHAR_FORWARD_SLASH,
      /* / */
      CHAR_LEFT_CURLY_BRACE,
      /* { */
      CHAR_LEFT_PARENTHESES,
      /* ( */
      CHAR_LEFT_SQUARE_BRACKET,
      /* [ */
      CHAR_PLUS,
      /* + */
      CHAR_QUESTION_MARK,
      /* ? */
      CHAR_RIGHT_CURLY_BRACE,
      /* } */
      CHAR_RIGHT_PARENTHESES,
      /* ) */
      CHAR_RIGHT_SQUARE_BRACKET
      /* ] */
    } = require_constants();
    var isPathSeparator = (code) => {
      return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
    };
    var depth = (token) => {
      if (token.isPrefix !== true) {
        token.depth = token.isGlobstar ? Infinity : 1;
      }
    };
    var scan = (input, options) => {
      const opts = options || {};
      const length = input.length - 1;
      const scanToEnd = opts.parts === true || opts.scanToEnd === true;
      const slashes = [];
      const tokens = [];
      const parts = [];
      let str = input;
      let index = -1;
      let start = 0;
      let lastIndex = 0;
      let isBrace = false;
      let isBracket = false;
      let isGlob = false;
      let isExtglob = false;
      let isGlobstar = false;
      let braceEscaped = false;
      let backslashes = false;
      let negated = false;
      let negatedExtglob = false;
      let finished = false;
      let braces = 0;
      let prev;
      let code;
      let token = { value: "", depth: 0, isGlob: false };
      const eos = () => index >= length;
      const peek = () => str.charCodeAt(index + 1);
      const advance = () => {
        prev = code;
        return str.charCodeAt(++index);
      };
      while (index < length) {
        code = advance();
        let next;
        if (code === CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = true;
          code = advance();
          if (code === CHAR_LEFT_CURLY_BRACE) {
            braceEscaped = true;
          }
          continue;
        }
        if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
          braces++;
          while (eos() !== true && (code = advance())) {
            if (code === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (code === CHAR_LEFT_CURLY_BRACE) {
              braces++;
              continue;
            }
            if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (braceEscaped !== true && code === CHAR_COMMA) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (code === CHAR_RIGHT_CURLY_BRACE) {
              braces--;
              if (braces === 0) {
                braceEscaped = false;
                isBrace = token.isBrace = true;
                finished = true;
                break;
              }
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_FORWARD_SLASH) {
          slashes.push(index);
          tokens.push(token);
          token = { value: "", depth: 0, isGlob: false };
          if (finished === true) continue;
          if (prev === CHAR_DOT && index === start + 1) {
            start += 2;
            continue;
          }
          lastIndex = index + 1;
          continue;
        }
        if (opts.noext !== true) {
          const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;
          if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
            isGlob = token.isGlob = true;
            isExtglob = token.isExtglob = true;
            finished = true;
            if (code === CHAR_EXCLAMATION_MARK && index === start) {
              negatedExtglob = true;
            }
            if (scanToEnd === true) {
              while (eos() !== true && (code = advance())) {
                if (code === CHAR_BACKWARD_SLASH) {
                  backslashes = token.backslashes = true;
                  code = advance();
                  continue;
                }
                if (code === CHAR_RIGHT_PARENTHESES) {
                  isGlob = token.isGlob = true;
                  finished = true;
                  break;
                }
              }
              continue;
            }
            break;
          }
        }
        if (code === CHAR_ASTERISK) {
          if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_QUESTION_MARK) {
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_LEFT_SQUARE_BRACKET) {
          while (eos() !== true && (next = advance())) {
            if (next === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              isBracket = token.isBracket = true;
              isGlob = token.isGlob = true;
              finished = true;
              break;
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
          negated = token.negated = true;
          start++;
          continue;
        }
        if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
          isGlob = token.isGlob = true;
          if (scanToEnd === true) {
            while (eos() !== true && (code = advance())) {
              if (code === CHAR_LEFT_PARENTHESES) {
                backslashes = token.backslashes = true;
                code = advance();
                continue;
              }
              if (code === CHAR_RIGHT_PARENTHESES) {
                finished = true;
                break;
              }
            }
            continue;
          }
          break;
        }
        if (isGlob === true) {
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
      }
      if (opts.noext === true) {
        isExtglob = false;
        isGlob = false;
      }
      let base = str;
      let prefix = "";
      let glob = "";
      if (start > 0) {
        prefix = str.slice(0, start);
        str = str.slice(start);
        lastIndex -= start;
      }
      if (base && isGlob === true && lastIndex > 0) {
        base = str.slice(0, lastIndex);
        glob = str.slice(lastIndex);
      } else if (isGlob === true) {
        base = "";
        glob = str;
      } else {
        base = str;
      }
      if (base && base !== "" && base !== "/" && base !== str) {
        if (isPathSeparator(base.charCodeAt(base.length - 1))) {
          base = base.slice(0, -1);
        }
      }
      if (opts.unescape === true) {
        if (glob) glob = utils.removeBackslashes(glob);
        if (base && backslashes === true) {
          base = utils.removeBackslashes(base);
        }
      }
      const state = {
        prefix,
        input,
        start,
        base,
        glob,
        isBrace,
        isBracket,
        isGlob,
        isExtglob,
        isGlobstar,
        negated,
        negatedExtglob
      };
      if (opts.tokens === true) {
        state.maxDepth = 0;
        if (!isPathSeparator(code)) {
          tokens.push(token);
        }
        state.tokens = tokens;
      }
      if (opts.parts === true || opts.tokens === true) {
        let prevIndex;
        for (let idx = 0; idx < slashes.length; idx++) {
          const n = prevIndex ? prevIndex + 1 : start;
          const i = slashes[idx];
          const value = input.slice(n, i);
          if (opts.tokens) {
            if (idx === 0 && start !== 0) {
              tokens[idx].isPrefix = true;
              tokens[idx].value = prefix;
            } else {
              tokens[idx].value = value;
            }
            depth(tokens[idx]);
            state.maxDepth += tokens[idx].depth;
          }
          if (idx !== 0 || value !== "") {
            parts.push(value);
          }
          prevIndex = i;
        }
        if (prevIndex && prevIndex + 1 < input.length) {
          const value = input.slice(prevIndex + 1);
          parts.push(value);
          if (opts.tokens) {
            tokens[tokens.length - 1].value = value;
            depth(tokens[tokens.length - 1]);
            state.maxDepth += tokens[tokens.length - 1].depth;
          }
        }
        state.slashes = slashes;
        state.parts = parts;
      }
      return state;
    };
    module2.exports = scan;
  }
});

// ../../node_modules/picomatch/lib/parse.js
var require_parse = __commonJS({
  "../../node_modules/picomatch/lib/parse.js"(exports2, module2) {
    "use strict";
    var constants = require_constants();
    var utils = require_utils3();
    var {
      MAX_LENGTH,
      POSIX_REGEX_SOURCE,
      REGEX_NON_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_BACKREF,
      REPLACEMENTS
    } = constants;
    var expandRange = (args, options) => {
      if (typeof options.expandRange === "function") {
        return options.expandRange(...args, options);
      }
      args.sort();
      const value = `[${args.join("-")}]`;
      try {
        new RegExp(value);
      } catch (ex) {
        return args.map((v) => utils.escapeRegex(v)).join("..");
      }
      return value;
    };
    var syntaxError = (type, char) => {
      return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
    };
    var parse = (input, options) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      input = REPLACEMENTS[input] || input;
      const opts = { ...options };
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      let len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      const bos = { type: "bos", value: "", output: opts.prepend || "" };
      const tokens = [bos];
      const capture = opts.capture ? "" : "?:";
      const PLATFORM_CHARS = constants.globChars(opts.windows);
      const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);
      const {
        DOT_LITERAL,
        PLUS_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOT_SLASH,
        NO_DOTS_SLASH,
        QMARK,
        QMARK_NO_DOT,
        STAR,
        START_ANCHOR
      } = PLATFORM_CHARS;
      const globstar = (opts2) => {
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const nodot = opts.dot ? "" : NO_DOT;
      const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
      let star = opts.bash === true ? globstar(opts) : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      if (typeof opts.noext === "boolean") {
        opts.noextglob = opts.noext;
      }
      const state = {
        input,
        index: -1,
        start: 0,
        dot: opts.dot === true,
        consumed: "",
        output: "",
        prefix: "",
        backtrack: false,
        negated: false,
        brackets: 0,
        braces: 0,
        parens: 0,
        quotes: 0,
        globstar: false,
        tokens
      };
      input = utils.removePrefix(input, state);
      len = input.length;
      const extglobs = [];
      const braces = [];
      const stack = [];
      let prev = bos;
      let value;
      const eos = () => state.index === len - 1;
      const peek = state.peek = (n = 1) => input[state.index + n];
      const advance = state.advance = () => input[++state.index] || "";
      const remaining = () => input.slice(state.index + 1);
      const consume = (value2 = "", num = 0) => {
        state.consumed += value2;
        state.index += num;
      };
      const append = (token) => {
        state.output += token.output != null ? token.output : token.value;
        consume(token.value);
      };
      const negate = () => {
        let count = 1;
        while (peek() === "!" && (peek(2) !== "(" || peek(3) === "?")) {
          advance();
          state.start++;
          count++;
        }
        if (count % 2 === 0) {
          return false;
        }
        state.negated = true;
        state.start++;
        return true;
      };
      const increment = (type) => {
        state[type]++;
        stack.push(type);
      };
      const decrement = (type) => {
        state[type]--;
        stack.pop();
      };
      const push = (tok) => {
        if (prev.type === "globstar") {
          const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace");
          const isExtglob = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
          if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob) {
            state.output = state.output.slice(0, -prev.output.length);
            prev.type = "star";
            prev.value = "*";
            prev.output = star;
            state.output += prev.output;
          }
        }
        if (extglobs.length && tok.type !== "paren") {
          extglobs[extglobs.length - 1].inner += tok.value;
        }
        if (tok.value || tok.output) append(tok);
        if (prev && prev.type === "text" && tok.type === "text") {
          prev.output = (prev.output || prev.value) + tok.value;
          prev.value += tok.value;
          return;
        }
        tok.prev = prev;
        tokens.push(tok);
        prev = tok;
      };
      const extglobOpen = (type, value2) => {
        const token = { ...EXTGLOB_CHARS[value2], conditions: 1, inner: "" };
        token.prev = prev;
        token.parens = state.parens;
        token.output = state.output;
        const output = (opts.capture ? "(" : "") + token.open;
        increment("parens");
        push({ type, value: value2, output: state.output ? "" : ONE_CHAR });
        push({ type: "paren", extglob: true, value: advance(), output });
        extglobs.push(token);
      };
      const extglobClose = (token) => {
        let output = token.close + (opts.capture ? ")" : "");
        let rest;
        if (token.type === "negate") {
          let extglobStar = star;
          if (token.inner && token.inner.length > 1 && token.inner.includes("/")) {
            extglobStar = globstar(opts);
          }
          if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
            output = token.close = `)$))${extglobStar}`;
          }
          if (token.inner.includes("*") && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
            const expression = parse(rest, { ...options, fastpaths: false }).output;
            output = token.close = `)${expression})${extglobStar})`;
          }
          if (token.prev.type === "bos") {
            state.negatedExtglob = true;
          }
        }
        push({ type: "paren", extglob: true, value, output });
        decrement("parens");
      };
      if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
        let backslashes = false;
        let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {
          if (first === "\\") {
            backslashes = true;
            return m;
          }
          if (first === "?") {
            if (esc) {
              return esc + first + (rest ? QMARK.repeat(rest.length) : "");
            }
            if (index === 0) {
              return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : "");
            }
            return QMARK.repeat(chars.length);
          }
          if (first === ".") {
            return DOT_LITERAL.repeat(chars.length);
          }
          if (first === "*") {
            if (esc) {
              return esc + first + (rest ? star : "");
            }
            return star;
          }
          return esc ? m : `\\${m}`;
        });
        if (backslashes === true) {
          if (opts.unescape === true) {
            output = output.replace(/\\/g, "");
          } else {
            output = output.replace(/\\+/g, (m) => {
              return m.length % 2 === 0 ? "\\\\" : m ? "\\" : "";
            });
          }
        }
        if (output === input && opts.contains === true) {
          state.output = input;
          return state;
        }
        state.output = utils.wrapOutput(output, state, options);
        return state;
      }
      while (!eos()) {
        value = advance();
        if (value === "\0") {
          continue;
        }
        if (value === "\\") {
          const next = peek();
          if (next === "/" && opts.bash !== true) {
            continue;
          }
          if (next === "." || next === ";") {
            continue;
          }
          if (!next) {
            value += "\\";
            push({ type: "text", value });
            continue;
          }
          const match = /^\\+/.exec(remaining());
          let slashes = 0;
          if (match && match[0].length > 2) {
            slashes = match[0].length;
            state.index += slashes;
            if (slashes % 2 !== 0) {
              value += "\\";
            }
          }
          if (opts.unescape === true) {
            value = advance();
          } else {
            value += advance();
          }
          if (state.brackets === 0) {
            push({ type: "text", value });
            continue;
          }
        }
        if (state.brackets > 0 && (value !== "]" || prev.value === "[" || prev.value === "[^")) {
          if (opts.posix !== false && value === ":") {
            const inner = prev.value.slice(1);
            if (inner.includes("[")) {
              prev.posix = true;
              if (inner.includes(":")) {
                const idx = prev.value.lastIndexOf("[");
                const pre = prev.value.slice(0, idx);
                const rest2 = prev.value.slice(idx + 2);
                const posix = POSIX_REGEX_SOURCE[rest2];
                if (posix) {
                  prev.value = pre + posix;
                  state.backtrack = true;
                  advance();
                  if (!bos.output && tokens.indexOf(prev) === 1) {
                    bos.output = ONE_CHAR;
                  }
                  continue;
                }
              }
            }
          }
          if (value === "[" && peek() !== ":" || value === "-" && peek() === "]") {
            value = `\\${value}`;
          }
          if (value === "]" && (prev.value === "[" || prev.value === "[^")) {
            value = `\\${value}`;
          }
          if (opts.posix === true && value === "!" && prev.value === "[") {
            value = "^";
          }
          prev.value += value;
          append({ value });
          continue;
        }
        if (state.quotes === 1 && value !== '"') {
          value = utils.escapeRegex(value);
          prev.value += value;
          append({ value });
          continue;
        }
        if (value === '"') {
          state.quotes = state.quotes === 1 ? 0 : 1;
          if (opts.keepQuotes === true) {
            push({ type: "text", value });
          }
          continue;
        }
        if (value === "(") {
          increment("parens");
          push({ type: "paren", value });
          continue;
        }
        if (value === ")") {
          if (state.parens === 0 && opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError("opening", "("));
          }
          const extglob = extglobs[extglobs.length - 1];
          if (extglob && state.parens === extglob.parens + 1) {
            extglobClose(extglobs.pop());
            continue;
          }
          push({ type: "paren", value, output: state.parens ? ")" : "\\)" });
          decrement("parens");
          continue;
        }
        if (value === "[") {
          if (opts.nobracket === true || !remaining().includes("]")) {
            if (opts.nobracket !== true && opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("closing", "]"));
            }
            value = `\\${value}`;
          } else {
            increment("brackets");
          }
          push({ type: "bracket", value });
          continue;
        }
        if (value === "]") {
          if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
            push({ type: "text", value, output: `\\${value}` });
            continue;
          }
          if (state.brackets === 0) {
            if (opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("opening", "["));
            }
            push({ type: "text", value, output: `\\${value}` });
            continue;
          }
          decrement("brackets");
          const prevValue = prev.value.slice(1);
          if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
            value = `/${value}`;
          }
          prev.value += value;
          append({ value });
          if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
            continue;
          }
          const escaped = utils.escapeRegex(prev.value);
          state.output = state.output.slice(0, -prev.value.length);
          if (opts.literalBrackets === true) {
            state.output += escaped;
            prev.value = escaped;
            continue;
          }
          prev.value = `(${capture}${escaped}|${prev.value})`;
          state.output += prev.value;
          continue;
        }
        if (value === "{" && opts.nobrace !== true) {
          increment("braces");
          const open = {
            type: "brace",
            value,
            output: "(",
            outputIndex: state.output.length,
            tokensIndex: state.tokens.length
          };
          braces.push(open);
          push(open);
          continue;
        }
        if (value === "}") {
          const brace = braces[braces.length - 1];
          if (opts.nobrace === true || !brace) {
            push({ type: "text", value, output: value });
            continue;
          }
          let output = ")";
          if (brace.dots === true) {
            const arr = tokens.slice();
            const range = [];
            for (let i = arr.length - 1; i >= 0; i--) {
              tokens.pop();
              if (arr[i].type === "brace") {
                break;
              }
              if (arr[i].type !== "dots") {
                range.unshift(arr[i].value);
              }
            }
            output = expandRange(range, opts);
            state.backtrack = true;
          }
          if (brace.comma !== true && brace.dots !== true) {
            const out = state.output.slice(0, brace.outputIndex);
            const toks = state.tokens.slice(brace.tokensIndex);
            brace.value = brace.output = "\\{";
            value = output = "\\}";
            state.output = out;
            for (const t of toks) {
              state.output += t.output || t.value;
            }
          }
          push({ type: "brace", value, output });
          decrement("braces");
          braces.pop();
          continue;
        }
        if (value === "|") {
          if (extglobs.length > 0) {
            extglobs[extglobs.length - 1].conditions++;
          }
          push({ type: "text", value });
          continue;
        }
        if (value === ",") {
          let output = value;
          const brace = braces[braces.length - 1];
          if (brace && stack[stack.length - 1] === "braces") {
            brace.comma = true;
            output = "|";
          }
          push({ type: "comma", value, output });
          continue;
        }
        if (value === "/") {
          if (prev.type === "dot" && state.index === state.start + 1) {
            state.start = state.index + 1;
            state.consumed = "";
            state.output = "";
            tokens.pop();
            prev = bos;
            continue;
          }
          push({ type: "slash", value, output: SLASH_LITERAL });
          continue;
        }
        if (value === ".") {
          if (state.braces > 0 && prev.type === "dot") {
            if (prev.value === ".") prev.output = DOT_LITERAL;
            const brace = braces[braces.length - 1];
            prev.type = "dots";
            prev.output += value;
            prev.value += value;
            brace.dots = true;
            continue;
          }
          if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
            push({ type: "text", value, output: DOT_LITERAL });
            continue;
          }
          push({ type: "dot", value, output: DOT_LITERAL });
          continue;
        }
        if (value === "?") {
          const isGroup = prev && prev.value === "(";
          if (!isGroup && opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("qmark", value);
            continue;
          }
          if (prev && prev.type === "paren") {
            const next = peek();
            let output = value;
            if (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) {
              output = `\\${value}`;
            }
            push({ type: "text", value, output });
            continue;
          }
          if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
            push({ type: "qmark", value, output: QMARK_NO_DOT });
            continue;
          }
          push({ type: "qmark", value, output: QMARK });
          continue;
        }
        if (value === "!") {
          if (opts.noextglob !== true && peek() === "(") {
            if (peek(2) !== "?" || !/[!=<:]/.test(peek(3))) {
              extglobOpen("negate", value);
              continue;
            }
          }
          if (opts.nonegate !== true && state.index === 0) {
            negate();
            continue;
          }
        }
        if (value === "+") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("plus", value);
            continue;
          }
          if (prev && prev.value === "(" || opts.regex === false) {
            push({ type: "plus", value, output: PLUS_LITERAL });
            continue;
          }
          if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
            push({ type: "plus", value });
            continue;
          }
          push({ type: "plus", value: PLUS_LITERAL });
          continue;
        }
        if (value === "@") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            push({ type: "at", extglob: true, value, output: "" });
            continue;
          }
          push({ type: "text", value });
          continue;
        }
        if (value !== "*") {
          if (value === "$" || value === "^") {
            value = `\\${value}`;
          }
          const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
          if (match) {
            value += match[0];
            state.index += match[0].length;
          }
          push({ type: "text", value });
          continue;
        }
        if (prev && (prev.type === "globstar" || prev.star === true)) {
          prev.type = "star";
          prev.star = true;
          prev.value += value;
          prev.output = star;
          state.backtrack = true;
          state.globstar = true;
          consume(value);
          continue;
        }
        let rest = remaining();
        if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
          extglobOpen("star", value);
          continue;
        }
        if (prev.type === "star") {
          if (opts.noglobstar === true) {
            consume(value);
            continue;
          }
          const prior = prev.prev;
          const before = prior.prev;
          const isStart = prior.type === "slash" || prior.type === "bos";
          const afterStar = before && (before.type === "star" || before.type === "globstar");
          if (opts.bash === true && (!isStart || rest[0] && rest[0] !== "/")) {
            push({ type: "star", value, output: "" });
            continue;
          }
          const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace");
          const isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
          if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
            push({ type: "star", value, output: "" });
            continue;
          }
          while (rest.slice(0, 3) === "/**") {
            const after = input[state.index + 4];
            if (after && after !== "/") {
              break;
            }
            rest = rest.slice(3);
            consume("/**", 3);
          }
          if (prior.type === "bos" && eos()) {
            prev.type = "globstar";
            prev.value += value;
            prev.output = globstar(opts);
            state.output = prev.output;
            state.globstar = true;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
            prev.value += value;
            state.globstar = true;
            state.output += prior.output + prev.output;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
            const end = rest[1] !== void 0 ? "|$" : "";
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
            prev.value += value;
            state.output += prior.output + prev.output;
            state.globstar = true;
            consume(value + advance());
            push({ type: "slash", value: "/", output: "" });
            continue;
          }
          if (prior.type === "bos" && rest[0] === "/") {
            prev.type = "globstar";
            prev.value += value;
            prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
            state.output = prev.output;
            state.globstar = true;
            consume(value + advance());
            push({ type: "slash", value: "/", output: "" });
            continue;
          }
          state.output = state.output.slice(0, -prev.output.length);
          prev.type = "globstar";
          prev.output = globstar(opts);
          prev.value += value;
          state.output += prev.output;
          state.globstar = true;
          consume(value);
          continue;
        }
        const token = { type: "star", value, output: star };
        if (opts.bash === true) {
          token.output = ".*?";
          if (prev.type === "bos" || prev.type === "slash") {
            token.output = nodot + token.output;
          }
          push(token);
          continue;
        }
        if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
          token.output = value;
          push(token);
          continue;
        }
        if (state.index === state.start || prev.type === "slash" || prev.type === "dot") {
          if (prev.type === "dot") {
            state.output += NO_DOT_SLASH;
            prev.output += NO_DOT_SLASH;
          } else if (opts.dot === true) {
            state.output += NO_DOTS_SLASH;
            prev.output += NO_DOTS_SLASH;
          } else {
            state.output += nodot;
            prev.output += nodot;
          }
          if (peek() !== "*") {
            state.output += ONE_CHAR;
            prev.output += ONE_CHAR;
          }
        }
        push(token);
      }
      while (state.brackets > 0) {
        if (opts.strictBrackets === true) throw new SyntaxError(syntaxError("closing", "]"));
        state.output = utils.escapeLast(state.output, "[");
        decrement("brackets");
      }
      while (state.parens > 0) {
        if (opts.strictBrackets === true) throw new SyntaxError(syntaxError("closing", ")"));
        state.output = utils.escapeLast(state.output, "(");
        decrement("parens");
      }
      while (state.braces > 0) {
        if (opts.strictBrackets === true) throw new SyntaxError(syntaxError("closing", "}"));
        state.output = utils.escapeLast(state.output, "{");
        decrement("braces");
      }
      if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
        push({ type: "maybe_slash", value: "", output: `${SLASH_LITERAL}?` });
      }
      if (state.backtrack === true) {
        state.output = "";
        for (const token of state.tokens) {
          state.output += token.output != null ? token.output : token.value;
          if (token.suffix) {
            state.output += token.suffix;
          }
        }
      }
      return state;
    };
    parse.fastpaths = (input, options) => {
      const opts = { ...options };
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      const len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      input = REPLACEMENTS[input] || input;
      const {
        DOT_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOTS,
        NO_DOTS_SLASH,
        STAR,
        START_ANCHOR
      } = constants.globChars(opts.windows);
      const nodot = opts.dot ? NO_DOTS : NO_DOT;
      const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
      const capture = opts.capture ? "" : "?:";
      const state = { negated: false, prefix: "" };
      let star = opts.bash === true ? ".*?" : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      const globstar = (opts2) => {
        if (opts2.noglobstar === true) return star;
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const create = (str) => {
        switch (str) {
          case "*":
            return `${nodot}${ONE_CHAR}${star}`;
          case ".*":
            return `${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*.*":
            return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*/*":
            return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;
          case "**":
            return nodot + globstar(opts);
          case "**/*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;
          case "**/*.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "**/.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;
          default: {
            const match = /^(.*?)\.(\w+)$/.exec(str);
            if (!match) return;
            const source2 = create(match[1]);
            if (!source2) return;
            return source2 + DOT_LITERAL + match[2];
          }
        }
      };
      const output = utils.removePrefix(input, state);
      let source = create(output);
      if (source && opts.strictSlashes !== true) {
        source += `${SLASH_LITERAL}?`;
      }
      return source;
    };
    module2.exports = parse;
  }
});

// ../../node_modules/picomatch/lib/picomatch.js
var require_picomatch = __commonJS({
  "../../node_modules/picomatch/lib/picomatch.js"(exports2, module2) {
    "use strict";
    var scan = require_scan();
    var parse = require_parse();
    var utils = require_utils3();
    var constants = require_constants();
    var isObject = (val) => val && typeof val === "object" && !Array.isArray(val);
    var picomatch2 = (glob, options, returnState = false) => {
      if (Array.isArray(glob)) {
        const fns = glob.map((input) => picomatch2(input, options, returnState));
        const arrayMatcher = (str) => {
          for (const isMatch of fns) {
            const state2 = isMatch(str);
            if (state2) return state2;
          }
          return false;
        };
        return arrayMatcher;
      }
      const isState = isObject(glob) && glob.tokens && glob.input;
      if (glob === "" || typeof glob !== "string" && !isState) {
        throw new TypeError("Expected pattern to be a non-empty string");
      }
      const opts = options || {};
      const posix = opts.windows;
      const regex = isState ? picomatch2.compileRe(glob, options) : picomatch2.makeRe(glob, options, false, true);
      const state = regex.state;
      delete regex.state;
      let isIgnored = () => false;
      if (opts.ignore) {
        const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };
        isIgnored = picomatch2(opts.ignore, ignoreOpts, returnState);
      }
      const matcher = (input, returnObject = false) => {
        const { isMatch, match, output } = picomatch2.test(input, regex, options, { glob, posix });
        const result = { glob, state, regex, posix, input, output, match, isMatch };
        if (typeof opts.onResult === "function") {
          opts.onResult(result);
        }
        if (isMatch === false) {
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (isIgnored(input)) {
          if (typeof opts.onIgnore === "function") {
            opts.onIgnore(result);
          }
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (typeof opts.onMatch === "function") {
          opts.onMatch(result);
        }
        return returnObject ? result : true;
      };
      if (returnState) {
        matcher.state = state;
      }
      return matcher;
    };
    picomatch2.test = (input, regex, options, { glob, posix } = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected input to be a string");
      }
      if (input === "") {
        return { isMatch: false, output: "" };
      }
      const opts = options || {};
      const format = opts.format || (posix ? utils.toPosixSlashes : null);
      let match = input === glob;
      let output = match && format ? format(input) : input;
      if (match === false) {
        output = format ? format(input) : input;
        match = output === glob;
      }
      if (match === false || opts.capture === true) {
        if (opts.matchBase === true || opts.basename === true) {
          match = picomatch2.matchBase(input, regex, options, posix);
        } else {
          match = regex.exec(output);
        }
      }
      return { isMatch: Boolean(match), match, output };
    };
    picomatch2.matchBase = (input, glob, options) => {
      const regex = glob instanceof RegExp ? glob : picomatch2.makeRe(glob, options);
      return regex.test(utils.basename(input));
    };
    picomatch2.isMatch = (str, patterns, options) => picomatch2(patterns, options)(str);
    picomatch2.parse = (pattern, options) => {
      if (Array.isArray(pattern)) return pattern.map((p) => picomatch2.parse(p, options));
      return parse(pattern, { ...options, fastpaths: false });
    };
    picomatch2.scan = (input, options) => scan(input, options);
    picomatch2.compileRe = (state, options, returnOutput = false, returnState = false) => {
      if (returnOutput === true) {
        return state.output;
      }
      const opts = options || {};
      const prepend = opts.contains ? "" : "^";
      const append = opts.contains ? "" : "$";
      let source = `${prepend}(?:${state.output})${append}`;
      if (state && state.negated === true) {
        source = `^(?!${source}).*$`;
      }
      const regex = picomatch2.toRegex(source, options);
      if (returnState === true) {
        regex.state = state;
      }
      return regex;
    };
    picomatch2.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {
      if (!input || typeof input !== "string") {
        throw new TypeError("Expected a non-empty string");
      }
      let parsed = { negated: false, fastpaths: true };
      if (options.fastpaths !== false && (input[0] === "." || input[0] === "*")) {
        parsed.output = parse.fastpaths(input, options);
      }
      if (!parsed.output) {
        parsed = parse(input, options);
      }
      return picomatch2.compileRe(parsed, options, returnOutput, returnState);
    };
    picomatch2.toRegex = (source, options) => {
      try {
        const opts = options || {};
        return new RegExp(source, opts.flags || (opts.nocase ? "i" : ""));
      } catch (err) {
        if (options && options.debug === true) throw err;
        return /$^/;
      }
    };
    picomatch2.constants = constants;
    module2.exports = picomatch2;
  }
});

// ../../node_modules/picomatch/index.js
var require_picomatch2 = __commonJS({
  "../../node_modules/picomatch/index.js"(exports2, module2) {
    "use strict";
    var pico = require_picomatch();
    var utils = require_utils3();
    function picomatch2(glob, options, returnState = false) {
      if (options && (options.windows === null || options.windows === void 0)) {
        options = { ...options, windows: utils.isWindows() };
      }
      return pico(glob, options, returnState);
    }
    Object.assign(picomatch2, pico);
    module2.exports = picomatch2;
  }
});

// node_modules/commander/esm.mjs
var import_index = __toESM(require_commander(), 1);
var {
  program,
  createCommand,
  createArgument,
  createOption,
  CommanderError,
  InvalidArgumentError,
  InvalidOptionArgumentError,
  // deprecated old name
  Command,
  Argument,
  Option,
  Help
} = import_index.default;

// src/sdk-proxy.ts
var import_dev_tunnels_management2 = __toESM(require_dev_tunnels_management(), 1);

// src/tunnel-adapter.ts
var dns = __toESM(require("dns"), 1);
var net = __toESM(require("net"), 1);
var os2 = __toESM(require("os"), 1);
var import_dev_tunnels_connections = __toESM(require_dev_tunnels_connections(), 1);
var import_dev_tunnels_contracts = __toESM(require_dev_tunnels_contracts(), 1);
var import_dev_tunnels_management = __toESM(require_dev_tunnels_management(), 1);

// src/token-storage.ts
var import_keytar = __toESM(require("keytar"), 1);
var SERVICE_NAME = "agent-tunnels";
var ACCOUNT_NAME = "github-token-data";
async function loadTokenData() {
  try {
    const data = await import_keytar.default.getPassword(SERVICE_NAME, ACCOUNT_NAME);
    if (!data) return null;
    return JSON.parse(data);
  } catch (error) {
    console.warn("Failed to load token data from keychain:", error);
    return null;
  }
}
async function saveTokenData(tokenData) {
  try {
    await import_keytar.default.setPassword(SERVICE_NAME, ACCOUNT_NAME, JSON.stringify(tokenData));
  } catch (error) {
    console.warn("Failed to save token data to keychain:", error);
    throw error;
  }
}
async function clearTokenData() {
  try {
    await import_keytar.default.deletePassword(SERVICE_NAME, ACCOUNT_NAME);
  } catch (error) {
    console.warn("Failed to clear token data from keychain:", error);
  }
}

// src/tunnel-config.ts
var fs = __toESM(require("fs/promises"), 1);
var path = __toESM(require("path"), 1);
var os = __toESM(require("os"), 1);
function getConfigDir() {
  return path.join(os.homedir(), ".copilot", "agent-tunnels");
}
function getConfigPath() {
  return path.join(getConfigDir(), "host-config.json");
}
async function loadTunnelConfig() {
  try {
    const configPath = getConfigPath();
    const data = await fs.readFile(configPath, "utf-8");
    return JSON.parse(data);
  } catch {
    return null;
  }
}
async function saveTunnelConfig(config) {
  const configDir = getConfigDir();
  const configPath = getConfigPath();
  await fs.mkdir(configDir, { recursive: true });
  await fs.writeFile(configPath, JSON.stringify(config, null, 2), "utf-8");
}
async function clearTunnelConfig() {
  try {
    const configPath = getConfigPath();
    await fs.unlink(configPath);
  } catch {
  }
}

// src/tunnel-adapter.ts
var DEFAULT_KEEP_ALIVE_INTERVAL_SECONDS = 5;
var DEFAULT_CONNECTION_TIMEOUT_MS = 3e4;
var NETWORK_CHECK_INTERVAL_MS = 5e3;
var MIN_RETRY_DELAY_MS = 1e3;
var DNS_TIMEOUT_MS = 5e3;
var SLEEP_WAKE_THRESHOLD_MS = 3e4;
var TUNNEL_LABEL = "copilot-tunnel-session";
var GITHUB_CLIENT_ID = "Iv1.e7b89e013f801f03";
var GITHUB_SCOPES = "read:user,read:org";
var GITHUB_DEVICE_CODE_URL = "https://github.com/login/device/code";
var GITHUB_TOKEN_URL = "https://github.com/login/oauth/access_token";
var DEVICE_CODE_POLL_INTERVAL_MS = 5e3;
var DevTunnelHostAdapter = class {
  config;
  server = null;
  tunnel = null;
  host = null;
  managementClient = null;
  clientHandlers = [];
  disconnectHandlers = [];
  clientCounter = 0;
  clients = /* @__PURE__ */ new Map();
  disconnectedClients = /* @__PURE__ */ new Set();
  // Track already-disconnected clients to avoid duplicate notifications
  isDisposed = false;
  username;
  hasEverConnected = false;
  // Track initial connection for logging
  // Disconnect tracking for reconnection context
  lastDisconnectReason;
  disconnectedAt;
  // Network monitoring state (runs when disconnected)
  lastNetworkInterfaces = "";
  networkCheckTimer = null;
  lastNetworkCheckTime = 0;
  // For sleep/wake detection
  isNetworkAvailable = true;
  retryCount = 0;
  // Sleep detection state (runs always to detect system wake)
  sleepDetectionTimer = null;
  lastSleepCheckTime = 0;
  // Log level filtering
  logLevel;
  constructor(config) {
    this.config = config;
    this.logLevel = config.logLevel ?? "info";
  }
  log(level, message) {
    if (level === "debug" && this.logLevel !== "debug") {
      return;
    }
    this.config.onLog?.(level, message);
  }
  // ===========================================================================
  // Network Monitoring & Reconnection
  // ===========================================================================
  /**
   * Get a fingerprint of current network interfaces.
   * Changes indicate network state changed (e.g., wifi reconnected).
   */
  getNetworkFingerprint() {
    const interfaces = os2.networkInterfaces();
    const addresses = [];
    for (const [name, addrs] of Object.entries(interfaces)) {
      if (!addrs) continue;
      for (const addr of addrs) {
        if (!addr.internal && addr.family === "IPv4") {
          addresses.push(`${name}:${addr.address}`);
        }
      }
    }
    return addresses.sort().join(",");
  }
  /**
   * Check if network is available by attempting DNS resolution with timeout.
   */
  async checkNetworkAvailable() {
    return new Promise((resolve3) => {
      const timeout = setTimeout(() => resolve3(false), DNS_TIMEOUT_MS);
      dns.resolve("github.com", (err) => {
        clearTimeout(timeout);
        resolve3(!err);
      });
    });
  }
  /**
   * Start monitoring network for changes and system sleep/wake events.
   * When network is restored or system wakes from sleep, resets retryCount
   * so the next SDK retry will happen faster.
   */
  startNetworkMonitoring() {
    if (this.networkCheckTimer) return;
    this.lastNetworkInterfaces = this.getNetworkFingerprint();
    this.lastNetworkCheckTime = Date.now();
    this.log("debug", "Started network monitoring");
    this.networkCheckTimer = setInterval(async () => {
      if (this.isDisposed) {
        this.stopNetworkMonitoring();
        return;
      }
      const now = Date.now();
      const elapsed = now - this.lastNetworkCheckTime;
      this.lastNetworkCheckTime = now;
      if (elapsed > SLEEP_WAKE_THRESHOLD_MS) {
        this.log("debug", `System wake detected (${Math.round(elapsed / 1e3)}s since last check)`);
        await this.handleSystemWake();
        return;
      }
      const currentFingerprint = this.getNetworkFingerprint();
      if (currentFingerprint !== this.lastNetworkInterfaces) {
        this.lastNetworkInterfaces = currentFingerprint;
        await this.handleNetworkChange();
      }
    }, NETWORK_CHECK_INTERVAL_MS);
  }
  /**
   * Handle detected network interface change.
   */
  async handleNetworkChange() {
    this.log("debug", "Network interfaces changed");
    const available = await this.checkNetworkAvailable();
    if (available && !this.isNetworkAvailable) {
      this.log("debug", "Network connectivity restored - next retry will be faster");
      this.isNetworkAvailable = true;
      this.retryCount = 0;
    }
    this.isNetworkAvailable = available;
  }
  /**
   * Handle system wake from sleep.
   * Forces a reconnection attempt by resetting retry state, regardless of
   * whether network interfaces changed (they often don't when waking to same WiFi).
   */
  async handleSystemWake() {
    this.lastNetworkInterfaces = this.getNetworkFingerprint();
    const available = await this.checkNetworkAvailable();
    if (available) {
      this.log("debug", "Network available after wake - triggering reconnection");
      this.isNetworkAvailable = true;
      this.retryCount = 0;
    } else {
      this.log("debug", "Network not yet available after wake");
      this.isNetworkAvailable = false;
    }
  }
  /**
   * Stop network monitoring.
   */
  stopNetworkMonitoring() {
    if (this.networkCheckTimer) {
      clearInterval(this.networkCheckTimer);
      this.networkCheckTimer = null;
      this.log("debug", "Stopped network monitoring");
    }
  }
  /**
   * Start always-on sleep detection.
   * This runs even when connected to detect system wake events that may have
   * left the connection in a stale state.
   */
  startSleepDetection() {
    if (this.sleepDetectionTimer) return;
    this.lastSleepCheckTime = Date.now();
    this.log("debug", "Started sleep detection");
    this.sleepDetectionTimer = setInterval(() => {
      if (this.isDisposed) {
        this.stopSleepDetection();
        return;
      }
      const now = Date.now();
      const elapsed = now - this.lastSleepCheckTime;
      this.lastSleepCheckTime = now;
      if (elapsed > SLEEP_WAKE_THRESHOLD_MS) {
        this.log("debug", `System wake detected (${Math.round(elapsed / 1e3)}s since last check)`);
        this.handleConnectedWake();
      }
    }, NETWORK_CHECK_INTERVAL_MS);
  }
  /**
   * Stop sleep detection.
   */
  stopSleepDetection() {
    if (this.sleepDetectionTimer) {
      clearInterval(this.sleepDetectionTimer);
      this.sleepDetectionTimer = null;
      this.log("debug", "Stopped sleep detection");
    }
  }
  /**
   * Handle system wake while tunnel is connected.
   * The underlying connection may be stale after sleep, so we trigger
   * a keepAlive to verify and potentially force reconnection.
   */
  handleConnectedWake() {
    const host = this.host;
    if (host?.sshSession?.sendKeepAlive) {
      this.log("debug", "Triggering keepAlive check after wake");
      try {
        host.sshSession.sendKeepAlive();
      } catch (err) {
        this.log("warn", `KeepAlive after wake failed: ${err}`);
      }
    }
  }
  /**
   * Handle connection status change from SDK.
   */
  handleConnectionStatusChange(status, reason) {
    if (status === "disconnected") {
      this.log("info", "Tunnel disconnected" + (reason ? ` (${reason})` : ""));
      this.log("info", "Reconnecting...");
      this.lastDisconnectReason = reason;
      this.disconnectedAt = Date.now();
      this.stopSleepDetection();
      this.startNetworkMonitoring();
      if (this.clients.size > 0) {
        this.log("debug", `Closing ${this.clients.size} orphaned client connection(s)`);
        for (const [clientId, socket] of this.clients) {
          this.disconnectedClients.add(clientId);
          socket.destroy();
        }
      }
    } else if (status === "connected") {
      if (this.hasEverConnected) {
        const parts = ["Tunnel reconnected"];
        if (this.disconnectedAt) {
          const downtime = Math.round((Date.now() - this.disconnectedAt) / 1e3);
          parts.push(`after ${downtime}s`);
        }
        const contextParts = [];
        if (this.lastDisconnectReason) {
          contextParts.push(this.lastDisconnectReason);
        }
        if (this.retryCount > 0) {
          contextParts.push(`${this.retryCount} ${this.retryCount === 1 ? "retry" : "retries"}`);
        }
        if (contextParts.length > 0) {
          parts.push(`(${contextParts.join(", ")})`);
        }
        this.log("info", parts.join(" "));
        this.lastDisconnectReason = void 0;
        this.disconnectedAt = void 0;
      } else {
        this.hasEverConnected = true;
      }
      this.stopNetworkMonitoring();
      this.startSleepDetection();
      this.retryCount = 0;
      this.isNetworkAvailable = true;
    } else {
      this.log("debug", `Tunnel status: ${status}`);
    }
    this.config.onStatusChange?.(status, reason);
  }
  /**
   * Handle SDK retry event - speed up the first retry after network restoration.
   */
  handleRetryEvent(e) {
    this.retryCount++;
    this.log("debug", `Retry #${this.retryCount} in ${e.delayMs}ms (${e.error.message})`);
    if (this.isNetworkAvailable && this.retryCount === 1) {
      const reducedDelay = Math.min(e.delayMs, MIN_RETRY_DELAY_MS);
      if (reducedDelay < e.delayMs) {
        this.log("debug", `Network available, reducing delay to ${reducedDelay}ms`);
        e.delayMs = reducedDelay;
      }
    }
  }
  /**
   * Check if an error indicates the tunnel doesn't exist (404).
   */
  isTunnelNotFoundError(error) {
    if (error instanceof Error) {
      const message = error.message.toLowerCase();
      return message.includes("404") || message.includes("not found") || message.includes("does not exist");
    }
    return false;
  }
  /**
   * Connect to the tunnel relay and set up event handlers.
   */
  async connectToTunnel(rpcPort) {
    if (!this.managementClient || !this.tunnel) {
      throw new Error("Management client or tunnel not initialized");
    }
    this.log("debug", "Connecting to tunnel relay...");
    this.host = new import_dev_tunnels_connections.TunnelRelayTunnelHost(this.managementClient);
    this.host.connectionStatusChanged((e) => {
      const reason = e.disconnectReason;
      this.handleConnectionStatusChange(e.status, reason);
    });
    this.host.refreshingTunnelAccessToken((e) => {
      this.log("debug", `Token refresh requested (scope: ${e.tunnelAccessScope})`);
    });
    this.host.retryingTunnelConnection((e) => {
      this.handleRetryEvent(e);
    });
    const connectionOptions = {
      keepAliveIntervalInSeconds: DEFAULT_KEEP_ALIVE_INTERVAL_SECONDS,
      enableRetry: true,
      enableReconnect: true
    };
    await this.connectWithTimeout(connectionOptions, DEFAULT_CONNECTION_TIMEOUT_MS);
    this.setupHostKeepAlive();
  }
  /**
   * Workaround for Dev Tunnels SDK bug: manually configure keepAlive on the host's SSH session.
   * The SDK only configures keepAlive for clienthost sessions, not hostrelay sessions.
   */
  setupHostKeepAlive() {
    const sshSession = this.host?.sshSession;
    if (!sshSession?.config || !sshSession.startKeepAliveTimer) {
      this.log("warn", "Unable to configure host keepAlive - sshSession not accessible");
      return;
    }
    sshSession.config.keepAliveTimeoutInSeconds = DEFAULT_KEEP_ALIVE_INTERVAL_SECONDS;
    sshSession.onKeepAliveSucceeded?.(() => {
      this.log("debug", `KeepAlive success (count: ${sshSession.keepAliveSuccessCount})`);
    });
    sshSession.onKeepAliveFailed?.(() => {
      const failureCount = sshSession.keepAliveFailureCount ?? 0;
      this.log("debug", `KeepAlive failed (count: ${failureCount})`);
      if (failureCount === 3) {
        this.log("debug", "Multiple keepAlive failures - connection stale");
        if (this.clients.size > 0) {
          this.log("debug", `Closing ${this.clients.size} client connection(s) due to stale tunnel`);
          for (const [clientId, socket] of this.clients) {
            if (!this.disconnectedClients.has(clientId)) {
              this.disconnectedClients.add(clientId);
              socket.destroy();
            }
          }
        }
      }
    });
    sshSession.startKeepAliveTimer();
    this.log("debug", `Host keepAlive configured (interval: ${DEFAULT_KEEP_ALIVE_INTERVAL_SECONDS}s)`);
  }
  async start() {
    if (this.server) {
      throw new Error("Tunnel adapter already started");
    }
    this.log("debug", "Creating local TCP server...");
    this.server = await this.createServer();
    const rpcPort = this.server.address().port;
    this.log("debug", `Local JSON-RPC server listening on port ${rpcPort}`);
    const githubToken = await this.getOrRefreshToken();
    this.log("debug", "Creating tunnel management client...");
    this.managementClient = new import_dev_tunnels_management.TunnelManagementHttpClient(
      "RemoteSdkBridge/1.0",
      import_dev_tunnels_management.ManagementApiVersions.Version20230927preview,
      () => Promise.resolve(`github ${githubToken}`)
    );
    const storedConfig = await loadTunnelConfig();
    if (storedConfig) {
      this.log("info", `Found stored tunnel: ${storedConfig.tunnelId}`);
      try {
        const tunnelRequest = {
          tunnelId: storedConfig.tunnelId,
          clusterId: storedConfig.clusterId
        };
        this.tunnel = await this.managementClient.getTunnel(tunnelRequest, {
          tokenScopes: [import_dev_tunnels_contracts.TunnelAccessScopes.Host, import_dev_tunnels_contracts.TunnelAccessScopes.Connect],
          includePorts: true
        });
        if (this.tunnel) {
          if (this.tunnel.ports && this.tunnel.ports.length > 0) {
            for (const port of this.tunnel.ports) {
              if (port.portNumber) {
                this.log("debug", `Removing old port ${port.portNumber} from tunnel`);
                try {
                  await this.managementClient.deleteTunnelPort(this.tunnel, port.portNumber);
                } catch {
                }
              }
            }
          }
          this.log("debug", `Adding port ${rpcPort} to tunnel`);
          await this.managementClient.createTunnelPort(this.tunnel, {
            portNumber: rpcPort,
            protocol: "auto"
          });
          this.tunnel = await this.managementClient.getTunnel(this.tunnel, {
            tokenScopes: [import_dev_tunnels_contracts.TunnelAccessScopes.Host, import_dev_tunnels_contracts.TunnelAccessScopes.Connect],
            includePorts: true
          });
          this.log("debug", "Connecting to existing tunnel...");
          await this.connectToTunnel(rpcPort);
          this.log("info", "Connected to existing tunnel");
          return {
            tunnelId: this.tunnel.tunnelId,
            clusterId: this.tunnel.clusterId,
            port: rpcPort,
            username: this.username
          };
        }
      } catch (error) {
        if (this.isTunnelNotFoundError(error)) {
          this.log("info", "Stored tunnel no longer exists");
          await clearTunnelConfig();
        } else {
          throw error;
        }
      }
    }
    this.log("info", "Searching for existing tunnel by label...");
    const labeledTunnels = await this.managementClient.listTunnels(
      void 0,
      // global search (no cluster filter)
      void 0,
      // default domain
      { labels: [TUNNEL_LABEL] }
    );
    if (labeledTunnels.length > 0) {
      labeledTunnels.sort(
        (a, b) => new Date(b.created ?? 0).getTime() - new Date(a.created ?? 0).getTime()
      );
      const foundTunnel = labeledTunnels[0];
      this.log("info", `Found existing tunnel via label: ${foundTunnel.tunnelId}`);
      this.tunnel = await this.managementClient.getTunnel(
        { tunnelId: foundTunnel.tunnelId, clusterId: foundTunnel.clusterId },
        { tokenScopes: [import_dev_tunnels_contracts.TunnelAccessScopes.Host, import_dev_tunnels_contracts.TunnelAccessScopes.Connect], includePorts: true }
      );
      if (!this.tunnel) {
        throw new Error("Failed to fetch tunnel details");
      }
      if (this.tunnel.ports && this.tunnel.ports.length > 0) {
        for (const port of this.tunnel.ports) {
          if (port.portNumber) {
            this.log("debug", `Removing old port ${port.portNumber} from tunnel`);
            try {
              await this.managementClient.deleteTunnelPort(this.tunnel, port.portNumber);
            } catch {
            }
          }
        }
      }
      this.log("debug", `Adding port ${rpcPort} to tunnel`);
      await this.managementClient.createTunnelPort(this.tunnel, {
        portNumber: rpcPort,
        protocol: "auto"
      });
      this.tunnel = await this.managementClient.getTunnel(this.tunnel, {
        tokenScopes: [import_dev_tunnels_contracts.TunnelAccessScopes.Host, import_dev_tunnels_contracts.TunnelAccessScopes.Connect],
        includePorts: true
      });
      if (!this.tunnel) {
        throw new Error("Failed to refresh tunnel details");
      }
      await saveTunnelConfig({
        tunnelId: this.tunnel.tunnelId,
        clusterId: this.tunnel.clusterId,
        createdAt: (/* @__PURE__ */ new Date()).toISOString()
      });
      this.log("debug", "Tunnel config saved");
      this.log("debug", "Connecting to existing tunnel...");
      await this.connectToTunnel(rpcPort);
      this.log("info", "Connected to existing tunnel");
      return {
        tunnelId: this.tunnel.tunnelId,
        clusterId: this.tunnel.clusterId,
        port: rpcPort,
        username: this.username
      };
    }
    this.log("info", "Creating new tunnel...");
    const tunnelConfig = {
      labels: [TUNNEL_LABEL],
      ports: [
        { portNumber: rpcPort, protocol: "auto" }
      ]
    };
    this.tunnel = await this.managementClient.createTunnel(tunnelConfig, {
      tokenScopes: [import_dev_tunnels_contracts.TunnelAccessScopes.Host, import_dev_tunnels_contracts.TunnelAccessScopes.Connect],
      includePorts: true
    });
    this.log("info", `Tunnel created: ${this.tunnel.tunnelId} (cluster: ${this.tunnel.clusterId})`);
    await saveTunnelConfig({
      tunnelId: this.tunnel.tunnelId,
      clusterId: this.tunnel.clusterId,
      createdAt: (/* @__PURE__ */ new Date()).toISOString()
    });
    this.log("debug", "Tunnel config saved");
    await this.connectToTunnel(rpcPort);
    this.log("info", "Tunnel connected");
    return {
      tunnelId: this.tunnel.tunnelId,
      clusterId: this.tunnel.clusterId,
      port: rpcPort,
      username: this.username
    };
  }
  async stop() {
    this.isDisposed = true;
    this.stopNetworkMonitoring();
    this.stopSleepDetection();
    for (const [clientId, socket] of this.clients) {
      if (!this.disconnectedClients.has(clientId)) {
        this.disconnectedClients.add(clientId);
        socket.destroy();
        this.disconnectHandlers.forEach((h) => h(clientId));
      }
    }
    this.clients.clear();
    if (this.host) {
      await this.host.dispose();
      this.host = null;
    }
    this.tunnel = null;
    this.managementClient = null;
    if (this.server) {
      await new Promise((resolve3) => {
        this.server.close(() => resolve3());
      });
      this.server = null;
    }
    this.disconnectedClients.clear();
  }
  onClientConnected(handler) {
    this.clientHandlers.push(handler);
    return () => {
      const index = this.clientHandlers.indexOf(handler);
      if (index !== -1) {
        this.clientHandlers.splice(index, 1);
      }
    };
  }
  onClientDisconnected(handler) {
    this.disconnectHandlers.push(handler);
    return () => {
      const index = this.disconnectHandlers.indexOf(handler);
      if (index !== -1) {
        this.disconnectHandlers.splice(index, 1);
      }
    };
  }
  createServer() {
    return new Promise((resolve3, reject) => {
      const server = net.createServer((socket) => {
        if (this.isDisposed) {
          socket.destroy();
          return;
        }
        const clientId = `client-${++this.clientCounter}`;
        this.clients.set(clientId, socket);
        this.log("debug", `Client ${clientId} connected (total clients: ${this.clients.size})`);
        this.clientHandlers.forEach((h) => h(socket, clientId));
        socket.on("close", (hadError) => {
          if (this.disconnectedClients.has(clientId)) {
            this.log("debug", `Client ${clientId} already notified, skipping duplicate close event`);
            this.clients.delete(clientId);
            return;
          }
          this.disconnectedClients.add(clientId);
          const reason = hadError ? "connection_error" : "remote_closed";
          this.log("debug", `Client ${clientId} disconnected (${reason})`);
          this.clients.delete(clientId);
          this.disconnectHandlers.forEach((h) => h(clientId));
        });
        socket.on("error", (err) => {
          if (this.disconnectedClients.has(clientId)) {
            this.log("debug", `Client ${clientId} already notified, skipping duplicate error event`);
            return;
          }
          this.disconnectedClients.add(clientId);
          this.log("warn", `Client ${clientId} socket error: ${err.message}`);
          this.clients.delete(clientId);
          this.disconnectHandlers.forEach((h) => h(clientId));
        });
      });
      server.on("error", reject);
      server.listen(this.config.port || 0, () => {
        resolve3(server);
      });
    });
  }
  async connectWithTimeout(options, timeoutMs) {
    if (!this.host || !this.tunnel) {
      throw new Error("Host or tunnel not initialized");
    }
    const timeoutPromise = new Promise((_, reject) => {
      setTimeout(() => reject(new Error(`Connection timeout after ${timeoutMs}ms`)), timeoutMs);
    });
    await Promise.race([this.host.connect(this.tunnel, options), timeoutPromise]);
  }
  /**
   * Get a valid GitHub token, either from cache, refresh, or device flow.
   * Checks token expiration before use and refreshes if needed.
   * Also sets this.username for display purposes.
   */
  async getOrRefreshToken() {
    this.log("debug", "Checking for cached GitHub token...");
    let tokenData = await loadTokenData();
    const now = Date.now();
    if (tokenData) {
      const accessTokenExpired = tokenData.expiresAt < now + 5 * 60 * 1e3;
      const refreshTokenExpired = tokenData.refreshExpiresAt < now + 5 * 60 * 1e3;
      this.log("debug", `Access token expired: ${accessTokenExpired}, refresh token expired: ${refreshTokenExpired}`);
      if (!accessTokenExpired) {
        if (tokenData.username) {
          this.username = tokenData.username;
        } else {
          this.log("debug", "Fetching username for stored token...");
          this.username = await this.fetchGitHubUsername(tokenData.accessToken);
          if (this.username) {
            tokenData.username = this.username;
            await saveTokenData(tokenData);
          }
        }
        this.log("debug", "Cached access token is still valid");
        return tokenData.accessToken;
      }
      if (accessTokenExpired && !refreshTokenExpired && tokenData.refreshToken) {
        this.log("debug", "Access token expired, attempting refresh...");
        try {
          const oldUsername = tokenData.username;
          tokenData = await this.refreshAccessToken(tokenData.refreshToken);
          tokenData.username = oldUsername;
          await saveTokenData(tokenData);
          this.username = oldUsername;
          this.log("debug", "Token refreshed successfully");
          return tokenData.accessToken;
        } catch (refreshErr) {
          this.log("warn", `Token refresh failed: ${refreshErr}`);
          await clearTokenData();
          tokenData = null;
        }
      } else {
        this.log("debug", "Both tokens expired, clearing and re-authenticating...");
        await clearTokenData();
        tokenData = null;
      }
    }
    this.log("info", "No stored credentials found");
    tokenData = await this.authenticateWithDeviceFlow();
    this.username = await this.fetchGitHubUsername(tokenData.accessToken);
    tokenData.username = this.username;
    this.log("debug", "Saving token data to secure storage...");
    await saveTokenData(tokenData);
    this.log("info", `Authenticated as: ${this.username ?? "unknown"}`);
    return tokenData.accessToken;
  }
  /**
   * Refresh an access token using a refresh token.
   */
  async refreshAccessToken(refreshToken) {
    const response = await fetch(GITHUB_TOKEN_URL, {
      method: "POST",
      headers: {
        Accept: "application/json",
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        client_id: GITHUB_CLIENT_ID,
        refresh_token: refreshToken,
        grant_type: "refresh_token"
      })
    });
    if (!response.ok) {
      throw new Error(`Failed to refresh token: ${response.statusText}`);
    }
    const token = await response.json();
    if (token.error) {
      throw new Error(`Token refresh error: ${token.error_description || token.error}`);
    }
    if (!token.access_token) {
      throw new Error("Token refresh failed: no access token in response");
    }
    const now = Date.now();
    return {
      accessToken: token.access_token,
      refreshToken: token.refresh_token || refreshToken,
      // May or may not return new refresh token
      expiresAt: now + (token.expires_in || 28800) * 1e3,
      refreshExpiresAt: now + (token.refresh_token_expires_in || 15638400) * 1e3
    };
  }
  /**
   * Validate a GitHub token by making a test API call.
   * Returns true if the token is valid, false otherwise.
   */
  async validateToken(token) {
    try {
      const response = await fetch("https://api.github.com/user", {
        headers: {
          Authorization: `Bearer ${token}`,
          Accept: "application/vnd.github.v3+json",
          "User-Agent": "AgentTunnels/1.0"
        }
      });
      if (response.ok) {
        return true;
      }
      if (response.status === 401) {
        return false;
      }
      this.log("warn", `Token validation returned ${response.status}, assuming valid`);
      return true;
    } catch (error) {
      this.log("warn", `Token validation failed with network error, assuming valid`);
      return true;
    }
  }
  /**
   * Fetch the GitHub username for the given token.
   * Returns undefined if the fetch fails.
   */
  async fetchGitHubUsername(token) {
    try {
      const response = await fetch("https://api.github.com/user", {
        headers: {
          Authorization: `Bearer ${token}`,
          Accept: "application/vnd.github.v3+json",
          "User-Agent": "AgentTunnels/1.0"
        }
      });
      if (response.ok) {
        const user = await response.json();
        return user.login;
      }
      return void 0;
    } catch {
      return void 0;
    }
  }
  /**
   * Clear the stored token. Call this when the server reports an auth error.
   */
  async clearStoredToken() {
    this.log("info", "Clearing stored token due to auth error");
    await clearTokenData();
  }
  /**
   * Authenticate using GitHub device code flow.
   * This allows users to authenticate without providing a token upfront.
   */
  async authenticateWithDeviceFlow() {
    this.log("debug", "Requesting device code from GitHub...");
    const deviceCodeResponse = await fetch(GITHUB_DEVICE_CODE_URL, {
      method: "POST",
      headers: {
        Accept: "application/json",
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        client_id: GITHUB_CLIENT_ID,
        scope: GITHUB_SCOPES
      })
    });
    if (!deviceCodeResponse.ok) {
      throw new Error(`Failed to get device code: ${deviceCodeResponse.statusText}`);
    }
    const deviceCode = await deviceCodeResponse.json();
    this.log("debug", `Device code received, user code: ${deviceCode.user_code}`);
    this.config.onAuth?.(
      "GitHub authentication required",
      deviceCode.verification_uri,
      deviceCode.user_code
    );
    this.log("debug", "Waiting for user to complete authentication...");
    const pollInterval = Math.max(deviceCode.interval * 1e3, DEVICE_CODE_POLL_INTERVAL_MS);
    const pollExpiresAt = Date.now() + deviceCode.expires_in * 1e3;
    while (Date.now() < pollExpiresAt) {
      await this.sleep(pollInterval);
      const tokenResponse = await fetch(GITHUB_TOKEN_URL, {
        method: "POST",
        headers: {
          Accept: "application/json",
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          client_id: GITHUB_CLIENT_ID,
          device_code: deviceCode.device_code,
          grant_type: "urn:ietf:params:oauth:grant-type:device_code"
        })
      });
      if (!tokenResponse.ok) {
        throw new Error(`Failed to poll for token: ${tokenResponse.statusText}`);
      }
      const token = await tokenResponse.json();
      if (token.access_token) {
        this.log("debug", "GitHub authentication completed successfully");
        const now = Date.now();
        return {
          accessToken: token.access_token,
          refreshToken: token.refresh_token || "",
          expiresAt: now + (token.expires_in || 28800) * 1e3,
          refreshExpiresAt: now + (token.refresh_token_expires_in || 15638400) * 1e3
        };
      }
      if (token.error === "authorization_pending") {
        this.log("debug", "Authorization pending, continuing to poll...");
        continue;
      }
      if (token.error === "slow_down") {
        this.log("debug", "Rate limited, slowing down polling...");
        await this.sleep(5e3);
        continue;
      }
      if (token.error === "expired_token") {
        throw new Error("Device code expired. Please try again.");
      }
      if (token.error === "access_denied") {
        throw new Error("Authentication was denied.");
      }
      if (token.error) {
        throw new Error(`Authentication error: ${token.error_description || token.error}`);
      }
    }
    throw new Error("Device code expired before authentication completed.");
  }
  sleep(ms) {
    return new Promise((resolve3) => setTimeout(resolve3, ms));
  }
};
function createTunnelHostAdapter(config) {
  return new DevTunnelHostAdapter(config);
}

// ../../node_modules/@github/copilot-sdk/dist/client.js
var import_node_child_process = require("child_process");
var import_node_net = require("net");
var import_node = __toESM(require_node3(), 1);

// ../../node_modules/@github/copilot-sdk/dist/sdkProtocolVersion.js
var SDK_PROTOCOL_VERSION = 2;
function getSdkProtocolVersion() {
  return SDK_PROTOCOL_VERSION;
}

// ../../node_modules/@github/copilot-sdk/dist/session.js
var CopilotSession = class {
  /**
   * Creates a new CopilotSession instance.
   *
   * @param sessionId - The unique identifier for this session
   * @param connection - The JSON-RPC message connection to the Copilot CLI
   * @internal This constructor is internal. Use {@link CopilotClient.createSession} to create sessions.
   */
  constructor(sessionId, connection) {
    this.sessionId = sessionId;
    this.connection = connection;
  }
  eventHandlers = /* @__PURE__ */ new Set();
  toolHandlers = /* @__PURE__ */ new Map();
  permissionHandler;
  /**
   * Sends a message to this session and waits for the response.
   *
   * The message is processed asynchronously. Subscribe to events via {@link on}
   * to receive streaming responses and other session events.
   *
   * @param options - The message options including the prompt and optional attachments
   * @returns A promise that resolves with the message ID of the response
   * @throws Error if the session has been destroyed or the connection fails
   *
   * @example
   * ```typescript
   * const messageId = await session.send({
   *   prompt: "Explain this code",
   *   attachments: [{ type: "file", path: "./src/index.ts" }]
   * });
   * ```
   */
  async send(options) {
    const response = await this.connection.sendRequest("session.send", {
      sessionId: this.sessionId,
      prompt: options.prompt,
      attachments: options.attachments,
      mode: options.mode
    });
    return response.messageId;
  }
  /**
   * Sends a message to this session and waits until the session becomes idle.
   *
   * This is a convenience method that combines {@link send} with waiting for
   * the `session.idle` event. Use this when you want to block until the
   * assistant has finished processing the message.
   *
   * Events are still delivered to handlers registered via {@link on} while waiting.
   *
   * @param options - The message options including the prompt and optional attachments
   * @param timeout - Timeout in milliseconds (default: 60000). Controls how long to wait; does not abort in-flight agent work.
   * @returns A promise that resolves with the final assistant message when the session becomes idle,
   *          or undefined if no assistant message was received
   * @throws Error if the timeout is reached before the session becomes idle
   * @throws Error if the session has been destroyed or the connection fails
   *
   * @example
   * ```typescript
   * // Send and wait for completion with default 60s timeout
   * const response = await session.sendAndWait({ prompt: "What is 2+2?" });
   * console.log(response?.data.content); // "4"
   * ```
   */
  async sendAndWait(options, timeout) {
    const effectiveTimeout = timeout ?? 6e4;
    let resolveIdle;
    let rejectWithError;
    const idlePromise = new Promise((resolve3, reject) => {
      resolveIdle = resolve3;
      rejectWithError = reject;
    });
    let lastAssistantMessage;
    const unsubscribe = this.on((event) => {
      if (event.type === "assistant.message") {
        lastAssistantMessage = event;
      } else if (event.type === "session.idle") {
        resolveIdle();
      } else if (event.type === "session.error") {
        const error = new Error(event.data.message);
        error.stack = event.data.stack;
        rejectWithError(error);
      }
    });
    try {
      await this.send(options);
      const timeoutPromise = new Promise((_, reject) => {
        setTimeout(
          () => reject(
            new Error(
              `Timeout after ${effectiveTimeout}ms waiting for session.idle`
            )
          ),
          effectiveTimeout
        );
      });
      await Promise.race([idlePromise, timeoutPromise]);
      return lastAssistantMessage;
    } finally {
      unsubscribe();
    }
  }
  /**
   * Subscribes to events from this session.
   *
   * Events include assistant messages, tool executions, errors, and session state changes.
   * Multiple handlers can be registered and will all receive events.
   *
   * @param handler - A callback function that receives session events
   * @returns A function that, when called, unsubscribes the handler
   *
   * @example
   * ```typescript
   * const unsubscribe = session.on((event) => {
   *   switch (event.type) {
   *     case "assistant.message":
   *       console.log("Assistant:", event.data.content);
   *       break;
   *     case "session.error":
   *       console.error("Error:", event.data.message);
   *       break;
   *   }
   * });
   *
   * // Later, to stop receiving events:
   * unsubscribe();
   * ```
   */
  on(handler) {
    this.eventHandlers.add(handler);
    return () => {
      this.eventHandlers.delete(handler);
    };
  }
  /**
   * Dispatches an event to all registered handlers.
   *
   * @param event - The session event to dispatch
   * @internal This method is for internal use by the SDK.
   */
  _dispatchEvent(event) {
    for (const handler of this.eventHandlers) {
      try {
        handler(event);
      } catch (_error) {
      }
    }
  }
  /**
   * Registers custom tool handlers for this session.
   *
   * Tools allow the assistant to execute custom functions. When the assistant
   * invokes a tool, the corresponding handler is called with the tool arguments.
   *
   * @param tools - An array of tool definitions with their handlers, or undefined to clear all tools
   * @internal This method is typically called internally when creating a session with tools.
   */
  registerTools(tools) {
    this.toolHandlers.clear();
    if (!tools) {
      return;
    }
    for (const tool of tools) {
      this.toolHandlers.set(tool.name, tool.handler);
    }
  }
  /**
   * Retrieves a registered tool handler by name.
   *
   * @param name - The name of the tool to retrieve
   * @returns The tool handler if found, or undefined
   * @internal This method is for internal use by the SDK.
   */
  getToolHandler(name) {
    return this.toolHandlers.get(name);
  }
  /**
   * Registers a handler for permission requests.
   *
   * When the assistant needs permission to perform certain actions (e.g., file operations),
   * this handler is called to approve or deny the request.
   *
   * @param handler - The permission handler function, or undefined to remove the handler
   * @internal This method is typically called internally when creating a session.
   */
  registerPermissionHandler(handler) {
    this.permissionHandler = handler;
  }
  /**
   * Handles a permission request from the Copilot CLI.
   *
   * @param request - The permission request data from the CLI
   * @returns A promise that resolves with the permission decision
   * @internal This method is for internal use by the SDK.
   */
  async _handlePermissionRequest(request) {
    if (!this.permissionHandler) {
      return { kind: "denied-no-approval-rule-and-could-not-request-from-user" };
    }
    try {
      const result = await this.permissionHandler(request, {
        sessionId: this.sessionId
      });
      return result;
    } catch (_error) {
      return { kind: "denied-no-approval-rule-and-could-not-request-from-user" };
    }
  }
  /**
   * Retrieves all events and messages from this session's history.
   *
   * This returns the complete conversation history including user messages,
   * assistant responses, tool executions, and other session events.
   *
   * @returns A promise that resolves with an array of all session events
   * @throws Error if the session has been destroyed or the connection fails
   *
   * @example
   * ```typescript
   * const events = await session.getMessages();
   * for (const event of events) {
   *   if (event.type === "assistant.message") {
   *     console.log("Assistant:", event.data.content);
   *   }
   * }
   * ```
   */
  async getMessages() {
    const response = await this.connection.sendRequest("session.getMessages", {
      sessionId: this.sessionId
    });
    return response.events;
  }
  /**
   * Destroys this session and releases all associated resources.
   *
   * After calling this method, the session can no longer be used. All event
   * handlers and tool handlers are cleared. To continue the conversation,
   * use {@link CopilotClient.resumeSession} with the session ID.
   *
   * @returns A promise that resolves when the session is destroyed
   * @throws Error if the connection fails
   *
   * @example
   * ```typescript
   * // Clean up when done
   * await session.destroy();
   * ```
   */
  async destroy() {
    await this.connection.sendRequest("session.destroy", {
      sessionId: this.sessionId
    });
    this.eventHandlers.clear();
    this.toolHandlers.clear();
    this.permissionHandler = void 0;
  }
  /**
   * Aborts the currently processing message in this session.
   *
   * Use this to cancel a long-running request. The session remains valid
   * and can continue to be used for new messages.
   *
   * @returns A promise that resolves when the abort request is acknowledged
   * @throws Error if the session has been destroyed or the connection fails
   *
   * @example
   * ```typescript
   * // Start a long-running request
   * const messagePromise = session.send({ prompt: "Write a very long story..." });
   *
   * // Abort after 5 seconds
   * setTimeout(async () => {
   *   await session.abort();
   * }, 5000);
   * ```
   */
  async abort() {
    await this.connection.sendRequest("session.abort", {
      sessionId: this.sessionId
    });
  }
};

// ../../node_modules/@github/copilot-sdk/dist/client.js
function isZodSchema(value) {
  return value != null && typeof value === "object" && "toJSONSchema" in value && typeof value.toJSONSchema === "function";
}
function toJsonSchema(parameters) {
  if (!parameters) return void 0;
  if (isZodSchema(parameters)) {
    return parameters.toJSONSchema();
  }
  return parameters;
}
var CopilotClient = class {
  cliProcess = null;
  connection = null;
  socket = null;
  actualPort = null;
  actualHost = "localhost";
  state = "disconnected";
  sessions = /* @__PURE__ */ new Map();
  options;
  isExternalServer = false;
  forceStopping = false;
  /**
   * Creates a new CopilotClient instance.
   *
   * @param options - Configuration options for the client
   * @throws Error if mutually exclusive options are provided (e.g., cliUrl with useStdio or cliPath)
   *
   * @example
   * ```typescript
   * // Default options - spawns CLI server using stdio
   * const client = new CopilotClient();
   *
   * // Connect to an existing server
   * const client = new CopilotClient({ cliUrl: "localhost:3000" });
   *
   * // Custom CLI path with specific log level
   * const client = new CopilotClient({
   *   cliPath: "/usr/local/bin/copilot",
   *   logLevel: "debug"
   * });
   * ```
   */
  constructor(options = {}) {
    if (options.cliUrl && (options.useStdio === true || options.cliPath)) {
      throw new Error("cliUrl is mutually exclusive with useStdio and cliPath");
    }
    if (options.cliUrl) {
      const { host, port } = this.parseCliUrl(options.cliUrl);
      this.actualHost = host;
      this.actualPort = port;
      this.isExternalServer = true;
    }
    this.options = {
      cliPath: options.cliPath || "copilot",
      cliArgs: options.cliArgs ?? [],
      cwd: options.cwd ?? process.cwd(),
      port: options.port || 0,
      useStdio: options.cliUrl ? false : options.useStdio ?? true,
      // Default to stdio unless cliUrl is provided
      cliUrl: options.cliUrl,
      logLevel: options.logLevel || "debug",
      autoStart: options.autoStart ?? true,
      autoRestart: options.autoRestart ?? true,
      env: options.env ?? process.env
    };
  }
  /**
   * Parse CLI URL into host and port
   * Supports formats: "host:port", "http://host:port", "https://host:port", or just "port"
   */
  parseCliUrl(url) {
    let cleanUrl = url.replace(/^https?:\/\//, "");
    if (/^\d+$/.test(cleanUrl)) {
      return { host: "localhost", port: parseInt(cleanUrl, 10) };
    }
    const parts = cleanUrl.split(":");
    if (parts.length !== 2) {
      throw new Error(
        `Invalid cliUrl format: ${url}. Expected "host:port", "http://host:port", or "port"`
      );
    }
    const host = parts[0] || "localhost";
    const port = parseInt(parts[1], 10);
    if (isNaN(port) || port <= 0 || port > 65535) {
      throw new Error(`Invalid port in cliUrl: ${url}`);
    }
    return { host, port };
  }
  /**
   * Starts the CLI server and establishes a connection.
   *
   * If connecting to an external server (via cliUrl), only establishes the connection.
   * Otherwise, spawns the CLI server process and then connects.
   *
   * This method is called automatically when creating a session if `autoStart` is true (default).
   *
   * @returns A promise that resolves when the connection is established
   * @throws Error if the server fails to start or the connection fails
   *
   * @example
   * ```typescript
   * const client = new CopilotClient({ autoStart: false });
   * await client.start();
   * // Now ready to create sessions
   * ```
   */
  async start() {
    if (this.state === "connected") {
      return;
    }
    this.state = "connecting";
    try {
      if (!this.isExternalServer) {
        await this.startCLIServer();
      }
      await this.connectToServer();
      await this.verifyProtocolVersion();
      this.state = "connected";
    } catch (error) {
      this.state = "error";
      throw error;
    }
  }
  /**
   * Stops the CLI server and closes all active sessions.
   *
   * This method performs graceful cleanup:
   * 1. Destroys all active sessions with retry logic
   * 2. Closes the JSON-RPC connection
   * 3. Terminates the CLI server process (if spawned by this client)
   *
   * @returns A promise that resolves with an array of errors encountered during cleanup.
   *          An empty array indicates all cleanup succeeded.
   *
   * @example
   * ```typescript
   * const errors = await client.stop();
   * if (errors.length > 0) {
   *   console.error("Cleanup errors:", errors);
   * }
   * ```
   */
  async stop() {
    const errors = [];
    for (const session of this.sessions.values()) {
      const sessionId = session.sessionId;
      let lastError = null;
      for (let attempt = 1; attempt <= 3; attempt++) {
        try {
          await session.destroy();
          lastError = null;
          break;
        } catch (error) {
          lastError = error instanceof Error ? error : new Error(String(error));
          if (attempt < 3) {
            const delay = 100 * Math.pow(2, attempt - 1);
            await new Promise((resolve3) => setTimeout(resolve3, delay));
          }
        }
      }
      if (lastError) {
        errors.push(
          new Error(
            `Failed to destroy session ${sessionId} after 3 attempts: ${lastError.message}`
          )
        );
      }
    }
    this.sessions.clear();
    if (this.connection) {
      try {
        this.connection.dispose();
      } catch (error) {
        errors.push(
          new Error(
            `Failed to dispose connection: ${error instanceof Error ? error.message : String(error)}`
          )
        );
      }
      this.connection = null;
    }
    if (this.socket) {
      try {
        this.socket.end();
      } catch (error) {
        errors.push(
          new Error(
            `Failed to close socket: ${error instanceof Error ? error.message : String(error)}`
          )
        );
      }
      this.socket = null;
    }
    if (this.cliProcess && !this.isExternalServer) {
      try {
        this.cliProcess.kill();
      } catch (error) {
        errors.push(
          new Error(
            `Failed to kill CLI process: ${error instanceof Error ? error.message : String(error)}`
          )
        );
      }
      this.cliProcess = null;
    }
    this.state = "disconnected";
    this.actualPort = null;
    return errors;
  }
  /**
   * Forcefully stops the CLI server without graceful cleanup.
   *
   * Use this when {@link stop} fails or takes too long. This method:
   * - Clears all sessions immediately without destroying them
   * - Force closes the connection
   * - Sends SIGKILL to the CLI process (if spawned by this client)
   *
   * @returns A promise that resolves when the force stop is complete
   *
   * @example
   * ```typescript
   * // If normal stop hangs, force stop
   * const stopPromise = client.stop();
   * const timeout = new Promise((_, reject) =>
   *   setTimeout(() => reject(new Error("Timeout")), 5000)
   * );
   *
   * try {
   *   await Promise.race([stopPromise, timeout]);
   * } catch {
   *   await client.forceStop();
   * }
   * ```
   */
  async forceStop() {
    this.forceStopping = true;
    this.sessions.clear();
    if (this.connection) {
      try {
        this.connection.dispose();
      } catch {
      }
      this.connection = null;
    }
    if (this.socket) {
      try {
        this.socket.destroy();
      } catch {
      }
      this.socket = null;
    }
    if (this.cliProcess && !this.isExternalServer) {
      try {
        this.cliProcess.kill("SIGKILL");
      } catch {
      }
      this.cliProcess = null;
    }
    this.state = "disconnected";
    this.actualPort = null;
  }
  /**
   * Creates a new conversation session with the Copilot CLI.
   *
   * Sessions maintain conversation state, handle events, and manage tool execution.
   * If the client is not connected and `autoStart` is enabled, this will automatically
   * start the connection.
   *
   * @param config - Optional configuration for the session
   * @returns A promise that resolves with the created session
   * @throws Error if the client is not connected and autoStart is disabled
   *
   * @example
   * ```typescript
   * // Basic session
   * const session = await client.createSession();
   *
   * // Session with model and tools
   * const session = await client.createSession({
   *   model: "gpt-4",
   *   tools: [{
   *     name: "get_weather",
   *     description: "Get weather for a location",
   *     parameters: { type: "object", properties: { location: { type: "string" } } },
   *     handler: async (args) => ({ temperature: 72 })
   *   }]
   * });
   * ```
   */
  async createSession(config = {}) {
    if (!this.connection) {
      if (this.options.autoStart) {
        await this.start();
      } else {
        throw new Error("Client not connected. Call start() first.");
      }
    }
    const response = await this.connection.sendRequest("session.create", {
      model: config.model,
      sessionId: config.sessionId,
      tools: config.tools?.map((tool) => ({
        name: tool.name,
        description: tool.description,
        parameters: toJsonSchema(tool.parameters)
      })),
      systemMessage: config.systemMessage,
      availableTools: config.availableTools,
      excludedTools: config.excludedTools,
      provider: config.provider,
      requestPermission: !!config.onPermissionRequest,
      streaming: config.streaming,
      mcpServers: config.mcpServers,
      customAgents: config.customAgents,
      configDir: config.configDir,
      skillDirectories: config.skillDirectories,
      disabledSkills: config.disabledSkills
    });
    const sessionId = response.sessionId;
    const session = new CopilotSession(sessionId, this.connection);
    session.registerTools(config.tools);
    if (config.onPermissionRequest) {
      session.registerPermissionHandler(config.onPermissionRequest);
    }
    this.sessions.set(sessionId, session);
    return session;
  }
  /**
   * Resumes an existing conversation session by its ID.
   *
   * This allows you to continue a previous conversation, maintaining all
   * conversation history. The session must have been previously created
   * and not deleted.
   *
   * @param sessionId - The ID of the session to resume
   * @param config - Optional configuration for the resumed session
   * @returns A promise that resolves with the resumed session
   * @throws Error if the session does not exist or the client is not connected
   *
   * @example
   * ```typescript
   * // Resume a previous session
   * const session = await client.resumeSession("session-123");
   *
   * // Resume with new tools
   * const session = await client.resumeSession("session-123", {
   *   tools: [myNewTool]
   * });
   * ```
   */
  async resumeSession(sessionId, config = {}) {
    if (!this.connection) {
      if (this.options.autoStart) {
        await this.start();
      } else {
        throw new Error("Client not connected. Call start() first.");
      }
    }
    const response = await this.connection.sendRequest("session.resume", {
      sessionId,
      tools: config.tools?.map((tool) => ({
        name: tool.name,
        description: tool.description,
        parameters: toJsonSchema(tool.parameters)
      })),
      provider: config.provider,
      requestPermission: !!config.onPermissionRequest,
      streaming: config.streaming,
      mcpServers: config.mcpServers,
      customAgents: config.customAgents,
      skillDirectories: config.skillDirectories,
      disabledSkills: config.disabledSkills
    });
    const resumedSessionId = response.sessionId;
    const session = new CopilotSession(resumedSessionId, this.connection);
    session.registerTools(config.tools);
    if (config.onPermissionRequest) {
      session.registerPermissionHandler(config.onPermissionRequest);
    }
    this.sessions.set(resumedSessionId, session);
    return session;
  }
  /**
   * Gets the current connection state of the client.
   *
   * @returns The current connection state: "disconnected", "connecting", "connected", or "error"
   *
   * @example
   * ```typescript
   * if (client.getState() === "connected") {
   *   const session = await client.createSession();
   * }
   * ```
   */
  getState() {
    return this.state;
  }
  /**
   * Sends a ping request to the server to verify connectivity.
   *
   * @param message - Optional message to include in the ping
   * @returns A promise that resolves with the ping response containing the message and timestamp
   * @throws Error if the client is not connected
   *
   * @example
   * ```typescript
   * const response = await client.ping("health check");
   * console.log(`Server responded at ${new Date(response.timestamp)}`);
   * ```
   */
  async ping(message) {
    if (!this.connection) {
      throw new Error("Client not connected");
    }
    const result = await this.connection.sendRequest("ping", { message });
    return result;
  }
  /**
   * Get CLI status including version and protocol information
   */
  async getStatus() {
    if (!this.connection) {
      throw new Error("Client not connected");
    }
    const result = await this.connection.sendRequest("status.get", {});
    return result;
  }
  /**
   * Get current authentication status
   */
  async getAuthStatus() {
    if (!this.connection) {
      throw new Error("Client not connected");
    }
    const result = await this.connection.sendRequest("auth.getStatus", {});
    return result;
  }
  /**
   * List available models with their metadata
   * @throws Error if not authenticated
   */
  async listModels() {
    if (!this.connection) {
      throw new Error("Client not connected");
    }
    const result = await this.connection.sendRequest("models.list", {});
    const response = result;
    return response.models;
  }
  /**
   * Verify that the server's protocol version matches the SDK's expected version
   */
  async verifyProtocolVersion() {
    const expectedVersion = getSdkProtocolVersion();
    const pingResult = await this.ping();
    const serverVersion = pingResult.protocolVersion;
    if (serverVersion === void 0) {
      throw new Error(
        `SDK protocol version mismatch: SDK expects version ${expectedVersion}, but server does not report a protocol version. Please update your server to ensure compatibility.`
      );
    }
    if (serverVersion !== expectedVersion) {
      throw new Error(
        `SDK protocol version mismatch: SDK expects version ${expectedVersion}, but server reports version ${serverVersion}. Please update your SDK or server to ensure compatibility.`
      );
    }
  }
  /**
   * Gets the ID of the most recently updated session.
   *
   * This is useful for resuming the last conversation when the session ID
   * was not stored.
   *
   * @returns A promise that resolves with the session ID, or undefined if no sessions exist
   * @throws Error if the client is not connected
   *
   * @example
   * ```typescript
   * const lastId = await client.getLastSessionId();
   * if (lastId) {
   *   const session = await client.resumeSession(lastId);
   * }
   * ```
   */
  async getLastSessionId() {
    if (!this.connection) {
      throw new Error("Client not connected");
    }
    const response = await this.connection.sendRequest("session.getLastId", {});
    return response.sessionId;
  }
  /**
   * Deletes a session and its data from disk.
   *
   * This permanently removes the session and all its conversation history.
   * The session cannot be resumed after deletion.
   *
   * @param sessionId - The ID of the session to delete
   * @returns A promise that resolves when the session is deleted
   * @throws Error if the session does not exist or deletion fails
   *
   * @example
   * ```typescript
   * await client.deleteSession("session-123");
   * ```
   */
  async deleteSession(sessionId) {
    if (!this.connection) {
      throw new Error("Client not connected");
    }
    const response = await this.connection.sendRequest("session.delete", {
      sessionId
    });
    const { success, error } = response;
    if (!success) {
      throw new Error(`Failed to delete session ${sessionId}: ${error || "Unknown error"}`);
    }
    this.sessions.delete(sessionId);
  }
  /**
   * Lists all available sessions known to the server.
   *
   * Returns metadata about each session including ID, timestamps, and summary.
   *
   * @returns A promise that resolves with an array of session metadata
   * @throws Error if the client is not connected
   *
   * @example
   * ```typescript
   * const sessions = await client.listSessions();
   * for (const session of sessions) {
   *   console.log(`${session.sessionId}: ${session.summary}`);
   * }
   * ```
   */
  async listSessions() {
    if (!this.connection) {
      throw new Error("Client not connected");
    }
    const response = await this.connection.sendRequest("session.list", {});
    const { sessions } = response;
    return sessions.map((s) => ({
      sessionId: s.sessionId,
      startTime: new Date(s.startTime),
      modifiedTime: new Date(s.modifiedTime),
      summary: s.summary,
      isRemote: s.isRemote
    }));
  }
  /**
   * Start the CLI server process
   */
  async startCLIServer() {
    return new Promise((resolve3, reject) => {
      const args = [
        ...this.options.cliArgs,
        "--server",
        "--log-level",
        this.options.logLevel
      ];
      if (this.options.useStdio) {
        args.push("--stdio");
      } else if (this.options.port > 0) {
        args.push("--port", this.options.port.toString());
      }
      const envWithoutNodeDebug = { ...this.options.env };
      delete envWithoutNodeDebug.NODE_DEBUG;
      const isJsFile = this.options.cliPath.endsWith(".js");
      const isAbsolutePath = this.options.cliPath.startsWith("/") || /^[a-zA-Z]:/.test(this.options.cliPath);
      let command;
      let spawnArgs;
      if (isJsFile) {
        command = "node";
        spawnArgs = [this.options.cliPath, ...args];
      } else if (process.platform === "win32" && !isAbsolutePath) {
        command = "cmd";
        spawnArgs = ["/c", `${this.options.cliPath}`, ...args];
      } else {
        command = this.options.cliPath;
        spawnArgs = args;
      }
      this.cliProcess = (0, import_node_child_process.spawn)(command, spawnArgs, {
        stdio: this.options.useStdio ? ["pipe", "pipe", "pipe"] : ["ignore", "pipe", "pipe"],
        cwd: this.options.cwd,
        env: envWithoutNodeDebug
      });
      let stdout = "";
      let resolved = false;
      if (this.options.useStdio) {
        resolved = true;
        resolve3();
      } else {
        this.cliProcess.stdout?.on("data", (data) => {
          stdout += data.toString();
          const match = stdout.match(/listening on port (\d+)/i);
          if (match && !resolved) {
            this.actualPort = parseInt(match[1], 10);
            resolved = true;
            resolve3();
          }
        });
      }
      this.cliProcess.stderr?.on("data", (data) => {
        const lines = data.toString().split("\n");
        for (const line of lines) {
          if (line.trim()) {
            process.stderr.write(`[CLI subprocess] ${line}
`);
          }
        }
      });
      this.cliProcess.on("error", (error) => {
        if (!resolved) {
          resolved = true;
          reject(new Error(`Failed to start CLI server: ${error.message}`));
        }
      });
      this.cliProcess.on("exit", (code) => {
        if (!resolved) {
          resolved = true;
          reject(new Error(`CLI server exited with code ${code}`));
        } else if (this.options.autoRestart && this.state === "connected") {
          void this.reconnect();
        }
      });
      setTimeout(() => {
        if (!resolved) {
          resolved = true;
          reject(new Error("Timeout waiting for CLI server to start"));
        }
      }, 1e4);
    });
  }
  /**
   * Connect to the CLI server (via socket or stdio)
   */
  async connectToServer() {
    if (this.options.useStdio) {
      return this.connectViaStdio();
    } else {
      return this.connectViaTcp();
    }
  }
  /**
   * Connect via stdio pipes
   */
  async connectViaStdio() {
    if (!this.cliProcess) {
      throw new Error("CLI process not started");
    }
    this.cliProcess.stdin?.on("error", (err) => {
      if (!this.forceStopping) {
        throw err;
      }
    });
    this.connection = (0, import_node.createMessageConnection)(
      new import_node.StreamMessageReader(this.cliProcess.stdout),
      new import_node.StreamMessageWriter(this.cliProcess.stdin)
    );
    this.attachConnectionHandlers();
    this.connection.listen();
  }
  /**
   * Connect to the CLI server via TCP socket
   */
  async connectViaTcp() {
    if (!this.actualPort) {
      throw new Error("Server port not available");
    }
    return new Promise((resolve3, reject) => {
      this.socket = new import_node_net.Socket();
      this.socket.connect(this.actualPort, this.actualHost, () => {
        this.connection = (0, import_node.createMessageConnection)(
          new import_node.StreamMessageReader(this.socket),
          new import_node.StreamMessageWriter(this.socket)
        );
        this.attachConnectionHandlers();
        this.connection.listen();
        resolve3();
      });
      this.socket.on("error", (error) => {
        reject(new Error(`Failed to connect to CLI server: ${error.message}`));
      });
    });
  }
  attachConnectionHandlers() {
    if (!this.connection) {
      return;
    }
    this.connection.onNotification("session.event", (notification) => {
      this.handleSessionEventNotification(notification);
    });
    this.connection.onRequest(
      "tool.call",
      async (params) => await this.handleToolCallRequest(params)
    );
    this.connection.onRequest(
      "permission.request",
      async (params) => await this.handlePermissionRequest(params)
    );
    this.connection.onClose(() => {
      if (this.state === "connected" && this.options.autoRestart) {
        void this.reconnect();
      }
    });
    this.connection.onError((_error) => {
    });
  }
  handleSessionEventNotification(notification) {
    if (typeof notification !== "object" || !notification || !("sessionId" in notification) || typeof notification.sessionId !== "string" || !("event" in notification)) {
      return;
    }
    const session = this.sessions.get(notification.sessionId);
    if (session) {
      session._dispatchEvent(notification.event);
    }
  }
  async handleToolCallRequest(params) {
    if (!params || typeof params.sessionId !== "string" || typeof params.toolCallId !== "string" || typeof params.toolName !== "string") {
      throw new Error("Invalid tool call payload");
    }
    const session = this.sessions.get(params.sessionId);
    if (!session) {
      throw new Error(`Unknown session ${params.sessionId}`);
    }
    const handler = session.getToolHandler(params.toolName);
    if (!handler) {
      return { result: this.buildUnsupportedToolResult(params.toolName) };
    }
    return await this.executeToolCall(handler, params);
  }
  async executeToolCall(handler, request) {
    try {
      const invocation = {
        sessionId: request.sessionId,
        toolCallId: request.toolCallId,
        toolName: request.toolName,
        arguments: request.arguments
      };
      const result = await handler(request.arguments, invocation);
      return { result: this.normalizeToolResult(result) };
    } catch (error) {
      const message = error instanceof Error ? error.message : String(error);
      return {
        result: {
          // Don't expose detailed error information to the LLM for security reasons
          textResultForLlm: "Invoking this tool produced an error. Detailed information is not available.",
          resultType: "failure",
          error: message,
          toolTelemetry: {}
        }
      };
    }
  }
  async handlePermissionRequest(params) {
    if (!params || typeof params.sessionId !== "string" || !params.permissionRequest) {
      throw new Error("Invalid permission request payload");
    }
    const session = this.sessions.get(params.sessionId);
    if (!session) {
      throw new Error(`Session not found: ${params.sessionId}`);
    }
    try {
      const result = await session._handlePermissionRequest(params.permissionRequest);
      return { result };
    } catch (_error) {
      return {
        result: {
          kind: "denied-no-approval-rule-and-could-not-request-from-user"
        }
      };
    }
  }
  normalizeToolResult(result) {
    if (result === void 0 || result === null) {
      return {
        textResultForLlm: "Tool returned no result",
        resultType: "failure",
        error: "tool returned no result",
        toolTelemetry: {}
      };
    }
    if (this.isToolResultObject(result)) {
      return result;
    }
    const textResult = typeof result === "string" ? result : JSON.stringify(result);
    return {
      textResultForLlm: textResult,
      resultType: "success",
      toolTelemetry: {}
    };
  }
  isToolResultObject(value) {
    return typeof value === "object" && value !== null && "textResultForLlm" in value && typeof value.textResultForLlm === "string" && "resultType" in value;
  }
  buildUnsupportedToolResult(toolName) {
    return {
      textResultForLlm: `Tool '${toolName}' is not supported by this client instance.`,
      resultType: "failure",
      error: `tool '${toolName}' not supported`,
      toolTelemetry: {}
    };
  }
  /**
   * Attempt to reconnect to the server
   */
  async reconnect() {
    this.state = "disconnected";
    try {
      await this.stop();
      await this.start();
    } catch (_error) {
    }
  }
};

// ../remote-sdk-protocol/dist/index.js
var CONTENT_LENGTH_HEADER = "Content-Length: ";
var HEADER_DELIMITER = "\r\n\r\n";
function encodeJsonRpcMessageToBuffer(message) {
  const json = JSON.stringify(message);
  const header = `${CONTENT_LENGTH_HEADER}${Buffer.byteLength(json, "utf-8")}${HEADER_DELIMITER}`;
  return Buffer.from(header + json, "utf-8");
}
var SUPPORTED_MODELS = [
  { id: "claude-sonnet-4.5", label: "Claude Sonnet 4.5", multiplier: 1, isAvailable: true },
  { id: "claude-haiku-4.5", label: "Claude Haiku 4.5", multiplier: 0.33, isAvailable: true },
  { id: "claude-opus-4.5", label: "Claude Opus 4.5", multiplier: 1, isAvailable: true },
  { id: "claude-sonnet-4", label: "Claude Sonnet 4", multiplier: 1, isAvailable: true },
  { id: "gpt-5", label: "GPT-5", multiplier: 1, isAvailable: true },
  { id: "gpt-5.1", label: "GPT-5.1", multiplier: 1, isAvailable: true },
  { id: "gpt-5.1-codex", label: "GPT-5.1 Codex", multiplier: 1, isAvailable: true },
  { id: "gpt-5.1-codex-mini", label: "GPT-5.1 Codex Mini", multiplier: 0.33, isAvailable: true },
  { id: "gpt-5-mini", label: "GPT-5 Mini", multiplier: 0, isAvailable: true },
  { id: "gpt-4.1", label: "GPT-4.1", multiplier: 0, isAvailable: true },
  { id: "gemini-3-pro-preview", label: "Gemini 3 Pro Preview", multiplier: 1, isAvailable: true }
];
var DEFAULT_MODEL = "claude-sonnet-4.5";

// src/file-search-service.ts
var import_promises = require("fs/promises");
var import_node_path = require("path");

// ../../node_modules/fdir/dist/index.mjs
var import_module = require("module");
var import_path = require("path");
var nativeFs = __toESM(require("fs"), 1);
var __require = /* @__PURE__ */ (0, import_module.createRequire)(__bundled_import_meta_url);
function cleanPath(path2) {
  let normalized = (0, import_path.normalize)(path2);
  if (normalized.length > 1 && normalized[normalized.length - 1] === import_path.sep) normalized = normalized.substring(0, normalized.length - 1);
  return normalized;
}
var SLASHES_REGEX = /[\\/]/g;
function convertSlashes(path2, separator) {
  return path2.replace(SLASHES_REGEX, separator);
}
var WINDOWS_ROOT_DIR_REGEX = /^[a-z]:[\\/]$/i;
function isRootDirectory(path2) {
  return path2 === "/" || WINDOWS_ROOT_DIR_REGEX.test(path2);
}
function normalizePath(path2, options) {
  const { resolvePaths, normalizePath: normalizePath$1, pathSeparator } = options;
  const pathNeedsCleaning = process.platform === "win32" && path2.includes("/") || path2.startsWith(".");
  if (resolvePaths) path2 = (0, import_path.resolve)(path2);
  if (normalizePath$1 || pathNeedsCleaning) path2 = cleanPath(path2);
  if (path2 === ".") return "";
  const needsSeperator = path2[path2.length - 1] !== pathSeparator;
  return convertSlashes(needsSeperator ? path2 + pathSeparator : path2, pathSeparator);
}
function joinPathWithBasePath(filename, directoryPath) {
  return directoryPath + filename;
}
function joinPathWithRelativePath(root, options) {
  return function(filename, directoryPath) {
    const sameRoot = directoryPath.startsWith(root);
    if (sameRoot) return directoryPath.slice(root.length) + filename;
    else return convertSlashes((0, import_path.relative)(root, directoryPath), options.pathSeparator) + options.pathSeparator + filename;
  };
}
function joinPath(filename) {
  return filename;
}
function joinDirectoryPath(filename, directoryPath, separator) {
  return directoryPath + filename + separator;
}
function build$7(root, options) {
  const { relativePaths, includeBasePath } = options;
  return relativePaths && root ? joinPathWithRelativePath(root, options) : includeBasePath ? joinPathWithBasePath : joinPath;
}
function pushDirectoryWithRelativePath(root) {
  return function(directoryPath, paths) {
    paths.push(directoryPath.substring(root.length) || ".");
  };
}
function pushDirectoryFilterWithRelativePath(root) {
  return function(directoryPath, paths, filters) {
    const relativePath = directoryPath.substring(root.length) || ".";
    if (filters.every((filter) => filter(relativePath, true))) paths.push(relativePath);
  };
}
var pushDirectory = (directoryPath, paths) => {
  paths.push(directoryPath || ".");
};
var pushDirectoryFilter = (directoryPath, paths, filters) => {
  const path2 = directoryPath || ".";
  if (filters.every((filter) => filter(path2, true))) paths.push(path2);
};
var empty$2 = () => {
};
function build$6(root, options) {
  const { includeDirs, filters, relativePaths } = options;
  if (!includeDirs) return empty$2;
  if (relativePaths) return filters && filters.length ? pushDirectoryFilterWithRelativePath(root) : pushDirectoryWithRelativePath(root);
  return filters && filters.length ? pushDirectoryFilter : pushDirectory;
}
var pushFileFilterAndCount = (filename, _paths, counts, filters) => {
  if (filters.every((filter) => filter(filename, false))) counts.files++;
};
var pushFileFilter = (filename, paths, _counts, filters) => {
  if (filters.every((filter) => filter(filename, false))) paths.push(filename);
};
var pushFileCount = (_filename, _paths, counts, _filters) => {
  counts.files++;
};
var pushFile = (filename, paths) => {
  paths.push(filename);
};
var empty$1 = () => {
};
function build$5(options) {
  const { excludeFiles, filters, onlyCounts } = options;
  if (excludeFiles) return empty$1;
  if (filters && filters.length) return onlyCounts ? pushFileFilterAndCount : pushFileFilter;
  else if (onlyCounts) return pushFileCount;
  else return pushFile;
}
var getArray = (paths) => {
  return paths;
};
var getArrayGroup = () => {
  return [""].slice(0, 0);
};
function build$4(options) {
  return options.group ? getArrayGroup : getArray;
}
var groupFiles = (groups, directory, files) => {
  groups.push({
    directory,
    files,
    dir: directory
  });
};
var empty = () => {
};
function build$3(options) {
  return options.group ? groupFiles : empty;
}
var resolveSymlinksAsync = function(path2, state, callback$1) {
  const { queue, fs: fs2, options: { suppressErrors } } = state;
  queue.enqueue();
  fs2.realpath(path2, (error, resolvedPath) => {
    if (error) return queue.dequeue(suppressErrors ? null : error, state);
    fs2.stat(resolvedPath, (error$1, stat) => {
      if (error$1) return queue.dequeue(suppressErrors ? null : error$1, state);
      if (stat.isDirectory() && isRecursive(path2, resolvedPath, state)) return queue.dequeue(null, state);
      callback$1(stat, resolvedPath);
      queue.dequeue(null, state);
    });
  });
};
var resolveSymlinks = function(path2, state, callback$1) {
  const { queue, fs: fs2, options: { suppressErrors } } = state;
  queue.enqueue();
  try {
    const resolvedPath = fs2.realpathSync(path2);
    const stat = fs2.statSync(resolvedPath);
    if (stat.isDirectory() && isRecursive(path2, resolvedPath, state)) return;
    callback$1(stat, resolvedPath);
  } catch (e) {
    if (!suppressErrors) throw e;
  }
};
function build$2(options, isSynchronous) {
  if (!options.resolveSymlinks || options.excludeSymlinks) return null;
  return isSynchronous ? resolveSymlinks : resolveSymlinksAsync;
}
function isRecursive(path2, resolved, state) {
  if (state.options.useRealPaths) return isRecursiveUsingRealPaths(resolved, state);
  let parent = (0, import_path.dirname)(path2);
  let depth = 1;
  while (parent !== state.root && depth < 2) {
    const resolvedPath = state.symlinks.get(parent);
    const isSameRoot = !!resolvedPath && (resolvedPath === resolved || resolvedPath.startsWith(resolved) || resolved.startsWith(resolvedPath));
    if (isSameRoot) depth++;
    else parent = (0, import_path.dirname)(parent);
  }
  state.symlinks.set(path2, resolved);
  return depth > 1;
}
function isRecursiveUsingRealPaths(resolved, state) {
  return state.visited.includes(resolved + state.options.pathSeparator);
}
var onlyCountsSync = (state) => {
  return state.counts;
};
var groupsSync = (state) => {
  return state.groups;
};
var defaultSync = (state) => {
  return state.paths;
};
var limitFilesSync = (state) => {
  return state.paths.slice(0, state.options.maxFiles);
};
var onlyCountsAsync = (state, error, callback$1) => {
  report(error, callback$1, state.counts, state.options.suppressErrors);
  return null;
};
var defaultAsync = (state, error, callback$1) => {
  report(error, callback$1, state.paths, state.options.suppressErrors);
  return null;
};
var limitFilesAsync = (state, error, callback$1) => {
  report(error, callback$1, state.paths.slice(0, state.options.maxFiles), state.options.suppressErrors);
  return null;
};
var groupsAsync = (state, error, callback$1) => {
  report(error, callback$1, state.groups, state.options.suppressErrors);
  return null;
};
function report(error, callback$1, output, suppressErrors) {
  if (error && !suppressErrors) callback$1(error, output);
  else callback$1(null, output);
}
function build$1(options, isSynchronous) {
  const { onlyCounts, group, maxFiles } = options;
  if (onlyCounts) return isSynchronous ? onlyCountsSync : onlyCountsAsync;
  else if (group) return isSynchronous ? groupsSync : groupsAsync;
  else if (maxFiles) return isSynchronous ? limitFilesSync : limitFilesAsync;
  else return isSynchronous ? defaultSync : defaultAsync;
}
var readdirOpts = { withFileTypes: true };
var walkAsync = (state, crawlPath, directoryPath, currentDepth, callback$1) => {
  state.queue.enqueue();
  if (currentDepth < 0) return state.queue.dequeue(null, state);
  const { fs: fs2 } = state;
  state.visited.push(crawlPath);
  state.counts.directories++;
  fs2.readdir(crawlPath || ".", readdirOpts, (error, entries = []) => {
    callback$1(entries, directoryPath, currentDepth);
    state.queue.dequeue(state.options.suppressErrors ? null : error, state);
  });
};
var walkSync = (state, crawlPath, directoryPath, currentDepth, callback$1) => {
  const { fs: fs2 } = state;
  if (currentDepth < 0) return;
  state.visited.push(crawlPath);
  state.counts.directories++;
  let entries = [];
  try {
    entries = fs2.readdirSync(crawlPath || ".", readdirOpts);
  } catch (e) {
    if (!state.options.suppressErrors) throw e;
  }
  callback$1(entries, directoryPath, currentDepth);
};
function build(isSynchronous) {
  return isSynchronous ? walkSync : walkAsync;
}
var Queue = class {
  count = 0;
  constructor(onQueueEmpty) {
    this.onQueueEmpty = onQueueEmpty;
  }
  enqueue() {
    this.count++;
    return this.count;
  }
  dequeue(error, output) {
    if (this.onQueueEmpty && (--this.count <= 0 || error)) {
      this.onQueueEmpty(error, output);
      if (error) {
        output.controller.abort();
        this.onQueueEmpty = void 0;
      }
    }
  }
};
var Counter = class {
  _files = 0;
  _directories = 0;
  set files(num) {
    this._files = num;
  }
  get files() {
    return this._files;
  }
  set directories(num) {
    this._directories = num;
  }
  get directories() {
    return this._directories;
  }
  /**
  * @deprecated use `directories` instead
  */
  /* c8 ignore next 3 */
  get dirs() {
    return this._directories;
  }
};
var Aborter = class {
  aborted = false;
  abort() {
    this.aborted = true;
  }
};
var Walker = class {
  root;
  isSynchronous;
  state;
  joinPath;
  pushDirectory;
  pushFile;
  getArray;
  groupFiles;
  resolveSymlink;
  walkDirectory;
  callbackInvoker;
  constructor(root, options, callback$1) {
    this.isSynchronous = !callback$1;
    this.callbackInvoker = build$1(options, this.isSynchronous);
    this.root = normalizePath(root, options);
    this.state = {
      root: isRootDirectory(this.root) ? this.root : this.root.slice(0, -1),
      paths: [""].slice(0, 0),
      groups: [],
      counts: new Counter(),
      options,
      queue: new Queue((error, state) => this.callbackInvoker(state, error, callback$1)),
      symlinks: /* @__PURE__ */ new Map(),
      visited: [""].slice(0, 0),
      controller: new Aborter(),
      fs: options.fs || nativeFs
    };
    this.joinPath = build$7(this.root, options);
    this.pushDirectory = build$6(this.root, options);
    this.pushFile = build$5(options);
    this.getArray = build$4(options);
    this.groupFiles = build$3(options);
    this.resolveSymlink = build$2(options, this.isSynchronous);
    this.walkDirectory = build(this.isSynchronous);
  }
  start() {
    this.pushDirectory(this.root, this.state.paths, this.state.options.filters);
    this.walkDirectory(this.state, this.root, this.root, this.state.options.maxDepth, this.walk);
    return this.isSynchronous ? this.callbackInvoker(this.state, null) : null;
  }
  walk = (entries, directoryPath, depth) => {
    const { paths, options: { filters, resolveSymlinks: resolveSymlinks$1, excludeSymlinks, exclude, maxFiles, signal, useRealPaths, pathSeparator }, controller } = this.state;
    if (controller.aborted || signal && signal.aborted || maxFiles && paths.length > maxFiles) return;
    const files = this.getArray(this.state.paths);
    for (let i = 0; i < entries.length; ++i) {
      const entry = entries[i];
      if (entry.isFile() || entry.isSymbolicLink() && !resolveSymlinks$1 && !excludeSymlinks) {
        const filename = this.joinPath(entry.name, directoryPath);
        this.pushFile(filename, files, this.state.counts, filters);
      } else if (entry.isDirectory()) {
        let path2 = joinDirectoryPath(entry.name, directoryPath, this.state.options.pathSeparator);
        if (exclude && exclude(entry.name, path2)) continue;
        this.pushDirectory(path2, paths, filters);
        this.walkDirectory(this.state, path2, path2, depth - 1, this.walk);
      } else if (this.resolveSymlink && entry.isSymbolicLink()) {
        let path2 = joinPathWithBasePath(entry.name, directoryPath);
        this.resolveSymlink(path2, this.state, (stat, resolvedPath) => {
          if (stat.isDirectory()) {
            resolvedPath = normalizePath(resolvedPath, this.state.options);
            if (exclude && exclude(entry.name, useRealPaths ? resolvedPath : path2 + pathSeparator)) return;
            this.walkDirectory(this.state, resolvedPath, useRealPaths ? resolvedPath : path2 + pathSeparator, depth - 1, this.walk);
          } else {
            resolvedPath = useRealPaths ? resolvedPath : path2;
            const filename = (0, import_path.basename)(resolvedPath);
            const directoryPath$1 = normalizePath((0, import_path.dirname)(resolvedPath), this.state.options);
            resolvedPath = this.joinPath(filename, directoryPath$1);
            this.pushFile(resolvedPath, files, this.state.counts, filters);
          }
        });
      }
    }
    this.groupFiles(this.state.groups, directoryPath, files);
  };
};
function promise(root, options) {
  return new Promise((resolve$1, reject) => {
    callback(root, options, (err, output) => {
      if (err) return reject(err);
      resolve$1(output);
    });
  });
}
function callback(root, options, callback$1) {
  let walker = new Walker(root, options, callback$1);
  walker.start();
}
function sync(root, options) {
  const walker = new Walker(root, options);
  return walker.start();
}
var APIBuilder = class {
  constructor(root, options) {
    this.root = root;
    this.options = options;
  }
  withPromise() {
    return promise(this.root, this.options);
  }
  withCallback(cb) {
    callback(this.root, this.options, cb);
  }
  sync() {
    return sync(this.root, this.options);
  }
};
var pm = null;
try {
  __require.resolve("picomatch");
  pm = __require("picomatch");
} catch {
}
var Builder = class {
  globCache = {};
  options = {
    maxDepth: Infinity,
    suppressErrors: true,
    pathSeparator: import_path.sep,
    filters: []
  };
  globFunction;
  constructor(options) {
    this.options = {
      ...this.options,
      ...options
    };
    this.globFunction = this.options.globFunction;
  }
  group() {
    this.options.group = true;
    return this;
  }
  withPathSeparator(separator) {
    this.options.pathSeparator = separator;
    return this;
  }
  withBasePath() {
    this.options.includeBasePath = true;
    return this;
  }
  withRelativePaths() {
    this.options.relativePaths = true;
    return this;
  }
  withDirs() {
    this.options.includeDirs = true;
    return this;
  }
  withMaxDepth(depth) {
    this.options.maxDepth = depth;
    return this;
  }
  withMaxFiles(limit) {
    this.options.maxFiles = limit;
    return this;
  }
  withFullPaths() {
    this.options.resolvePaths = true;
    this.options.includeBasePath = true;
    return this;
  }
  withErrors() {
    this.options.suppressErrors = false;
    return this;
  }
  withSymlinks({ resolvePaths = true } = {}) {
    this.options.resolveSymlinks = true;
    this.options.useRealPaths = resolvePaths;
    return this.withFullPaths();
  }
  withAbortSignal(signal) {
    this.options.signal = signal;
    return this;
  }
  normalize() {
    this.options.normalizePath = true;
    return this;
  }
  filter(predicate) {
    this.options.filters.push(predicate);
    return this;
  }
  onlyDirs() {
    this.options.excludeFiles = true;
    this.options.includeDirs = true;
    return this;
  }
  exclude(predicate) {
    this.options.exclude = predicate;
    return this;
  }
  onlyCounts() {
    this.options.onlyCounts = true;
    return this;
  }
  crawl(root) {
    return new APIBuilder(root || ".", this.options);
  }
  withGlobFunction(fn) {
    this.globFunction = fn;
    return this;
  }
  /**
  * @deprecated Pass options using the constructor instead:
  * ```ts
  * new fdir(options).crawl("/path/to/root");
  * ```
  * This method will be removed in v7.0
  */
  /* c8 ignore next 4 */
  crawlWithOptions(root, options) {
    this.options = {
      ...this.options,
      ...options
    };
    return new APIBuilder(root || ".", this.options);
  }
  glob(...patterns) {
    if (this.globFunction) return this.globWithOptions(patterns);
    return this.globWithOptions(patterns, ...[{ dot: true }]);
  }
  globWithOptions(patterns, ...options) {
    const globFn = this.globFunction || pm;
    if (!globFn) throw new Error("Please specify a glob function to use glob matching.");
    var isMatch = this.globCache[patterns.join("\0")];
    if (!isMatch) {
      isMatch = globFn(patterns, ...options);
      this.globCache[patterns.join("\0")] = isMatch;
    }
    this.options.filters.push((path2) => isMatch(path2));
    return this;
  }
};

// src/file-search-service.ts
var import_picomatch = __toESM(require_picomatch2(), 1);
var ALWAYS_IGNORED_DIRS = [
  "node_modules",
  ".git",
  "dist",
  "build",
  ".next",
  "coverage",
  "__pycache__",
  ".cache",
  ".turbo",
  ".parcel-cache",
  "out",
  ".svn",
  ".hg",
  "vendor",
  ".venv",
  "venv",
  ".tox"
];
var ALWAYS_IGNORED_PATTERNS = [
  "*.pyc",
  "*.pyo",
  "*.class",
  "*.o",
  "*.obj",
  "*.swp",
  "*.swo",
  "*~",
  ".DS_Store",
  "Thumbs.db",
  "*.log",
  "*.tmp",
  "*.lock",
  "package-lock.json",
  "yarn.lock",
  "pnpm-lock.yaml"
];
function fuzzyMatch(query, target) {
  const lowerQuery = query.toLowerCase();
  const lowerTarget = target.toLowerCase();
  let queryIdx = 0;
  let score = 0;
  let consecutiveMatches = 0;
  let lastMatchIdx = -1;
  for (let i = 0; i < lowerTarget.length && queryIdx < lowerQuery.length; i++) {
    if (lowerTarget[i] === lowerQuery[queryIdx]) {
      if (lastMatchIdx === i - 1) {
        consecutiveMatches++;
        score += consecutiveMatches * 2;
      } else {
        consecutiveMatches = 1;
        score += 1;
      }
      if (i === 0 || lowerTarget[i - 1] === "/" || lowerTarget[i - 1] === "-" || lowerTarget[i - 1] === "_" || lowerTarget[i - 1] === ".") {
        score += 5;
      }
      lastMatchIdx = i;
      queryIdx++;
    }
  }
  return {
    match: queryIdx === lowerQuery.length,
    score
  };
}
var FileSearchService = class {
  indexes = /* @__PURE__ */ new Map();
  cacheTtl;
  constructor(options = {}) {
    this.cacheTtl = options.cacheTtl ?? 5 * 60 * 1e3;
  }
  /**
   * Search for files matching a query.
   */
  async search(request) {
    const { query, cwd, maxResults = 50, includeDirs = false } = request;
    const { files, freshIndex } = await this.getIndex(cwd, includeDirs);
    const results = await this.performSearch(files, query, maxResults);
    return {
      results,
      totalIndexed: files.length,
      freshIndex
    };
  }
  /**
   * Force refresh index for a working directory.
   */
  invalidate(cwd) {
    for (const key of this.indexes.keys()) {
      if (key.startsWith(cwd)) {
        this.indexes.delete(key);
      }
    }
  }
  // ===========================================================================
  // Private Methods
  // ===========================================================================
  async getIndex(cwd, includeDirs) {
    const key = `${cwd}:${includeDirs}`;
    const cached = this.indexes.get(key);
    if (cached && Date.now() - cached.createdAt < this.cacheTtl) {
      return { files: cached.files, freshIndex: false };
    }
    const files = await this.buildIndex(cwd, includeDirs);
    this.indexes.set(key, { files, createdAt: Date.now() });
    return { files, freshIndex: true };
  }
  async buildIndex(cwd, includeDirs) {
    const ignorePatterns = await this.loadIgnorePatterns(cwd);
    const allIgnorePatterns = [...ALWAYS_IGNORED_PATTERNS, ...ignorePatterns];
    const isIgnoredFile = (0, import_picomatch.default)(allIgnorePatterns, { dot: true });
    const ignoredDirSet = new Set(ALWAYS_IGNORED_DIRS);
    const crawler = new Builder().withRelativePaths().exclude((dirName) => {
      return ignoredDirSet.has(dirName);
    });
    if (includeDirs) {
      crawler.withDirs();
    }
    const allPaths = await crawler.crawl(cwd).withPromise();
    const filteredFiles = allPaths.filter((filePath) => {
      const fileName = (0, import_node_path.basename)(filePath);
      return !isIgnoredFile(fileName);
    });
    return filteredFiles;
  }
  async loadIgnorePatterns(cwd) {
    const patterns = [];
    try {
      const gitignorePath = (0, import_node_path.join)(cwd, ".gitignore");
      const content = await (0, import_promises.readFile)(gitignorePath, "utf-8");
      const lines = content.split("\n").map((line) => line.trim()).filter((line) => line && !line.startsWith("#"));
      patterns.push(...lines);
    } catch {
    }
    return patterns;
  }
  async performSearch(files, query, maxResults) {
    if (!query) {
      return files.slice().sort((a, b) => a.length - b.length).slice(0, maxResults).map((path2) => ({
        path: path2,
        type: this.getType(path2),
        score: 0
      }));
    }
    if (query.includes("*") || query.includes("?")) {
      const matcher = (0, import_picomatch.default)(query, { nocase: true, dot: true });
      return files.filter((f) => matcher(f)).slice(0, maxResults).map((path2) => ({
        path: path2,
        type: this.getType(path2),
        score: 1
      }));
    }
    const results = [];
    for (const filePath of files) {
      const { match, score: fuzzyScore } = fuzzyMatch(query, filePath);
      if (match) {
        const totalScore = this.calculateScore(filePath, query, fuzzyScore);
        results.push({ path: filePath, score: totalScore });
      }
    }
    return results.sort((a, b) => b.score - a.score).slice(0, maxResults).map(({ path: path2, score }) => ({
      path: path2,
      type: this.getType(path2),
      score
    }));
  }
  calculateScore(filePath, query, fuzzyScore) {
    const lowerPath = filePath.toLowerCase();
    const lowerQuery = query.toLowerCase();
    const filename = (0, import_node_path.basename)(filePath).toLowerCase();
    if (lowerPath === lowerQuery) {
      return 1e3 + fuzzyScore;
    }
    if (filename === lowerQuery) {
      return 800 + fuzzyScore;
    }
    if (filename.startsWith(lowerQuery)) {
      return 600 + fuzzyScore;
    }
    if (lowerPath.includes("/" + lowerQuery) || lowerPath.includes(lowerQuery + "/")) {
      return 500 + fuzzyScore;
    }
    if (lowerPath.includes(lowerQuery)) {
      return 400 + fuzzyScore;
    }
    return fuzzyScore;
  }
  getType(filePath) {
    return filePath.endsWith("/") ? "directory" : "file";
  }
};

// src/jsonrpc-proxy.ts
var import_node_child_process2 = require("child_process");
var import_promises2 = require("fs/promises");
var import_node_os = require("os");
var import_node_path2 = require("path");
function getGhCliToken() {
  try {
    const token = (0, import_node_child_process2.execSync)("gh auth token", {
      encoding: "utf-8",
      stdio: ["pipe", "pipe", "pipe"]
      // Suppress stderr
    }).trim();
    return token || void 0;
  } catch {
    return void 0;
  }
}
async function discoverSessionCwd(sessionId) {
  const sessionDir = (0, import_node_path2.join)((0, import_node_os.homedir)(), ".copilot", "session-state", sessionId);
  try {
    const yaml = await (0, import_promises2.readFile)((0, import_node_path2.join)(sessionDir, "workspace.yaml"), "utf-8");
    const match = yaml.match(/^cwd:\s*(.+)$/m);
    if (match) {
      return match[1].trim();
    }
  } catch {
  }
  try {
    const content = await (0, import_promises2.readFile)((0, import_node_path2.join)(sessionDir, "events.jsonl"), "utf-8");
    const firstLine = content.slice(0, content.indexOf("\n"));
    if (firstLine.startsWith('{"type":"session.start"')) {
      const cwdMatch = firstLine.match(/"cwd":"([^"]+)"/);
      if (cwdMatch) {
        return cwdMatch[1];
      }
    }
  } catch {
  }
  return void 0;
}
function resolveCopilotToken(explicitToken) {
  if (explicitToken) {
    return explicitToken;
  }
  if (process.env.COPILOT_GITHUB_TOKEN) {
    return process.env.COPILOT_GITHUB_TOKEN;
  }
  const ghToken = getGhCliToken();
  if (ghToken) {
    return ghToken;
  }
  return void 0;
}
var BUILT_IN_COMMANDS = [
  {
    name: "/session",
    help: "Show current session information",
    category: "info",
    requiresRemote: true,
    opensDialog: "session"
  }
];
var ClientConnection = class {
  constructor(clientStream, clientId, options = {}) {
    this.clientStream = clientStream;
    this.clientId = clientId;
    this.cliPath = options.cliPath ?? "copilot";
    this.defaultCwd = options.cwd ?? process.cwd();
    this.cliLogLevel = options.cliLogLevel ?? "info";
    this.logLevel = options.logLevel ?? "info";
    this.onLogCallback = options.onLog ?? (() => {
    });
    this.copilotToken = options.copilotToken;
  }
  sessions = /* @__PURE__ */ new Map();
  sessionCwds = /* @__PURE__ */ new Map();
  sessionUnsubscribers = /* @__PURE__ */ new Map();
  sessionTools = /* @__PURE__ */ new Map();
  receiveBuffer = Buffer.alloc(0);
  cliPath;
  defaultCwd;
  cliLogLevel;
  logLevel;
  onLogCallback;
  copilotToken;
  // Pool of CopilotClients keyed by cwd  each unique working directory gets its own CLI process
  clientPool = /* @__PURE__ */ new Map();
  cliEnv = {};
  // File search service for @-mention file picking
  fileSearchService = new FileSearchService();
  // Pending callback requests from SDK -> client
  pendingToolCallRequests = /* @__PURE__ */ new Map();
  pendingPermissionRequests = /* @__PURE__ */ new Map();
  nextCallbackId = 1;
  // Guard against double cleanup
  isCleanedUp = false;
  log(level, message) {
    if (level === "debug" && this.logLevel !== "debug") {
      return;
    }
    this.onLogCallback(level, message);
  }
  async start() {
    this.log("debug", `[${this.clientId}] Initializing SDK client...`);
    const resolvedToken = resolveCopilotToken(this.copilotToken);
    if (this.copilotToken) {
      this.log("debug", `[${this.clientId}] Using explicit copilotToken for auth`);
    } else if (process.env.COPILOT_GITHUB_TOKEN) {
      this.log("debug", `[${this.clientId}] Using COPILOT_GITHUB_TOKEN env var for auth`);
    } else if (resolvedToken) {
      this.log("debug", `[${this.clientId}] Using gh CLI token for auth`);
    } else {
      this.log("debug", `[${this.clientId}] No token found, SDK will use keychain`);
    }
    this.cliEnv = resolvedToken ? { ...process.env, COPILOT_GITHUB_TOKEN: resolvedToken } : { ...process.env };
    await this.getOrCreateClient(this.defaultCwd);
    this.log("debug", `[${this.clientId}] Default SDK client started (cwd: ${this.defaultCwd})`);
    this.clientStream.on("data", (data) => {
      this.handleClientData(data);
    });
    this.clientStream.on("close", () => {
      this.log("info", `Client disconnected: ${this.clientId}`);
      this.cleanup();
    });
    this.clientStream.on("error", (error) => {
      this.log("error", `[${this.clientId}] Client stream error: ${error.message}`);
      this.cleanup();
    });
  }
  /**
   * Get or create a CopilotClient for the given working directory.
   * Clients are pooled  same cwd reuses the same client (and CLI process).
   */
  async getOrCreateClient(cwd) {
    let client = this.clientPool.get(cwd);
    if (!client) {
      this.log("info", `Creating SDK client for cwd: ${cwd}`);
      client = new CopilotClient({
        cliPath: this.cliPath,
        cwd,
        logLevel: this.cliLogLevel,
        autoStart: true,
        autoRestart: true,
        env: this.cliEnv
      });
      await client.start();
      this.clientPool.set(cwd, client);
    }
    return client;
  }
  /** Get the default client (for cwd-agnostic operations like listSessions). */
  async getDefaultClient() {
    return this.getOrCreateClient(this.defaultCwd);
  }
  stop() {
    this.cleanup();
  }
  cleanup() {
    if (this.isCleanedUp) {
      this.log("debug", `[${this.clientId}] Cleanup already done, skipping`);
      return;
    }
    this.isCleanedUp = true;
    for (const unsubscribe of this.sessionUnsubscribers.values()) {
      unsubscribe();
    }
    this.sessionUnsubscribers.clear();
    if (this.sessions.size > 0) {
      this.log("debug", `[${this.clientId}] Clearing ${this.sessions.size} session(s)`);
    }
    this.sessions.clear();
    this.sessionCwds.clear();
    this.sessionTools.clear();
    void this.stopClients();
    if (!this.clientStream.destroyed) {
      try {
        this.clientStream.destroy();
      } catch {
      }
    }
  }
  /**
   * Stop all CopilotClients in the pool.
   * Separated to handle async cleanup without blocking the main cleanup flow.
   */
  async stopClients() {
    for (const [cwd, client] of this.clientPool) {
      try {
        await client.stop();
      } catch (err) {
        this.log("debug", `[${this.clientId}] SDK client stop error (cwd: ${cwd}): ${err}`);
      }
    }
    this.clientPool.clear();
  }
  handleClientData(data) {
    this.receiveBuffer = Buffer.concat([this.receiveBuffer, data]);
    while (true) {
      const headerDelimiter = Buffer.from(HEADER_DELIMITER);
      const headerEndIndex = this.findSequence(this.receiveBuffer, headerDelimiter);
      if (headerEndIndex === -1) break;
      const headerSection = this.receiveBuffer.subarray(0, headerEndIndex).toString();
      const contentLengthMatch = headerSection.match(/Content-Length:\s*(\d+)/i);
      if (!contentLengthMatch) {
        this.receiveBuffer = this.receiveBuffer.subarray(headerEndIndex + headerDelimiter.length);
        continue;
      }
      const contentLength = parseInt(contentLengthMatch[1], 10);
      const bodyStart = headerEndIndex + headerDelimiter.length;
      if (this.receiveBuffer.length < bodyStart + contentLength) break;
      const body = this.receiveBuffer.subarray(bodyStart, bodyStart + contentLength).toString();
      this.receiveBuffer = this.receiveBuffer.subarray(bodyStart + contentLength);
      try {
        const message = JSON.parse(body);
        this.handleClientMessage(message);
      } catch (err) {
        this.log("error", `[${this.clientId}] Failed to parse client message: ${err}`);
      }
    }
  }
  findSequence(buffer, sequence) {
    for (let i = 0; i <= buffer.length - sequence.length; i++) {
      let found = true;
      for (let j = 0; j < sequence.length; j++) {
        if (buffer[i + j] !== sequence[j]) {
          found = false;
          break;
        }
      }
      if (found) return i;
    }
    return -1;
  }
  async handleClientMessage(message) {
    if ("id" in message && ("result" in message || "error" in message) && !("method" in message)) {
      const response = message;
      this.handleCallbackResponse(response);
      return;
    }
    if ("method" in message && "id" in message) {
      const request = message;
      try {
        switch (request.method) {
          // Client methods
          case "ping":
            await this.handlePing(request);
            break;
          case "getState":
            await this.handleGetState(request);
            break;
          case "createSession":
            await this.handleCreateSession(request);
            break;
          case "resumeSession":
            await this.handleResumeSession(request);
            break;
          case "listSessions":
            await this.handleListSessions(request);
            break;
          case "getLastSessionId":
            await this.handleGetLastSessionId(request);
            break;
          case "deleteSession":
            await this.handleDeleteSession(request);
            break;
          // Slash commands
          case "listSlashCommands":
            await this.handleListSlashCommands(request);
            break;
          case "executeSlashCommand":
            await this.handleExecuteSlashCommand(request);
            break;
          // File search
          case "searchFiles":
            await this.handleSearchFiles(request);
            break;
          // Model selection
          case "getModels":
            await this.handleGetModels(request);
            break;
          // Session methods
          case "session.send":
            await this.handleSessionSend(request);
            break;
          case "session.sendAndWait":
            await this.handleSessionSendAndWait(request);
            break;
          case "session.getMessages":
            await this.handleSessionGetMessages(request);
            break;
          case "session.abort":
            await this.handleSessionAbort(request);
            break;
          case "session.destroy":
            await this.handleSessionDestroy(request);
            break;
          default:
            this.sendErrorResponse(request.id, -32601, `Method not found: ${request.method}`);
        }
      } catch (err) {
        this.log("error", `[${this.clientId}] Error handling ${request.method}: ${err}`);
        this.sendErrorResponse(request.id, -32603, `Internal error: ${err}`);
      }
    }
  }
  handleCallbackResponse(response) {
    const id = String(response.id);
    const toolCallPending = this.pendingToolCallRequests.get(id);
    if (toolCallPending) {
      this.pendingToolCallRequests.delete(id);
      if (response.error) {
        toolCallPending.reject(new Error(response.error.message));
      } else {
        const result = response.result;
        toolCallPending.resolve(result ?? "");
      }
      return;
    }
    const permissionPending = this.pendingPermissionRequests.get(id);
    if (permissionPending) {
      this.pendingPermissionRequests.delete(id);
      if (response.error) {
        permissionPending.reject(new Error(response.error.message));
      } else {
        const result = response.result;
        permissionPending.resolve(result ?? { kind: "denied-interactively-by-user" });
      }
      return;
    }
    this.log("debug", `[${this.clientId}] Received unexpected response: ${response.id}`);
  }
  // ==========================================================================
  // Client Methods
  // ==========================================================================
  async handlePing(request) {
    const client = await this.getDefaultClient();
    const params = request.params;
    const result = await client.ping(params?.message);
    this.sendToClient({
      jsonrpc: "2.0",
      id: request.id,
      result
    });
  }
  async handleGetState(request) {
    const client = await this.getDefaultClient();
    const state = client.getState();
    this.sendToClient({
      jsonrpc: "2.0",
      id: request.id,
      result: state
    });
  }
  async handleCreateSession(request) {
    const params = request.params;
    const cwd = params?.cwd ?? this.defaultCwd;
    this.log("debug", `[${this.clientId}] RPC -> createSession (model: ${params?.model}, cwd: ${cwd})`);
    const client = await this.getOrCreateClient(cwd);
    const toolHandlers = /* @__PURE__ */ new Map();
    const sdkTools = params?.tools?.map((toolDef) => ({
      name: toolDef.name,
      description: toolDef.description,
      parameters: toolDef.parameters,
      handler: async (args, invocation) => {
        return this.handleToolCall(invocation.sessionId, invocation.toolCallId, toolDef.name, args);
      }
    }));
    const sessionConfig = {
      sessionId: params?.sessionId,
      model: params?.model,
      configDir: params?.configDir,
      streaming: params?.streaming ?? true,
      systemMessage: params?.systemMessage,
      availableTools: params?.availableTools,
      excludedTools: params?.excludedTools,
      provider: params?.provider,
      mcpServers: params?.mcpServers,
      customAgents: params?.customAgents,
      skillDirectories: params?.skillDirectories,
      disabledSkills: params?.disabledSkills,
      tools: sdkTools,
      onPermissionRequest: (permReq, invocation) => this.handlePermissionRequest(permReq, invocation.sessionId)
    };
    const session = await client.createSession(sessionConfig);
    const sessionId = session.sessionId;
    this.sessions.set(sessionId, session);
    this.sessionCwds.set(sessionId, cwd);
    this.sessionTools.set(sessionId, toolHandlers);
    const unsubscribe = session.on((event) => {
      this.forwardSessionEvent(sessionId, event);
    });
    this.sessionUnsubscribers.set(sessionId, unsubscribe);
    this.log("info", `Session started: ${sessionId}`);
    this.sendToClient({
      jsonrpc: "2.0",
      id: request.id,
      result: {
        sessionId,
        model: params?.model
        // Echo back the requested model
      }
    });
  }
  async handleResumeSession(request) {
    const params = request.params;
    const sessionId = params?.sessionId;
    if (!sessionId) {
      this.sendErrorResponse(request.id, -32602, "Missing sessionId parameter");
      return;
    }
    this.log("debug", `[${this.clientId}] RPC -> resumeSession: ${sessionId}`);
    if (this.sessions.has(sessionId)) {
      this.log("debug", `[${this.clientId}] Session ${sessionId} already active`);
      this.sendToClient({
        jsonrpc: "2.0",
        id: request.id,
        result: { sessionId }
      });
      return;
    }
    const cwd = await discoverSessionCwd(sessionId);
    const client = await this.getOrCreateClient(cwd ?? this.defaultCwd);
    const toolHandlers = /* @__PURE__ */ new Map();
    const sdkTools = params?.tools?.map((toolDef) => ({
      name: toolDef.name,
      description: toolDef.description,
      parameters: toolDef.parameters,
      handler: async (args, invocation) => {
        return this.handleToolCall(invocation.sessionId, invocation.toolCallId, toolDef.name, args);
      }
    }));
    const resumeConfig = {
      streaming: params?.streaming ?? true,
      provider: params?.provider,
      mcpServers: params?.mcpServers,
      customAgents: params?.customAgents,
      skillDirectories: params?.skillDirectories,
      disabledSkills: params?.disabledSkills,
      tools: sdkTools,
      onPermissionRequest: (permReq, invocation) => this.handlePermissionRequest(permReq, invocation.sessionId)
    };
    const session = await client.resumeSession(sessionId, resumeConfig);
    this.sessions.set(sessionId, session);
    this.sessionCwds.set(sessionId, cwd ?? this.defaultCwd);
    this.sessionTools.set(sessionId, toolHandlers);
    const unsubscribe = session.on((event) => {
      this.forwardSessionEvent(sessionId, event);
    });
    this.sessionUnsubscribers.set(sessionId, unsubscribe);
    this.log("info", `Session started: ${sessionId}`);
    this.sendToClient({
      jsonrpc: "2.0",
      id: request.id,
      result: { sessionId }
    });
  }
  async handleListSessions(request) {
    const client = await this.getDefaultClient();
    this.log("debug", `[${this.clientId}] RPC -> listSessions`);
    const sessions = await client.listSessions();
    this.log("debug", `[${this.clientId}] RPC <- listSessions (${sessions.length} sessions)`);
    const sessionsWithCwd = await Promise.all(
      sessions.map(async (s) => {
        const cwd = await discoverSessionCwd(s.sessionId);
        return {
          sessionId: s.sessionId,
          startTime: s.startTime.toISOString(),
          modifiedTime: s.modifiedTime.toISOString(),
          summary: s.summary,
          isRemote: s.isRemote,
          cwd
        };
      })
    );
    this.sendToClient({
      jsonrpc: "2.0",
      id: request.id,
      result: { sessions: sessionsWithCwd }
    });
  }
  async handleGetLastSessionId(request) {
    const client = await this.getDefaultClient();
    this.log("debug", `[${this.clientId}] RPC -> getLastSessionId`);
    const sessionId = await client.getLastSessionId();
    this.sendToClient({
      jsonrpc: "2.0",
      id: request.id,
      result: sessionId
    });
  }
  async handleDeleteSession(request) {
    const client = await this.getDefaultClient();
    const params = request.params;
    const sessionId = params?.sessionId;
    if (!sessionId) {
      this.sendErrorResponse(request.id, -32602, "Missing sessionId parameter");
      return;
    }
    this.log("debug", `[${this.clientId}] RPC -> deleteSession: ${sessionId}`);
    if (this.sessions.has(sessionId)) {
      const unsubscribe = this.sessionUnsubscribers.get(sessionId);
      if (unsubscribe) {
        unsubscribe();
        this.sessionUnsubscribers.delete(sessionId);
      }
      this.sessions.delete(sessionId);
      this.sessionCwds.delete(sessionId);
      this.sessionTools.delete(sessionId);
    }
    await client.deleteSession(sessionId);
    this.sendToClient({
      jsonrpc: "2.0",
      id: request.id,
      result: null
    });
  }
  // ==========================================================================
  // Slash Commands
  // ==========================================================================
  async handleListSlashCommands(request) {
    this.log("debug", `[${this.clientId}] RPC -> listSlashCommands`);
    this.sendToClient({
      jsonrpc: "2.0",
      id: request.id,
      result: { commands: BUILT_IN_COMMANDS }
    });
  }
  async handleExecuteSlashCommand(request) {
    const params = request.params;
    const command = params?.command;
    const sessionId = params?.sessionId;
    if (!command) {
      this.sendErrorResponse(request.id, -32602, "Missing command parameter");
      return;
    }
    this.log("info", `[${this.clientId}] RPC -> executeSlashCommand: ${command}`);
    const trimmed = command.trim();
    const parts = trimmed.split(/\s+/);
    const commandName = parts[0].toLowerCase();
    const args = parts.slice(1);
    const result = await this.executeSlashCommandInternal(commandName, args, sessionId);
    const response = {
      success: result.kind !== "message" || result.type !== "error",
      result
    };
    this.sendToClient({
      jsonrpc: "2.0",
      id: request.id,
      result: response
    });
  }
  async executeSlashCommandInternal(commandName, args, sessionId) {
    const cmd = BUILT_IN_COMMANDS.find(
      (c) => c.name === commandName || c.aliases?.includes(commandName)
    );
    if (!cmd) {
      return {
        kind: "message",
        type: "error",
        text: `Unknown command: ${commandName}`
      };
    }
    switch (cmd.name) {
      case "/session": {
        const cwd = sessionId ? this.sessionCwds.get(sessionId) ?? this.defaultCwd : this.defaultCwd;
        return {
          kind: "open-dialog",
          dialog: "session",
          data: {
            sessionId: sessionId ?? "No active session",
            workingDirectory: cwd
          }
        };
      }
      default:
        return {
          kind: "message",
          type: "error",
          text: `Unknown command: ${cmd.name}`
        };
    }
  }
  // ==========================================================================
  // File Search
  // ==========================================================================
  async handleSearchFiles(request) {
    const params = request.params;
    if (!params?.cwd) {
      this.sendErrorResponse(request.id, -32602, "Missing cwd parameter");
      return;
    }
    this.log("debug", `[${this.clientId}] RPC -> searchFiles: "${params.query}" in ${params.cwd}`);
    try {
      const result = await this.fileSearchService.search(params);
      this.log("debug", `[${this.clientId}] RPC <- searchFiles: ${result.results.length} results`);
      this.sendToClient({
        jsonrpc: "2.0",
        id: request.id,
        result
      });
    } catch (err) {
      this.log("error", `[${this.clientId}] File search failed: ${err}`);
      this.sendErrorResponse(request.id, -32603, `File search failed: ${err}`);
    }
  }
  // ==========================================================================
  // Model Selection
  // ==========================================================================
  async handleGetModels(request) {
    this.log("debug", `[${this.clientId}] RPC -> getModels`);
    const response = {
      models: SUPPORTED_MODELS,
      defaultModel: DEFAULT_MODEL
      // currentModel could be tracked per-session if needed
    };
    this.sendToClient({
      jsonrpc: "2.0",
      id: request.id,
      result: response
    });
  }
  // ==========================================================================
  // Session Methods
  // ==========================================================================
  async handleSessionSend(request) {
    const params = request.params;
    const sessionId = params?.sessionId;
    const prompt = params?.prompt;
    if (!sessionId) {
      this.sendErrorResponse(request.id, -32602, "Missing sessionId parameter");
      return;
    }
    if (!prompt) {
      this.sendErrorResponse(request.id, -32602, "Missing prompt parameter");
      return;
    }
    const session = this.sessions.get(sessionId);
    if (!session) {
      this.sendErrorResponse(request.id, -32600, `Session not found: ${sessionId}`);
      return;
    }
    const truncatedPrompt = prompt.length > 50 ? `${prompt.substring(0, 50)}...` : prompt;
    this.log("info", `Prompt received: "${truncatedPrompt}" (cwd: ${this.sessionCwds.get(sessionId) ?? this.defaultCwd})`);
    const messageOptions = {
      prompt,
      attachments: params?.attachments,
      mode: params?.mode
    };
    const messageId = await session.send(messageOptions);
    this.sendToClient({
      jsonrpc: "2.0",
      id: request.id,
      result: { messageId }
    });
  }
  async handleSessionSendAndWait(request) {
    const params = request.params;
    const sessionId = params?.sessionId;
    const prompt = params?.prompt;
    if (!sessionId) {
      this.sendErrorResponse(request.id, -32602, "Missing sessionId parameter");
      return;
    }
    if (!prompt) {
      this.sendErrorResponse(request.id, -32602, "Missing prompt parameter");
      return;
    }
    const session = this.sessions.get(sessionId);
    if (!session) {
      this.sendErrorResponse(request.id, -32600, `Session not found: ${sessionId}`);
      return;
    }
    const truncatedPrompt = prompt.length > 50 ? `${prompt.substring(0, 50)}...` : prompt;
    this.log("info", `Prompt received: "${truncatedPrompt}" (cwd: ${this.sessionCwds.get(sessionId) ?? this.defaultCwd})`);
    const messageOptions = {
      prompt,
      attachments: params?.attachments,
      mode: params?.mode
    };
    const result = await session.sendAndWait(messageOptions, params?.timeout);
    this.sendToClient({
      jsonrpc: "2.0",
      id: request.id,
      result: result ?? null
    });
  }
  async handleSessionGetMessages(request) {
    const params = request.params;
    const sessionId = params?.sessionId;
    if (!sessionId) {
      this.sendErrorResponse(request.id, -32602, "Missing sessionId parameter");
      return;
    }
    const session = this.sessions.get(sessionId);
    if (!session) {
      this.sendErrorResponse(request.id, -32600, `Session not found: ${sessionId}`);
      return;
    }
    this.log("debug", `[${this.clientId}] RPC -> session.getMessages: ${sessionId}`);
    const messages = await session.getMessages();
    this.sendToClient({
      jsonrpc: "2.0",
      id: request.id,
      result: messages
    });
  }
  async handleSessionAbort(request) {
    const params = request.params;
    const sessionId = params?.sessionId;
    if (!sessionId) {
      this.sendErrorResponse(request.id, -32602, "Missing sessionId parameter");
      return;
    }
    const session = this.sessions.get(sessionId);
    if (!session) {
      this.sendErrorResponse(request.id, -32600, `Session not found: ${sessionId}`);
      return;
    }
    this.log("debug", `[${this.clientId}] RPC -> session.abort: ${sessionId}`);
    await session.abort();
    this.sendToClient({
      jsonrpc: "2.0",
      id: request.id,
      result: null
    });
  }
  async handleSessionDestroy(request) {
    const params = request.params;
    const sessionId = params?.sessionId;
    if (!sessionId) {
      this.sendErrorResponse(request.id, -32602, "Missing sessionId parameter");
      return;
    }
    const session = this.sessions.get(sessionId);
    if (!session) {
      this.sendErrorResponse(request.id, -32600, `Session not found: ${sessionId}`);
      return;
    }
    this.log("info", `Session ended: ${sessionId}`);
    const unsubscribe = this.sessionUnsubscribers.get(sessionId);
    if (unsubscribe) {
      unsubscribe();
      this.sessionUnsubscribers.delete(sessionId);
    }
    await session.destroy();
    this.sessions.delete(sessionId);
    this.sessionCwds.delete(sessionId);
    this.sessionTools.delete(sessionId);
    this.sendToClient({
      jsonrpc: "2.0",
      id: request.id,
      result: null
    });
  }
  // ==========================================================================
  // Event Forwarding
  // ==========================================================================
  forwardSessionEvent(sessionId, event) {
    this.log("debug", `[${this.clientId}] \u2190 session.event (${sessionId}): ${event.type}`);
    this.sendToClient({
      jsonrpc: "2.0",
      method: "session.event",
      params: {
        sessionId,
        event
      }
    });
  }
  // ==========================================================================
  // Callback Handling (SDK -> Client)
  // ==========================================================================
  async handleToolCall(sessionId, toolCallId, toolName, args) {
    const callbackId = String(this.nextCallbackId++);
    this.log("debug", `[${this.clientId}] RPC -> tool.call: ${toolName}`);
    this.sendToClient({
      jsonrpc: "2.0",
      id: callbackId,
      method: "tool.call",
      params: {
        sessionId,
        toolCallId,
        toolName,
        arguments: args
      }
    });
    return new Promise((resolve3, reject) => {
      const timeout = setTimeout(() => {
        this.pendingToolCallRequests.delete(callbackId);
        reject(new Error("Tool call request timeout"));
      }, 3e5);
      this.pendingToolCallRequests.set(callbackId, {
        resolve: (result) => {
          clearTimeout(timeout);
          resolve3(result);
        },
        reject: (error) => {
          clearTimeout(timeout);
          reject(error);
        }
      });
    });
  }
  async handlePermissionRequest(request, sessionId) {
    const callbackId = String(this.nextCallbackId++);
    this.log("debug", `[${this.clientId}] RPC -> permission.request: ${request.kind}`);
    this.sendToClient({
      jsonrpc: "2.0",
      id: callbackId,
      method: "permission.request",
      params: {
        sessionId,
        permissionRequest: request
      }
    });
    return new Promise((resolve3, reject) => {
      const timeout = setTimeout(() => {
        this.pendingPermissionRequests.delete(callbackId);
        reject(new Error("Permission request timeout"));
      }, 6e4);
      this.pendingPermissionRequests.set(callbackId, {
        resolve: (result) => {
          clearTimeout(timeout);
          resolve3(result);
        },
        reject: (error) => {
          clearTimeout(timeout);
          reject(error);
        }
      });
    });
  }
  // ==========================================================================
  // Utilities
  // ==========================================================================
  sendErrorResponse(id, code, message) {
    this.sendToClient({
      jsonrpc: "2.0",
      id,
      error: { code, message }
    });
  }
  sendToClient(message) {
    if (this.clientStream.destroyed) return;
    const encoded = encodeJsonRpcMessageToBuffer(message);
    this.clientStream.write(encoded);
  }
};
var JsonRpcProxyHost = class {
  clients = /* @__PURE__ */ new Map();
  options;
  constructor(options = {}) {
    this.options = options;
  }
  /**
   * Handle a new client connection from the tunnel.
   */
  async handleClient(stream, clientId) {
    const connection = new ClientConnection(stream, clientId, this.options);
    this.clients.set(clientId, connection);
    await connection.start();
  }
  /**
   * Handle client disconnection.
   */
  handleClientDisconnect(clientId) {
    const connection = this.clients.get(clientId);
    if (connection) {
      connection.stop();
      this.clients.delete(clientId);
    }
  }
  /**
   * Stop all client connections and CLI processes.
   */
  async stop() {
    for (const connection of this.clients.values()) {
      connection.stop();
    }
    this.clients.clear();
  }
};

// src/logger.ts
var LOG_LEVEL_PRIORITY = {
  debug: 0,
  info: 1,
  warn: 2,
  error: 3
};
function formatTimestamp() {
  const now = /* @__PURE__ */ new Date();
  const hours = String(now.getHours()).padStart(2, "0");
  const minutes = String(now.getMinutes()).padStart(2, "0");
  const seconds = String(now.getSeconds()).padStart(2, "0");
  return `${hours}:${minutes}:${seconds}`;
}
function formatLevel(level) {
  return level.toUpperCase().padEnd(5);
}
function createLogger(options) {
  const minLevel = options.level;
  const minPriority = LOG_LEVEL_PRIORITY[minLevel];
  function shouldLog(level) {
    return LOG_LEVEL_PRIORITY[level] >= minPriority;
  }
  function log(level, message) {
    if (!shouldLog(level)) return;
    const timestamp = formatTimestamp();
    const levelStr = formatLevel(level);
    if (message.includes("\n")) {
      const lines = message.split("\n");
      for (const line of lines) {
        console.log(`[${timestamp}] [${levelStr}] ${line}`);
      }
    } else {
      console.log(`[${timestamp}] [${levelStr}] ${message}`);
    }
  }
  return {
    debug: (message) => log("debug", message),
    info: (message) => log("info", message),
    warn: (message) => log("warn", message),
    error: (message) => log("error", message),
    log,
    blank: () => console.log(""),
    getLevel: () => minLevel
  };
}
function createLogCallback(logger) {
  return (level, message) => logger.log(level, message);
}

// src/version-check.ts
var CURRENT_VERSION = "0.1.10";
var RELEASE_REPO_URL = "https://raw.githubusercontent.com/avanderhoorn/tunnel-proxy-release/main/package.json";
var UPDATE_COMMAND = "npm install -g github:avanderhoorn/tunnel-proxy-release";
var RED = "\x1B[31m";
var GREEN = "\x1B[32m";
var YELLOW = "\x1B[33m";
var DIM = "\x1B[2m";
var RESET = "\x1B[0m";
var BOLD = "\x1B[1m";
function parseSemVer(version) {
  const [major, minor, patch] = version.split(".").map(Number);
  return { major, minor, patch };
}
function compareSemVer(a, b) {
  if (a.major !== b.major) return a.major - b.major;
  if (a.minor !== b.minor) return a.minor - b.minor;
  return a.patch - b.patch;
}
async function fetchLatestVersion() {
  try {
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), 5e3);
    const response = await fetch(RELEASE_REPO_URL, {
      signal: controller.signal
    });
    clearTimeout(timeout);
    if (!response.ok) return null;
    const pkg = await response.json();
    return pkg.version;
  } catch {
    return null;
  }
}
async function checkForUpdates() {
  if (CURRENT_VERSION.startsWith("__")) {
    return;
  }
  const latestVersion = await fetchLatestVersion();
  if (!latestVersion) {
    return;
  }
  const current = parseSemVer(CURRENT_VERSION);
  const latest = parseSemVer(latestVersion);
  const comparison = compareSemVer(current, latest);
  if (comparison < 0) {
    console.log(
      `  ${BOLD}${YELLOW}Update available:${RESET} ${RED}${CURRENT_VERSION}${RESET} \u2192 ${GREEN}${latestVersion}${RESET}`
    );
    console.log(`  ${DIM}Run: ${UPDATE_COMMAND}${RESET}`);
    console.log();
  }
}

// src/banner.ts
var GREEN2 = "\x1B[32m";
var CYAN = "\x1B[36m";
var MAGENTA = "\x1B[35m";
var DIM2 = "\x1B[2m";
var RESET2 = "\x1B[0m";
var BOLD2 = "\x1B[1m";
function printBanner() {
  const version = CURRENT_VERSION.startsWith("__") ? "dev" : `v${CURRENT_VERSION}`;
  const url = "https://gh.io/copilot-tunnel";
  const iconL1 = `${CYAN}\u256D\u2500\u256E\u256D\u2500\u256E${RESET2}`;
  const iconL2 = `${CYAN}\u2570\u2500\u256F\u2570\u2500\u256F${RESET2}`;
  const iconL3 = `${MAGENTA}\u2588${RESET2} ${GREEN2}\u2598\u259D${RESET2} ${MAGENTA}\u2588${RESET2}`;
  const iconL4 = `${MAGENTA}\u2594\u2594\u2594\u2594${RESET2}`;
  const titleLine = `${MAGENTA}${BOLD2}GitHub Copilot Tunnel Host${RESET2}  ${DIM2}${version}${RESET2}`;
  const descLine = `${DIM2}Making your sessions available online.${RESET2}`;
  const urlLine = `${DIM2}See ${RESET2}${CYAN}${url}${RESET2}`;
  const line1 = `  ${iconL1}`;
  const line2 = `  ${iconL2}  ${titleLine}`;
  const line3 = `  ${iconL3}  ${descLine}`;
  const line4 = `   ${iconL4}   ${urlLine}`;
  console.log();
  console.log(line1);
  console.log(line2);
  console.log(line3);
  console.log(line4);
  console.log();
}

// src/sdk-proxy.ts
var GITHUB_CLIENT_ID2 = "Iv1.e7b89e013f801f03";
var GITHUB_TOKEN_URL2 = "https://github.com/login/oauth/access_token";
var program2 = new Command();
program2.name("remote-sdk-host").description("Host a Remote SDK session via Dev Tunnels").version(CURRENT_VERSION).option("-d, --debug", "Enable verbose debug logging").option("-p, --port <number>", "Port for local SDK connection", "0").action(runHost);
program2.command("logout").description("Clear stored GitHub credentials").action(runLogout);
var tunnelCmd = program2.command("tunnel").description("Manage stored tunnel configuration").action(runTunnelInfo);
tunnelCmd.command("clear").description("Clear stored tunnel configuration").action(runTunnelClear);
tunnelCmd.command("regenerate").option("-d, --debug", "Enable verbose debug logging").option("-p, --port <number>", "Port for local SDK connection", "0").description("Clear stored tunnel and create a fresh one").action(runTunnelRegenerate);
program2.parse();
async function runHost(options) {
  printBanner();
  checkForUpdates().catch(() => {
  });
  const logLevel = options.debug ? "debug" : "info";
  const port = parseInt(options.port || "0", 10);
  const logger = createLogger({ level: logLevel });
  const logCallback = createLogCallback(logger);
  const proxyHost = new JsonRpcProxyHost({
    cliPath: "copilot",
    cwd: process.cwd(),
    cliLogLevel: "info",
    logLevel,
    onLog: logCallback
  });
  const tunnelAdapter = createTunnelHostAdapter({
    port,
    logLevel,
    onLog: logCallback,
    onStatusChange: (status) => {
    },
    onAuth: (message, uri, userCode) => {
      logger.blank();
      logger.info("=== GitHub Authentication ===");
      logger.info(`Visit: ${uri}`);
      logger.info(`Enter code: ${userCode}`);
      logger.blank();
    }
  });
  tunnelAdapter.onClientConnected((stream, clientId) => {
    logger.info(`Client connected: ${clientId}`);
    proxyHost.handleClient(stream, clientId).catch((error) => {
      logger.error(`Error handling client ${clientId}: ${error}`);
    });
  });
  tunnelAdapter.onClientDisconnected((clientId) => {
    logger.info(`Client disconnected: ${clientId}`);
    proxyHost.handleClientDisconnect(clientId);
  });
  logger.debug("Starting tunnel...");
  let tunnelInfo;
  try {
    tunnelInfo = await tunnelAdapter.start();
  } catch (error) {
    logger.error(`Failed to start tunnel: ${error}`);
    process.exit(1);
  }
  if (tunnelInfo.username) {
    logger.info(`Using stored credentials (${tunnelInfo.username})`);
    logger.info("To switch accounts, run: remote-sdk-host logout");
  }
  logger.blank();
  logger.info("=== Tunnel Ready ===");
  logger.info(`Tunnel ID: ${tunnelInfo.tunnelId}`);
  logger.info(`Cluster:   ${tunnelInfo.clusterId}`);
  logger.info(`Port:      ${tunnelInfo.port}`);
  logger.blank();
  let isShuttingDown = false;
  const shutdown = async () => {
    if (isShuttingDown) return;
    isShuttingDown = true;
    logger.blank();
    logger.info("Shutting down...");
    const ignoreShutdownErrors = (err) => {
      if (err.message?.includes("stream was destroyed") || err.message?.includes("ERR_STREAM_DESTROYED")) {
        return;
      }
      logger.warn(`Shutdown error: ${err.message}`);
    };
    process.on("uncaughtException", ignoreShutdownErrors);
    process.on("unhandledRejection", ignoreShutdownErrors);
    try {
      await proxyHost.stop();
    } catch {
    }
    try {
      await tunnelAdapter.stop();
    } catch {
    }
    process.exit(0);
  };
  process.on("SIGINT", shutdown);
  process.on("SIGTERM", shutdown);
}
async function runLogout() {
  try {
    await clearTokenData();
    console.log("Credentials cleared.");
  } catch (error) {
    console.error(`Failed to clear credentials: ${error}`);
    process.exit(1);
  }
}
async function runTunnelInfo() {
  const configPath = getConfigPath();
  console.log(`Config file: ${configPath}`);
  console.log();
  try {
    const config = await loadTunnelConfig();
    if (config) {
      console.log("Stored tunnel configuration:");
      console.log(`  Tunnel ID: ${config.tunnelId}`);
      console.log(`  Cluster:   ${config.clusterId}`);
      console.log(`  Created:   ${config.createdAt}`);
    } else {
      console.log("No stored tunnel configuration.");
    }
  } catch (error) {
    console.error(`Failed to read tunnel config: ${error}`);
    process.exit(1);
  }
}
async function refreshAccessToken(refreshToken) {
  const response = await fetch(GITHUB_TOKEN_URL2, {
    method: "POST",
    headers: {
      Accept: "application/json",
      "Content-Type": "application/json"
    },
    body: JSON.stringify({
      client_id: GITHUB_CLIENT_ID2,
      refresh_token: refreshToken,
      grant_type: "refresh_token"
    })
  });
  if (!response.ok) {
    throw new Error(`Failed to refresh token: ${response.statusText}`);
  }
  const token = await response.json();
  if (token.error) {
    throw new Error(`Token refresh error: ${token.error_description || token.error}`);
  }
  if (!token.access_token) {
    throw new Error("Token refresh failed: no access token in response");
  }
  const now = Date.now();
  return {
    accessToken: token.access_token,
    refreshToken: token.refresh_token || refreshToken,
    expiresAt: now + (token.expires_in || 28800) * 1e3,
    refreshExpiresAt: now + (token.refresh_token_expires_in || 15638400) * 1e3
  };
}
async function getValidToken() {
  let tokenData = await loadTokenData();
  if (!tokenData) {
    return null;
  }
  const now = Date.now();
  const accessTokenExpired = tokenData.expiresAt < now + 5 * 60 * 1e3;
  const refreshTokenExpired = tokenData.refreshExpiresAt < now + 5 * 60 * 1e3;
  if (!accessTokenExpired) {
    return tokenData.accessToken;
  }
  if (accessTokenExpired && !refreshTokenExpired && tokenData.refreshToken) {
    try {
      const oldUsername = tokenData.username;
      tokenData = await refreshAccessToken(tokenData.refreshToken);
      tokenData.username = oldUsername;
      await saveTokenData(tokenData);
      return tokenData.accessToken;
    } catch {
      return null;
    }
  }
  return null;
}
async function runTunnelClear() {
  try {
    const githubToken = await getValidToken();
    if (githubToken) {
      console.log("Deleting tunnels from server...");
      const managementClient = new import_dev_tunnels_management2.TunnelManagementHttpClient(
        "RemoteSdkBridge/1.0",
        import_dev_tunnels_management2.ManagementApiVersions.Version20230927preview,
        () => Promise.resolve(`github ${githubToken}`)
      );
      const tunnels = await managementClient.listTunnels(
        void 0,
        // global search
        void 0,
        // default domain
        { labels: [TUNNEL_LABEL] }
      );
      if (tunnels.length > 0) {
        for (const tunnel of tunnels) {
          console.log(`  Deleting tunnel ${tunnel.tunnelId}...`);
          await managementClient.deleteTunnel(tunnel);
        }
        console.log(`Deleted ${tunnels.length} tunnel(s) from server.`);
      } else {
        console.log("No tunnels found with label.");
      }
    } else {
      console.log("No valid credentials found - only clearing local config.");
      console.log("(Run the host first to authenticate if you want to delete remote tunnels.)");
    }
    await clearTunnelConfig();
    console.log("Local tunnel configuration cleared.");
  } catch (error) {
    console.error(`Failed to clear tunnel config: ${error}`);
    process.exit(1);
  }
}
async function runTunnelRegenerate(options) {
  try {
    await clearTunnelConfig();
    console.log("Cleared stored tunnel configuration.");
    console.log();
  } catch (error) {
    console.error(`Failed to clear tunnel config: ${error}`);
    process.exit(1);
  }
  await runHost(options);
}
/*! Bundled license information:

mime-db/index.js:
  (*!
   * mime-db
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015-2022 Douglas Christopher Wilson
   * MIT Licensed
   *)

mime-types/index.js:
  (*!
   * mime-types
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

axios/dist/node/axios.cjs:
  (*! Axios v1.13.2 Copyright (c) 2025 Matt Zabriskie and contributors *)
*/
