#!/usr/bin/env node

const __bundled_import_meta_url = require('url').pathToFileURL(__filename).href;

"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/commander/lib/error.js
var require_error = __commonJS({
  "node_modules/commander/lib/error.js"(exports2) {
    "use strict";
    var CommanderError2 = class extends Error {
      /**
       * Constructs the CommanderError class
       * @param {number} exitCode suggested exit code which could be used with process.exit
       * @param {string} code an id string representing the error
       * @param {string} message human-readable description of the error
       */
      constructor(exitCode, code, message) {
        super(message);
        Error.captureStackTrace(this, this.constructor);
        this.name = this.constructor.name;
        this.code = code;
        this.exitCode = exitCode;
        this.nestedError = void 0;
      }
    };
    var InvalidArgumentError2 = class extends CommanderError2 {
      /**
       * Constructs the InvalidArgumentError class
       * @param {string} [message] explanation of why argument is invalid
       */
      constructor(message) {
        super(1, "commander.invalidArgument", message);
        Error.captureStackTrace(this, this.constructor);
        this.name = this.constructor.name;
      }
    };
    exports2.CommanderError = CommanderError2;
    exports2.InvalidArgumentError = InvalidArgumentError2;
  }
});

// node_modules/commander/lib/argument.js
var require_argument = __commonJS({
  "node_modules/commander/lib/argument.js"(exports2) {
    "use strict";
    var { InvalidArgumentError: InvalidArgumentError2 } = require_error();
    var Argument2 = class {
      /**
       * Initialize a new command argument with the given name and description.
       * The default is that the argument is required, and you can explicitly
       * indicate this with <> around the name. Put [] around the name for an optional argument.
       *
       * @param {string} name
       * @param {string} [description]
       */
      constructor(name, description) {
        this.description = description || "";
        this.variadic = false;
        this.parseArg = void 0;
        this.defaultValue = void 0;
        this.defaultValueDescription = void 0;
        this.argChoices = void 0;
        switch (name[0]) {
          case "<":
            this.required = true;
            this._name = name.slice(1, -1);
            break;
          case "[":
            this.required = false;
            this._name = name.slice(1, -1);
            break;
          default:
            this.required = true;
            this._name = name;
            break;
        }
        if (this._name.length > 3 && this._name.slice(-3) === "...") {
          this.variadic = true;
          this._name = this._name.slice(0, -3);
        }
      }
      /**
       * Return argument name.
       *
       * @return {string}
       */
      name() {
        return this._name;
      }
      /**
       * @package
       */
      _concatValue(value, previous) {
        if (previous === this.defaultValue || !Array.isArray(previous)) {
          return [value];
        }
        return previous.concat(value);
      }
      /**
       * Set the default value, and optionally supply the description to be displayed in the help.
       *
       * @param {*} value
       * @param {string} [description]
       * @return {Argument}
       */
      default(value, description) {
        this.defaultValue = value;
        this.defaultValueDescription = description;
        return this;
      }
      /**
       * Set the custom handler for processing CLI command arguments into argument values.
       *
       * @param {Function} [fn]
       * @return {Argument}
       */
      argParser(fn) {
        this.parseArg = fn;
        return this;
      }
      /**
       * Only allow argument value to be one of choices.
       *
       * @param {string[]} values
       * @return {Argument}
       */
      choices(values) {
        this.argChoices = values.slice();
        this.parseArg = (arg, previous) => {
          if (!this.argChoices.includes(arg)) {
            throw new InvalidArgumentError2(
              `Allowed choices are ${this.argChoices.join(", ")}.`
            );
          }
          if (this.variadic) {
            return this._concatValue(arg, previous);
          }
          return arg;
        };
        return this;
      }
      /**
       * Make argument required.
       *
       * @returns {Argument}
       */
      argRequired() {
        this.required = true;
        return this;
      }
      /**
       * Make argument optional.
       *
       * @returns {Argument}
       */
      argOptional() {
        this.required = false;
        return this;
      }
    };
    function humanReadableArgName(arg) {
      const nameOutput = arg.name() + (arg.variadic === true ? "..." : "");
      return arg.required ? "<" + nameOutput + ">" : "[" + nameOutput + "]";
    }
    exports2.Argument = Argument2;
    exports2.humanReadableArgName = humanReadableArgName;
  }
});

// node_modules/commander/lib/help.js
var require_help = __commonJS({
  "node_modules/commander/lib/help.js"(exports2) {
    "use strict";
    var { humanReadableArgName } = require_argument();
    var Help2 = class {
      constructor() {
        this.helpWidth = void 0;
        this.sortSubcommands = false;
        this.sortOptions = false;
        this.showGlobalOptions = false;
      }
      /**
       * Get an array of the visible subcommands. Includes a placeholder for the implicit help command, if there is one.
       *
       * @param {Command} cmd
       * @returns {Command[]}
       */
      visibleCommands(cmd) {
        const visibleCommands = cmd.commands.filter((cmd2) => !cmd2._hidden);
        const helpCommand = cmd._getHelpCommand();
        if (helpCommand && !helpCommand._hidden) {
          visibleCommands.push(helpCommand);
        }
        if (this.sortSubcommands) {
          visibleCommands.sort((a, b) => {
            return a.name().localeCompare(b.name());
          });
        }
        return visibleCommands;
      }
      /**
       * Compare options for sort.
       *
       * @param {Option} a
       * @param {Option} b
       * @returns {number}
       */
      compareOptions(a, b) {
        const getSortKey = (option) => {
          return option.short ? option.short.replace(/^-/, "") : option.long.replace(/^--/, "");
        };
        return getSortKey(a).localeCompare(getSortKey(b));
      }
      /**
       * Get an array of the visible options. Includes a placeholder for the implicit help option, if there is one.
       *
       * @param {Command} cmd
       * @returns {Option[]}
       */
      visibleOptions(cmd) {
        const visibleOptions = cmd.options.filter((option) => !option.hidden);
        const helpOption = cmd._getHelpOption();
        if (helpOption && !helpOption.hidden) {
          const removeShort = helpOption.short && cmd._findOption(helpOption.short);
          const removeLong = helpOption.long && cmd._findOption(helpOption.long);
          if (!removeShort && !removeLong) {
            visibleOptions.push(helpOption);
          } else if (helpOption.long && !removeLong) {
            visibleOptions.push(
              cmd.createOption(helpOption.long, helpOption.description)
            );
          } else if (helpOption.short && !removeShort) {
            visibleOptions.push(
              cmd.createOption(helpOption.short, helpOption.description)
            );
          }
        }
        if (this.sortOptions) {
          visibleOptions.sort(this.compareOptions);
        }
        return visibleOptions;
      }
      /**
       * Get an array of the visible global options. (Not including help.)
       *
       * @param {Command} cmd
       * @returns {Option[]}
       */
      visibleGlobalOptions(cmd) {
        if (!this.showGlobalOptions) return [];
        const globalOptions = [];
        for (let ancestorCmd = cmd.parent; ancestorCmd; ancestorCmd = ancestorCmd.parent) {
          const visibleOptions = ancestorCmd.options.filter(
            (option) => !option.hidden
          );
          globalOptions.push(...visibleOptions);
        }
        if (this.sortOptions) {
          globalOptions.sort(this.compareOptions);
        }
        return globalOptions;
      }
      /**
       * Get an array of the arguments if any have a description.
       *
       * @param {Command} cmd
       * @returns {Argument[]}
       */
      visibleArguments(cmd) {
        if (cmd._argsDescription) {
          cmd.registeredArguments.forEach((argument) => {
            argument.description = argument.description || cmd._argsDescription[argument.name()] || "";
          });
        }
        if (cmd.registeredArguments.find((argument) => argument.description)) {
          return cmd.registeredArguments;
        }
        return [];
      }
      /**
       * Get the command term to show in the list of subcommands.
       *
       * @param {Command} cmd
       * @returns {string}
       */
      subcommandTerm(cmd) {
        const args = cmd.registeredArguments.map((arg) => humanReadableArgName(arg)).join(" ");
        return cmd._name + (cmd._aliases[0] ? "|" + cmd._aliases[0] : "") + (cmd.options.length ? " [options]" : "") + // simplistic check for non-help option
        (args ? " " + args : "");
      }
      /**
       * Get the option term to show in the list of options.
       *
       * @param {Option} option
       * @returns {string}
       */
      optionTerm(option) {
        return option.flags;
      }
      /**
       * Get the argument term to show in the list of arguments.
       *
       * @param {Argument} argument
       * @returns {string}
       */
      argumentTerm(argument) {
        return argument.name();
      }
      /**
       * Get the longest command term length.
       *
       * @param {Command} cmd
       * @param {Help} helper
       * @returns {number}
       */
      longestSubcommandTermLength(cmd, helper) {
        return helper.visibleCommands(cmd).reduce((max, command) => {
          return Math.max(max, helper.subcommandTerm(command).length);
        }, 0);
      }
      /**
       * Get the longest option term length.
       *
       * @param {Command} cmd
       * @param {Help} helper
       * @returns {number}
       */
      longestOptionTermLength(cmd, helper) {
        return helper.visibleOptions(cmd).reduce((max, option) => {
          return Math.max(max, helper.optionTerm(option).length);
        }, 0);
      }
      /**
       * Get the longest global option term length.
       *
       * @param {Command} cmd
       * @param {Help} helper
       * @returns {number}
       */
      longestGlobalOptionTermLength(cmd, helper) {
        return helper.visibleGlobalOptions(cmd).reduce((max, option) => {
          return Math.max(max, helper.optionTerm(option).length);
        }, 0);
      }
      /**
       * Get the longest argument term length.
       *
       * @param {Command} cmd
       * @param {Help} helper
       * @returns {number}
       */
      longestArgumentTermLength(cmd, helper) {
        return helper.visibleArguments(cmd).reduce((max, argument) => {
          return Math.max(max, helper.argumentTerm(argument).length);
        }, 0);
      }
      /**
       * Get the command usage to be displayed at the top of the built-in help.
       *
       * @param {Command} cmd
       * @returns {string}
       */
      commandUsage(cmd) {
        let cmdName = cmd._name;
        if (cmd._aliases[0]) {
          cmdName = cmdName + "|" + cmd._aliases[0];
        }
        let ancestorCmdNames = "";
        for (let ancestorCmd = cmd.parent; ancestorCmd; ancestorCmd = ancestorCmd.parent) {
          ancestorCmdNames = ancestorCmd.name() + " " + ancestorCmdNames;
        }
        return ancestorCmdNames + cmdName + " " + cmd.usage();
      }
      /**
       * Get the description for the command.
       *
       * @param {Command} cmd
       * @returns {string}
       */
      commandDescription(cmd) {
        return cmd.description();
      }
      /**
       * Get the subcommand summary to show in the list of subcommands.
       * (Fallback to description for backwards compatibility.)
       *
       * @param {Command} cmd
       * @returns {string}
       */
      subcommandDescription(cmd) {
        return cmd.summary() || cmd.description();
      }
      /**
       * Get the option description to show in the list of options.
       *
       * @param {Option} option
       * @return {string}
       */
      optionDescription(option) {
        const extraInfo = [];
        if (option.argChoices) {
          extraInfo.push(
            // use stringify to match the display of the default value
            `choices: ${option.argChoices.map((choice) => JSON.stringify(choice)).join(", ")}`
          );
        }
        if (option.defaultValue !== void 0) {
          const showDefault = option.required || option.optional || option.isBoolean() && typeof option.defaultValue === "boolean";
          if (showDefault) {
            extraInfo.push(
              `default: ${option.defaultValueDescription || JSON.stringify(option.defaultValue)}`
            );
          }
        }
        if (option.presetArg !== void 0 && option.optional) {
          extraInfo.push(`preset: ${JSON.stringify(option.presetArg)}`);
        }
        if (option.envVar !== void 0) {
          extraInfo.push(`env: ${option.envVar}`);
        }
        if (extraInfo.length > 0) {
          return `${option.description} (${extraInfo.join(", ")})`;
        }
        return option.description;
      }
      /**
       * Get the argument description to show in the list of arguments.
       *
       * @param {Argument} argument
       * @return {string}
       */
      argumentDescription(argument) {
        const extraInfo = [];
        if (argument.argChoices) {
          extraInfo.push(
            // use stringify to match the display of the default value
            `choices: ${argument.argChoices.map((choice) => JSON.stringify(choice)).join(", ")}`
          );
        }
        if (argument.defaultValue !== void 0) {
          extraInfo.push(
            `default: ${argument.defaultValueDescription || JSON.stringify(argument.defaultValue)}`
          );
        }
        if (extraInfo.length > 0) {
          const extraDescripton = `(${extraInfo.join(", ")})`;
          if (argument.description) {
            return `${argument.description} ${extraDescripton}`;
          }
          return extraDescripton;
        }
        return argument.description;
      }
      /**
       * Generate the built-in help text.
       *
       * @param {Command} cmd
       * @param {Help} helper
       * @returns {string}
       */
      formatHelp(cmd, helper) {
        const termWidth = helper.padWidth(cmd, helper);
        const helpWidth = helper.helpWidth || 80;
        const itemIndentWidth = 2;
        const itemSeparatorWidth = 2;
        function formatItem(term, description) {
          if (description) {
            const fullText = `${term.padEnd(termWidth + itemSeparatorWidth)}${description}`;
            return helper.wrap(
              fullText,
              helpWidth - itemIndentWidth,
              termWidth + itemSeparatorWidth
            );
          }
          return term;
        }
        function formatList(textArray) {
          return textArray.join("\n").replace(/^/gm, " ".repeat(itemIndentWidth));
        }
        let output = [`Usage: ${helper.commandUsage(cmd)}`, ""];
        const commandDescription = helper.commandDescription(cmd);
        if (commandDescription.length > 0) {
          output = output.concat([
            helper.wrap(commandDescription, helpWidth, 0),
            ""
          ]);
        }
        const argumentList = helper.visibleArguments(cmd).map((argument) => {
          return formatItem(
            helper.argumentTerm(argument),
            helper.argumentDescription(argument)
          );
        });
        if (argumentList.length > 0) {
          output = output.concat(["Arguments:", formatList(argumentList), ""]);
        }
        const optionList = helper.visibleOptions(cmd).map((option) => {
          return formatItem(
            helper.optionTerm(option),
            helper.optionDescription(option)
          );
        });
        if (optionList.length > 0) {
          output = output.concat(["Options:", formatList(optionList), ""]);
        }
        if (this.showGlobalOptions) {
          const globalOptionList = helper.visibleGlobalOptions(cmd).map((option) => {
            return formatItem(
              helper.optionTerm(option),
              helper.optionDescription(option)
            );
          });
          if (globalOptionList.length > 0) {
            output = output.concat([
              "Global Options:",
              formatList(globalOptionList),
              ""
            ]);
          }
        }
        const commandList = helper.visibleCommands(cmd).map((cmd2) => {
          return formatItem(
            helper.subcommandTerm(cmd2),
            helper.subcommandDescription(cmd2)
          );
        });
        if (commandList.length > 0) {
          output = output.concat(["Commands:", formatList(commandList), ""]);
        }
        return output.join("\n");
      }
      /**
       * Calculate the pad width from the maximum term length.
       *
       * @param {Command} cmd
       * @param {Help} helper
       * @returns {number}
       */
      padWidth(cmd, helper) {
        return Math.max(
          helper.longestOptionTermLength(cmd, helper),
          helper.longestGlobalOptionTermLength(cmd, helper),
          helper.longestSubcommandTermLength(cmd, helper),
          helper.longestArgumentTermLength(cmd, helper)
        );
      }
      /**
       * Wrap the given string to width characters per line, with lines after the first indented.
       * Do not wrap if insufficient room for wrapping (minColumnWidth), or string is manually formatted.
       *
       * @param {string} str
       * @param {number} width
       * @param {number} indent
       * @param {number} [minColumnWidth=40]
       * @return {string}
       *
       */
      wrap(str, width, indent, minColumnWidth = 40) {
        const indents = " \\f\\t\\v\xA0\u1680\u2000-\u200A\u202F\u205F\u3000\uFEFF";
        const manualIndent = new RegExp(`[\\n][${indents}]+`);
        if (str.match(manualIndent)) return str;
        const columnWidth = width - indent;
        if (columnWidth < minColumnWidth) return str;
        const leadingStr = str.slice(0, indent);
        const columnText = str.slice(indent).replace("\r\n", "\n");
        const indentString = " ".repeat(indent);
        const zeroWidthSpace = "\u200B";
        const breaks = `\\s${zeroWidthSpace}`;
        const regex = new RegExp(
          `
|.{1,${columnWidth - 1}}([${breaks}]|$)|[^${breaks}]+?([${breaks}]|$)`,
          "g"
        );
        const lines = columnText.match(regex) || [];
        return leadingStr + lines.map((line, i) => {
          if (line === "\n") return "";
          return (i > 0 ? indentString : "") + line.trimEnd();
        }).join("\n");
      }
    };
    exports2.Help = Help2;
  }
});

// node_modules/commander/lib/option.js
var require_option = __commonJS({
  "node_modules/commander/lib/option.js"(exports2) {
    "use strict";
    var { InvalidArgumentError: InvalidArgumentError2 } = require_error();
    var Option2 = class {
      /**
       * Initialize a new `Option` with the given `flags` and `description`.
       *
       * @param {string} flags
       * @param {string} [description]
       */
      constructor(flags, description) {
        this.flags = flags;
        this.description = description || "";
        this.required = flags.includes("<");
        this.optional = flags.includes("[");
        this.variadic = /\w\.\.\.[>\]]$/.test(flags);
        this.mandatory = false;
        const optionFlags = splitOptionFlags(flags);
        this.short = optionFlags.shortFlag;
        this.long = optionFlags.longFlag;
        this.negate = false;
        if (this.long) {
          this.negate = this.long.startsWith("--no-");
        }
        this.defaultValue = void 0;
        this.defaultValueDescription = void 0;
        this.presetArg = void 0;
        this.envVar = void 0;
        this.parseArg = void 0;
        this.hidden = false;
        this.argChoices = void 0;
        this.conflictsWith = [];
        this.implied = void 0;
      }
      /**
       * Set the default value, and optionally supply the description to be displayed in the help.
       *
       * @param {*} value
       * @param {string} [description]
       * @return {Option}
       */
      default(value, description) {
        this.defaultValue = value;
        this.defaultValueDescription = description;
        return this;
      }
      /**
       * Preset to use when option used without option-argument, especially optional but also boolean and negated.
       * The custom processing (parseArg) is called.
       *
       * @example
       * new Option('--color').default('GREYSCALE').preset('RGB');
       * new Option('--donate [amount]').preset('20').argParser(parseFloat);
       *
       * @param {*} arg
       * @return {Option}
       */
      preset(arg) {
        this.presetArg = arg;
        return this;
      }
      /**
       * Add option name(s) that conflict with this option.
       * An error will be displayed if conflicting options are found during parsing.
       *
       * @example
       * new Option('--rgb').conflicts('cmyk');
       * new Option('--js').conflicts(['ts', 'jsx']);
       *
       * @param {(string | string[])} names
       * @return {Option}
       */
      conflicts(names) {
        this.conflictsWith = this.conflictsWith.concat(names);
        return this;
      }
      /**
       * Specify implied option values for when this option is set and the implied options are not.
       *
       * The custom processing (parseArg) is not called on the implied values.
       *
       * @example
       * program
       *   .addOption(new Option('--log', 'write logging information to file'))
       *   .addOption(new Option('--trace', 'log extra details').implies({ log: 'trace.txt' }));
       *
       * @param {object} impliedOptionValues
       * @return {Option}
       */
      implies(impliedOptionValues) {
        let newImplied = impliedOptionValues;
        if (typeof impliedOptionValues === "string") {
          newImplied = { [impliedOptionValues]: true };
        }
        this.implied = Object.assign(this.implied || {}, newImplied);
        return this;
      }
      /**
       * Set environment variable to check for option value.
       *
       * An environment variable is only used if when processed the current option value is
       * undefined, or the source of the current value is 'default' or 'config' or 'env'.
       *
       * @param {string} name
       * @return {Option}
       */
      env(name) {
        this.envVar = name;
        return this;
      }
      /**
       * Set the custom handler for processing CLI option arguments into option values.
       *
       * @param {Function} [fn]
       * @return {Option}
       */
      argParser(fn) {
        this.parseArg = fn;
        return this;
      }
      /**
       * Whether the option is mandatory and must have a value after parsing.
       *
       * @param {boolean} [mandatory=true]
       * @return {Option}
       */
      makeOptionMandatory(mandatory = true) {
        this.mandatory = !!mandatory;
        return this;
      }
      /**
       * Hide option in help.
       *
       * @param {boolean} [hide=true]
       * @return {Option}
       */
      hideHelp(hide = true) {
        this.hidden = !!hide;
        return this;
      }
      /**
       * @package
       */
      _concatValue(value, previous) {
        if (previous === this.defaultValue || !Array.isArray(previous)) {
          return [value];
        }
        return previous.concat(value);
      }
      /**
       * Only allow option value to be one of choices.
       *
       * @param {string[]} values
       * @return {Option}
       */
      choices(values) {
        this.argChoices = values.slice();
        this.parseArg = (arg, previous) => {
          if (!this.argChoices.includes(arg)) {
            throw new InvalidArgumentError2(
              `Allowed choices are ${this.argChoices.join(", ")}.`
            );
          }
          if (this.variadic) {
            return this._concatValue(arg, previous);
          }
          return arg;
        };
        return this;
      }
      /**
       * Return option name.
       *
       * @return {string}
       */
      name() {
        if (this.long) {
          return this.long.replace(/^--/, "");
        }
        return this.short.replace(/^-/, "");
      }
      /**
       * Return option name, in a camelcase format that can be used
       * as a object attribute key.
       *
       * @return {string}
       */
      attributeName() {
        return camelcase(this.name().replace(/^no-/, ""));
      }
      /**
       * Check if `arg` matches the short or long flag.
       *
       * @param {string} arg
       * @return {boolean}
       * @package
       */
      is(arg) {
        return this.short === arg || this.long === arg;
      }
      /**
       * Return whether a boolean option.
       *
       * Options are one of boolean, negated, required argument, or optional argument.
       *
       * @return {boolean}
       * @package
       */
      isBoolean() {
        return !this.required && !this.optional && !this.negate;
      }
    };
    var DualOptions = class {
      /**
       * @param {Option[]} options
       */
      constructor(options) {
        this.positiveOptions = /* @__PURE__ */ new Map();
        this.negativeOptions = /* @__PURE__ */ new Map();
        this.dualOptions = /* @__PURE__ */ new Set();
        options.forEach((option) => {
          if (option.negate) {
            this.negativeOptions.set(option.attributeName(), option);
          } else {
            this.positiveOptions.set(option.attributeName(), option);
          }
        });
        this.negativeOptions.forEach((value, key) => {
          if (this.positiveOptions.has(key)) {
            this.dualOptions.add(key);
          }
        });
      }
      /**
       * Did the value come from the option, and not from possible matching dual option?
       *
       * @param {*} value
       * @param {Option} option
       * @returns {boolean}
       */
      valueFromOption(value, option) {
        const optionKey = option.attributeName();
        if (!this.dualOptions.has(optionKey)) return true;
        const preset = this.negativeOptions.get(optionKey).presetArg;
        const negativeValue = preset !== void 0 ? preset : false;
        return option.negate === (negativeValue === value);
      }
    };
    function camelcase(str) {
      return str.split("-").reduce((str2, word) => {
        return str2 + word[0].toUpperCase() + word.slice(1);
      });
    }
    function splitOptionFlags(flags) {
      let shortFlag;
      let longFlag;
      const flagParts = flags.split(/[ |,]+/);
      if (flagParts.length > 1 && !/^[[<]/.test(flagParts[1]))
        shortFlag = flagParts.shift();
      longFlag = flagParts.shift();
      if (!shortFlag && /^-[^-]$/.test(longFlag)) {
        shortFlag = longFlag;
        longFlag = void 0;
      }
      return { shortFlag, longFlag };
    }
    exports2.Option = Option2;
    exports2.DualOptions = DualOptions;
  }
});

// node_modules/commander/lib/suggestSimilar.js
var require_suggestSimilar = __commonJS({
  "node_modules/commander/lib/suggestSimilar.js"(exports2) {
    "use strict";
    var maxDistance = 3;
    function editDistance(a, b) {
      if (Math.abs(a.length - b.length) > maxDistance)
        return Math.max(a.length, b.length);
      const d = [];
      for (let i = 0; i <= a.length; i++) {
        d[i] = [i];
      }
      for (let j = 0; j <= b.length; j++) {
        d[0][j] = j;
      }
      for (let j = 1; j <= b.length; j++) {
        for (let i = 1; i <= a.length; i++) {
          let cost = 1;
          if (a[i - 1] === b[j - 1]) {
            cost = 0;
          } else {
            cost = 1;
          }
          d[i][j] = Math.min(
            d[i - 1][j] + 1,
            // deletion
            d[i][j - 1] + 1,
            // insertion
            d[i - 1][j - 1] + cost
            // substitution
          );
          if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {
            d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + 1);
          }
        }
      }
      return d[a.length][b.length];
    }
    function suggestSimilar(word, candidates) {
      if (!candidates || candidates.length === 0) return "";
      candidates = Array.from(new Set(candidates));
      const searchingOptions = word.startsWith("--");
      if (searchingOptions) {
        word = word.slice(2);
        candidates = candidates.map((candidate) => candidate.slice(2));
      }
      let similar = [];
      let bestDistance = maxDistance;
      const minSimilarity = 0.4;
      candidates.forEach((candidate) => {
        if (candidate.length <= 1) return;
        const distance = editDistance(word, candidate);
        const length = Math.max(word.length, candidate.length);
        const similarity = (length - distance) / length;
        if (similarity > minSimilarity) {
          if (distance < bestDistance) {
            bestDistance = distance;
            similar = [candidate];
          } else if (distance === bestDistance) {
            similar.push(candidate);
          }
        }
      });
      similar.sort((a, b) => a.localeCompare(b));
      if (searchingOptions) {
        similar = similar.map((candidate) => `--${candidate}`);
      }
      if (similar.length > 1) {
        return `
(Did you mean one of ${similar.join(", ")}?)`;
      }
      if (similar.length === 1) {
        return `
(Did you mean ${similar[0]}?)`;
      }
      return "";
    }
    exports2.suggestSimilar = suggestSimilar;
  }
});

// node_modules/commander/lib/command.js
var require_command = __commonJS({
  "node_modules/commander/lib/command.js"(exports2) {
    "use strict";
    var EventEmitter4 = require("events").EventEmitter;
    var childProcess = require("child_process");
    var path11 = require("path");
    var fs10 = require("fs");
    var process2 = require("process");
    var { Argument: Argument2, humanReadableArgName } = require_argument();
    var { CommanderError: CommanderError2 } = require_error();
    var { Help: Help2 } = require_help();
    var { Option: Option2, DualOptions } = require_option();
    var { suggestSimilar } = require_suggestSimilar();
    var Command2 = class _Command extends EventEmitter4 {
      /**
       * Initialize a new `Command`.
       *
       * @param {string} [name]
       */
      constructor(name) {
        super();
        this.commands = [];
        this.options = [];
        this.parent = null;
        this._allowUnknownOption = false;
        this._allowExcessArguments = true;
        this.registeredArguments = [];
        this._args = this.registeredArguments;
        this.args = [];
        this.rawArgs = [];
        this.processedArgs = [];
        this._scriptPath = null;
        this._name = name || "";
        this._optionValues = {};
        this._optionValueSources = {};
        this._storeOptionsAsProperties = false;
        this._actionHandler = null;
        this._executableHandler = false;
        this._executableFile = null;
        this._executableDir = null;
        this._defaultCommandName = null;
        this._exitCallback = null;
        this._aliases = [];
        this._combineFlagAndOptionalValue = true;
        this._description = "";
        this._summary = "";
        this._argsDescription = void 0;
        this._enablePositionalOptions = false;
        this._passThroughOptions = false;
        this._lifeCycleHooks = {};
        this._showHelpAfterError = false;
        this._showSuggestionAfterError = true;
        this._outputConfiguration = {
          writeOut: (str) => process2.stdout.write(str),
          writeErr: (str) => process2.stderr.write(str),
          getOutHelpWidth: () => process2.stdout.isTTY ? process2.stdout.columns : void 0,
          getErrHelpWidth: () => process2.stderr.isTTY ? process2.stderr.columns : void 0,
          outputError: (str, write) => write(str)
        };
        this._hidden = false;
        this._helpOption = void 0;
        this._addImplicitHelpCommand = void 0;
        this._helpCommand = void 0;
        this._helpConfiguration = {};
      }
      /**
       * Copy settings that are useful to have in common across root command and subcommands.
       *
       * (Used internally when adding a command using `.command()` so subcommands inherit parent settings.)
       *
       * @param {Command} sourceCommand
       * @return {Command} `this` command for chaining
       */
      copyInheritedSettings(sourceCommand) {
        this._outputConfiguration = sourceCommand._outputConfiguration;
        this._helpOption = sourceCommand._helpOption;
        this._helpCommand = sourceCommand._helpCommand;
        this._helpConfiguration = sourceCommand._helpConfiguration;
        this._exitCallback = sourceCommand._exitCallback;
        this._storeOptionsAsProperties = sourceCommand._storeOptionsAsProperties;
        this._combineFlagAndOptionalValue = sourceCommand._combineFlagAndOptionalValue;
        this._allowExcessArguments = sourceCommand._allowExcessArguments;
        this._enablePositionalOptions = sourceCommand._enablePositionalOptions;
        this._showHelpAfterError = sourceCommand._showHelpAfterError;
        this._showSuggestionAfterError = sourceCommand._showSuggestionAfterError;
        return this;
      }
      /**
       * @returns {Command[]}
       * @private
       */
      _getCommandAndAncestors() {
        const result = [];
        for (let command = this; command; command = command.parent) {
          result.push(command);
        }
        return result;
      }
      /**
       * Define a command.
       *
       * There are two styles of command: pay attention to where to put the description.
       *
       * @example
       * // Command implemented using action handler (description is supplied separately to `.command`)
       * program
       *   .command('clone <source> [destination]')
       *   .description('clone a repository into a newly created directory')
       *   .action((source, destination) => {
       *     console.log('clone command called');
       *   });
       *
       * // Command implemented using separate executable file (description is second parameter to `.command`)
       * program
       *   .command('start <service>', 'start named service')
       *   .command('stop [service]', 'stop named service, or all if no name supplied');
       *
       * @param {string} nameAndArgs - command name and arguments, args are `<required>` or `[optional]` and last may also be `variadic...`
       * @param {(object | string)} [actionOptsOrExecDesc] - configuration options (for action), or description (for executable)
       * @param {object} [execOpts] - configuration options (for executable)
       * @return {Command} returns new command for action handler, or `this` for executable command
       */
      command(nameAndArgs, actionOptsOrExecDesc, execOpts) {
        let desc = actionOptsOrExecDesc;
        let opts = execOpts;
        if (typeof desc === "object" && desc !== null) {
          opts = desc;
          desc = null;
        }
        opts = opts || {};
        const [, name, args] = nameAndArgs.match(/([^ ]+) *(.*)/);
        const cmd = this.createCommand(name);
        if (desc) {
          cmd.description(desc);
          cmd._executableHandler = true;
        }
        if (opts.isDefault) this._defaultCommandName = cmd._name;
        cmd._hidden = !!(opts.noHelp || opts.hidden);
        cmd._executableFile = opts.executableFile || null;
        if (args) cmd.arguments(args);
        this._registerCommand(cmd);
        cmd.parent = this;
        cmd.copyInheritedSettings(this);
        if (desc) return this;
        return cmd;
      }
      /**
       * Factory routine to create a new unattached command.
       *
       * See .command() for creating an attached subcommand, which uses this routine to
       * create the command. You can override createCommand to customise subcommands.
       *
       * @param {string} [name]
       * @return {Command} new command
       */
      createCommand(name) {
        return new _Command(name);
      }
      /**
       * You can customise the help with a subclass of Help by overriding createHelp,
       * or by overriding Help properties using configureHelp().
       *
       * @return {Help}
       */
      createHelp() {
        return Object.assign(new Help2(), this.configureHelp());
      }
      /**
       * You can customise the help by overriding Help properties using configureHelp(),
       * or with a subclass of Help by overriding createHelp().
       *
       * @param {object} [configuration] - configuration options
       * @return {(Command | object)} `this` command for chaining, or stored configuration
       */
      configureHelp(configuration) {
        if (configuration === void 0) return this._helpConfiguration;
        this._helpConfiguration = configuration;
        return this;
      }
      /**
       * The default output goes to stdout and stderr. You can customise this for special
       * applications. You can also customise the display of errors by overriding outputError.
       *
       * The configuration properties are all functions:
       *
       *     // functions to change where being written, stdout and stderr
       *     writeOut(str)
       *     writeErr(str)
       *     // matching functions to specify width for wrapping help
       *     getOutHelpWidth()
       *     getErrHelpWidth()
       *     // functions based on what is being written out
       *     outputError(str, write) // used for displaying errors, and not used for displaying help
       *
       * @param {object} [configuration] - configuration options
       * @return {(Command | object)} `this` command for chaining, or stored configuration
       */
      configureOutput(configuration) {
        if (configuration === void 0) return this._outputConfiguration;
        Object.assign(this._outputConfiguration, configuration);
        return this;
      }
      /**
       * Display the help or a custom message after an error occurs.
       *
       * @param {(boolean|string)} [displayHelp]
       * @return {Command} `this` command for chaining
       */
      showHelpAfterError(displayHelp = true) {
        if (typeof displayHelp !== "string") displayHelp = !!displayHelp;
        this._showHelpAfterError = displayHelp;
        return this;
      }
      /**
       * Display suggestion of similar commands for unknown commands, or options for unknown options.
       *
       * @param {boolean} [displaySuggestion]
       * @return {Command} `this` command for chaining
       */
      showSuggestionAfterError(displaySuggestion = true) {
        this._showSuggestionAfterError = !!displaySuggestion;
        return this;
      }
      /**
       * Add a prepared subcommand.
       *
       * See .command() for creating an attached subcommand which inherits settings from its parent.
       *
       * @param {Command} cmd - new subcommand
       * @param {object} [opts] - configuration options
       * @return {Command} `this` command for chaining
       */
      addCommand(cmd, opts) {
        if (!cmd._name) {
          throw new Error(`Command passed to .addCommand() must have a name
- specify the name in Command constructor or using .name()`);
        }
        opts = opts || {};
        if (opts.isDefault) this._defaultCommandName = cmd._name;
        if (opts.noHelp || opts.hidden) cmd._hidden = true;
        this._registerCommand(cmd);
        cmd.parent = this;
        cmd._checkForBrokenPassThrough();
        return this;
      }
      /**
       * Factory routine to create a new unattached argument.
       *
       * See .argument() for creating an attached argument, which uses this routine to
       * create the argument. You can override createArgument to return a custom argument.
       *
       * @param {string} name
       * @param {string} [description]
       * @return {Argument} new argument
       */
      createArgument(name, description) {
        return new Argument2(name, description);
      }
      /**
       * Define argument syntax for command.
       *
       * The default is that the argument is required, and you can explicitly
       * indicate this with <> around the name. Put [] around the name for an optional argument.
       *
       * @example
       * program.argument('<input-file>');
       * program.argument('[output-file]');
       *
       * @param {string} name
       * @param {string} [description]
       * @param {(Function|*)} [fn] - custom argument processing function
       * @param {*} [defaultValue]
       * @return {Command} `this` command for chaining
       */
      argument(name, description, fn, defaultValue) {
        const argument = this.createArgument(name, description);
        if (typeof fn === "function") {
          argument.default(defaultValue).argParser(fn);
        } else {
          argument.default(fn);
        }
        this.addArgument(argument);
        return this;
      }
      /**
       * Define argument syntax for command, adding multiple at once (without descriptions).
       *
       * See also .argument().
       *
       * @example
       * program.arguments('<cmd> [env]');
       *
       * @param {string} names
       * @return {Command} `this` command for chaining
       */
      arguments(names) {
        names.trim().split(/ +/).forEach((detail) => {
          this.argument(detail);
        });
        return this;
      }
      /**
       * Define argument syntax for command, adding a prepared argument.
       *
       * @param {Argument} argument
       * @return {Command} `this` command for chaining
       */
      addArgument(argument) {
        const previousArgument = this.registeredArguments.slice(-1)[0];
        if (previousArgument && previousArgument.variadic) {
          throw new Error(
            `only the last argument can be variadic '${previousArgument.name()}'`
          );
        }
        if (argument.required && argument.defaultValue !== void 0 && argument.parseArg === void 0) {
          throw new Error(
            `a default value for a required argument is never used: '${argument.name()}'`
          );
        }
        this.registeredArguments.push(argument);
        return this;
      }
      /**
       * Customise or override default help command. By default a help command is automatically added if your command has subcommands.
       *
       * @example
       *    program.helpCommand('help [cmd]');
       *    program.helpCommand('help [cmd]', 'show help');
       *    program.helpCommand(false); // suppress default help command
       *    program.helpCommand(true); // add help command even if no subcommands
       *
       * @param {string|boolean} enableOrNameAndArgs - enable with custom name and/or arguments, or boolean to override whether added
       * @param {string} [description] - custom description
       * @return {Command} `this` command for chaining
       */
      helpCommand(enableOrNameAndArgs, description) {
        if (typeof enableOrNameAndArgs === "boolean") {
          this._addImplicitHelpCommand = enableOrNameAndArgs;
          return this;
        }
        enableOrNameAndArgs = enableOrNameAndArgs ?? "help [command]";
        const [, helpName, helpArgs] = enableOrNameAndArgs.match(/([^ ]+) *(.*)/);
        const helpDescription = description ?? "display help for command";
        const helpCommand = this.createCommand(helpName);
        helpCommand.helpOption(false);
        if (helpArgs) helpCommand.arguments(helpArgs);
        if (helpDescription) helpCommand.description(helpDescription);
        this._addImplicitHelpCommand = true;
        this._helpCommand = helpCommand;
        return this;
      }
      /**
       * Add prepared custom help command.
       *
       * @param {(Command|string|boolean)} helpCommand - custom help command, or deprecated enableOrNameAndArgs as for `.helpCommand()`
       * @param {string} [deprecatedDescription] - deprecated custom description used with custom name only
       * @return {Command} `this` command for chaining
       */
      addHelpCommand(helpCommand, deprecatedDescription) {
        if (typeof helpCommand !== "object") {
          this.helpCommand(helpCommand, deprecatedDescription);
          return this;
        }
        this._addImplicitHelpCommand = true;
        this._helpCommand = helpCommand;
        return this;
      }
      /**
       * Lazy create help command.
       *
       * @return {(Command|null)}
       * @package
       */
      _getHelpCommand() {
        const hasImplicitHelpCommand = this._addImplicitHelpCommand ?? (this.commands.length && !this._actionHandler && !this._findCommand("help"));
        if (hasImplicitHelpCommand) {
          if (this._helpCommand === void 0) {
            this.helpCommand(void 0, void 0);
          }
          return this._helpCommand;
        }
        return null;
      }
      /**
       * Add hook for life cycle event.
       *
       * @param {string} event
       * @param {Function} listener
       * @return {Command} `this` command for chaining
       */
      hook(event, listener) {
        const allowedValues = ["preSubcommand", "preAction", "postAction"];
        if (!allowedValues.includes(event)) {
          throw new Error(`Unexpected value for event passed to hook : '${event}'.
Expecting one of '${allowedValues.join("', '")}'`);
        }
        if (this._lifeCycleHooks[event]) {
          this._lifeCycleHooks[event].push(listener);
        } else {
          this._lifeCycleHooks[event] = [listener];
        }
        return this;
      }
      /**
       * Register callback to use as replacement for calling process.exit.
       *
       * @param {Function} [fn] optional callback which will be passed a CommanderError, defaults to throwing
       * @return {Command} `this` command for chaining
       */
      exitOverride(fn) {
        if (fn) {
          this._exitCallback = fn;
        } else {
          this._exitCallback = (err) => {
            if (err.code !== "commander.executeSubCommandAsync") {
              throw err;
            } else {
            }
          };
        }
        return this;
      }
      /**
       * Call process.exit, and _exitCallback if defined.
       *
       * @param {number} exitCode exit code for using with process.exit
       * @param {string} code an id string representing the error
       * @param {string} message human-readable description of the error
       * @return never
       * @private
       */
      _exit(exitCode, code, message) {
        if (this._exitCallback) {
          this._exitCallback(new CommanderError2(exitCode, code, message));
        }
        process2.exit(exitCode);
      }
      /**
       * Register callback `fn` for the command.
       *
       * @example
       * program
       *   .command('serve')
       *   .description('start service')
       *   .action(function() {
       *      // do work here
       *   });
       *
       * @param {Function} fn
       * @return {Command} `this` command for chaining
       */
      action(fn) {
        const listener = (args) => {
          const expectedArgsCount = this.registeredArguments.length;
          const actionArgs = args.slice(0, expectedArgsCount);
          if (this._storeOptionsAsProperties) {
            actionArgs[expectedArgsCount] = this;
          } else {
            actionArgs[expectedArgsCount] = this.opts();
          }
          actionArgs.push(this);
          return fn.apply(this, actionArgs);
        };
        this._actionHandler = listener;
        return this;
      }
      /**
       * Factory routine to create a new unattached option.
       *
       * See .option() for creating an attached option, which uses this routine to
       * create the option. You can override createOption to return a custom option.
       *
       * @param {string} flags
       * @param {string} [description]
       * @return {Option} new option
       */
      createOption(flags, description) {
        return new Option2(flags, description);
      }
      /**
       * Wrap parseArgs to catch 'commander.invalidArgument'.
       *
       * @param {(Option | Argument)} target
       * @param {string} value
       * @param {*} previous
       * @param {string} invalidArgumentMessage
       * @private
       */
      _callParseArg(target, value, previous, invalidArgumentMessage) {
        try {
          return target.parseArg(value, previous);
        } catch (err) {
          if (err.code === "commander.invalidArgument") {
            const message = `${invalidArgumentMessage} ${err.message}`;
            this.error(message, { exitCode: err.exitCode, code: err.code });
          }
          throw err;
        }
      }
      /**
       * Check for option flag conflicts.
       * Register option if no conflicts found, or throw on conflict.
       *
       * @param {Option} option
       * @private
       */
      _registerOption(option) {
        const matchingOption = option.short && this._findOption(option.short) || option.long && this._findOption(option.long);
        if (matchingOption) {
          const matchingFlag = option.long && this._findOption(option.long) ? option.long : option.short;
          throw new Error(`Cannot add option '${option.flags}'${this._name && ` to command '${this._name}'`} due to conflicting flag '${matchingFlag}'
-  already used by option '${matchingOption.flags}'`);
        }
        this.options.push(option);
      }
      /**
       * Check for command name and alias conflicts with existing commands.
       * Register command if no conflicts found, or throw on conflict.
       *
       * @param {Command} command
       * @private
       */
      _registerCommand(command) {
        const knownBy = (cmd) => {
          return [cmd.name()].concat(cmd.aliases());
        };
        const alreadyUsed = knownBy(command).find(
          (name) => this._findCommand(name)
        );
        if (alreadyUsed) {
          const existingCmd = knownBy(this._findCommand(alreadyUsed)).join("|");
          const newCmd = knownBy(command).join("|");
          throw new Error(
            `cannot add command '${newCmd}' as already have command '${existingCmd}'`
          );
        }
        this.commands.push(command);
      }
      /**
       * Add an option.
       *
       * @param {Option} option
       * @return {Command} `this` command for chaining
       */
      addOption(option) {
        this._registerOption(option);
        const oname = option.name();
        const name = option.attributeName();
        if (option.negate) {
          const positiveLongFlag = option.long.replace(/^--no-/, "--");
          if (!this._findOption(positiveLongFlag)) {
            this.setOptionValueWithSource(
              name,
              option.defaultValue === void 0 ? true : option.defaultValue,
              "default"
            );
          }
        } else if (option.defaultValue !== void 0) {
          this.setOptionValueWithSource(name, option.defaultValue, "default");
        }
        const handleOptionValue = (val, invalidValueMessage, valueSource) => {
          if (val == null && option.presetArg !== void 0) {
            val = option.presetArg;
          }
          const oldValue = this.getOptionValue(name);
          if (val !== null && option.parseArg) {
            val = this._callParseArg(option, val, oldValue, invalidValueMessage);
          } else if (val !== null && option.variadic) {
            val = option._concatValue(val, oldValue);
          }
          if (val == null) {
            if (option.negate) {
              val = false;
            } else if (option.isBoolean() || option.optional) {
              val = true;
            } else {
              val = "";
            }
          }
          this.setOptionValueWithSource(name, val, valueSource);
        };
        this.on("option:" + oname, (val) => {
          const invalidValueMessage = `error: option '${option.flags}' argument '${val}' is invalid.`;
          handleOptionValue(val, invalidValueMessage, "cli");
        });
        if (option.envVar) {
          this.on("optionEnv:" + oname, (val) => {
            const invalidValueMessage = `error: option '${option.flags}' value '${val}' from env '${option.envVar}' is invalid.`;
            handleOptionValue(val, invalidValueMessage, "env");
          });
        }
        return this;
      }
      /**
       * Internal implementation shared by .option() and .requiredOption()
       *
       * @return {Command} `this` command for chaining
       * @private
       */
      _optionEx(config, flags, description, fn, defaultValue) {
        if (typeof flags === "object" && flags instanceof Option2) {
          throw new Error(
            "To add an Option object use addOption() instead of option() or requiredOption()"
          );
        }
        const option = this.createOption(flags, description);
        option.makeOptionMandatory(!!config.mandatory);
        if (typeof fn === "function") {
          option.default(defaultValue).argParser(fn);
        } else if (fn instanceof RegExp) {
          const regex = fn;
          fn = (val, def) => {
            const m = regex.exec(val);
            return m ? m[0] : def;
          };
          option.default(defaultValue).argParser(fn);
        } else {
          option.default(fn);
        }
        return this.addOption(option);
      }
      /**
       * Define option with `flags`, `description`, and optional argument parsing function or `defaultValue` or both.
       *
       * The `flags` string contains the short and/or long flags, separated by comma, a pipe or space. A required
       * option-argument is indicated by `<>` and an optional option-argument by `[]`.
       *
       * See the README for more details, and see also addOption() and requiredOption().
       *
       * @example
       * program
       *     .option('-p, --pepper', 'add pepper')
       *     .option('-p, --pizza-type <TYPE>', 'type of pizza') // required option-argument
       *     .option('-c, --cheese [CHEESE]', 'add extra cheese', 'mozzarella') // optional option-argument with default
       *     .option('-t, --tip <VALUE>', 'add tip to purchase cost', parseFloat) // custom parse function
       *
       * @param {string} flags
       * @param {string} [description]
       * @param {(Function|*)} [parseArg] - custom option processing function or default value
       * @param {*} [defaultValue]
       * @return {Command} `this` command for chaining
       */
      option(flags, description, parseArg, defaultValue) {
        return this._optionEx({}, flags, description, parseArg, defaultValue);
      }
      /**
       * Add a required option which must have a value after parsing. This usually means
       * the option must be specified on the command line. (Otherwise the same as .option().)
       *
       * The `flags` string contains the short and/or long flags, separated by comma, a pipe or space.
       *
       * @param {string} flags
       * @param {string} [description]
       * @param {(Function|*)} [parseArg] - custom option processing function or default value
       * @param {*} [defaultValue]
       * @return {Command} `this` command for chaining
       */
      requiredOption(flags, description, parseArg, defaultValue) {
        return this._optionEx(
          { mandatory: true },
          flags,
          description,
          parseArg,
          defaultValue
        );
      }
      /**
       * Alter parsing of short flags with optional values.
       *
       * @example
       * // for `.option('-f,--flag [value]'):
       * program.combineFlagAndOptionalValue(true);  // `-f80` is treated like `--flag=80`, this is the default behaviour
       * program.combineFlagAndOptionalValue(false) // `-fb` is treated like `-f -b`
       *
       * @param {boolean} [combine] - if `true` or omitted, an optional value can be specified directly after the flag.
       * @return {Command} `this` command for chaining
       */
      combineFlagAndOptionalValue(combine = true) {
        this._combineFlagAndOptionalValue = !!combine;
        return this;
      }
      /**
       * Allow unknown options on the command line.
       *
       * @param {boolean} [allowUnknown] - if `true` or omitted, no error will be thrown for unknown options.
       * @return {Command} `this` command for chaining
       */
      allowUnknownOption(allowUnknown = true) {
        this._allowUnknownOption = !!allowUnknown;
        return this;
      }
      /**
       * Allow excess command-arguments on the command line. Pass false to make excess arguments an error.
       *
       * @param {boolean} [allowExcess] - if `true` or omitted, no error will be thrown for excess arguments.
       * @return {Command} `this` command for chaining
       */
      allowExcessArguments(allowExcess = true) {
        this._allowExcessArguments = !!allowExcess;
        return this;
      }
      /**
       * Enable positional options. Positional means global options are specified before subcommands which lets
       * subcommands reuse the same option names, and also enables subcommands to turn on passThroughOptions.
       * The default behaviour is non-positional and global options may appear anywhere on the command line.
       *
       * @param {boolean} [positional]
       * @return {Command} `this` command for chaining
       */
      enablePositionalOptions(positional = true) {
        this._enablePositionalOptions = !!positional;
        return this;
      }
      /**
       * Pass through options that come after command-arguments rather than treat them as command-options,
       * so actual command-options come before command-arguments. Turning this on for a subcommand requires
       * positional options to have been enabled on the program (parent commands).
       * The default behaviour is non-positional and options may appear before or after command-arguments.
       *
       * @param {boolean} [passThrough] for unknown options.
       * @return {Command} `this` command for chaining
       */
      passThroughOptions(passThrough = true) {
        this._passThroughOptions = !!passThrough;
        this._checkForBrokenPassThrough();
        return this;
      }
      /**
       * @private
       */
      _checkForBrokenPassThrough() {
        if (this.parent && this._passThroughOptions && !this.parent._enablePositionalOptions) {
          throw new Error(
            `passThroughOptions cannot be used for '${this._name}' without turning on enablePositionalOptions for parent command(s)`
          );
        }
      }
      /**
       * Whether to store option values as properties on command object,
       * or store separately (specify false). In both cases the option values can be accessed using .opts().
       *
       * @param {boolean} [storeAsProperties=true]
       * @return {Command} `this` command for chaining
       */
      storeOptionsAsProperties(storeAsProperties = true) {
        if (this.options.length) {
          throw new Error("call .storeOptionsAsProperties() before adding options");
        }
        if (Object.keys(this._optionValues).length) {
          throw new Error(
            "call .storeOptionsAsProperties() before setting option values"
          );
        }
        this._storeOptionsAsProperties = !!storeAsProperties;
        return this;
      }
      /**
       * Retrieve option value.
       *
       * @param {string} key
       * @return {object} value
       */
      getOptionValue(key) {
        if (this._storeOptionsAsProperties) {
          return this[key];
        }
        return this._optionValues[key];
      }
      /**
       * Store option value.
       *
       * @param {string} key
       * @param {object} value
       * @return {Command} `this` command for chaining
       */
      setOptionValue(key, value) {
        return this.setOptionValueWithSource(key, value, void 0);
      }
      /**
       * Store option value and where the value came from.
       *
       * @param {string} key
       * @param {object} value
       * @param {string} source - expected values are default/config/env/cli/implied
       * @return {Command} `this` command for chaining
       */
      setOptionValueWithSource(key, value, source) {
        if (this._storeOptionsAsProperties) {
          this[key] = value;
        } else {
          this._optionValues[key] = value;
        }
        this._optionValueSources[key] = source;
        return this;
      }
      /**
       * Get source of option value.
       * Expected values are default | config | env | cli | implied
       *
       * @param {string} key
       * @return {string}
       */
      getOptionValueSource(key) {
        return this._optionValueSources[key];
      }
      /**
       * Get source of option value. See also .optsWithGlobals().
       * Expected values are default | config | env | cli | implied
       *
       * @param {string} key
       * @return {string}
       */
      getOptionValueSourceWithGlobals(key) {
        let source;
        this._getCommandAndAncestors().forEach((cmd) => {
          if (cmd.getOptionValueSource(key) !== void 0) {
            source = cmd.getOptionValueSource(key);
          }
        });
        return source;
      }
      /**
       * Get user arguments from implied or explicit arguments.
       * Side-effects: set _scriptPath if args included script. Used for default program name, and subcommand searches.
       *
       * @private
       */
      _prepareUserArgs(argv, parseOptions) {
        if (argv !== void 0 && !Array.isArray(argv)) {
          throw new Error("first parameter to parse must be array or undefined");
        }
        parseOptions = parseOptions || {};
        if (argv === void 0 && parseOptions.from === void 0) {
          if (process2.versions?.electron) {
            parseOptions.from = "electron";
          }
          const execArgv = process2.execArgv ?? [];
          if (execArgv.includes("-e") || execArgv.includes("--eval") || execArgv.includes("-p") || execArgv.includes("--print")) {
            parseOptions.from = "eval";
          }
        }
        if (argv === void 0) {
          argv = process2.argv;
        }
        this.rawArgs = argv.slice();
        let userArgs;
        switch (parseOptions.from) {
          case void 0:
          case "node":
            this._scriptPath = argv[1];
            userArgs = argv.slice(2);
            break;
          case "electron":
            if (process2.defaultApp) {
              this._scriptPath = argv[1];
              userArgs = argv.slice(2);
            } else {
              userArgs = argv.slice(1);
            }
            break;
          case "user":
            userArgs = argv.slice(0);
            break;
          case "eval":
            userArgs = argv.slice(1);
            break;
          default:
            throw new Error(
              `unexpected parse option { from: '${parseOptions.from}' }`
            );
        }
        if (!this._name && this._scriptPath)
          this.nameFromFilename(this._scriptPath);
        this._name = this._name || "program";
        return userArgs;
      }
      /**
       * Parse `argv`, setting options and invoking commands when defined.
       *
       * Use parseAsync instead of parse if any of your action handlers are async.
       *
       * Call with no parameters to parse `process.argv`. Detects Electron and special node options like `node --eval`. Easy mode!
       *
       * Or call with an array of strings to parse, and optionally where the user arguments start by specifying where the arguments are `from`:
       * - `'node'`: default, `argv[0]` is the application and `argv[1]` is the script being run, with user arguments after that
       * - `'electron'`: `argv[0]` is the application and `argv[1]` varies depending on whether the electron application is packaged
       * - `'user'`: just user arguments
       *
       * @example
       * program.parse(); // parse process.argv and auto-detect electron and special node flags
       * program.parse(process.argv); // assume argv[0] is app and argv[1] is script
       * program.parse(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]
       *
       * @param {string[]} [argv] - optional, defaults to process.argv
       * @param {object} [parseOptions] - optionally specify style of options with from: node/user/electron
       * @param {string} [parseOptions.from] - where the args are from: 'node', 'user', 'electron'
       * @return {Command} `this` command for chaining
       */
      parse(argv, parseOptions) {
        const userArgs = this._prepareUserArgs(argv, parseOptions);
        this._parseCommand([], userArgs);
        return this;
      }
      /**
       * Parse `argv`, setting options and invoking commands when defined.
       *
       * Call with no parameters to parse `process.argv`. Detects Electron and special node options like `node --eval`. Easy mode!
       *
       * Or call with an array of strings to parse, and optionally where the user arguments start by specifying where the arguments are `from`:
       * - `'node'`: default, `argv[0]` is the application and `argv[1]` is the script being run, with user arguments after that
       * - `'electron'`: `argv[0]` is the application and `argv[1]` varies depending on whether the electron application is packaged
       * - `'user'`: just user arguments
       *
       * @example
       * await program.parseAsync(); // parse process.argv and auto-detect electron and special node flags
       * await program.parseAsync(process.argv); // assume argv[0] is app and argv[1] is script
       * await program.parseAsync(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]
       *
       * @param {string[]} [argv]
       * @param {object} [parseOptions]
       * @param {string} parseOptions.from - where the args are from: 'node', 'user', 'electron'
       * @return {Promise}
       */
      async parseAsync(argv, parseOptions) {
        const userArgs = this._prepareUserArgs(argv, parseOptions);
        await this._parseCommand([], userArgs);
        return this;
      }
      /**
       * Execute a sub-command executable.
       *
       * @private
       */
      _executeSubCommand(subcommand, args) {
        args = args.slice();
        let launchWithNode = false;
        const sourceExt = [".js", ".ts", ".tsx", ".mjs", ".cjs"];
        function findFile(baseDir, baseName) {
          const localBin = path11.resolve(baseDir, baseName);
          if (fs10.existsSync(localBin)) return localBin;
          if (sourceExt.includes(path11.extname(baseName))) return void 0;
          const foundExt = sourceExt.find(
            (ext) => fs10.existsSync(`${localBin}${ext}`)
          );
          if (foundExt) return `${localBin}${foundExt}`;
          return void 0;
        }
        this._checkForMissingMandatoryOptions();
        this._checkForConflictingOptions();
        let executableFile = subcommand._executableFile || `${this._name}-${subcommand._name}`;
        let executableDir = this._executableDir || "";
        if (this._scriptPath) {
          let resolvedScriptPath;
          try {
            resolvedScriptPath = fs10.realpathSync(this._scriptPath);
          } catch (err) {
            resolvedScriptPath = this._scriptPath;
          }
          executableDir = path11.resolve(
            path11.dirname(resolvedScriptPath),
            executableDir
          );
        }
        if (executableDir) {
          let localFile = findFile(executableDir, executableFile);
          if (!localFile && !subcommand._executableFile && this._scriptPath) {
            const legacyName = path11.basename(
              this._scriptPath,
              path11.extname(this._scriptPath)
            );
            if (legacyName !== this._name) {
              localFile = findFile(
                executableDir,
                `${legacyName}-${subcommand._name}`
              );
            }
          }
          executableFile = localFile || executableFile;
        }
        launchWithNode = sourceExt.includes(path11.extname(executableFile));
        let proc;
        if (process2.platform !== "win32") {
          if (launchWithNode) {
            args.unshift(executableFile);
            args = incrementNodeInspectorPort(process2.execArgv).concat(args);
            proc = childProcess.spawn(process2.argv[0], args, { stdio: "inherit" });
          } else {
            proc = childProcess.spawn(executableFile, args, { stdio: "inherit" });
          }
        } else {
          args.unshift(executableFile);
          args = incrementNodeInspectorPort(process2.execArgv).concat(args);
          proc = childProcess.spawn(process2.execPath, args, { stdio: "inherit" });
        }
        if (!proc.killed) {
          const signals = ["SIGUSR1", "SIGUSR2", "SIGTERM", "SIGINT", "SIGHUP"];
          signals.forEach((signal) => {
            process2.on(signal, () => {
              if (proc.killed === false && proc.exitCode === null) {
                proc.kill(signal);
              }
            });
          });
        }
        const exitCallback = this._exitCallback;
        proc.on("close", (code) => {
          code = code ?? 1;
          if (!exitCallback) {
            process2.exit(code);
          } else {
            exitCallback(
              new CommanderError2(
                code,
                "commander.executeSubCommandAsync",
                "(close)"
              )
            );
          }
        });
        proc.on("error", (err) => {
          if (err.code === "ENOENT") {
            const executableDirMessage = executableDir ? `searched for local subcommand relative to directory '${executableDir}'` : "no directory for search for local subcommand, use .executableDir() to supply a custom directory";
            const executableMissing = `'${executableFile}' does not exist
 - if '${subcommand._name}' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead
 - if the default executable name is not suitable, use the executableFile option to supply a custom name or path
 - ${executableDirMessage}`;
            throw new Error(executableMissing);
          } else if (err.code === "EACCES") {
            throw new Error(`'${executableFile}' not executable`);
          }
          if (!exitCallback) {
            process2.exit(1);
          } else {
            const wrappedError = new CommanderError2(
              1,
              "commander.executeSubCommandAsync",
              "(error)"
            );
            wrappedError.nestedError = err;
            exitCallback(wrappedError);
          }
        });
        this.runningCommand = proc;
      }
      /**
       * @private
       */
      _dispatchSubcommand(commandName, operands, unknown) {
        const subCommand = this._findCommand(commandName);
        if (!subCommand) this.help({ error: true });
        let promiseChain;
        promiseChain = this._chainOrCallSubCommandHook(
          promiseChain,
          subCommand,
          "preSubcommand"
        );
        promiseChain = this._chainOrCall(promiseChain, () => {
          if (subCommand._executableHandler) {
            this._executeSubCommand(subCommand, operands.concat(unknown));
          } else {
            return subCommand._parseCommand(operands, unknown);
          }
        });
        return promiseChain;
      }
      /**
       * Invoke help directly if possible, or dispatch if necessary.
       * e.g. help foo
       *
       * @private
       */
      _dispatchHelpCommand(subcommandName) {
        if (!subcommandName) {
          this.help();
        }
        const subCommand = this._findCommand(subcommandName);
        if (subCommand && !subCommand._executableHandler) {
          subCommand.help();
        }
        return this._dispatchSubcommand(
          subcommandName,
          [],
          [this._getHelpOption()?.long ?? this._getHelpOption()?.short ?? "--help"]
        );
      }
      /**
       * Check this.args against expected this.registeredArguments.
       *
       * @private
       */
      _checkNumberOfArguments() {
        this.registeredArguments.forEach((arg, i) => {
          if (arg.required && this.args[i] == null) {
            this.missingArgument(arg.name());
          }
        });
        if (this.registeredArguments.length > 0 && this.registeredArguments[this.registeredArguments.length - 1].variadic) {
          return;
        }
        if (this.args.length > this.registeredArguments.length) {
          this._excessArguments(this.args);
        }
      }
      /**
       * Process this.args using this.registeredArguments and save as this.processedArgs!
       *
       * @private
       */
      _processArguments() {
        const myParseArg = (argument, value, previous) => {
          let parsedValue = value;
          if (value !== null && argument.parseArg) {
            const invalidValueMessage = `error: command-argument value '${value}' is invalid for argument '${argument.name()}'.`;
            parsedValue = this._callParseArg(
              argument,
              value,
              previous,
              invalidValueMessage
            );
          }
          return parsedValue;
        };
        this._checkNumberOfArguments();
        const processedArgs = [];
        this.registeredArguments.forEach((declaredArg, index) => {
          let value = declaredArg.defaultValue;
          if (declaredArg.variadic) {
            if (index < this.args.length) {
              value = this.args.slice(index);
              if (declaredArg.parseArg) {
                value = value.reduce((processed, v) => {
                  return myParseArg(declaredArg, v, processed);
                }, declaredArg.defaultValue);
              }
            } else if (value === void 0) {
              value = [];
            }
          } else if (index < this.args.length) {
            value = this.args[index];
            if (declaredArg.parseArg) {
              value = myParseArg(declaredArg, value, declaredArg.defaultValue);
            }
          }
          processedArgs[index] = value;
        });
        this.processedArgs = processedArgs;
      }
      /**
       * Once we have a promise we chain, but call synchronously until then.
       *
       * @param {(Promise|undefined)} promise
       * @param {Function} fn
       * @return {(Promise|undefined)}
       * @private
       */
      _chainOrCall(promise2, fn) {
        if (promise2 && promise2.then && typeof promise2.then === "function") {
          return promise2.then(() => fn());
        }
        return fn();
      }
      /**
       *
       * @param {(Promise|undefined)} promise
       * @param {string} event
       * @return {(Promise|undefined)}
       * @private
       */
      _chainOrCallHooks(promise2, event) {
        let result = promise2;
        const hooks = [];
        this._getCommandAndAncestors().reverse().filter((cmd) => cmd._lifeCycleHooks[event] !== void 0).forEach((hookedCommand) => {
          hookedCommand._lifeCycleHooks[event].forEach((callback2) => {
            hooks.push({ hookedCommand, callback: callback2 });
          });
        });
        if (event === "postAction") {
          hooks.reverse();
        }
        hooks.forEach((hookDetail) => {
          result = this._chainOrCall(result, () => {
            return hookDetail.callback(hookDetail.hookedCommand, this);
          });
        });
        return result;
      }
      /**
       *
       * @param {(Promise|undefined)} promise
       * @param {Command} subCommand
       * @param {string} event
       * @return {(Promise|undefined)}
       * @private
       */
      _chainOrCallSubCommandHook(promise2, subCommand, event) {
        let result = promise2;
        if (this._lifeCycleHooks[event] !== void 0) {
          this._lifeCycleHooks[event].forEach((hook) => {
            result = this._chainOrCall(result, () => {
              return hook(this, subCommand);
            });
          });
        }
        return result;
      }
      /**
       * Process arguments in context of this command.
       * Returns action result, in case it is a promise.
       *
       * @private
       */
      _parseCommand(operands, unknown) {
        const parsed = this.parseOptions(unknown);
        this._parseOptionsEnv();
        this._parseOptionsImplied();
        operands = operands.concat(parsed.operands);
        unknown = parsed.unknown;
        this.args = operands.concat(unknown);
        if (operands && this._findCommand(operands[0])) {
          return this._dispatchSubcommand(operands[0], operands.slice(1), unknown);
        }
        if (this._getHelpCommand() && operands[0] === this._getHelpCommand().name()) {
          return this._dispatchHelpCommand(operands[1]);
        }
        if (this._defaultCommandName) {
          this._outputHelpIfRequested(unknown);
          return this._dispatchSubcommand(
            this._defaultCommandName,
            operands,
            unknown
          );
        }
        if (this.commands.length && this.args.length === 0 && !this._actionHandler && !this._defaultCommandName) {
          this.help({ error: true });
        }
        this._outputHelpIfRequested(parsed.unknown);
        this._checkForMissingMandatoryOptions();
        this._checkForConflictingOptions();
        const checkForUnknownOptions = () => {
          if (parsed.unknown.length > 0) {
            this.unknownOption(parsed.unknown[0]);
          }
        };
        const commandEvent = `command:${this.name()}`;
        if (this._actionHandler) {
          checkForUnknownOptions();
          this._processArguments();
          let promiseChain;
          promiseChain = this._chainOrCallHooks(promiseChain, "preAction");
          promiseChain = this._chainOrCall(
            promiseChain,
            () => this._actionHandler(this.processedArgs)
          );
          if (this.parent) {
            promiseChain = this._chainOrCall(promiseChain, () => {
              this.parent.emit(commandEvent, operands, unknown);
            });
          }
          promiseChain = this._chainOrCallHooks(promiseChain, "postAction");
          return promiseChain;
        }
        if (this.parent && this.parent.listenerCount(commandEvent)) {
          checkForUnknownOptions();
          this._processArguments();
          this.parent.emit(commandEvent, operands, unknown);
        } else if (operands.length) {
          if (this._findCommand("*")) {
            return this._dispatchSubcommand("*", operands, unknown);
          }
          if (this.listenerCount("command:*")) {
            this.emit("command:*", operands, unknown);
          } else if (this.commands.length) {
            this.unknownCommand();
          } else {
            checkForUnknownOptions();
            this._processArguments();
          }
        } else if (this.commands.length) {
          checkForUnknownOptions();
          this.help({ error: true });
        } else {
          checkForUnknownOptions();
          this._processArguments();
        }
      }
      /**
       * Find matching command.
       *
       * @private
       * @return {Command | undefined}
       */
      _findCommand(name) {
        if (!name) return void 0;
        return this.commands.find(
          (cmd) => cmd._name === name || cmd._aliases.includes(name)
        );
      }
      /**
       * Return an option matching `arg` if any.
       *
       * @param {string} arg
       * @return {Option}
       * @package
       */
      _findOption(arg) {
        return this.options.find((option) => option.is(arg));
      }
      /**
       * Display an error message if a mandatory option does not have a value.
       * Called after checking for help flags in leaf subcommand.
       *
       * @private
       */
      _checkForMissingMandatoryOptions() {
        this._getCommandAndAncestors().forEach((cmd) => {
          cmd.options.forEach((anOption) => {
            if (anOption.mandatory && cmd.getOptionValue(anOption.attributeName()) === void 0) {
              cmd.missingMandatoryOptionValue(anOption);
            }
          });
        });
      }
      /**
       * Display an error message if conflicting options are used together in this.
       *
       * @private
       */
      _checkForConflictingLocalOptions() {
        const definedNonDefaultOptions = this.options.filter((option) => {
          const optionKey = option.attributeName();
          if (this.getOptionValue(optionKey) === void 0) {
            return false;
          }
          return this.getOptionValueSource(optionKey) !== "default";
        });
        const optionsWithConflicting = definedNonDefaultOptions.filter(
          (option) => option.conflictsWith.length > 0
        );
        optionsWithConflicting.forEach((option) => {
          const conflictingAndDefined = definedNonDefaultOptions.find(
            (defined) => option.conflictsWith.includes(defined.attributeName())
          );
          if (conflictingAndDefined) {
            this._conflictingOption(option, conflictingAndDefined);
          }
        });
      }
      /**
       * Display an error message if conflicting options are used together.
       * Called after checking for help flags in leaf subcommand.
       *
       * @private
       */
      _checkForConflictingOptions() {
        this._getCommandAndAncestors().forEach((cmd) => {
          cmd._checkForConflictingLocalOptions();
        });
      }
      /**
       * Parse options from `argv` removing known options,
       * and return argv split into operands and unknown arguments.
       *
       * Examples:
       *
       *     argv => operands, unknown
       *     --known kkk op => [op], []
       *     op --known kkk => [op], []
       *     sub --unknown uuu op => [sub], [--unknown uuu op]
       *     sub -- --unknown uuu op => [sub --unknown uuu op], []
       *
       * @param {string[]} argv
       * @return {{operands: string[], unknown: string[]}}
       */
      parseOptions(argv) {
        const operands = [];
        const unknown = [];
        let dest = operands;
        const args = argv.slice();
        function maybeOption(arg) {
          return arg.length > 1 && arg[0] === "-";
        }
        let activeVariadicOption = null;
        while (args.length) {
          const arg = args.shift();
          if (arg === "--") {
            if (dest === unknown) dest.push(arg);
            dest.push(...args);
            break;
          }
          if (activeVariadicOption && !maybeOption(arg)) {
            this.emit(`option:${activeVariadicOption.name()}`, arg);
            continue;
          }
          activeVariadicOption = null;
          if (maybeOption(arg)) {
            const option = this._findOption(arg);
            if (option) {
              if (option.required) {
                const value = args.shift();
                if (value === void 0) this.optionMissingArgument(option);
                this.emit(`option:${option.name()}`, value);
              } else if (option.optional) {
                let value = null;
                if (args.length > 0 && !maybeOption(args[0])) {
                  value = args.shift();
                }
                this.emit(`option:${option.name()}`, value);
              } else {
                this.emit(`option:${option.name()}`);
              }
              activeVariadicOption = option.variadic ? option : null;
              continue;
            }
          }
          if (arg.length > 2 && arg[0] === "-" && arg[1] !== "-") {
            const option = this._findOption(`-${arg[1]}`);
            if (option) {
              if (option.required || option.optional && this._combineFlagAndOptionalValue) {
                this.emit(`option:${option.name()}`, arg.slice(2));
              } else {
                this.emit(`option:${option.name()}`);
                args.unshift(`-${arg.slice(2)}`);
              }
              continue;
            }
          }
          if (/^--[^=]+=/.test(arg)) {
            const index = arg.indexOf("=");
            const option = this._findOption(arg.slice(0, index));
            if (option && (option.required || option.optional)) {
              this.emit(`option:${option.name()}`, arg.slice(index + 1));
              continue;
            }
          }
          if (maybeOption(arg)) {
            dest = unknown;
          }
          if ((this._enablePositionalOptions || this._passThroughOptions) && operands.length === 0 && unknown.length === 0) {
            if (this._findCommand(arg)) {
              operands.push(arg);
              if (args.length > 0) unknown.push(...args);
              break;
            } else if (this._getHelpCommand() && arg === this._getHelpCommand().name()) {
              operands.push(arg);
              if (args.length > 0) operands.push(...args);
              break;
            } else if (this._defaultCommandName) {
              unknown.push(arg);
              if (args.length > 0) unknown.push(...args);
              break;
            }
          }
          if (this._passThroughOptions) {
            dest.push(arg);
            if (args.length > 0) dest.push(...args);
            break;
          }
          dest.push(arg);
        }
        return { operands, unknown };
      }
      /**
       * Return an object containing local option values as key-value pairs.
       *
       * @return {object}
       */
      opts() {
        if (this._storeOptionsAsProperties) {
          const result = {};
          const len = this.options.length;
          for (let i = 0; i < len; i++) {
            const key = this.options[i].attributeName();
            result[key] = key === this._versionOptionName ? this._version : this[key];
          }
          return result;
        }
        return this._optionValues;
      }
      /**
       * Return an object containing merged local and global option values as key-value pairs.
       *
       * @return {object}
       */
      optsWithGlobals() {
        return this._getCommandAndAncestors().reduce(
          (combinedOptions, cmd) => Object.assign(combinedOptions, cmd.opts()),
          {}
        );
      }
      /**
       * Display error message and exit (or call exitOverride).
       *
       * @param {string} message
       * @param {object} [errorOptions]
       * @param {string} [errorOptions.code] - an id string representing the error
       * @param {number} [errorOptions.exitCode] - used with process.exit
       */
      error(message, errorOptions) {
        this._outputConfiguration.outputError(
          `${message}
`,
          this._outputConfiguration.writeErr
        );
        if (typeof this._showHelpAfterError === "string") {
          this._outputConfiguration.writeErr(`${this._showHelpAfterError}
`);
        } else if (this._showHelpAfterError) {
          this._outputConfiguration.writeErr("\n");
          this.outputHelp({ error: true });
        }
        const config = errorOptions || {};
        const exitCode = config.exitCode || 1;
        const code = config.code || "commander.error";
        this._exit(exitCode, code, message);
      }
      /**
       * Apply any option related environment variables, if option does
       * not have a value from cli or client code.
       *
       * @private
       */
      _parseOptionsEnv() {
        this.options.forEach((option) => {
          if (option.envVar && option.envVar in process2.env) {
            const optionKey = option.attributeName();
            if (this.getOptionValue(optionKey) === void 0 || ["default", "config", "env"].includes(
              this.getOptionValueSource(optionKey)
            )) {
              if (option.required || option.optional) {
                this.emit(`optionEnv:${option.name()}`, process2.env[option.envVar]);
              } else {
                this.emit(`optionEnv:${option.name()}`);
              }
            }
          }
        });
      }
      /**
       * Apply any implied option values, if option is undefined or default value.
       *
       * @private
       */
      _parseOptionsImplied() {
        const dualHelper = new DualOptions(this.options);
        const hasCustomOptionValue = (optionKey) => {
          return this.getOptionValue(optionKey) !== void 0 && !["default", "implied"].includes(this.getOptionValueSource(optionKey));
        };
        this.options.filter(
          (option) => option.implied !== void 0 && hasCustomOptionValue(option.attributeName()) && dualHelper.valueFromOption(
            this.getOptionValue(option.attributeName()),
            option
          )
        ).forEach((option) => {
          Object.keys(option.implied).filter((impliedKey) => !hasCustomOptionValue(impliedKey)).forEach((impliedKey) => {
            this.setOptionValueWithSource(
              impliedKey,
              option.implied[impliedKey],
              "implied"
            );
          });
        });
      }
      /**
       * Argument `name` is missing.
       *
       * @param {string} name
       * @private
       */
      missingArgument(name) {
        const message = `error: missing required argument '${name}'`;
        this.error(message, { code: "commander.missingArgument" });
      }
      /**
       * `Option` is missing an argument.
       *
       * @param {Option} option
       * @private
       */
      optionMissingArgument(option) {
        const message = `error: option '${option.flags}' argument missing`;
        this.error(message, { code: "commander.optionMissingArgument" });
      }
      /**
       * `Option` does not have a value, and is a mandatory option.
       *
       * @param {Option} option
       * @private
       */
      missingMandatoryOptionValue(option) {
        const message = `error: required option '${option.flags}' not specified`;
        this.error(message, { code: "commander.missingMandatoryOptionValue" });
      }
      /**
       * `Option` conflicts with another option.
       *
       * @param {Option} option
       * @param {Option} conflictingOption
       * @private
       */
      _conflictingOption(option, conflictingOption) {
        const findBestOptionFromValue = (option2) => {
          const optionKey = option2.attributeName();
          const optionValue = this.getOptionValue(optionKey);
          const negativeOption = this.options.find(
            (target) => target.negate && optionKey === target.attributeName()
          );
          const positiveOption = this.options.find(
            (target) => !target.negate && optionKey === target.attributeName()
          );
          if (negativeOption && (negativeOption.presetArg === void 0 && optionValue === false || negativeOption.presetArg !== void 0 && optionValue === negativeOption.presetArg)) {
            return negativeOption;
          }
          return positiveOption || option2;
        };
        const getErrorMessage2 = (option2) => {
          const bestOption = findBestOptionFromValue(option2);
          const optionKey = bestOption.attributeName();
          const source = this.getOptionValueSource(optionKey);
          if (source === "env") {
            return `environment variable '${bestOption.envVar}'`;
          }
          return `option '${bestOption.flags}'`;
        };
        const message = `error: ${getErrorMessage2(option)} cannot be used with ${getErrorMessage2(conflictingOption)}`;
        this.error(message, { code: "commander.conflictingOption" });
      }
      /**
       * Unknown option `flag`.
       *
       * @param {string} flag
       * @private
       */
      unknownOption(flag) {
        if (this._allowUnknownOption) return;
        let suggestion = "";
        if (flag.startsWith("--") && this._showSuggestionAfterError) {
          let candidateFlags = [];
          let command = this;
          do {
            const moreFlags = command.createHelp().visibleOptions(command).filter((option) => option.long).map((option) => option.long);
            candidateFlags = candidateFlags.concat(moreFlags);
            command = command.parent;
          } while (command && !command._enablePositionalOptions);
          suggestion = suggestSimilar(flag, candidateFlags);
        }
        const message = `error: unknown option '${flag}'${suggestion}`;
        this.error(message, { code: "commander.unknownOption" });
      }
      /**
       * Excess arguments, more than expected.
       *
       * @param {string[]} receivedArgs
       * @private
       */
      _excessArguments(receivedArgs) {
        if (this._allowExcessArguments) return;
        const expected = this.registeredArguments.length;
        const s = expected === 1 ? "" : "s";
        const forSubcommand = this.parent ? ` for '${this.name()}'` : "";
        const message = `error: too many arguments${forSubcommand}. Expected ${expected} argument${s} but got ${receivedArgs.length}.`;
        this.error(message, { code: "commander.excessArguments" });
      }
      /**
       * Unknown command.
       *
       * @private
       */
      unknownCommand() {
        const unknownName = this.args[0];
        let suggestion = "";
        if (this._showSuggestionAfterError) {
          const candidateNames = [];
          this.createHelp().visibleCommands(this).forEach((command) => {
            candidateNames.push(command.name());
            if (command.alias()) candidateNames.push(command.alias());
          });
          suggestion = suggestSimilar(unknownName, candidateNames);
        }
        const message = `error: unknown command '${unknownName}'${suggestion}`;
        this.error(message, { code: "commander.unknownCommand" });
      }
      /**
       * Get or set the program version.
       *
       * This method auto-registers the "-V, --version" option which will print the version number.
       *
       * You can optionally supply the flags and description to override the defaults.
       *
       * @param {string} [str]
       * @param {string} [flags]
       * @param {string} [description]
       * @return {(this | string | undefined)} `this` command for chaining, or version string if no arguments
       */
      version(str, flags, description) {
        if (str === void 0) return this._version;
        this._version = str;
        flags = flags || "-V, --version";
        description = description || "output the version number";
        const versionOption = this.createOption(flags, description);
        this._versionOptionName = versionOption.attributeName();
        this._registerOption(versionOption);
        this.on("option:" + versionOption.name(), () => {
          this._outputConfiguration.writeOut(`${str}
`);
          this._exit(0, "commander.version", str);
        });
        return this;
      }
      /**
       * Set the description.
       *
       * @param {string} [str]
       * @param {object} [argsDescription]
       * @return {(string|Command)}
       */
      description(str, argsDescription) {
        if (str === void 0 && argsDescription === void 0)
          return this._description;
        this._description = str;
        if (argsDescription) {
          this._argsDescription = argsDescription;
        }
        return this;
      }
      /**
       * Set the summary. Used when listed as subcommand of parent.
       *
       * @param {string} [str]
       * @return {(string|Command)}
       */
      summary(str) {
        if (str === void 0) return this._summary;
        this._summary = str;
        return this;
      }
      /**
       * Set an alias for the command.
       *
       * You may call more than once to add multiple aliases. Only the first alias is shown in the auto-generated help.
       *
       * @param {string} [alias]
       * @return {(string|Command)}
       */
      alias(alias) {
        if (alias === void 0) return this._aliases[0];
        let command = this;
        if (this.commands.length !== 0 && this.commands[this.commands.length - 1]._executableHandler) {
          command = this.commands[this.commands.length - 1];
        }
        if (alias === command._name)
          throw new Error("Command alias can't be the same as its name");
        const matchingCommand = this.parent?._findCommand(alias);
        if (matchingCommand) {
          const existingCmd = [matchingCommand.name()].concat(matchingCommand.aliases()).join("|");
          throw new Error(
            `cannot add alias '${alias}' to command '${this.name()}' as already have command '${existingCmd}'`
          );
        }
        command._aliases.push(alias);
        return this;
      }
      /**
       * Set aliases for the command.
       *
       * Only the first alias is shown in the auto-generated help.
       *
       * @param {string[]} [aliases]
       * @return {(string[]|Command)}
       */
      aliases(aliases) {
        if (aliases === void 0) return this._aliases;
        aliases.forEach((alias) => this.alias(alias));
        return this;
      }
      /**
       * Set / get the command usage `str`.
       *
       * @param {string} [str]
       * @return {(string|Command)}
       */
      usage(str) {
        if (str === void 0) {
          if (this._usage) return this._usage;
          const args = this.registeredArguments.map((arg) => {
            return humanReadableArgName(arg);
          });
          return [].concat(
            this.options.length || this._helpOption !== null ? "[options]" : [],
            this.commands.length ? "[command]" : [],
            this.registeredArguments.length ? args : []
          ).join(" ");
        }
        this._usage = str;
        return this;
      }
      /**
       * Get or set the name of the command.
       *
       * @param {string} [str]
       * @return {(string|Command)}
       */
      name(str) {
        if (str === void 0) return this._name;
        this._name = str;
        return this;
      }
      /**
       * Set the name of the command from script filename, such as process.argv[1],
       * or require.main.filename, or __filename.
       *
       * (Used internally and public although not documented in README.)
       *
       * @example
       * program.nameFromFilename(require.main.filename);
       *
       * @param {string} filename
       * @return {Command}
       */
      nameFromFilename(filename) {
        this._name = path11.basename(filename, path11.extname(filename));
        return this;
      }
      /**
       * Get or set the directory for searching for executable subcommands of this command.
       *
       * @example
       * program.executableDir(__dirname);
       * // or
       * program.executableDir('subcommands');
       *
       * @param {string} [path]
       * @return {(string|null|Command)}
       */
      executableDir(path12) {
        if (path12 === void 0) return this._executableDir;
        this._executableDir = path12;
        return this;
      }
      /**
       * Return program help documentation.
       *
       * @param {{ error: boolean }} [contextOptions] - pass {error:true} to wrap for stderr instead of stdout
       * @return {string}
       */
      helpInformation(contextOptions) {
        const helper = this.createHelp();
        if (helper.helpWidth === void 0) {
          helper.helpWidth = contextOptions && contextOptions.error ? this._outputConfiguration.getErrHelpWidth() : this._outputConfiguration.getOutHelpWidth();
        }
        return helper.formatHelp(this, helper);
      }
      /**
       * @private
       */
      _getHelpContext(contextOptions) {
        contextOptions = contextOptions || {};
        const context = { error: !!contextOptions.error };
        let write;
        if (context.error) {
          write = (arg) => this._outputConfiguration.writeErr(arg);
        } else {
          write = (arg) => this._outputConfiguration.writeOut(arg);
        }
        context.write = contextOptions.write || write;
        context.command = this;
        return context;
      }
      /**
       * Output help information for this command.
       *
       * Outputs built-in help, and custom text added using `.addHelpText()`.
       *
       * @param {{ error: boolean } | Function} [contextOptions] - pass {error:true} to write to stderr instead of stdout
       */
      outputHelp(contextOptions) {
        let deprecatedCallback;
        if (typeof contextOptions === "function") {
          deprecatedCallback = contextOptions;
          contextOptions = void 0;
        }
        const context = this._getHelpContext(contextOptions);
        this._getCommandAndAncestors().reverse().forEach((command) => command.emit("beforeAllHelp", context));
        this.emit("beforeHelp", context);
        let helpInformation = this.helpInformation(context);
        if (deprecatedCallback) {
          helpInformation = deprecatedCallback(helpInformation);
          if (typeof helpInformation !== "string" && !Buffer.isBuffer(helpInformation)) {
            throw new Error("outputHelp callback must return a string or a Buffer");
          }
        }
        context.write(helpInformation);
        if (this._getHelpOption()?.long) {
          this.emit(this._getHelpOption().long);
        }
        this.emit("afterHelp", context);
        this._getCommandAndAncestors().forEach(
          (command) => command.emit("afterAllHelp", context)
        );
      }
      /**
       * You can pass in flags and a description to customise the built-in help option.
       * Pass in false to disable the built-in help option.
       *
       * @example
       * program.helpOption('-?, --help' 'show help'); // customise
       * program.helpOption(false); // disable
       *
       * @param {(string | boolean)} flags
       * @param {string} [description]
       * @return {Command} `this` command for chaining
       */
      helpOption(flags, description) {
        if (typeof flags === "boolean") {
          if (flags) {
            this._helpOption = this._helpOption ?? void 0;
          } else {
            this._helpOption = null;
          }
          return this;
        }
        flags = flags ?? "-h, --help";
        description = description ?? "display help for command";
        this._helpOption = this.createOption(flags, description);
        return this;
      }
      /**
       * Lazy create help option.
       * Returns null if has been disabled with .helpOption(false).
       *
       * @returns {(Option | null)} the help option
       * @package
       */
      _getHelpOption() {
        if (this._helpOption === void 0) {
          this.helpOption(void 0, void 0);
        }
        return this._helpOption;
      }
      /**
       * Supply your own option to use for the built-in help option.
       * This is an alternative to using helpOption() to customise the flags and description etc.
       *
       * @param {Option} option
       * @return {Command} `this` command for chaining
       */
      addHelpOption(option) {
        this._helpOption = option;
        return this;
      }
      /**
       * Output help information and exit.
       *
       * Outputs built-in help, and custom text added using `.addHelpText()`.
       *
       * @param {{ error: boolean }} [contextOptions] - pass {error:true} to write to stderr instead of stdout
       */
      help(contextOptions) {
        this.outputHelp(contextOptions);
        let exitCode = process2.exitCode || 0;
        if (exitCode === 0 && contextOptions && typeof contextOptions !== "function" && contextOptions.error) {
          exitCode = 1;
        }
        this._exit(exitCode, "commander.help", "(outputHelp)");
      }
      /**
       * Add additional text to be displayed with the built-in help.
       *
       * Position is 'before' or 'after' to affect just this command,
       * and 'beforeAll' or 'afterAll' to affect this command and all its subcommands.
       *
       * @param {string} position - before or after built-in help
       * @param {(string | Function)} text - string to add, or a function returning a string
       * @return {Command} `this` command for chaining
       */
      addHelpText(position, text) {
        const allowedValues = ["beforeAll", "before", "after", "afterAll"];
        if (!allowedValues.includes(position)) {
          throw new Error(`Unexpected value for position to addHelpText.
Expecting one of '${allowedValues.join("', '")}'`);
        }
        const helpEvent = `${position}Help`;
        this.on(helpEvent, (context) => {
          let helpStr;
          if (typeof text === "function") {
            helpStr = text({ error: context.error, command: context.command });
          } else {
            helpStr = text;
          }
          if (helpStr) {
            context.write(`${helpStr}
`);
          }
        });
        return this;
      }
      /**
       * Output help information if help flags specified
       *
       * @param {Array} args - array of options to search for help flags
       * @private
       */
      _outputHelpIfRequested(args) {
        const helpOption = this._getHelpOption();
        const helpRequested = helpOption && args.find((arg) => helpOption.is(arg));
        if (helpRequested) {
          this.outputHelp();
          this._exit(0, "commander.helpDisplayed", "(outputHelp)");
        }
      }
    };
    function incrementNodeInspectorPort(args) {
      return args.map((arg) => {
        if (!arg.startsWith("--inspect")) {
          return arg;
        }
        let debugOption;
        let debugHost = "127.0.0.1";
        let debugPort = "9229";
        let match;
        if ((match = arg.match(/^(--inspect(-brk)?)$/)) !== null) {
          debugOption = match[1];
        } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+)$/)) !== null) {
          debugOption = match[1];
          if (/^\d+$/.test(match[3])) {
            debugPort = match[3];
          } else {
            debugHost = match[3];
          }
        } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+):(\d+)$/)) !== null) {
          debugOption = match[1];
          debugHost = match[3];
          debugPort = match[4];
        }
        if (debugOption && debugPort !== "0") {
          return `${debugOption}=${debugHost}:${parseInt(debugPort) + 1}`;
        }
        return arg;
      });
    }
    exports2.Command = Command2;
  }
});

// node_modules/commander/index.js
var require_commander = __commonJS({
  "node_modules/commander/index.js"(exports2) {
    "use strict";
    var { Argument: Argument2 } = require_argument();
    var { Command: Command2 } = require_command();
    var { CommanderError: CommanderError2, InvalidArgumentError: InvalidArgumentError2 } = require_error();
    var { Help: Help2 } = require_help();
    var { Option: Option2 } = require_option();
    exports2.program = new Command2();
    exports2.createCommand = (name) => new Command2(name);
    exports2.createOption = (flags, description) => new Option2(flags, description);
    exports2.createArgument = (name, description) => new Argument2(name, description);
    exports2.Command = Command2;
    exports2.Option = Option2;
    exports2.Argument = Argument2;
    exports2.Help = Help2;
    exports2.CommanderError = CommanderError2;
    exports2.InvalidArgumentError = InvalidArgumentError2;
    exports2.InvalidOptionArgumentError = InvalidArgumentError2;
  }
});

// ../../node_modules/vscode-jsonrpc/lib/is.js
var require_is = __commonJS({
  "../../node_modules/vscode-jsonrpc/lib/is.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function boolean(value) {
      return value === true || value === false;
    }
    exports2.boolean = boolean;
    function string(value) {
      return typeof value === "string" || value instanceof String;
    }
    exports2.string = string;
    function number(value) {
      return typeof value === "number" || value instanceof Number;
    }
    exports2.number = number;
    function error(value) {
      return value instanceof Error;
    }
    exports2.error = error;
    function func(value) {
      return typeof value === "function";
    }
    exports2.func = func;
    function array(value) {
      return Array.isArray(value);
    }
    exports2.array = array;
    function stringArray(value) {
      return array(value) && value.every((elem) => string(elem));
    }
    exports2.stringArray = stringArray;
  }
});

// ../../node_modules/vscode-jsonrpc/lib/messages.js
var require_messages = __commonJS({
  "../../node_modules/vscode-jsonrpc/lib/messages.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var is = require_is();
    var ErrorCodes;
    (function(ErrorCodes2) {
      ErrorCodes2.ParseError = -32700;
      ErrorCodes2.InvalidRequest = -32600;
      ErrorCodes2.MethodNotFound = -32601;
      ErrorCodes2.InvalidParams = -32602;
      ErrorCodes2.InternalError = -32603;
      ErrorCodes2.serverErrorStart = -32099;
      ErrorCodes2.serverErrorEnd = -32e3;
      ErrorCodes2.ServerNotInitialized = -32002;
      ErrorCodes2.UnknownErrorCode = -32001;
      ErrorCodes2.RequestCancelled = -32800;
      ErrorCodes2.MessageWriteError = 1;
      ErrorCodes2.MessageReadError = 2;
    })(ErrorCodes = exports2.ErrorCodes || (exports2.ErrorCodes = {}));
    var ResponseError = class _ResponseError extends Error {
      constructor(code, message, data) {
        super(message);
        this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;
        this.data = data;
        Object.setPrototypeOf(this, _ResponseError.prototype);
      }
      toJson() {
        return {
          code: this.code,
          message: this.message,
          data: this.data
        };
      }
    };
    exports2.ResponseError = ResponseError;
    var AbstractMessageType = class {
      constructor(_method, _numberOfParams) {
        this._method = _method;
        this._numberOfParams = _numberOfParams;
      }
      get method() {
        return this._method;
      }
      get numberOfParams() {
        return this._numberOfParams;
      }
    };
    exports2.AbstractMessageType = AbstractMessageType;
    var RequestType0 = class extends AbstractMessageType {
      constructor(method) {
        super(method, 0);
        this._ = void 0;
      }
    };
    exports2.RequestType0 = RequestType0;
    var RequestType = class extends AbstractMessageType {
      constructor(method) {
        super(method, 1);
        this._ = void 0;
      }
    };
    exports2.RequestType = RequestType;
    var RequestType1 = class extends AbstractMessageType {
      constructor(method) {
        super(method, 1);
        this._ = void 0;
      }
    };
    exports2.RequestType1 = RequestType1;
    var RequestType2 = class extends AbstractMessageType {
      constructor(method) {
        super(method, 2);
        this._ = void 0;
      }
    };
    exports2.RequestType2 = RequestType2;
    var RequestType3 = class extends AbstractMessageType {
      constructor(method) {
        super(method, 3);
        this._ = void 0;
      }
    };
    exports2.RequestType3 = RequestType3;
    var RequestType4 = class extends AbstractMessageType {
      constructor(method) {
        super(method, 4);
        this._ = void 0;
      }
    };
    exports2.RequestType4 = RequestType4;
    var RequestType5 = class extends AbstractMessageType {
      constructor(method) {
        super(method, 5);
        this._ = void 0;
      }
    };
    exports2.RequestType5 = RequestType5;
    var RequestType6 = class extends AbstractMessageType {
      constructor(method) {
        super(method, 6);
        this._ = void 0;
      }
    };
    exports2.RequestType6 = RequestType6;
    var RequestType7 = class extends AbstractMessageType {
      constructor(method) {
        super(method, 7);
        this._ = void 0;
      }
    };
    exports2.RequestType7 = RequestType7;
    var RequestType8 = class extends AbstractMessageType {
      constructor(method) {
        super(method, 8);
        this._ = void 0;
      }
    };
    exports2.RequestType8 = RequestType8;
    var RequestType9 = class extends AbstractMessageType {
      constructor(method) {
        super(method, 9);
        this._ = void 0;
      }
    };
    exports2.RequestType9 = RequestType9;
    var NotificationType = class extends AbstractMessageType {
      constructor(method) {
        super(method, 1);
        this._ = void 0;
      }
    };
    exports2.NotificationType = NotificationType;
    var NotificationType0 = class extends AbstractMessageType {
      constructor(method) {
        super(method, 0);
        this._ = void 0;
      }
    };
    exports2.NotificationType0 = NotificationType0;
    var NotificationType1 = class extends AbstractMessageType {
      constructor(method) {
        super(method, 1);
        this._ = void 0;
      }
    };
    exports2.NotificationType1 = NotificationType1;
    var NotificationType2 = class extends AbstractMessageType {
      constructor(method) {
        super(method, 2);
        this._ = void 0;
      }
    };
    exports2.NotificationType2 = NotificationType2;
    var NotificationType3 = class extends AbstractMessageType {
      constructor(method) {
        super(method, 3);
        this._ = void 0;
      }
    };
    exports2.NotificationType3 = NotificationType3;
    var NotificationType4 = class extends AbstractMessageType {
      constructor(method) {
        super(method, 4);
        this._ = void 0;
      }
    };
    exports2.NotificationType4 = NotificationType4;
    var NotificationType5 = class extends AbstractMessageType {
      constructor(method) {
        super(method, 5);
        this._ = void 0;
      }
    };
    exports2.NotificationType5 = NotificationType5;
    var NotificationType6 = class extends AbstractMessageType {
      constructor(method) {
        super(method, 6);
        this._ = void 0;
      }
    };
    exports2.NotificationType6 = NotificationType6;
    var NotificationType7 = class extends AbstractMessageType {
      constructor(method) {
        super(method, 7);
        this._ = void 0;
      }
    };
    exports2.NotificationType7 = NotificationType7;
    var NotificationType8 = class extends AbstractMessageType {
      constructor(method) {
        super(method, 8);
        this._ = void 0;
      }
    };
    exports2.NotificationType8 = NotificationType8;
    var NotificationType9 = class extends AbstractMessageType {
      constructor(method) {
        super(method, 9);
        this._ = void 0;
      }
    };
    exports2.NotificationType9 = NotificationType9;
    function isRequestMessage(message) {
      let candidate = message;
      return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
    }
    exports2.isRequestMessage = isRequestMessage;
    function isNotificationMessage(message) {
      let candidate = message;
      return candidate && is.string(candidate.method) && message.id === void 0;
    }
    exports2.isNotificationMessage = isNotificationMessage;
    function isResponseMessage(message) {
      let candidate = message;
      return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
    }
    exports2.isResponseMessage = isResponseMessage;
  }
});

// ../../node_modules/vscode-jsonrpc/lib/events.js
var require_events = __commonJS({
  "../../node_modules/vscode-jsonrpc/lib/events.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var Disposable;
    (function(Disposable2) {
      function create(func) {
        return {
          dispose: func
        };
      }
      Disposable2.create = create;
    })(Disposable = exports2.Disposable || (exports2.Disposable = {}));
    var Event;
    (function(Event2) {
      const _disposable = { dispose() {
      } };
      Event2.None = function() {
        return _disposable;
      };
    })(Event = exports2.Event || (exports2.Event = {}));
    var CallbackList = class {
      add(callback2, context = null, bucket) {
        if (!this._callbacks) {
          this._callbacks = [];
          this._contexts = [];
        }
        this._callbacks.push(callback2);
        this._contexts.push(context);
        if (Array.isArray(bucket)) {
          bucket.push({ dispose: () => this.remove(callback2, context) });
        }
      }
      remove(callback2, context = null) {
        if (!this._callbacks) {
          return;
        }
        var foundCallbackWithDifferentContext = false;
        for (var i = 0, len = this._callbacks.length; i < len; i++) {
          if (this._callbacks[i] === callback2) {
            if (this._contexts[i] === context) {
              this._callbacks.splice(i, 1);
              this._contexts.splice(i, 1);
              return;
            } else {
              foundCallbackWithDifferentContext = true;
            }
          }
        }
        if (foundCallbackWithDifferentContext) {
          throw new Error("When adding a listener with a context, you should remove it with the same context");
        }
      }
      invoke(...args) {
        if (!this._callbacks) {
          return [];
        }
        var ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
        for (var i = 0, len = callbacks.length; i < len; i++) {
          try {
            ret.push(callbacks[i].apply(contexts[i], args));
          } catch (e) {
            console.error(e);
          }
        }
        return ret;
      }
      isEmpty() {
        return !this._callbacks || this._callbacks.length === 0;
      }
      dispose() {
        this._callbacks = void 0;
        this._contexts = void 0;
      }
    };
    var Emitter = class _Emitter {
      constructor(_options) {
        this._options = _options;
      }
      /**
       * For the public to allow to subscribe
       * to events from this Emitter
       */
      get event() {
        if (!this._event) {
          this._event = (listener, thisArgs, disposables) => {
            if (!this._callbacks) {
              this._callbacks = new CallbackList();
            }
            if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
              this._options.onFirstListenerAdd(this);
            }
            this._callbacks.add(listener, thisArgs);
            let result;
            result = {
              dispose: () => {
                this._callbacks.remove(listener, thisArgs);
                result.dispose = _Emitter._noop;
                if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                  this._options.onLastListenerRemove(this);
                }
              }
            };
            if (Array.isArray(disposables)) {
              disposables.push(result);
            }
            return result;
          };
        }
        return this._event;
      }
      /**
       * To be kept private to fire an event to
       * subscribers
       */
      fire(event) {
        if (this._callbacks) {
          this._callbacks.invoke.call(this._callbacks, event);
        }
      }
      dispose() {
        if (this._callbacks) {
          this._callbacks.dispose();
          this._callbacks = void 0;
        }
      }
    };
    Emitter._noop = function() {
    };
    exports2.Emitter = Emitter;
  }
});

// ../../node_modules/vscode-jsonrpc/lib/messageReader.js
var require_messageReader = __commonJS({
  "../../node_modules/vscode-jsonrpc/lib/messageReader.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var events_1 = require_events();
    var Is = require_is();
    var DefaultSize = 8192;
    var CR = Buffer.from("\r", "ascii")[0];
    var LF = Buffer.from("\n", "ascii")[0];
    var CRLF = "\r\n";
    var MessageBuffer = class {
      constructor(encoding = "utf8") {
        this.encoding = encoding;
        this.index = 0;
        this.buffer = Buffer.allocUnsafe(DefaultSize);
      }
      append(chunk) {
        var toAppend = chunk;
        if (typeof chunk === "string") {
          var str = chunk;
          var bufferLen = Buffer.byteLength(str, this.encoding);
          toAppend = Buffer.allocUnsafe(bufferLen);
          toAppend.write(str, 0, bufferLen, this.encoding);
        }
        if (this.buffer.length - this.index >= toAppend.length) {
          toAppend.copy(this.buffer, this.index, 0, toAppend.length);
        } else {
          var newSize = (Math.ceil((this.index + toAppend.length) / DefaultSize) + 1) * DefaultSize;
          if (this.index === 0) {
            this.buffer = Buffer.allocUnsafe(newSize);
            toAppend.copy(this.buffer, 0, 0, toAppend.length);
          } else {
            this.buffer = Buffer.concat([this.buffer.slice(0, this.index), toAppend], newSize);
          }
        }
        this.index += toAppend.length;
      }
      tryReadHeaders() {
        let result = void 0;
        let current = 0;
        while (current + 3 < this.index && (this.buffer[current] !== CR || this.buffer[current + 1] !== LF || this.buffer[current + 2] !== CR || this.buffer[current + 3] !== LF)) {
          current++;
        }
        if (current + 3 >= this.index) {
          return result;
        }
        result = /* @__PURE__ */ Object.create(null);
        let headers = this.buffer.toString("ascii", 0, current).split(CRLF);
        headers.forEach((header) => {
          let index = header.indexOf(":");
          if (index === -1) {
            throw new Error("Message header must separate key and value using :");
          }
          let key = header.substr(0, index);
          let value = header.substr(index + 1).trim();
          result[key] = value;
        });
        let nextStart = current + 4;
        this.buffer = this.buffer.slice(nextStart);
        this.index = this.index - nextStart;
        return result;
      }
      tryReadContent(length) {
        if (this.index < length) {
          return null;
        }
        let result = this.buffer.toString(this.encoding, 0, length);
        let nextStart = length;
        this.buffer.copy(this.buffer, 0, nextStart);
        this.index = this.index - nextStart;
        return result;
      }
      get numberOfBytes() {
        return this.index;
      }
    };
    var MessageReader;
    (function(MessageReader2) {
      function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.listen) && Is.func(candidate.dispose) && Is.func(candidate.onError) && Is.func(candidate.onClose) && Is.func(candidate.onPartialMessage);
      }
      MessageReader2.is = is;
    })(MessageReader = exports2.MessageReader || (exports2.MessageReader = {}));
    var AbstractMessageReader = class {
      constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
        this.partialMessageEmitter = new events_1.Emitter();
      }
      dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
      }
      get onError() {
        return this.errorEmitter.event;
      }
      fireError(error) {
        this.errorEmitter.fire(this.asError(error));
      }
      get onClose() {
        return this.closeEmitter.event;
      }
      fireClose() {
        this.closeEmitter.fire(void 0);
      }
      get onPartialMessage() {
        return this.partialMessageEmitter.event;
      }
      firePartialMessage(info) {
        this.partialMessageEmitter.fire(info);
      }
      asError(error) {
        if (error instanceof Error) {
          return error;
        } else {
          return new Error(`Reader recevied error. Reason: ${Is.string(error.message) ? error.message : "unknown"}`);
        }
      }
    };
    exports2.AbstractMessageReader = AbstractMessageReader;
    var StreamMessageReader = class extends AbstractMessageReader {
      constructor(readable, encoding = "utf8") {
        super();
        this.readable = readable;
        this.buffer = new MessageBuffer(encoding);
        this._partialMessageTimeout = 1e4;
      }
      set partialMessageTimeout(timeout) {
        this._partialMessageTimeout = timeout;
      }
      get partialMessageTimeout() {
        return this._partialMessageTimeout;
      }
      listen(callback2) {
        this.nextMessageLength = -1;
        this.messageToken = 0;
        this.partialMessageTimer = void 0;
        this.callback = callback2;
        this.readable.on("data", (data) => {
          this.onData(data);
        });
        this.readable.on("error", (error) => this.fireError(error));
        this.readable.on("close", () => this.fireClose());
      }
      onData(data) {
        this.buffer.append(data);
        while (true) {
          if (this.nextMessageLength === -1) {
            let headers = this.buffer.tryReadHeaders();
            if (!headers) {
              return;
            }
            let contentLength = headers["Content-Length"];
            if (!contentLength) {
              throw new Error("Header must provide a Content-Length property.");
            }
            let length = parseInt(contentLength);
            if (isNaN(length)) {
              throw new Error("Content-Length value must be a number.");
            }
            this.nextMessageLength = length;
          }
          var msg = this.buffer.tryReadContent(this.nextMessageLength);
          if (msg === null) {
            this.setPartialMessageTimer();
            return;
          }
          this.clearPartialMessageTimer();
          this.nextMessageLength = -1;
          this.messageToken++;
          var json = JSON.parse(msg);
          this.callback(json);
        }
      }
      clearPartialMessageTimer() {
        if (this.partialMessageTimer) {
          clearTimeout(this.partialMessageTimer);
          this.partialMessageTimer = void 0;
        }
      }
      setPartialMessageTimer() {
        this.clearPartialMessageTimer();
        if (this._partialMessageTimeout <= 0) {
          return;
        }
        this.partialMessageTimer = setTimeout((token, timeout) => {
          this.partialMessageTimer = void 0;
          if (token === this.messageToken) {
            this.firePartialMessage({ messageToken: token, waitingTime: timeout });
            this.setPartialMessageTimer();
          }
        }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
      }
    };
    exports2.StreamMessageReader = StreamMessageReader;
    var IPCMessageReader = class extends AbstractMessageReader {
      constructor(process2) {
        super();
        this.process = process2;
        let eventEmitter = this.process;
        eventEmitter.on("error", (error) => this.fireError(error));
        eventEmitter.on("close", () => this.fireClose());
      }
      listen(callback2) {
        this.process.on("message", callback2);
      }
    };
    exports2.IPCMessageReader = IPCMessageReader;
    var SocketMessageReader = class extends StreamMessageReader {
      constructor(socket, encoding = "utf-8") {
        super(socket, encoding);
      }
    };
    exports2.SocketMessageReader = SocketMessageReader;
  }
});

// ../../node_modules/vscode-jsonrpc/lib/messageWriter.js
var require_messageWriter = __commonJS({
  "../../node_modules/vscode-jsonrpc/lib/messageWriter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var events_1 = require_events();
    var Is = require_is();
    var ContentLength = "Content-Length: ";
    var CRLF = "\r\n";
    var MessageWriter;
    (function(MessageWriter2) {
      function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.dispose) && Is.func(candidate.onClose) && Is.func(candidate.onError) && Is.func(candidate.write);
      }
      MessageWriter2.is = is;
    })(MessageWriter = exports2.MessageWriter || (exports2.MessageWriter = {}));
    var AbstractMessageWriter = class {
      constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
      }
      dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
      }
      get onError() {
        return this.errorEmitter.event;
      }
      fireError(error, message, count) {
        this.errorEmitter.fire([this.asError(error), message, count]);
      }
      get onClose() {
        return this.closeEmitter.event;
      }
      fireClose() {
        this.closeEmitter.fire(void 0);
      }
      asError(error) {
        if (error instanceof Error) {
          return error;
        } else {
          return new Error(`Writer recevied error. Reason: ${Is.string(error.message) ? error.message : "unknown"}`);
        }
      }
    };
    exports2.AbstractMessageWriter = AbstractMessageWriter;
    var StreamMessageWriter = class extends AbstractMessageWriter {
      constructor(writable, encoding = "utf8") {
        super();
        this.writable = writable;
        this.encoding = encoding;
        this.errorCount = 0;
        this.writable.on("error", (error) => this.fireError(error));
        this.writable.on("close", () => this.fireClose());
      }
      write(msg) {
        let json = JSON.stringify(msg);
        let contentLength = Buffer.byteLength(json, this.encoding);
        let headers = [
          ContentLength,
          contentLength.toString(),
          CRLF,
          CRLF
        ];
        try {
          this.writable.write(headers.join(""), "ascii");
          this.writable.write(json, this.encoding);
          this.errorCount = 0;
        } catch (error) {
          this.errorCount++;
          this.fireError(error, msg, this.errorCount);
        }
      }
    };
    exports2.StreamMessageWriter = StreamMessageWriter;
    var IPCMessageWriter = class extends AbstractMessageWriter {
      constructor(process2) {
        super();
        this.process = process2;
        this.errorCount = 0;
        this.queue = [];
        this.sending = false;
        let eventEmitter = this.process;
        eventEmitter.on("error", (error) => this.fireError(error));
        eventEmitter.on("close", () => this.fireClose);
      }
      write(msg) {
        if (!this.sending && this.queue.length === 0) {
          this.doWriteMessage(msg);
        } else {
          this.queue.push(msg);
        }
      }
      doWriteMessage(msg) {
        try {
          if (this.process.send) {
            this.sending = true;
            this.process.send(msg, void 0, void 0, (error) => {
              this.sending = false;
              if (error) {
                this.errorCount++;
                this.fireError(error, msg, this.errorCount);
              } else {
                this.errorCount = 0;
              }
              if (this.queue.length > 0) {
                this.doWriteMessage(this.queue.shift());
              }
            });
          }
        } catch (error) {
          this.errorCount++;
          this.fireError(error, msg, this.errorCount);
        }
      }
    };
    exports2.IPCMessageWriter = IPCMessageWriter;
    var SocketMessageWriter = class extends AbstractMessageWriter {
      constructor(socket, encoding = "utf8") {
        super();
        this.socket = socket;
        this.queue = [];
        this.sending = false;
        this.encoding = encoding;
        this.errorCount = 0;
        this.socket.on("error", (error) => this.fireError(error));
        this.socket.on("close", () => this.fireClose());
      }
      write(msg) {
        if (!this.sending && this.queue.length === 0) {
          this.doWriteMessage(msg);
        } else {
          this.queue.push(msg);
        }
      }
      doWriteMessage(msg) {
        let json = JSON.stringify(msg);
        let contentLength = Buffer.byteLength(json, this.encoding);
        let headers = [
          ContentLength,
          contentLength.toString(),
          CRLF,
          CRLF
        ];
        try {
          this.sending = true;
          this.socket.write(headers.join(""), "ascii", (error) => {
            if (error) {
              this.handleError(error, msg);
            }
            try {
              this.socket.write(json, this.encoding, (error2) => {
                this.sending = false;
                if (error2) {
                  this.handleError(error2, msg);
                } else {
                  this.errorCount = 0;
                }
                if (this.queue.length > 0) {
                  this.doWriteMessage(this.queue.shift());
                }
              });
            } catch (error2) {
              this.handleError(error2, msg);
            }
          });
        } catch (error) {
          this.handleError(error, msg);
        }
      }
      handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
      }
    };
    exports2.SocketMessageWriter = SocketMessageWriter;
  }
});

// ../../node_modules/vscode-jsonrpc/lib/cancellation.js
var require_cancellation = __commonJS({
  "../../node_modules/vscode-jsonrpc/lib/cancellation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var events_1 = require_events();
    var Is = require_is();
    var CancellationToken;
    (function(CancellationToken2) {
      CancellationToken2.None = Object.freeze({
        isCancellationRequested: false,
        onCancellationRequested: events_1.Event.None
      });
      CancellationToken2.Cancelled = Object.freeze({
        isCancellationRequested: true,
        onCancellationRequested: events_1.Event.None
      });
      function is(value) {
        let candidate = value;
        return candidate && (candidate === CancellationToken2.None || candidate === CancellationToken2.Cancelled || Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested);
      }
      CancellationToken2.is = is;
    })(CancellationToken = exports2.CancellationToken || (exports2.CancellationToken = {}));
    var shortcutEvent = Object.freeze(function(callback2, context) {
      let handle = setTimeout(callback2.bind(context), 0);
      return { dispose() {
        clearTimeout(handle);
      } };
    });
    var MutableToken = class {
      constructor() {
        this._isCancelled = false;
      }
      cancel() {
        if (!this._isCancelled) {
          this._isCancelled = true;
          if (this._emitter) {
            this._emitter.fire(void 0);
            this._emitter = void 0;
          }
        }
      }
      get isCancellationRequested() {
        return this._isCancelled;
      }
      get onCancellationRequested() {
        if (this._isCancelled) {
          return shortcutEvent;
        }
        if (!this._emitter) {
          this._emitter = new events_1.Emitter();
        }
        return this._emitter.event;
      }
    };
    var CancellationTokenSource = class {
      get token() {
        if (!this._token) {
          this._token = new MutableToken();
        }
        return this._token;
      }
      cancel() {
        if (!this._token) {
          this._token = CancellationToken.Cancelled;
        } else {
          this._token.cancel();
        }
      }
      dispose() {
        this.cancel();
      }
    };
    exports2.CancellationTokenSource = CancellationTokenSource;
  }
});

// ../../node_modules/vscode-jsonrpc/lib/linkedMap.js
var require_linkedMap = __commonJS({
  "../../node_modules/vscode-jsonrpc/lib/linkedMap.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var Touch;
    (function(Touch2) {
      Touch2.None = 0;
      Touch2.First = 1;
      Touch2.Last = 2;
    })(Touch = exports2.Touch || (exports2.Touch = {}));
    var LinkedMap = class {
      constructor() {
        this._map = /* @__PURE__ */ new Map();
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
      }
      clear() {
        this._map.clear();
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
      }
      isEmpty() {
        return !this._head && !this._tail;
      }
      get size() {
        return this._size;
      }
      has(key) {
        return this._map.has(key);
      }
      get(key) {
        const item = this._map.get(key);
        if (!item) {
          return void 0;
        }
        return item.value;
      }
      set(key, value, touch = Touch.None) {
        let item = this._map.get(key);
        if (item) {
          item.value = value;
          if (touch !== Touch.None) {
            this.touch(item, touch);
          }
        } else {
          item = { key, value, next: void 0, previous: void 0 };
          switch (touch) {
            case Touch.None:
              this.addItemLast(item);
              break;
            case Touch.First:
              this.addItemFirst(item);
              break;
            case Touch.Last:
              this.addItemLast(item);
              break;
            default:
              this.addItemLast(item);
              break;
          }
          this._map.set(key, item);
          this._size++;
        }
      }
      delete(key) {
        const item = this._map.get(key);
        if (!item) {
          return false;
        }
        this._map.delete(key);
        this.removeItem(item);
        this._size--;
        return true;
      }
      shift() {
        if (!this._head && !this._tail) {
          return void 0;
        }
        if (!this._head || !this._tail) {
          throw new Error("Invalid list");
        }
        const item = this._head;
        this._map.delete(item.key);
        this.removeItem(item);
        this._size--;
        return item.value;
      }
      forEach(callbackfn, thisArg) {
        let current = this._head;
        while (current) {
          if (thisArg) {
            callbackfn.bind(thisArg)(current.value, current.key, this);
          } else {
            callbackfn(current.value, current.key, this);
          }
          current = current.next;
        }
      }
      forEachReverse(callbackfn, thisArg) {
        let current = this._tail;
        while (current) {
          if (thisArg) {
            callbackfn.bind(thisArg)(current.value, current.key, this);
          } else {
            callbackfn(current.value, current.key, this);
          }
          current = current.previous;
        }
      }
      values() {
        let result = [];
        let current = this._head;
        while (current) {
          result.push(current.value);
          current = current.next;
        }
        return result;
      }
      keys() {
        let result = [];
        let current = this._head;
        while (current) {
          result.push(current.key);
          current = current.next;
        }
        return result;
      }
      /* JSON RPC run on es5 which has no Symbol.iterator
          public keys(): IterableIterator<K> {
              let current = this._head;
              let iterator: IterableIterator<K> = {
                  [Symbol.iterator]() {
                      return iterator;
                  },
                  next():IteratorResult<K> {
                      if (current) {
                          let result = { value: current.key, done: false };
                          current = current.next;
                          return result;
                      } else {
                          return { value: undefined, done: true };
                      }
                  }
              };
              return iterator;
          }
      
          public values(): IterableIterator<V> {
              let current = this._head;
              let iterator: IterableIterator<V> = {
                  [Symbol.iterator]() {
                      return iterator;
                  },
                  next():IteratorResult<V> {
                      if (current) {
                          let result = { value: current.value, done: false };
                          current = current.next;
                          return result;
                      } else {
                          return { value: undefined, done: true };
                      }
                  }
              };
              return iterator;
          }
          */
      addItemFirst(item) {
        if (!this._head && !this._tail) {
          this._tail = item;
        } else if (!this._head) {
          throw new Error("Invalid list");
        } else {
          item.next = this._head;
          this._head.previous = item;
        }
        this._head = item;
      }
      addItemLast(item) {
        if (!this._head && !this._tail) {
          this._head = item;
        } else if (!this._tail) {
          throw new Error("Invalid list");
        } else {
          item.previous = this._tail;
          this._tail.next = item;
        }
        this._tail = item;
      }
      removeItem(item) {
        if (item === this._head && item === this._tail) {
          this._head = void 0;
          this._tail = void 0;
        } else if (item === this._head) {
          this._head = item.next;
        } else if (item === this._tail) {
          this._tail = item.previous;
        } else {
          const next = item.next;
          const previous = item.previous;
          if (!next || !previous) {
            throw new Error("Invalid list");
          }
          next.previous = previous;
          previous.next = next;
        }
      }
      touch(item, touch) {
        if (!this._head || !this._tail) {
          throw new Error("Invalid list");
        }
        if (touch !== Touch.First && touch !== Touch.Last) {
          return;
        }
        if (touch === Touch.First) {
          if (item === this._head) {
            return;
          }
          const next = item.next;
          const previous = item.previous;
          if (item === this._tail) {
            previous.next = void 0;
            this._tail = previous;
          } else {
            next.previous = previous;
            previous.next = next;
          }
          item.previous = void 0;
          item.next = this._head;
          this._head.previous = item;
          this._head = item;
        } else if (touch === Touch.Last) {
          if (item === this._tail) {
            return;
          }
          const next = item.next;
          const previous = item.previous;
          if (item === this._head) {
            next.previous = void 0;
            this._head = next;
          } else {
            next.previous = previous;
            previous.next = next;
          }
          item.next = void 0;
          item.previous = this._tail;
          this._tail.next = item;
          this._tail = item;
        }
      }
    };
    exports2.LinkedMap = LinkedMap;
  }
});

// ../../node_modules/vscode-jsonrpc/lib/pipeSupport.js
var require_pipeSupport = __commonJS({
  "../../node_modules/vscode-jsonrpc/lib/pipeSupport.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var path_1 = require("path");
    var os_1 = require("os");
    var crypto_1 = require("crypto");
    var net_1 = require("net");
    var messageReader_1 = require_messageReader();
    var messageWriter_1 = require_messageWriter();
    function generateRandomPipeName() {
      const randomSuffix = crypto_1.randomBytes(21).toString("hex");
      if (process.platform === "win32") {
        return `\\\\.\\pipe\\vscode-jsonrpc-${randomSuffix}-sock`;
      } else {
        return path_1.join(os_1.tmpdir(), `vscode-${randomSuffix}.sock`);
      }
    }
    exports2.generateRandomPipeName = generateRandomPipeName;
    function createClientPipeTransport(pipeName, encoding = "utf-8") {
      let connectResolve;
      let connected = new Promise((resolve8, _reject) => {
        connectResolve = resolve8;
      });
      return new Promise((resolve8, reject) => {
        let server = net_1.createServer((socket) => {
          server.close();
          connectResolve([
            new messageReader_1.SocketMessageReader(socket, encoding),
            new messageWriter_1.SocketMessageWriter(socket, encoding)
          ]);
        });
        server.on("error", reject);
        server.listen(pipeName, () => {
          server.removeListener("error", reject);
          resolve8({
            onConnected: () => {
              return connected;
            }
          });
        });
      });
    }
    exports2.createClientPipeTransport = createClientPipeTransport;
    function createServerPipeTransport(pipeName, encoding = "utf-8") {
      const socket = net_1.createConnection(pipeName);
      return [
        new messageReader_1.SocketMessageReader(socket, encoding),
        new messageWriter_1.SocketMessageWriter(socket, encoding)
      ];
    }
    exports2.createServerPipeTransport = createServerPipeTransport;
  }
});

// ../../node_modules/vscode-jsonrpc/lib/socketSupport.js
var require_socketSupport = __commonJS({
  "../../node_modules/vscode-jsonrpc/lib/socketSupport.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var net_1 = require("net");
    var messageReader_1 = require_messageReader();
    var messageWriter_1 = require_messageWriter();
    function createClientSocketTransport(port, encoding = "utf-8") {
      let connectResolve;
      let connected = new Promise((resolve8, _reject) => {
        connectResolve = resolve8;
      });
      return new Promise((resolve8, reject) => {
        let server = net_1.createServer((socket) => {
          server.close();
          connectResolve([
            new messageReader_1.SocketMessageReader(socket, encoding),
            new messageWriter_1.SocketMessageWriter(socket, encoding)
          ]);
        });
        server.on("error", reject);
        server.listen(port, "127.0.0.1", () => {
          server.removeListener("error", reject);
          resolve8({
            onConnected: () => {
              return connected;
            }
          });
        });
      });
    }
    exports2.createClientSocketTransport = createClientSocketTransport;
    function createServerSocketTransport(port, encoding = "utf-8") {
      const socket = net_1.createConnection(port, "127.0.0.1");
      return [
        new messageReader_1.SocketMessageReader(socket, encoding),
        new messageWriter_1.SocketMessageWriter(socket, encoding)
      ];
    }
    exports2.createServerSocketTransport = createServerSocketTransport;
  }
});

// ../../node_modules/vscode-jsonrpc/lib/main.js
var require_main = __commonJS({
  "../../node_modules/vscode-jsonrpc/lib/main.js"(exports2) {
    "use strict";
    function __export3(m) {
      for (var p in m) if (!exports2.hasOwnProperty(p)) exports2[p] = m[p];
    }
    Object.defineProperty(exports2, "__esModule", { value: true });
    var Is = require_is();
    var messages_1 = require_messages();
    exports2.RequestType = messages_1.RequestType;
    exports2.RequestType0 = messages_1.RequestType0;
    exports2.RequestType1 = messages_1.RequestType1;
    exports2.RequestType2 = messages_1.RequestType2;
    exports2.RequestType3 = messages_1.RequestType3;
    exports2.RequestType4 = messages_1.RequestType4;
    exports2.RequestType5 = messages_1.RequestType5;
    exports2.RequestType6 = messages_1.RequestType6;
    exports2.RequestType7 = messages_1.RequestType7;
    exports2.RequestType8 = messages_1.RequestType8;
    exports2.RequestType9 = messages_1.RequestType9;
    exports2.ResponseError = messages_1.ResponseError;
    exports2.ErrorCodes = messages_1.ErrorCodes;
    exports2.NotificationType = messages_1.NotificationType;
    exports2.NotificationType0 = messages_1.NotificationType0;
    exports2.NotificationType1 = messages_1.NotificationType1;
    exports2.NotificationType2 = messages_1.NotificationType2;
    exports2.NotificationType3 = messages_1.NotificationType3;
    exports2.NotificationType4 = messages_1.NotificationType4;
    exports2.NotificationType5 = messages_1.NotificationType5;
    exports2.NotificationType6 = messages_1.NotificationType6;
    exports2.NotificationType7 = messages_1.NotificationType7;
    exports2.NotificationType8 = messages_1.NotificationType8;
    exports2.NotificationType9 = messages_1.NotificationType9;
    var messageReader_1 = require_messageReader();
    exports2.MessageReader = messageReader_1.MessageReader;
    exports2.StreamMessageReader = messageReader_1.StreamMessageReader;
    exports2.IPCMessageReader = messageReader_1.IPCMessageReader;
    exports2.SocketMessageReader = messageReader_1.SocketMessageReader;
    var messageWriter_1 = require_messageWriter();
    exports2.MessageWriter = messageWriter_1.MessageWriter;
    exports2.StreamMessageWriter = messageWriter_1.StreamMessageWriter;
    exports2.IPCMessageWriter = messageWriter_1.IPCMessageWriter;
    exports2.SocketMessageWriter = messageWriter_1.SocketMessageWriter;
    var events_1 = require_events();
    exports2.Disposable = events_1.Disposable;
    exports2.Event = events_1.Event;
    exports2.Emitter = events_1.Emitter;
    var cancellation_1 = require_cancellation();
    exports2.CancellationTokenSource = cancellation_1.CancellationTokenSource;
    exports2.CancellationToken = cancellation_1.CancellationToken;
    var linkedMap_1 = require_linkedMap();
    __export3(require_pipeSupport());
    __export3(require_socketSupport());
    var CancelNotification;
    (function(CancelNotification2) {
      CancelNotification2.type = new messages_1.NotificationType("$/cancelRequest");
    })(CancelNotification || (CancelNotification = {}));
    exports2.NullLogger = Object.freeze({
      error: () => {
      },
      warn: () => {
      },
      info: () => {
      },
      log: () => {
      }
    });
    var Trace;
    (function(Trace2) {
      Trace2[Trace2["Off"] = 0] = "Off";
      Trace2[Trace2["Messages"] = 1] = "Messages";
      Trace2[Trace2["Verbose"] = 2] = "Verbose";
    })(Trace = exports2.Trace || (exports2.Trace = {}));
    (function(Trace2) {
      function fromString(value) {
        value = value.toLowerCase();
        switch (value) {
          case "off":
            return Trace2.Off;
          case "messages":
            return Trace2.Messages;
          case "verbose":
            return Trace2.Verbose;
          default:
            return Trace2.Off;
        }
      }
      Trace2.fromString = fromString;
      function toString(value) {
        switch (value) {
          case Trace2.Off:
            return "off";
          case Trace2.Messages:
            return "messages";
          case Trace2.Verbose:
            return "verbose";
          default:
            return "off";
        }
      }
      Trace2.toString = toString;
    })(Trace = exports2.Trace || (exports2.Trace = {}));
    var TraceFormat;
    (function(TraceFormat2) {
      TraceFormat2["Text"] = "text";
      TraceFormat2["JSON"] = "json";
    })(TraceFormat = exports2.TraceFormat || (exports2.TraceFormat = {}));
    (function(TraceFormat2) {
      function fromString(value) {
        value = value.toLowerCase();
        if (value === "json") {
          return TraceFormat2.JSON;
        } else {
          return TraceFormat2.Text;
        }
      }
      TraceFormat2.fromString = fromString;
    })(TraceFormat = exports2.TraceFormat || (exports2.TraceFormat = {}));
    var SetTraceNotification;
    (function(SetTraceNotification2) {
      SetTraceNotification2.type = new messages_1.NotificationType("$/setTraceNotification");
    })(SetTraceNotification = exports2.SetTraceNotification || (exports2.SetTraceNotification = {}));
    var LogTraceNotification;
    (function(LogTraceNotification2) {
      LogTraceNotification2.type = new messages_1.NotificationType("$/logTraceNotification");
    })(LogTraceNotification = exports2.LogTraceNotification || (exports2.LogTraceNotification = {}));
    var ConnectionErrors;
    (function(ConnectionErrors2) {
      ConnectionErrors2[ConnectionErrors2["Closed"] = 1] = "Closed";
      ConnectionErrors2[ConnectionErrors2["Disposed"] = 2] = "Disposed";
      ConnectionErrors2[ConnectionErrors2["AlreadyListening"] = 3] = "AlreadyListening";
    })(ConnectionErrors = exports2.ConnectionErrors || (exports2.ConnectionErrors = {}));
    var ConnectionError = class _ConnectionError extends Error {
      constructor(code, message) {
        super(message);
        this.code = code;
        Object.setPrototypeOf(this, _ConnectionError.prototype);
      }
    };
    exports2.ConnectionError = ConnectionError;
    var ConnectionStrategy;
    (function(ConnectionStrategy2) {
      function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.cancelUndispatched);
      }
      ConnectionStrategy2.is = is;
    })(ConnectionStrategy = exports2.ConnectionStrategy || (exports2.ConnectionStrategy = {}));
    var ConnectionState;
    (function(ConnectionState2) {
      ConnectionState2[ConnectionState2["New"] = 1] = "New";
      ConnectionState2[ConnectionState2["Listening"] = 2] = "Listening";
      ConnectionState2[ConnectionState2["Closed"] = 3] = "Closed";
      ConnectionState2[ConnectionState2["Disposed"] = 4] = "Disposed";
    })(ConnectionState || (ConnectionState = {}));
    function _createMessageConnection(messageReader, messageWriter, logger, strategy) {
      let sequenceNumber = 0;
      let notificationSquenceNumber = 0;
      let unknownResponseSquenceNumber = 0;
      const version = "2.0";
      let starRequestHandler = void 0;
      let requestHandlers = /* @__PURE__ */ Object.create(null);
      let starNotificationHandler = void 0;
      let notificationHandlers = /* @__PURE__ */ Object.create(null);
      let timer;
      let messageQueue = new linkedMap_1.LinkedMap();
      let responsePromises = /* @__PURE__ */ Object.create(null);
      let requestTokens = /* @__PURE__ */ Object.create(null);
      let trace = Trace.Off;
      let traceFormat = TraceFormat.Text;
      let tracer;
      let state = ConnectionState.New;
      let errorEmitter = new events_1.Emitter();
      let closeEmitter = new events_1.Emitter();
      let unhandledNotificationEmitter = new events_1.Emitter();
      let disposeEmitter = new events_1.Emitter();
      function createRequestQueueKey(id) {
        return "req-" + id.toString();
      }
      function createResponseQueueKey(id) {
        if (id === null) {
          return "res-unknown-" + (++unknownResponseSquenceNumber).toString();
        } else {
          return "res-" + id.toString();
        }
      }
      function createNotificationQueueKey() {
        return "not-" + (++notificationSquenceNumber).toString();
      }
      function addMessageToQueue(queue, message) {
        if (messages_1.isRequestMessage(message)) {
          queue.set(createRequestQueueKey(message.id), message);
        } else if (messages_1.isResponseMessage(message)) {
          queue.set(createResponseQueueKey(message.id), message);
        } else {
          queue.set(createNotificationQueueKey(), message);
        }
      }
      function cancelUndispatched(_message) {
        return void 0;
      }
      function isListening() {
        return state === ConnectionState.Listening;
      }
      function isClosed() {
        return state === ConnectionState.Closed;
      }
      function isDisposed() {
        return state === ConnectionState.Disposed;
      }
      function closeHandler() {
        if (state === ConnectionState.New || state === ConnectionState.Listening) {
          state = ConnectionState.Closed;
          closeEmitter.fire(void 0);
        }
      }
      ;
      function readErrorHandler(error) {
        errorEmitter.fire([error, void 0, void 0]);
      }
      function writeErrorHandler(data) {
        errorEmitter.fire(data);
      }
      messageReader.onClose(closeHandler);
      messageReader.onError(readErrorHandler);
      messageWriter.onClose(closeHandler);
      messageWriter.onError(writeErrorHandler);
      function triggerMessageQueue() {
        if (timer || messageQueue.size === 0) {
          return;
        }
        timer = setImmediate(() => {
          timer = void 0;
          processMessageQueue();
        });
      }
      function processMessageQueue() {
        if (messageQueue.size === 0) {
          return;
        }
        let message = messageQueue.shift();
        try {
          if (messages_1.isRequestMessage(message)) {
            handleRequest(message);
          } else if (messages_1.isNotificationMessage(message)) {
            handleNotification(message);
          } else if (messages_1.isResponseMessage(message)) {
            handleResponse(message);
          } else {
            handleInvalidMessage(message);
          }
        } finally {
          triggerMessageQueue();
        }
      }
      let callback2 = (message) => {
        try {
          if (messages_1.isNotificationMessage(message) && message.method === CancelNotification.type.method) {
            let key = createRequestQueueKey(message.params.id);
            let toCancel = messageQueue.get(key);
            if (messages_1.isRequestMessage(toCancel)) {
              let response = strategy && strategy.cancelUndispatched ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
              if (response && (response.error !== void 0 || response.result !== void 0)) {
                messageQueue.delete(key);
                response.id = toCancel.id;
                traceSendingResponse(response, message.method, Date.now());
                messageWriter.write(response);
                return;
              }
            }
          }
          addMessageToQueue(messageQueue, message);
        } finally {
          triggerMessageQueue();
        }
      };
      function handleRequest(requestMessage) {
        if (isDisposed()) {
          return;
        }
        function reply(resultOrError, method, startTime2) {
          let message = {
            jsonrpc: version,
            id: requestMessage.id
          };
          if (resultOrError instanceof messages_1.ResponseError) {
            message.error = resultOrError.toJson();
          } else {
            message.result = resultOrError === void 0 ? null : resultOrError;
          }
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message);
        }
        function replyError(error, method, startTime2) {
          let message = {
            jsonrpc: version,
            id: requestMessage.id,
            error: error.toJson()
          };
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message);
        }
        function replySuccess(result, method, startTime2) {
          if (result === void 0) {
            result = null;
          }
          let message = {
            jsonrpc: version,
            id: requestMessage.id,
            result
          };
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message);
        }
        traceReceivedRequest(requestMessage);
        let element = requestHandlers[requestMessage.method];
        let type;
        let requestHandler;
        if (element) {
          type = element.type;
          requestHandler = element.handler;
        }
        let startTime = Date.now();
        if (requestHandler || starRequestHandler) {
          let cancellationSource = new cancellation_1.CancellationTokenSource();
          let tokenKey = String(requestMessage.id);
          requestTokens[tokenKey] = cancellationSource;
          try {
            let handlerResult;
            if (requestMessage.params === void 0 || type !== void 0 && type.numberOfParams === 0) {
              handlerResult = requestHandler ? requestHandler(cancellationSource.token) : starRequestHandler(requestMessage.method, cancellationSource.token);
            } else if (Is.array(requestMessage.params) && (type === void 0 || type.numberOfParams > 1)) {
              handlerResult = requestHandler ? requestHandler(...requestMessage.params, cancellationSource.token) : starRequestHandler(requestMessage.method, ...requestMessage.params, cancellationSource.token);
            } else {
              handlerResult = requestHandler ? requestHandler(requestMessage.params, cancellationSource.token) : starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
            }
            let promise2 = handlerResult;
            if (!handlerResult) {
              delete requestTokens[tokenKey];
              replySuccess(handlerResult, requestMessage.method, startTime);
            } else if (promise2.then) {
              promise2.then((resultOrError) => {
                delete requestTokens[tokenKey];
                reply(resultOrError, requestMessage.method, startTime);
              }, (error) => {
                delete requestTokens[tokenKey];
                if (error instanceof messages_1.ResponseError) {
                  replyError(error, requestMessage.method, startTime);
                } else if (error && Is.string(error.message)) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                } else {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                }
              });
            } else {
              delete requestTokens[tokenKey];
              reply(handlerResult, requestMessage.method, startTime);
            }
          } catch (error) {
            delete requestTokens[tokenKey];
            if (error instanceof messages_1.ResponseError) {
              reply(error, requestMessage.method, startTime);
            } else if (error && Is.string(error.message)) {
              replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
            } else {
              replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
            }
          }
        } else {
          replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
        }
      }
      function handleResponse(responseMessage) {
        if (isDisposed()) {
          return;
        }
        if (responseMessage.id === null) {
          if (responseMessage.error) {
            logger.error(`Received response message without id: Error is: 
${JSON.stringify(responseMessage.error, void 0, 4)}`);
          } else {
            logger.error(`Received response message without id. No further error information provided.`);
          }
        } else {
          let key = String(responseMessage.id);
          let responsePromise = responsePromises[key];
          traceReceivedResponse(responseMessage, responsePromise);
          if (responsePromise) {
            delete responsePromises[key];
            try {
              if (responseMessage.error) {
                let error = responseMessage.error;
                responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
              } else if (responseMessage.result !== void 0) {
                responsePromise.resolve(responseMessage.result);
              } else {
                throw new Error("Should never happen.");
              }
            } catch (error) {
              if (error.message) {
                logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
              } else {
                logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
              }
            }
          }
        }
      }
      function handleNotification(message) {
        if (isDisposed()) {
          return;
        }
        let type = void 0;
        let notificationHandler;
        if (message.method === CancelNotification.type.method) {
          notificationHandler = (params) => {
            let id = params.id;
            let source = requestTokens[String(id)];
            if (source) {
              source.cancel();
            }
          };
        } else {
          let element = notificationHandlers[message.method];
          if (element) {
            notificationHandler = element.handler;
            type = element.type;
          }
        }
        if (notificationHandler || starNotificationHandler) {
          try {
            traceReceivedNotification(message);
            if (message.params === void 0 || type !== void 0 && type.numberOfParams === 0) {
              notificationHandler ? notificationHandler() : starNotificationHandler(message.method);
            } else if (Is.array(message.params) && (type === void 0 || type.numberOfParams > 1)) {
              notificationHandler ? notificationHandler(...message.params) : starNotificationHandler(message.method, ...message.params);
            } else {
              notificationHandler ? notificationHandler(message.params) : starNotificationHandler(message.method, message.params);
            }
          } catch (error) {
            if (error.message) {
              logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
            } else {
              logger.error(`Notification handler '${message.method}' failed unexpectedly.`);
            }
          }
        } else {
          unhandledNotificationEmitter.fire(message);
        }
      }
      function handleInvalidMessage(message) {
        if (!message) {
          logger.error("Received empty message.");
          return;
        }
        logger.error(`Received message which is neither a response nor a notification message:
${JSON.stringify(message, null, 4)}`);
        let responseMessage = message;
        if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {
          let key = String(responseMessage.id);
          let responseHandler = responsePromises[key];
          if (responseHandler) {
            responseHandler.reject(new Error("The received response has neither a result nor an error property."));
          }
        }
      }
      function traceSendingRequest(message) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose && message.params) {
            data = `Params: ${JSON.stringify(message.params, null, 4)}

`;
          }
          tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
        } else {
          logLSPMessage("send-request", message);
        }
      }
      function traceSendingNotification(message) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose) {
            if (message.params) {
              data = `Params: ${JSON.stringify(message.params, null, 4)}

`;
            } else {
              data = "No parameters provided.\n\n";
            }
          }
          tracer.log(`Sending notification '${message.method}'.`, data);
        } else {
          logLSPMessage("send-notification", message);
        }
      }
      function traceSendingResponse(message, method, startTime) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose) {
            if (message.error && message.error.data) {
              data = `Error data: ${JSON.stringify(message.error.data, null, 4)}

`;
            } else {
              if (message.result) {
                data = `Result: ${JSON.stringify(message.result, null, 4)}

`;
              } else if (message.error === void 0) {
                data = "No result returned.\n\n";
              }
            }
          }
          tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
        } else {
          logLSPMessage("send-response", message);
        }
      }
      function traceReceivedRequest(message) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose && message.params) {
            data = `Params: ${JSON.stringify(message.params, null, 4)}

`;
          }
          tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
        } else {
          logLSPMessage("receive-request", message);
        }
      }
      function traceReceivedNotification(message) {
        if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose) {
            if (message.params) {
              data = `Params: ${JSON.stringify(message.params, null, 4)}

`;
            } else {
              data = "No parameters provided.\n\n";
            }
          }
          tracer.log(`Received notification '${message.method}'.`, data);
        } else {
          logLSPMessage("receive-notification", message);
        }
      }
      function traceReceivedResponse(message, responsePromise) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose) {
            if (message.error && message.error.data) {
              data = `Error data: ${JSON.stringify(message.error.data, null, 4)}

`;
            } else {
              if (message.result) {
                data = `Result: ${JSON.stringify(message.result, null, 4)}

`;
              } else if (message.error === void 0) {
                data = "No result returned.\n\n";
              }
            }
          }
          if (responsePromise) {
            let error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : "";
            tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
          } else {
            tracer.log(`Received response ${message.id} without active response promise.`, data);
          }
        } else {
          logLSPMessage("receive-response", message);
        }
      }
      function logLSPMessage(type, message) {
        if (!tracer || trace === Trace.Off) {
          return;
        }
        const lspMessage = {
          isLSPMessage: true,
          type,
          message,
          timestamp: Date.now()
        };
        tracer.log(lspMessage);
      }
      function throwIfClosedOrDisposed() {
        if (isClosed()) {
          throw new ConnectionError(ConnectionErrors.Closed, "Connection is closed.");
        }
        if (isDisposed()) {
          throw new ConnectionError(ConnectionErrors.Disposed, "Connection is disposed.");
        }
      }
      function throwIfListening() {
        if (isListening()) {
          throw new ConnectionError(ConnectionErrors.AlreadyListening, "Connection is already listening");
        }
      }
      function throwIfNotListening() {
        if (!isListening()) {
          throw new Error("Call listen() first.");
        }
      }
      function undefinedToNull(param) {
        if (param === void 0) {
          return null;
        } else {
          return param;
        }
      }
      function computeMessageParams(type, params) {
        let result;
        let numberOfParams = type.numberOfParams;
        switch (numberOfParams) {
          case 0:
            result = null;
            break;
          case 1:
            result = undefinedToNull(params[0]);
            break;
          default:
            result = [];
            for (let i = 0; i < params.length && i < numberOfParams; i++) {
              result.push(undefinedToNull(params[i]));
            }
            if (params.length < numberOfParams) {
              for (let i = params.length; i < numberOfParams; i++) {
                result.push(null);
              }
            }
            break;
        }
        return result;
      }
      let connection = {
        sendNotification: (type, ...params) => {
          throwIfClosedOrDisposed();
          let method;
          let messageParams;
          if (Is.string(type)) {
            method = type;
            switch (params.length) {
              case 0:
                messageParams = null;
                break;
              case 1:
                messageParams = params[0];
                break;
              default:
                messageParams = params;
                break;
            }
          } else {
            method = type.method;
            messageParams = computeMessageParams(type, params);
          }
          let notificationMessage = {
            jsonrpc: version,
            method,
            params: messageParams
          };
          traceSendingNotification(notificationMessage);
          messageWriter.write(notificationMessage);
        },
        onNotification: (type, handler) => {
          throwIfClosedOrDisposed();
          if (Is.func(type)) {
            starNotificationHandler = type;
          } else if (handler) {
            if (Is.string(type)) {
              notificationHandlers[type] = { type: void 0, handler };
            } else {
              notificationHandlers[type.method] = { type, handler };
            }
          }
        },
        sendRequest: (type, ...params) => {
          throwIfClosedOrDisposed();
          throwIfNotListening();
          let method;
          let messageParams;
          let token = void 0;
          if (Is.string(type)) {
            method = type;
            switch (params.length) {
              case 0:
                messageParams = null;
                break;
              case 1:
                if (cancellation_1.CancellationToken.is(params[0])) {
                  messageParams = null;
                  token = params[0];
                } else {
                  messageParams = undefinedToNull(params[0]);
                }
                break;
              default:
                const last2 = params.length - 1;
                if (cancellation_1.CancellationToken.is(params[last2])) {
                  token = params[last2];
                  if (params.length === 2) {
                    messageParams = undefinedToNull(params[0]);
                  } else {
                    messageParams = params.slice(0, last2).map((value) => undefinedToNull(value));
                  }
                } else {
                  messageParams = params.map((value) => undefinedToNull(value));
                }
                break;
            }
          } else {
            method = type.method;
            messageParams = computeMessageParams(type, params);
            let numberOfParams = type.numberOfParams;
            token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : void 0;
          }
          let id = sequenceNumber++;
          let result = new Promise((resolve8, reject) => {
            let requestMessage = {
              jsonrpc: version,
              id,
              method,
              params: messageParams
            };
            let responsePromise = { method, timerStart: Date.now(), resolve: resolve8, reject };
            traceSendingRequest(requestMessage);
            try {
              messageWriter.write(requestMessage);
            } catch (e) {
              responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, e.message ? e.message : "Unknown reason"));
              responsePromise = null;
            }
            if (responsePromise) {
              responsePromises[String(id)] = responsePromise;
            }
          });
          if (token) {
            token.onCancellationRequested(() => {
              connection.sendNotification(CancelNotification.type, { id });
            });
          }
          return result;
        },
        onRequest: (type, handler) => {
          throwIfClosedOrDisposed();
          if (Is.func(type)) {
            starRequestHandler = type;
          } else if (handler) {
            if (Is.string(type)) {
              requestHandlers[type] = { type: void 0, handler };
            } else {
              requestHandlers[type.method] = { type, handler };
            }
          }
        },
        trace: (_value, _tracer, sendNotificationOrTraceOptions) => {
          let _sendNotification = false;
          let _traceFormat = TraceFormat.Text;
          if (sendNotificationOrTraceOptions !== void 0) {
            if (Is.boolean(sendNotificationOrTraceOptions)) {
              _sendNotification = sendNotificationOrTraceOptions;
            } else {
              _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
              _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;
            }
          }
          trace = _value;
          traceFormat = _traceFormat;
          if (trace === Trace.Off) {
            tracer = void 0;
          } else {
            tracer = _tracer;
          }
          if (_sendNotification && !isClosed() && !isDisposed()) {
            connection.sendNotification(SetTraceNotification.type, { value: Trace.toString(_value) });
          }
        },
        onError: errorEmitter.event,
        onClose: closeEmitter.event,
        onUnhandledNotification: unhandledNotificationEmitter.event,
        onDispose: disposeEmitter.event,
        dispose: () => {
          if (isDisposed()) {
            return;
          }
          state = ConnectionState.Disposed;
          disposeEmitter.fire(void 0);
          let error = new Error("Connection got disposed.");
          Object.keys(responsePromises).forEach((key) => {
            responsePromises[key].reject(error);
          });
          responsePromises = /* @__PURE__ */ Object.create(null);
          requestTokens = /* @__PURE__ */ Object.create(null);
          messageQueue = new linkedMap_1.LinkedMap();
          if (Is.func(messageWriter.dispose)) {
            messageWriter.dispose();
          }
          if (Is.func(messageReader.dispose)) {
            messageReader.dispose();
          }
        },
        listen: () => {
          throwIfClosedOrDisposed();
          throwIfListening();
          state = ConnectionState.Listening;
          messageReader.listen(callback2);
        },
        inspect: () => {
          console.log("inspect");
        }
      };
      connection.onNotification(LogTraceNotification.type, (params) => {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        tracer.log(params.message, trace === Trace.Verbose ? params.verbose : void 0);
      });
      return connection;
    }
    function isMessageReader(value) {
      return value.listen !== void 0 && value.read === void 0;
    }
    function isMessageWriter(value) {
      return value.write !== void 0 && value.end === void 0;
    }
    function createMessageConnection(input, output, logger, strategy) {
      if (!logger) {
        logger = exports2.NullLogger;
      }
      let reader = isMessageReader(input) ? input : new messageReader_1.StreamMessageReader(input);
      let writer = isMessageWriter(output) ? output : new messageWriter_1.StreamMessageWriter(output);
      return _createMessageConnection(reader, writer, logger, strategy);
    }
    exports2.createMessageConnection = createMessageConnection;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/keyExchangeAlgorithm.js
var require_keyExchangeAlgorithm = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/keyExchangeAlgorithm.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.KeyExchangeAlgorithm = void 0;
    var KeyExchangeAlgorithm = class {
      constructor(name, keySizeInBits, hashAlgorithmName, hashDigestLength) {
        this.name = name;
        this.keySizeInBits = keySizeInBits;
        this.hashAlgorithmName = hashAlgorithmName;
        this.hashDigestLength = hashDigestLength;
      }
    };
    exports2.KeyExchangeAlgorithm = KeyExchangeAlgorithm;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/io/bigInt.js
var require_bigInt = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/io/bigInt.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BigInt = void 0;
    var buffer_1 = require("buffer");
    var sshData_1 = require_sshData();
    var BigInt2 = class _BigInt {
      /**
       * Creates a new BigInt instance from a buffer of signed bytes.
       *
       * The first (high) bit of the first (high) byte is the sign bit. Therefore if the
       * highest byte of an unsigned integer is greater than 127, the bytes must include
       * a leading zero byte to prevent interpretation as a negative value.
       */
      constructor(buffer) {
        this.buffer = buffer;
        if (buffer.length === 0) {
          throw new Error("BigInt buffer length must be greater than zero.");
        }
      }
      /**
       * Gets a value that indicates the sign of the big integer:
       * 1 for positive, 0 for zero, -1 for negative.
       */
      get sign() {
        const highByte = this.buffer[0];
        if (highByte === 0) {
          return this.buffer.length > 1 ? 1 : 0;
        } else {
          return (highByte & 128) === 0 ? 1 : -1;
        }
      }
      static fromInt32(value) {
        if (value === 0) {
          return _BigInt.zero;
        }
        let isNegative = false;
        if (value < 0) {
          isNegative = true;
          value = -value;
        }
        const bytes = [];
        for (let bit = 24; bit >= 0; bit -= 8) {
          if (value >= 1 << bit || bytes.length > 0) {
            bytes.push(value >> bit);
            value = value & ~((1 << bit) - 1);
          }
        }
        if (isNegative) {
          if ((bytes[0] & 128) === 0) {
            bytes[0] |= 128;
          } else {
            bytes.splice(0, 0, 128);
          }
        }
        return new _BigInt(buffer_1.Buffer.from(new Uint8Array(bytes)));
      }
      toInt32() {
        if (this.buffer.length > 4) {
          throw new TypeError("BigInt value cannot be converted to a 32-bit signed integer.");
        }
        let value = this.buffer[0];
        if (this.sign < 0) {
          value &= 127;
        }
        for (let i = 1; i < this.buffer.length; i++) {
          value = (value << 8) + this.buffer[i];
        }
        if (this.sign < 0) {
          value = -value;
        }
        return value;
      }
      /**
       * Creates a new BigInt instance from a byte buffer.
       * @param bytes Source byte buffer.
       * @param options.unsigned True if the bytes should be interpreted as unsigned. If false,
       * the high bit of the high byte is the sign bit. The default is false.
       */
      static fromBytes(bytes, options) {
        if (!buffer_1.Buffer.isBuffer(bytes)) {
          throw new TypeError("Buffer expected.");
        } else if (bytes.length === 0) {
          throw new Error("BigInt buffer length must be greater than zero.");
        }
        options = options !== null && options !== void 0 ? options : {};
        const highBit = (bytes[0] & 128) !== 0;
        const prependZeroCount = options.unsigned && highBit ? 1 : 0;
        let skipZeroCount = 0;
        for (let i = 0; i < bytes.length - 1 && bytes[i] === 0; i++) {
          if ((bytes[i + 1] & 128) === 0) {
            skipZeroCount++;
          }
        }
        const newBytes = buffer_1.Buffer.alloc(bytes.length + prependZeroCount - skipZeroCount);
        bytes.copy(newBytes, prependZeroCount, skipZeroCount, bytes.length);
        return new _BigInt(newBytes);
      }
      /**
       * Converts a BigInt instance to a byte buffer.
       *
       * @param options.unsigned True if the returned bytes will be interprted as unsigned.
       * If false, a positive integer may have a leading zero to prevent it from being
       * interpreted as negative.
       * @param options.length Desired length of the resulting buffer. The value will be zero-
       * padded to fill the length. Only applies when `options.unsigned` is true.
       */
      toBytes(options) {
        options = options !== null && options !== void 0 ? options : {};
        let bytes = this.buffer;
        if (options.unsigned) {
          if (this.sign < 0) {
            throw new TypeError("Cannot format a negative BigInt as unsigned.");
          } else if (bytes[0] === 0 && bytes.length > 1) {
            bytes = bytes.slice(1, bytes.length);
          }
          if (options.length !== void 0) {
            if (bytes.length > options.length) {
              throw new Error(`BigInt (${bytes.length} bytes) is too large for length ${options.length}.`);
            } else if (bytes.length < options.length) {
              const padded = buffer_1.Buffer.alloc(options.length);
              bytes.copy(padded, options.length - bytes.length);
              return padded;
            }
          }
        }
        const newBytes = buffer_1.Buffer.alloc(bytes.length);
        bytes.copy(newBytes, 0, 0, bytes.length);
        return newBytes;
      }
      copyTo(buffer, offset = 0) {
        this.buffer.copy(buffer, offset, 0, this.buffer.length);
      }
      equals(other) {
        return other instanceof _BigInt && this.buffer.equals(other.buffer);
      }
      toString(name) {
        return (0, sshData_1.formatBuffer)(this.buffer, name !== null && name !== void 0 ? name : "BigInt");
      }
    };
    exports2.BigInt = BigInt2;
    BigInt2.zero = new BigInt2(buffer_1.Buffer.alloc(1));
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/io/sshData.js
var require_sshData = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/io/sshData.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.formatBuffer = exports2.SshDataWriter = exports2.SshDataReader = void 0;
    var buffer_1 = require("buffer");
    var sshAlgorithms_1 = require_sshAlgorithms();
    var bigInt_1 = require_bigInt();
    var SshDataReader = class {
      constructor(buffer) {
        this.buffer = buffer;
        this.position = 0;
      }
      get available() {
        return this.buffer.length - this.position;
      }
      read(length) {
        if (this.available < length) {
          throw new Error("Attempted to read past end of buffer.");
        }
        const data = this.buffer.slice(this.position, this.position + length);
        this.position += length;
        return data;
      }
      readByte() {
        if (this.available === 0) {
          throw new Error("Attempted to read past end of buffer.");
        }
        const value = this.buffer[this.position];
        this.position++;
        return value;
      }
      readBinary() {
        const length = this.readUInt32();
        if (this.available < length) {
          throw new Error("Attempted to read past end of buffer.");
        }
        const data = this.buffer.slice(this.position, this.position + length);
        this.position += length;
        return data;
      }
      readString(encoding) {
        const bytes = this.readBinary();
        return bytes.toString();
      }
      readList(encoding) {
        const stringList = this.readString(encoding);
        return stringList.length === 0 ? [] : stringList.split(",");
      }
      readBoolean() {
        return this.readByte() !== 0;
      }
      readUInt32() {
        if (this.available < 4) {
          throw new Error("Attempted to read past end of buffer.");
        }
        const value0 = this.buffer[this.position + 0];
        const value1 = this.buffer[this.position + 1];
        const value2 = this.buffer[this.position + 2];
        const value3 = this.buffer[this.position + 3];
        this.position += 4;
        const value = (value0 << 24 | value1 << 16 | value2 << 8 | value3) >>> 0;
        return value;
      }
      readUInt64() {
        if (this.available < 8) {
          throw new Error("Attempted to read past end of buffer.");
        }
        const value0 = this.buffer[this.position + 0];
        const value1 = this.buffer[this.position + 1];
        const value2 = this.buffer[this.position + 2];
        const value3 = this.buffer[this.position + 3];
        const value4 = this.buffer[this.position + 4];
        const value5 = this.buffer[this.position + 5];
        const value6 = this.buffer[this.position + 6];
        const value7 = this.buffer[this.position + 7];
        this.position += 8;
        const high = (value0 << 24 | value1 << 16 | value2 << 8 | value3) >>> 0;
        const low = (value4 << 24 | value5 << 16 | value6 << 8 | value7) >>> 0;
        return high * 4294967296 + low;
      }
      readBigInt() {
        const data = this.readBinary();
        if (data.length === 0) {
          return bigInt_1.BigInt.zero;
        }
        return bigInt_1.BigInt.fromBytes(data);
      }
    };
    exports2.SshDataReader = SshDataReader;
    SshDataReader.mpintZero = buffer_1.Buffer.alloc(1);
    var SshDataWriter = class {
      constructor(buffer) {
        this.buffer = buffer;
        this.position = 0;
      }
      write(data) {
        this.ensureCapacity(this.position + data.length);
        data.copy(this.buffer, this.position);
        this.position += data.length;
      }
      writeByte(value) {
        this.ensureCapacity(this.position + 1);
        this.buffer[this.position] = value;
        this.position++;
      }
      writeBinary(data) {
        this.ensureCapacity(this.position + 4 + data.length);
        this.writeUInt32(data.length);
        data.copy(this.buffer, this.position);
        this.position += data.length;
      }
      writeString(value, encoding) {
        this.writeBinary(buffer_1.Buffer.from(value));
      }
      writeList(value, encoding) {
        this.writeString(value ? value.join(",") : "", encoding);
      }
      writeBoolean(value) {
        this.writeByte(value ? 1 : 0);
      }
      writeUInt32(value) {
        this.ensureCapacity(this.position + 4);
        this.buffer[this.position + 0] = value >>> 24;
        this.buffer[this.position + 1] = value >>> 16;
        this.buffer[this.position + 2] = value >>> 8;
        this.buffer[this.position + 3] = value >>> 0;
        this.position += 4;
      }
      /* @internal */
      static writeUInt32(buffer, offset, value) {
        buffer[offset + 0] = value >>> 24;
        buffer[offset + 1] = value >>> 16;
        buffer[offset + 2] = value >>> 8;
        buffer[offset + 3] = value >>> 0;
      }
      writeUInt64(value) {
        this.ensureCapacity(this.position + 8);
        const low = value & 4294967295;
        const high = (value - low) / 4294967296;
        this.buffer[this.position + 0] = high >>> 24;
        this.buffer[this.position + 1] = high >>> 16;
        this.buffer[this.position + 2] = high >>> 8;
        this.buffer[this.position + 3] = high >>> 0;
        this.buffer[this.position + 4] = low >>> 24;
        this.buffer[this.position + 5] = low >>> 16;
        this.buffer[this.position + 6] = low >>> 8;
        this.buffer[this.position + 7] = low >>> 0;
        this.position += 8;
      }
      writeBigInt(value) {
        const data = value.toBytes();
        if (data.length === 1 && data[0] === 0) {
          this.writeUInt32(0);
        } else {
          this.writeBinary(data);
        }
      }
      writeRandom(length) {
        this.ensureCapacity(this.position + length);
        const randomBuffer = this.buffer.slice(this.position, this.position + length);
        sshAlgorithms_1.SshAlgorithms.random.getBytes(randomBuffer);
        this.position += length;
      }
      skip(length) {
        this.ensureCapacity(this.position + length);
        this.position += length;
      }
      ensureCapacity(capacity) {
        if (this.buffer.length < capacity) {
          let newLength = Math.max(512, this.buffer.length * 2);
          while (newLength < capacity)
            newLength *= 2;
          const newBuffer = buffer_1.Buffer.alloc(newLength);
          this.buffer.copy(newBuffer, 0, 0, this.position);
          this.buffer = newBuffer;
        }
      }
      toBuffer() {
        return this.buffer.slice(0, this.position);
      }
    };
    exports2.SshDataWriter = SshDataWriter;
    function makeCrcTable() {
      let c;
      const table = [];
      for (let n = 0; n < 256; n++) {
        c = n;
        for (let k = 0; k < 8; k++) {
          c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
        }
        table[n] = c;
      }
      return table;
    }
    var crcTable;
    function crc32(data) {
      if (!crcTable) {
        crcTable = makeCrcTable();
      }
      let crc = 0 ^ -1;
      for (let i = 0; i < data.length; i++) {
        crc = crc >>> 8 ^ crcTable[(crc ^ data[i]) & 255];
      }
      const result = (crc ^ -1) >>> 0;
      return (result + 4294967296).toString(16).substr(-8).toUpperCase();
    }
    function formatBuffer(data, name, formatData) {
      let s = `${name === void 0 ? "Buffer" : name}[${data.length}] (${crc32(data)})
`;
      if (formatData === false) {
        return s;
      }
      const max = Math.min(2048, data.length);
      for (let lineOffset = 0; lineOffset < max; lineOffset += 16) {
        if (lineOffset < 1e3)
          s += "0";
        if (lineOffset < 100)
          s += "0";
        if (lineOffset < 10)
          s += "0";
        s += lineOffset + ":";
        for (let i = lineOffset; i < lineOffset + 16; i++) {
          if (i < max) {
            s += " " + data.slice(i, i + 1).toString("hex");
          } else {
            s += "   ";
          }
        }
        s += "  ";
        for (let i = lineOffset; i < lineOffset + 16; i++) {
          if (i < max) {
            const c = data[i];
            s += c > 32 && c <= 127 ? data.slice(i, i + 1).toString() : ".";
          } else {
            s += " ";
          }
        }
        s += "\n";
      }
      if (max < data.length) {
        s += "...\n";
      }
      return s;
    }
    exports2.formatBuffer = formatBuffer;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/publicKeyAlgorithm.js
var require_publicKeyAlgorithm = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/publicKeyAlgorithm.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PublicKeyAlgorithm = void 0;
    var buffer_1 = require("buffer");
    var sshData_1 = require_sshData();
    var PublicKeyAlgorithm = class {
      constructor(name, keyAlgorithmName, hashAlgorithmName) {
        this.name = name;
        this.keyAlgorithmName = keyAlgorithmName;
        this.hashAlgorithmName = hashAlgorithmName;
      }
      readSignatureData(signatureData) {
        const reader = new sshData_1.SshDataReader(signatureData);
        const algorithmName = reader.readString("ascii");
        if (algorithmName !== this.name) {
          throw new Error(`Mismatched public key algorithm: got '${algorithmName}', expected '${this.name}'.`);
        }
        const signature = reader.readBinary();
        return signature;
      }
      createSignatureData(signature) {
        const writer = new sshData_1.SshDataWriter(buffer_1.Buffer.alloc(this.name.length + signature.length + 20));
        writer.writeString(this.name, "ascii");
        writer.writeBinary(signature);
        return writer.toBuffer();
      }
    };
    exports2.PublicKeyAlgorithm = PublicKeyAlgorithm;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/encryptionAlgorithm.js
var require_encryptionAlgorithm = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/encryptionAlgorithm.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EncryptionAlgorithm = void 0;
    var EncryptionAlgorithm = class {
      constructor(name) {
        this.name = name;
      }
    };
    exports2.EncryptionAlgorithm = EncryptionAlgorithm;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/hmacAlgorithm.js
var require_hmacAlgorithm = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/hmacAlgorithm.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.HmacAlgorithm = void 0;
    var HmacAlgorithm = class {
      constructor(name, algorithmName, keyLength, digestLength) {
        this.name = name;
        this.algorithmName = algorithmName;
        this.keyLength = keyLength;
        this.digestLength = digestLength;
      }
    };
    exports2.HmacAlgorithm = HmacAlgorithm;
  }
});

// ../../node_modules/diffie-hellman/index.js
var require_diffie_hellman = __commonJS({
  "../../node_modules/diffie-hellman/index.js"(exports2) {
    "use strict";
    var crypto2 = require("crypto");
    exports2.DiffieHellmanGroup = crypto2.DiffieHellmanGroup;
    exports2.createDiffieHellmanGroup = crypto2.createDiffieHellmanGroup;
    exports2.getDiffieHellman = crypto2.getDiffieHellman;
    exports2.createDiffieHellman = crypto2.createDiffieHellman;
    exports2.DiffieHellman = crypto2.DiffieHellman;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/web/webHmac.js
var require_webHmac = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/web/webHmac.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WebHmac = void 0;
    var buffer_1 = require("buffer");
    var hmacAlgorithm_1 = require_hmacAlgorithm();
    var WebHmac = class _WebHmac extends hmacAlgorithm_1.HmacAlgorithm {
      constructor(name, algorithmName, encryptThenMac = false) {
        super(name, algorithmName, _WebHmac.getHashKeyLength(algorithmName), _WebHmac.getHashDigestLength(algorithmName));
        this.encryptThenMac = encryptThenMac;
      }
      async createSigner(key) {
        const hmac = new WebSignerVerifier(this.algorithmName, true, this.digestLength, this.encryptThenMac);
        await hmac.init(key);
        return hmac;
      }
      async createVerifier(key) {
        const hmac = new WebSignerVerifier(this.algorithmName, false, this.digestLength, this.encryptThenMac);
        await hmac.init(key);
        return hmac;
      }
      static getHashKeyLength(hashAlgorithmName) {
        if (hashAlgorithmName === "SHA2-512")
          return 512 / 8;
        if (hashAlgorithmName === "SHA2-384")
          return 384 / 8;
        if (hashAlgorithmName === "SHA2-256")
          return 256 / 8;
        throw new Error(`Unsupported hash algorithm: ${hashAlgorithmName}`);
      }
      static getHashDigestLength(hashAlgorithmName) {
        return this.getHashKeyLength(hashAlgorithmName);
      }
      static getWebHashAlgorithmName(hashAlgorithmName) {
        if (hashAlgorithmName === "SHA2-512")
          return "SHA-512";
        if (hashAlgorithmName === "SHA2-384")
          return "SHA-384";
        if (hashAlgorithmName === "SHA2-256")
          return "SHA-256";
        throw new Error(`Unsupported hash algorithm: ${hashAlgorithmName}`);
      }
    };
    exports2.WebHmac = WebHmac;
    var WebSignerVerifier = class {
      constructor(algorithmName, isSigning, digestLength, encryptThenMac) {
        this.algorithmName = algorithmName;
        this.isSigning = isSigning;
        this.digestLength = digestLength;
        this.encryptThenMac = encryptThenMac;
      }
      async init(key) {
        try {
          const name = this.algorithmName.replace("SHA2-", "SHA-");
          this.key = await crypto.subtle.importKey("raw", key, { name: "HMAC", hash: { name } }, false, this.isSigning ? ["sign"] : ["verify"]);
        } catch (e) {
          throw new Error("Failed to initialize HMAC: " + e);
        }
      }
      async sign(data) {
        return buffer_1.Buffer.from(await crypto.subtle.sign({ name: "HMAC", hash: { name: this.algorithmName } }, this.key, data));
      }
      async verify(data, signature) {
        return await crypto.subtle.verify({ name: "HMAC", hash: { name: this.algorithmName } }, this.key, signature, data);
      }
      dispose() {
      }
    };
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/ecdsaCurves.js
var require_ecdsaCurves = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/ecdsaCurves.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.curves = void 0;
    exports2.curves = [
      {
        shortName: "P-256",
        name: "nistp256",
        oid: "1.2.840.10045.3.1.7",
        keySize: 256
      },
      {
        shortName: "P-384",
        name: "nistp384",
        oid: "1.3.132.0.34",
        keySize: 384
      },
      {
        shortName: "P-521",
        name: "nistp521",
        oid: "1.3.132.0.35",
        keySize: 521
      }
    ];
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/web/jsonWebKeyFormatter.js
var require_jsonWebKeyFormatter = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/web/jsonWebKeyFormatter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.JsonWebKeyFormatter = void 0;
    var bigInt_1 = require_bigInt();
    var ecdsaCurves_1 = require_ecdsaCurves();
    var JsonWebKeyFormatter = class _JsonWebKeyFormatter {
      static formatRsa(rsa, includePrivate) {
        const formatBigInt = _JsonWebKeyFormatter.formatBigInt;
        let jwk;
        if (includePrivate !== false && rsa.d && rsa.p && rsa.q && rsa.dp && rsa.dq && rsa.qi) {
          jwk = {
            kty: "RSA",
            n: formatBigInt(rsa.modulus),
            e: formatBigInt(rsa.exponent),
            d: formatBigInt(rsa.d),
            p: formatBigInt(rsa.p),
            q: formatBigInt(rsa.q),
            dp: formatBigInt(rsa.dp),
            dq: formatBigInt(rsa.dq),
            qi: formatBigInt(rsa.qi)
          };
        } else if (!includePrivate) {
          jwk = {
            kty: "RSA",
            n: formatBigInt(rsa.modulus),
            e: formatBigInt(rsa.exponent)
          };
        } else {
          throw new Error("Missing private key parameters.");
        }
        return jwk;
      }
      static parseRsa(jwk, includePrivate) {
        if ((jwk === null || jwk === void 0 ? void 0 : jwk.kty) !== "RSA" || !(jwk.n && jwk.e))
          throw new Error("Invalid RSA JWK.");
        const parseBigInt = _JsonWebKeyFormatter.parseBigInt;
        let rsa;
        if (includePrivate !== false && jwk.d && jwk.p && jwk.q && jwk.dp && jwk.dq && jwk.qi) {
          rsa = {
            modulus: parseBigInt(jwk.n),
            exponent: parseBigInt(jwk.e),
            d: parseBigInt(jwk.d),
            p: parseBigInt(jwk.p),
            q: parseBigInt(jwk.q),
            dp: parseBigInt(jwk.dp),
            dq: parseBigInt(jwk.dq),
            qi: parseBigInt(jwk.qi)
          };
        } else {
          rsa = {
            modulus: parseBigInt(jwk.n),
            exponent: parseBigInt(jwk.e)
          };
        }
        return rsa;
      }
      static formatEC(ec, includePrivate) {
        const formatBigInt = _JsonWebKeyFormatter.formatBigInt;
        const curve = ecdsaCurves_1.curves.find((c) => c.oid === ec.curve.oid || c.name === ec.curve.name || c.shortName === ec.curve.name);
        const keySizeInBytes = Math.ceil(curve.keySize / 8);
        const jwk = {
          kty: "EC",
          crv: ec.curve.name,
          x: formatBigInt(ec.x, keySizeInBytes),
          y: formatBigInt(ec.y, keySizeInBytes)
        };
        if (includePrivate !== false && ec.d) {
          jwk.d = formatBigInt(ec.d, keySizeInBytes);
        } else if (includePrivate) {
          throw new Error("Missing private key parameters.");
        }
        return jwk;
      }
      static parseEC(jwk, includePrivate) {
        if ((jwk === null || jwk === void 0 ? void 0 : jwk.kty) !== "EC" || !(jwk.crv && jwk.x && jwk.y))
          throw new Error("Invalid EC JWK.");
        const parseBigInt = _JsonWebKeyFormatter.parseBigInt;
        const ec = {
          curve: { name: jwk.crv },
          x: parseBigInt(jwk.x),
          y: parseBigInt(jwk.y)
        };
        if (includePrivate !== false && jwk.d) {
          ec.d = parseBigInt(jwk.d);
        }
        return ec;
      }
      static formatBigInt(value, length) {
        return _JsonWebKeyFormatter.base64UrlEncode(value.toBytes({ unsigned: true, length }));
      }
      static parseBigInt(value) {
        return bigInt_1.BigInt.fromBytes(Buffer.from(value, "base64"), { unsigned: true });
      }
      static base64UrlEncode(data) {
        return data.toString("base64").replace(/=+$/g, "").replace(/\+/g, "-").replace(/\//g, "_");
      }
    };
    exports2.JsonWebKeyFormatter = JsonWebKeyFormatter;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/web/webKeyExchange.js
var require_webKeyExchange = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/web/webKeyExchange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WebECDiffieHellman = exports2.WebDiffieHellman = void 0;
    var buffer_1 = require("buffer");
    var diffie_hellman_1 = require_diffie_hellman();
    var keyExchangeAlgorithm_1 = require_keyExchangeAlgorithm();
    var webHmac_1 = require_webHmac();
    var bigInt_1 = require_bigInt();
    var jsonWebKeyFormatter_1 = require_jsonWebKeyFormatter();
    var WebDiffieHellman = class extends keyExchangeAlgorithm_1.KeyExchangeAlgorithm {
      constructor(name, keySizeInBits, hashAlgorithmName) {
        super(name, keySizeInBits, hashAlgorithmName, webHmac_1.WebHmac.getHashDigestLength(hashAlgorithmName));
      }
      createKeyExchange() {
        return new WebDiffieHellmanKex(this.keySizeInBits, webHmac_1.WebHmac.getWebHashAlgorithmName(this.hashAlgorithmName), this.hashDigestLength);
      }
    };
    exports2.WebDiffieHellman = WebDiffieHellman;
    var WebDiffieHellmanKex = class {
      constructor(bitLength, hashAlgorithmName, digestLength) {
        this.hashAlgorithmName = hashAlgorithmName;
        this.digestLength = digestLength;
        switch (bitLength) {
          case 1024:
            this.dh = (0, diffie_hellman_1.getDiffieHellman)("modp2");
            break;
          case 2048:
            this.dh = (0, diffie_hellman_1.getDiffieHellman)("modp14");
            break;
          case 4096:
            this.dh = (0, diffie_hellman_1.getDiffieHellman)("modp16");
            break;
          default:
            throw new Error("Invalid DH bit length.");
        }
      }
      startKeyExchange() {
        const exchangeValueKeys = this.dh.generateKeys();
        const exchangeValue = bigInt_1.BigInt.fromBytes(exchangeValueKeys, { unsigned: true }).toBytes();
        return Promise.resolve(exchangeValue);
      }
      decryptKeyExchange(exchangeValue) {
        const key = this.dh.computeSecret(exchangeValue);
        const sharedSecret = bigInt_1.BigInt.fromBytes(key, { unsigned: true }).toBytes();
        return Promise.resolve(sharedSecret);
      }
      async sign(data) {
        const hashBuffer = await crypto.subtle.digest(this.hashAlgorithmName, data);
        return buffer_1.Buffer.from(hashBuffer);
      }
      dispose() {
      }
    };
    var WebECDiffieHellman = class extends keyExchangeAlgorithm_1.KeyExchangeAlgorithm {
      constructor(name, keySizeInBits, hashAlgorithmName) {
        super(name, keySizeInBits, hashAlgorithmName, webHmac_1.WebHmac.getHashDigestLength(hashAlgorithmName));
      }
      createKeyExchange() {
        return new WebECDiffieHellmanKex(this.keySizeInBits, webHmac_1.WebHmac.getWebHashAlgorithmName(this.hashAlgorithmName), this.hashDigestLength);
      }
    };
    exports2.WebECDiffieHellman = WebECDiffieHellman;
    var WebECDiffieHellmanKex = class {
      constructor(bitLength, hashAlgorithmName, digestLength) {
        this.bitLength = bitLength;
        this.hashAlgorithmName = hashAlgorithmName;
        this.digestLength = digestLength;
        this.algorithm = {
          name: "ECDH",
          namedCurve: "P-" + bitLength
        };
      }
      async startKeyExchange() {
        if (!this.keyPair) {
          this.keyPair = await crypto.subtle.generateKey(
            this.algorithm,
            true,
            // exportable
            ["deriveBits"]
          );
        }
        const jwk = await crypto.subtle.exportKey("jwk", this.keyPair.publicKey);
        const ec = jsonWebKeyFormatter_1.JsonWebKeyFormatter.parseEC(jwk);
        const length = Math.ceil(this.bitLength / 8);
        const publicKeyBytes = buffer_1.Buffer.alloc(1 + length * 2);
        publicKeyBytes[0] = 4;
        ec.x.toBytes({ unsigned: true, length }).copy(publicKeyBytes, 1);
        ec.y.toBytes({ unsigned: true, length }).copy(publicKeyBytes, 1 + length);
        return buffer_1.Buffer.from(publicKeyBytes);
      }
      async decryptKeyExchange(exchangeValue) {
        if (!this.keyPair) {
          throw new Error("Key exchange not started.");
        }
        const xy = exchangeValue;
        const jwk = jsonWebKeyFormatter_1.JsonWebKeyFormatter.formatEC({
          curve: { name: this.algorithm.namedCurve },
          x: bigInt_1.BigInt.fromBytes(xy.slice(1, 1 + (xy.length - 1) / 2), { unsigned: true }),
          y: bigInt_1.BigInt.fromBytes(xy.slice(1 + (xy.length - 1) / 2), { unsigned: true })
        });
        const otherPublicKey = await crypto.subtle.importKey("jwk", jwk, this.algorithm, false, []);
        const sharedSecretBytes = buffer_1.Buffer.from(await crypto.subtle.deriveBits(Object.assign(Object.assign({}, this.algorithm), { public: otherPublicKey }), this.keyPair.privateKey, Math.ceil(this.bitLength / 8) * 8));
        const sharedSecret = bigInt_1.BigInt.fromBytes(sharedSecretBytes, { unsigned: true }).toBytes();
        return sharedSecret;
      }
      async sign(data) {
        const hashBuffer = await crypto.subtle.digest(this.hashAlgorithmName, data);
        return buffer_1.Buffer.from(hashBuffer);
      }
      dispose() {
      }
    };
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/web/webRsa.js
var require_webRsa = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/web/webRsa.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WebRsa = void 0;
    var buffer_1 = require("buffer");
    var publicKeyAlgorithm_1 = require_publicKeyAlgorithm();
    var webHmac_1 = require_webHmac();
    var sshData_1 = require_sshData();
    var jsonWebKeyFormatter_1 = require_jsonWebKeyFormatter();
    var WebRsaKeyPair = class _WebRsaKeyPair {
      /* @internal */
      constructor(hashAlgorithm) {
        this.hashAlgorithm = hashAlgorithm;
        this.comment = null;
      }
      get hasPublicKey() {
        return !!this.publicKey;
      }
      get hasPrivateKey() {
        return !!this.privateKey;
      }
      get keyAlgorithmName() {
        return WebRsa.keyAlgorithmName;
      }
      async generate(keySizeInBits) {
        keySizeInBits = keySizeInBits !== null && keySizeInBits !== void 0 ? keySizeInBits : _WebRsaKeyPair.defaultKeySize;
        try {
          const keyGenParams = {
            name: "RSASSA-PKCS1-v1_5",
            modulusLength: keySizeInBits,
            publicExponent: new Uint8Array([1, 0, 1]),
            hash: { name: this.hashAlgorithm }
          };
          const keyPair = await crypto.subtle.generateKey(keyGenParams, true, ["sign", "verify"]);
          this.publicKey = keyPair.publicKey;
          this.privateKey = keyPair.privateKey;
        } catch (e) {
          throw new Error("Failed to generate RSA key pair: " + e);
        }
      }
      async setPublicKeyBytes(keyBytes) {
        if (!keyBytes) {
          throw new TypeError("Buffer is required.");
        }
        const reader = new sshData_1.SshDataReader(keyBytes);
        const algorithmName = reader.readString("ascii");
        if (algorithmName !== this.keyAlgorithmName && algorithmName !== WebRsa.rsaWithSha256 && algorithmName !== WebRsa.rsaWithSha512) {
          throw new Error(`Invalid RSA key algorithm: ${algorithmName}`);
        }
        const exponent = reader.readBigInt();
        const modulus = reader.readBigInt();
        const jwk = jsonWebKeyFormatter_1.JsonWebKeyFormatter.formatRsa({ modulus, exponent }, false);
        jwk.alg = "RS" + this.hashAlgorithm.replace("SHA-", "");
        jwk.key_ops = ["verify"];
        try {
          const importParams = {
            name: "RSASSA-PKCS1-v1_5",
            hash: { name: this.hashAlgorithm }
          };
          this.publicKey = await crypto.subtle.importKey("jwk", jwk, importParams, true, ["verify"]);
        } catch (e) {
          throw new Error("Failed to import RSA public key: " + e);
        }
      }
      async getPublicKeyBytes(algorithmName) {
        if (!this.publicKey) {
          return null;
        }
        if (!algorithmName) {
          algorithmName = this.keyAlgorithmName;
        }
        let jwk;
        try {
          jwk = await crypto.subtle.exportKey("jwk", this.publicKey);
        } catch (e) {
          throw new Error("Failed to export RSA public key: " + e);
        }
        const { modulus, exponent } = jsonWebKeyFormatter_1.JsonWebKeyFormatter.parseRsa(jwk, false);
        const keyBuffer = buffer_1.Buffer.alloc(512);
        const keyWriter = new sshData_1.SshDataWriter(keyBuffer);
        keyWriter.writeString(algorithmName, "ascii");
        keyWriter.writeBigInt(exponent);
        keyWriter.writeBigInt(modulus);
        const keyBytes = keyWriter.toBuffer();
        return keyBytes;
      }
      async importParameters(parameters) {
        const privateJwk = parameters.d ? jsonWebKeyFormatter_1.JsonWebKeyFormatter.formatRsa(parameters, true) : null;
        const publicJwk = jsonWebKeyFormatter_1.JsonWebKeyFormatter.formatRsa(parameters, false);
        const importParams = {
          name: "RSASSA-PKCS1-v1_5",
          hash: { name: this.hashAlgorithm }
        };
        try {
          this.publicKey = await crypto.subtle.importKey("jwk", publicJwk, importParams, true, [
            "verify"
          ]);
          if (privateJwk) {
            this.privateKey = await crypto.subtle.importKey("jwk", privateJwk, importParams, true, [
              "sign"
            ]);
          } else {
            this.privateKey = void 0;
          }
        } catch (e) {
          if (!(e instanceof Error))
            throw e;
          throw new Error("Failed to import RSA key pair: " + e.message);
        }
      }
      async exportParameters() {
        var _a2;
        if (!this.publicKey)
          throw new Error("Public key not set.");
        let jwk;
        try {
          jwk = await crypto.subtle.exportKey("jwk", (_a2 = this.privateKey) !== null && _a2 !== void 0 ? _a2 : this.publicKey);
        } catch (e) {
          if (!(e instanceof Error))
            throw e;
          throw new Error("Failed to export RSA public key: " + e.message);
        }
        return jsonWebKeyFormatter_1.JsonWebKeyFormatter.parseRsa(jwk, !!this.privateKey);
      }
      dispose() {
      }
    };
    WebRsaKeyPair.defaultKeySize = 2048;
    var WebRsa = class _WebRsa extends publicKeyAlgorithm_1.PublicKeyAlgorithm {
      constructor(name, hashAlgorithmName) {
        super(name, _WebRsa.keyAlgorithmName, hashAlgorithmName);
      }
      createKeyPair() {
        const hashAlgorithm = _WebRsa.convertHashAlgorithmName(this.hashAlgorithmName);
        return new WebRsaKeyPair(hashAlgorithm);
      }
      async generateKeyPair(keySizeInBits) {
        const hashAlgorithm = _WebRsa.convertHashAlgorithmName(this.hashAlgorithmName);
        const rsaKey = new WebRsaKeyPair(hashAlgorithm);
        await rsaKey.generate(keySizeInBits);
        return rsaKey;
      }
      createSigner(keyPair) {
        if (!(keyPair instanceof WebRsaKeyPair)) {
          throw new TypeError("RSA key pair object expected.");
        }
        const hashAlgorithm = _WebRsa.convertHashAlgorithmName(this.hashAlgorithmName);
        return new WebRsaSignerVerifier(keyPair, hashAlgorithm, webHmac_1.WebHmac.getHashDigestLength(this.hashAlgorithmName));
      }
      createVerifier(keyPair) {
        if (!(keyPair instanceof WebRsaKeyPair)) {
          throw new TypeError("RSA key pair object expected.");
        }
        const hashAlgorithm = _WebRsa.convertHashAlgorithmName(this.hashAlgorithmName);
        return new WebRsaSignerVerifier(keyPair, hashAlgorithm, webHmac_1.WebHmac.getHashDigestLength(this.hashAlgorithmName));
      }
      static convertHashAlgorithmName(hashAlgorithmName) {
        return hashAlgorithmName.replace("SHA2-", "SHA-");
      }
    };
    exports2.WebRsa = WebRsa;
    WebRsa.keyAlgorithmName = "ssh-rsa";
    WebRsa.rsaWithSha256 = "rsa-sha2-256";
    WebRsa.rsaWithSha512 = "rsa-sha2-512";
    WebRsa.KeyPair = WebRsaKeyPair;
    var WebRsaSignerVerifier = class {
      constructor(keyPair, hashAlgorithm, digestLength) {
        this.keyPair = keyPair;
        this.hashAlgorithm = hashAlgorithm;
        this.digestLength = digestLength;
      }
      async sign(data) {
        if (!this.keyPair.privateKey) {
          throw new Error("Private key not set.");
        }
        await this.convertKeyHashAlgorithm();
        const signature = buffer_1.Buffer.from(await crypto.subtle.sign("RSASSA-PKCS1-v1_5", this.keyPair.privateKey, data));
        return signature;
      }
      async verify(data, signature) {
        if (!this.keyPair.publicKey) {
          throw new Error("Public key not set.");
        }
        await this.convertKeyHashAlgorithm();
        const result = await crypto.subtle.verify("RSASSA-PKCS1-v1_5", this.keyPair.publicKey, signature, data);
        return result;
      }
      async convertKeyHashAlgorithm() {
        if (this.keyPair.hashAlgorithm !== this.hashAlgorithm) {
          const parameters = await this.keyPair.exportParameters();
          this.keyPair = new WebRsaKeyPair(this.hashAlgorithm);
          await this.keyPair.importParameters(parameters);
        }
      }
      dispose() {
      }
    };
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/web/webECDsa.js
var require_webECDsa = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/web/webECDsa.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WebECDsa = void 0;
    var buffer_1 = require("buffer");
    var publicKeyAlgorithm_1 = require_publicKeyAlgorithm();
    var sshData_1 = require_sshData();
    var ecdsaCurves_1 = require_ecdsaCurves();
    var bigInt_1 = require_bigInt();
    var jsonWebKeyFormatter_1 = require_jsonWebKeyFormatter();
    var WebECDsaKeyPair = class {
      /**
       * Constructs a new ECDSA key pair object.
       *
       * @param algorithmName Key pair algorithm name. If unspecified, the key pair object must be
       * initialized before use via `importParameters()`.
       */
      constructor(algorithmName) {
        this.comment = null;
        if (algorithmName) {
          this.algorithmName = algorithmName;
        }
      }
      get hasPublicKey() {
        return !!this.publicKey;
      }
      get hasPrivateKey() {
        return !!this.privateKey;
      }
      get keyAlgorithmName() {
        return this.algorithmName;
      }
      get algorithmName() {
        return this.algorithm;
      }
      set algorithmName(value) {
        const curveName = value.split("-")[2];
        this.curve = ecdsaCurves_1.curves.find((c) => c.name === curveName);
        if (!this.curve) {
          throw new Error("Invalid or unsupported ECDSA algorithm: " + value);
        }
        this.algorithm = value;
      }
      async generate() {
        try {
          const keyGenParams = {
            name: "ECDSA",
            namedCurve: this.curve.shortName
          };
          const keyPair = await crypto.subtle.generateKey(keyGenParams, true, ["sign", "verify"]);
          this.publicKey = keyPair.publicKey;
          this.privateKey = keyPair.privateKey;
        } catch (e) {
          throw new Error("Failed to generate RSA key pair: " + e);
        }
      }
      async setPublicKeyBytes(keyBytes, algorithmName) {
        if (!keyBytes) {
          throw new TypeError("Buffer is required.");
        }
        const reader = new sshData_1.SshDataReader(keyBytes);
        const readAlgorithmName = reader.readString("ascii");
        this.algorithmName = algorithmName || readAlgorithmName;
        const curveName = reader.readString("ascii");
        if (curveName !== this.curve.name) {
          throw new Error("EC curve name does not match.");
        }
        const key = reader.readBinary();
        const n = Math.ceil(this.curve.keySize / 8);
        const x = bigInt_1.BigInt.fromBytes(key.slice(1, 1 + n), { unsigned: true });
        const y = bigInt_1.BigInt.fromBytes(key.slice(1 + n, key.length), { unsigned: true });
        const jwk = jsonWebKeyFormatter_1.JsonWebKeyFormatter.formatEC({
          curve: { name: this.curve.shortName, oid: this.curve.oid },
          x,
          y
        });
        try {
          const importParams = {
            name: "ECDSA",
            namedCurve: this.curve.shortName
          };
          this.publicKey = await crypto.subtle.importKey("jwk", jwk, importParams, true, ["verify"]);
        } catch (e) {
          throw new Error("Failed to import EC public key: " + e);
        }
      }
      async getPublicKeyBytes(algorithmName) {
        if (!this.publicKey) {
          return null;
        }
        let jwk;
        try {
          jwk = await crypto.subtle.exportKey("jwk", this.publicKey);
        } catch (e) {
          throw new Error("Failed to export ECDSA public key: " + e);
        }
        const x = buffer_1.Buffer.from(jwk.x, "base64");
        const y = buffer_1.Buffer.from(jwk.y, "base64");
        const n = Math.ceil(this.curve.keySize / 8);
        if (x.length !== n || y.length !== n) {
          throw new Error("Unexpected key length.");
        }
        algorithmName = algorithmName || this.algorithmName || this.keyAlgorithmName;
        const keyBuffer = buffer_1.Buffer.alloc(algorithmName.length + x.length + y.length + 10);
        const keyWriter = new sshData_1.SshDataWriter(keyBuffer);
        keyWriter.writeString(algorithmName, "ascii");
        keyWriter.writeString(this.curve.name, "ascii");
        keyWriter.writeUInt32(1 + x.length + y.length);
        keyWriter.writeByte(4);
        keyWriter.write(x);
        keyWriter.write(y);
        const keyBytes = keyWriter.toBuffer();
        return keyBytes;
      }
      async importParameters(parameters) {
        if (!parameters.curve)
          throw new TypeError("A curve is required.");
        let curve;
        if (parameters.curve.oid) {
          curve = ecdsaCurves_1.curves.find((c) => c.oid === parameters.curve.oid);
          if (!curve) {
            throw new Error(`Unsupported curve OID: ${parameters.curve.oid}`);
          }
        } else if (parameters.curve.name) {
          curve = ecdsaCurves_1.curves.find((c) => c.name === parameters.curve.name);
          if (!curve) {
            throw new Error(`Unsupported curve: ${parameters.curve.name}`);
          }
        } else {
          throw new TypeError("A curve OID or name is required.");
        }
        this.algorithmName = "ecdsa-sha2-" + curve.name;
        const importParams = {
          name: "ECDSA",
          namedCurve: this.curve.shortName
        };
        const jwk = jsonWebKeyFormatter_1.JsonWebKeyFormatter.formatEC(parameters);
        jwk.crv = this.curve.shortName;
        try {
          if (jwk.d) {
            this.privateKey = await crypto.subtle.importKey("jwk", jwk, importParams, true, [
              "sign"
            ]);
            jwk.d = void 0;
          } else {
            this.privateKey = void 0;
          }
          this.publicKey = await crypto.subtle.importKey("jwk", jwk, importParams, true, ["verify"]);
        } catch (e) {
          throw new Error("Failed to import ECDSA key pair: " + e);
        }
      }
      async exportParameters() {
        var _a2;
        const exportKey = (_a2 = this.privateKey) !== null && _a2 !== void 0 ? _a2 : this.publicKey;
        if (!exportKey) {
          throw new Error("Key not present.");
        }
        let jwk;
        try {
          jwk = await crypto.subtle.exportKey("jwk", exportKey);
        } catch (e) {
          throw new Error("Failed to export ECDSA key pair: " + e);
        }
        const parameters = jsonWebKeyFormatter_1.JsonWebKeyFormatter.parseEC(jwk);
        parameters.curve = { name: this.curve.name, oid: this.curve.oid };
        return parameters;
      }
      dispose() {
      }
    };
    var WebECDsa = class _WebECDsa extends publicKeyAlgorithm_1.PublicKeyAlgorithm {
      constructor(name, hashAlgorithmName) {
        super(name, name, hashAlgorithmName);
      }
      createKeyPair() {
        return new WebECDsaKeyPair(this.name);
      }
      async generateKeyPair() {
        const ecdsaKey = new WebECDsaKeyPair(this.name);
        await ecdsaKey.generate();
        return ecdsaKey;
      }
      createSigner(keyPair) {
        if (!(keyPair instanceof WebECDsaKeyPair)) {
          throw new TypeError("ECDSA key pair object expected.");
        }
        const hashAlgorithm = _WebECDsa.convertHashAlgorithmName(this.hashAlgorithmName);
        return new WebECDsaSignerVerifier(keyPair, hashAlgorithm);
      }
      createVerifier(keyPair) {
        if (!(keyPair instanceof WebECDsaKeyPair)) {
          throw new TypeError("ECDSA key pair object expected.");
        }
        const hashAlgorithm = _WebECDsa.convertHashAlgorithmName(this.hashAlgorithmName);
        return new WebECDsaSignerVerifier(keyPair, hashAlgorithm);
      }
      static convertHashAlgorithmName(hashAlgorithmName) {
        return hashAlgorithmName.replace("SHA2-", "SHA-");
      }
      /* @internal */
      static getSignatureLength(keySizeInBits) {
        const keySizeInBytes = Math.ceil(keySizeInBits / 8);
        return (4 + 1 + keySizeInBytes) * 2;
      }
    };
    exports2.WebECDsa = WebECDsa;
    WebECDsa.ecdsaSha2Nistp256 = "ecdsa-sha2-nistp256";
    WebECDsa.ecdsaSha2Nistp384 = "ecdsa-sha2-nistp384";
    WebECDsa.ecdsaSha2Nistp521 = "ecdsa-sha2-nistp521";
    WebECDsa.curves = ecdsaCurves_1.curves;
    WebECDsa.KeyPair = WebECDsaKeyPair;
    var WebECDsaSignerVerifier = class {
      constructor(keyPair, hashAlgorithm) {
        this.keyPair = keyPair;
        this.hashAlgorithm = hashAlgorithm;
      }
      get digestLength() {
        const curve = this.keyPair.curve;
        if (!curve) {
          return 0;
        } else {
          return WebECDsa.getSignatureLength(curve.keySize);
        }
      }
      async sign(data) {
        if (!this.keyPair.privateKey) {
          throw new Error("Private key not set.");
        }
        let signature = buffer_1.Buffer.from(await crypto.subtle.sign({ name: "ECDSA", hash: { name: this.hashAlgorithm } }, this.keyPair.privateKey, data));
        const keySizeInBytes = Math.ceil(this.keyPair.curve.keySize / 8);
        if (signature.length !== 2 * keySizeInBytes) {
          throw new Error(`Unexpected signature length: ${signature.length}`);
        }
        const x = bigInt_1.BigInt.fromBytes(signature.slice(0, keySizeInBytes), { unsigned: true });
        const y = bigInt_1.BigInt.fromBytes(signature.slice(keySizeInBytes, signature.length), {
          unsigned: true
        });
        const signatureWriter = new sshData_1.SshDataWriter(buffer_1.Buffer.alloc(this.digestLength));
        signatureWriter.writeBinary(x.toBytes({ unsigned: true, length: keySizeInBytes + 1 }));
        signatureWriter.writeBinary(y.toBytes({ unsigned: true, length: keySizeInBytes + 1 }));
        signature = signatureWriter.toBuffer();
        return signature;
      }
      async verify(data, signature) {
        if (!this.keyPair.publicKey) {
          throw new Error("Public key not set.");
        }
        const signatureReader = new sshData_1.SshDataReader(signature);
        const x = signatureReader.readBigInt();
        const y = signatureReader.readBigInt();
        const keySizeInBytes = Math.ceil(this.keyPair.curve.keySize / 8);
        signature = buffer_1.Buffer.alloc(2 * keySizeInBytes);
        x.toBytes({ unsigned: true, length: keySizeInBytes }).copy(signature, 0);
        y.toBytes({ unsigned: true, length: keySizeInBytes }).copy(signature, keySizeInBytes);
        const result = await crypto.subtle.verify({ name: "ECDSA", hash: { name: this.hashAlgorithm } }, this.keyPair.publicKey, signature, data);
        return result;
      }
      dispose() {
      }
    };
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/web/webEncryption.js
var require_webEncryption = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/web/webEncryption.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WebEncryption = void 0;
    var buffer_1 = require("buffer");
    var encryptionAlgorithm_1 = require_encryptionAlgorithm();
    var WebEncryption = class _WebEncryption extends encryptionAlgorithm_1.EncryptionAlgorithm {
      constructor(name, algorithmName, cipherMode, keySizeInBits) {
        super(name);
        this.algorithmName = algorithmName;
        this.cipherMode = cipherMode;
        this.keySizeInBits = keySizeInBits;
        this.blockSizeInBits = _WebEncryption.getBlockSize(algorithmName);
      }
      get keyLength() {
        return this.keySizeInBits / 8;
      }
      get blockLength() {
        return this.blockSizeInBits / 8;
      }
      async createCipher(isEncryption, key, iv) {
        const cipher = new WebCipher(isEncryption, this.algorithmName, this.cipherMode, this.keySizeInBits, this.blockSizeInBits);
        await cipher.init(key, iv);
        return cipher;
      }
      static getBlockSize(algorithmName) {
        if (algorithmName === "AES") {
          return 128;
        } else {
          throw new Error(`Unsupported encryption algorithm: ${algorithmName}`);
        }
      }
    };
    exports2.WebEncryption = WebEncryption;
    var WebCipher = class {
      get blockLength() {
        return this.blockSizeInBits / 8;
      }
      constructor(isEncryption, algorithmName, cipherMode, keySizeInBits, blockSizeInBits) {
        this.isEncryption = isEncryption;
        this.algorithmName = algorithmName;
        this.cipherMode = cipherMode;
        this.keySizeInBits = keySizeInBits;
        this.blockSizeInBits = blockSizeInBits;
        this.tag = null;
        if (this.algorithmName === "AES" && this.cipherMode === "CTR") {
          this.transform = this.aesCtr.bind(this, isEncryption);
        } else if (this.algorithmName === "AES" && this.cipherMode === "CBC") {
          this.transform = this.aesCbc.bind(this, isEncryption);
        } else if (this.algorithmName === "AES" && this.cipherMode === "GCM") {
          this.transform = this.aesGcm.bind(this, isEncryption);
          this.associatedData = buffer_1.Buffer.alloc(4);
          this.decryptBuffer = buffer_1.Buffer.alloc(this.blockLength * 4);
        } else {
          throw new Error(`Unsupported encryption algorithm: ${this.algorithmName}-${this.cipherMode}`);
        }
      }
      async init(key, iv) {
        try {
          const name = `${this.algorithmName}-${this.cipherMode}`;
          this.key = await crypto.subtle.importKey("raw", key, { name, length: this.keySizeInBits }, false, this.isEncryption ? ["encrypt"] : ["decrypt"]);
        } catch (e) {
          throw new Error("Failed to initialize AES: " + e);
        }
        if (this.cipherMode === "GCM") {
          this.iv = buffer_1.Buffer.from(iv.slice(0, 12));
        } else {
          this.iv = buffer_1.Buffer.from(iv);
        }
      }
      async aesCtr(isEncryption, data) {
        if (data.length % this.blockLength !== 0) {
          const message = `Encrypt/decrypt input has invalid length ${data.length}, not a multiple of block size ${this.blockLength}.`;
          throw new Error(message);
        }
        let result;
        if (isEncryption) {
          result = buffer_1.Buffer.from(await crypto.subtle.encrypt({ name: "AES-CTR", counter: this.iv, length: this.blockSizeInBits }, this.key, data));
        } else {
          result = buffer_1.Buffer.from(await crypto.subtle.decrypt({ name: "AES-CTR", counter: this.iv, length: this.blockSizeInBits }, this.key, data));
        }
        if (result.length !== data.length) {
          const message = `Result from encrypt/decrypt has invalid length ${result.length}, expected ${data.length}.`;
          throw new Error(message);
        }
        const incrementCount = data.length / this.blockLength;
        for (let i = 0; i < incrementCount; i++) {
          for (let k = this.iv.length - 1; k >= 0; k--) {
            this.iv[k] = this.iv[k] + 1;
            if (this.iv[k])
              break;
          }
        }
        return result;
      }
      async aesCbc(isEncryption, data) {
        if (isEncryption) {
          let result = buffer_1.Buffer.from(await crypto.subtle.encrypt({ name: "AES-CBC", iv: this.iv }, this.key, data));
          result = result.slice(0, data.length);
          return result;
        } else {
          return buffer_1.Buffer.from(await crypto.subtle.decrypt({ name: "AES-CBC", iv: this.iv }, this.key, data));
        }
      }
      async aesGcm(isEncryption, data) {
        if (data.length % this.blockLength !== 0) {
          const message = `Encrypt/decrypt input has invalid length ${data.length}, not a multiple of block size ${this.blockLength}.`;
          throw new Error(message);
        }
        const packetLength = data.length;
        this.associatedData[0] = packetLength >>> 24;
        this.associatedData[1] = packetLength >>> 16;
        this.associatedData[2] = packetLength >>> 8;
        this.associatedData[3] = packetLength;
        let result;
        if (isEncryption) {
          result = buffer_1.Buffer.from(await crypto.subtle.encrypt({
            name: "AES-GCM",
            iv: this.iv,
            additionalData: this.associatedData,
            tagLength: this.digestLength * 8
            // tagLength is in bits, not bytes
          }, this.key, data));
          this.tag = result.slice(result.length - this.digestLength);
          result = result.slice(0, result.length - this.digestLength);
        } else {
          if (!this.tag) {
            throw new Error("AES-GCM tag was not set before decrypting.");
          }
          const inputLength = data.length + this.digestLength;
          if (this.decryptBuffer.length < inputLength) {
            let newLength = this.decryptBuffer.length * 2;
            while (newLength < inputLength)
              newLength *= 2;
            this.decryptBuffer = buffer_1.Buffer.alloc(newLength);
          }
          const input = this.decryptBuffer.slice(0, inputLength);
          data.copy(input, 0);
          this.tag.copy(input, data.length);
          result = buffer_1.Buffer.from(await crypto.subtle.decrypt({
            name: "AES-GCM",
            iv: this.iv,
            additionalData: this.associatedData,
            tagLength: this.digestLength * 8
            // tagLength is in bits, not bytes
          }, this.key, input));
        }
        if (result.length !== data.length) {
          const message = `Result from encrypt/decrypt has invalid length ${result.length}, expected ${data.length}.`;
          throw new Error(message);
        }
        let k = 12;
        while (--k >= 4) {
          this.iv[k]++;
          if (this.iv[k] !== 0) {
            break;
          }
        }
        return result;
      }
      get digestLength() {
        return 16;
      }
      get authenticatedEncryption() {
        return this.cipherMode === "GCM";
      }
      async sign(data) {
        if (!this.tag) {
          throw new Error("AES-GCM tag was not obtained by encrypting.");
        }
        return this.tag;
      }
      async verify(data, signature) {
        if (signature.length !== this.digestLength) {
          throw new Error("Incorrect AES-GCM tag length.");
        }
        this.tag = signature;
        return true;
      }
      dispose() {
      }
    };
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/web/webRandom.js
var require_webRandom = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/web/webRandom.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WebRandom = void 0;
    var WebRandom = class {
      getBytes(buffer) {
        crypto.getRandomValues(buffer);
      }
    };
    exports2.WebRandom = WebRandom;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/node/nodeHmac.js
var require_nodeHmac = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/node/nodeHmac.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NodeHmac = void 0;
    var crypto2 = require("crypto");
    var buffer_1 = require("buffer");
    var hmacAlgorithm_1 = require_hmacAlgorithm();
    var NodeHmac = class _NodeHmac extends hmacAlgorithm_1.HmacAlgorithm {
      constructor(name, algorithmName, encryptThenMac = false) {
        super(name, algorithmName, _NodeHmac.getHashKeyLength(algorithmName), _NodeHmac.getHashDigestLength(algorithmName));
        this.encryptThenMac = encryptThenMac;
      }
      async createSigner(key) {
        const hmac = new NodeSignerVerifier(_NodeHmac.getNodeHashAlgorithmName(this.algorithmName), this.digestLength, this.encryptThenMac, key);
        return hmac;
      }
      async createVerifier(key) {
        const hmac = new NodeSignerVerifier(_NodeHmac.getNodeHashAlgorithmName(this.algorithmName), this.digestLength, this.encryptThenMac, key);
        return hmac;
      }
      static getHashKeyLength(hashAlgorithmName) {
        if (hashAlgorithmName === "SHA2-512")
          return 512 / 8;
        if (hashAlgorithmName === "SHA2-384")
          return 384 / 8;
        if (hashAlgorithmName === "SHA2-256")
          return 256 / 8;
        throw new Error(`Unsupported hash algorithm: ${hashAlgorithmName}`);
      }
      static getHashDigestLength(hashAlgorithmName) {
        return this.getHashKeyLength(hashAlgorithmName);
      }
      static getNodeHashAlgorithmName(hashAlgorithmName) {
        if (hashAlgorithmName === "SHA2-512")
          return "sha512";
        if (hashAlgorithmName === "SHA2-384")
          return "sha384";
        if (hashAlgorithmName === "SHA2-256")
          return "sha256";
        throw new Error(`Unsupported hash algorithm: ${hashAlgorithmName}`);
      }
    };
    exports2.NodeHmac = NodeHmac;
    var NodeSignerVerifier = class {
      constructor(algorithmName, digestLength, encryptThenMac, key) {
        this.algorithmName = algorithmName;
        this.digestLength = digestLength;
        this.encryptThenMac = encryptThenMac;
        this.key = crypto2.createSecretKey ? crypto2.createSecretKey(key) : buffer_1.Buffer.from(key);
      }
      async sign(data) {
        const signer = crypto2.createHmac(this.algorithmName, this.key);
        signer.update(data);
        const hmac = signer.digest();
        return hmac;
      }
      async verify(data, signature) {
        const verifier = crypto2.createHmac(this.algorithmName, this.key);
        verifier.update(data);
        const hmac = verifier.digest();
        const result = hmac.equals(signature);
        return result;
      }
      dispose() {
      }
    };
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/node/nodeKeyExchange.js
var require_nodeKeyExchange = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/node/nodeKeyExchange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NodeECDiffieHellman = exports2.NodeDiffieHellman = void 0;
    var crypto2 = require("crypto");
    var buffer_1 = require("buffer");
    var keyExchangeAlgorithm_1 = require_keyExchangeAlgorithm();
    var nodeHmac_1 = require_nodeHmac();
    var bigInt_1 = require_bigInt();
    var NodeDiffieHellman = class extends keyExchangeAlgorithm_1.KeyExchangeAlgorithm {
      constructor(name, keySizeInBits, hashAlgorithmName) {
        super(name, keySizeInBits, hashAlgorithmName, nodeHmac_1.NodeHmac.getHashDigestLength(hashAlgorithmName));
      }
      createKeyExchange() {
        return new NodeDiffieHellmanKex(this.keySizeInBits, nodeHmac_1.NodeHmac.getNodeHashAlgorithmName(this.hashAlgorithmName), this.hashDigestLength);
      }
    };
    exports2.NodeDiffieHellman = NodeDiffieHellman;
    var NodeDiffieHellmanKex = class {
      constructor(bitLength, hashAlgorithmName, digestLength) {
        this.hashAlgorithmName = hashAlgorithmName;
        this.digestLength = digestLength;
        switch (bitLength) {
          case 1024:
            this.dh = crypto2.getDiffieHellman("modp2");
            break;
          case 2048:
            this.dh = crypto2.getDiffieHellman("modp14");
            break;
          case 4096:
            this.dh = crypto2.getDiffieHellman("modp16");
            break;
          default:
            throw new Error("Invalid DH bit length.");
        }
      }
      startKeyExchange() {
        const exchangeValueKeys = this.dh.generateKeys();
        const exchangeValue = bigInt_1.BigInt.fromBytes(exchangeValueKeys, { unsigned: true }).toBytes();
        return Promise.resolve(exchangeValue);
      }
      decryptKeyExchange(exchangeValue) {
        const key = this.dh.computeSecret(exchangeValue);
        const sharedSecret = bigInt_1.BigInt.fromBytes(key, { unsigned: true }).toBytes();
        return Promise.resolve(sharedSecret);
      }
      async sign(data) {
        const hash = crypto2.createHash(this.hashAlgorithmName);
        hash.update(data);
        return buffer_1.Buffer.from(hash.digest());
      }
      dispose() {
      }
    };
    var NodeECDiffieHellman = class extends keyExchangeAlgorithm_1.KeyExchangeAlgorithm {
      constructor(name, keySizeInBits, hashAlgorithmName) {
        super(name, keySizeInBits, hashAlgorithmName, nodeHmac_1.NodeHmac.getHashDigestLength(hashAlgorithmName));
      }
      createKeyExchange() {
        return new NodeECDiffieHellmanKex(this.keySizeInBits, nodeHmac_1.NodeHmac.getNodeHashAlgorithmName(this.hashAlgorithmName), this.hashDigestLength);
      }
    };
    exports2.NodeECDiffieHellman = NodeECDiffieHellman;
    var NodeECDiffieHellmanKex = class {
      constructor(bitLength, hashAlgorithmName, digestLength) {
        this.hashAlgorithmName = hashAlgorithmName;
        this.digestLength = digestLength;
        switch (bitLength) {
          case 256:
            this.ecdh = crypto2.createECDH("prime256v1");
            break;
          case 384:
            this.ecdh = crypto2.createECDH("secp384r1");
            break;
          case 521:
            this.ecdh = crypto2.createECDH("secp521r1");
            break;
          default:
            throw new Error("Invalid ECDH bit length.");
        }
      }
      startKeyExchange() {
        const exchangeValue = this.ecdh.generateKeys();
        return Promise.resolve(exchangeValue);
      }
      decryptKeyExchange(exchangeValue) {
        const sharedSecretBytes = this.ecdh.computeSecret(exchangeValue);
        const sharedSecret = bigInt_1.BigInt.fromBytes(sharedSecretBytes, { unsigned: true }).toBytes();
        return Promise.resolve(sharedSecret);
      }
      async sign(data) {
        const hash = crypto2.createHash(this.hashAlgorithmName);
        hash.update(data);
        return buffer_1.Buffer.from(hash.digest());
      }
      dispose() {
      }
    };
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/io/derData.js
var require_derData = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/io/derData.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DerWriter = exports2.DerReader = void 0;
    var buffer_1 = require("buffer");
    var bigInt_1 = require_bigInt();
    var DerReader = class _DerReader {
      constructor(buffer, dataType = 32 | 16) {
        this.buffer = buffer;
        this.position = 0;
        this.readType(dataType);
        const length = this.readLength();
        if (length > this.buffer.length - this.position) {
          throw new Error("Read out of bounds.");
        }
        this.buffer = this.buffer.slice(0, this.position + length);
      }
      get available() {
        return this.buffer.length - this.position;
      }
      readNull() {
        this.readType(
          5
          /* DerType.Null */
        );
        if (this.readByte() !== 0) {
          throw new Error("Expected a 0 after Null type.");
        }
      }
      readInteger() {
        this.readType(
          2
          /* DerType.Integer */
        );
        const length = this.readLength();
        const bytes = this.readBytes(length);
        const result = new bigInt_1.BigInt(bytes);
        return result;
      }
      readOctetString() {
        this.readType(
          4
          /* DerType.OctetString */
        );
        const length = this.readLength();
        const result = this.readBytes(length);
        return result;
      }
      readBitString() {
        this.readType(
          3
          /* DerType.BitString */
        );
        const length = this.readLength();
        const padding = this.readByte();
        if (padding !== 0) {
          throw new Error("Padded bit strings are not supported.");
        }
        const result = this.readBytes(length - 1);
        return result;
      }
      readObjectIdentifier(expected) {
        this.readType(
          6
          /* DerType.ObjectIdentifier */
        );
        const length = this.readLength();
        const end = this.position + length;
        const values = [];
        const first2 = this.readByte();
        values.push(Math.trunc(first2 / 40));
        values.push(first2 % 40);
        let next = 0;
        while (this.position < end) {
          const b = this.readByte();
          if ((b & 128) !== 0) {
            next = next * 128 + (b & 127);
          } else {
            next = next * 128 + b;
            values.push(next);
            next = 0;
          }
        }
        if (next !== 0) {
          throw new Error("Invalid OID format.");
        }
        const result = values.join(".");
        if (expected && result !== expected) {
          throw new Error(`Expected OID ${expected}, found: ${result}`);
        }
        return result;
      }
      readSequence() {
        const start = this.position;
        this.readType(
          32 | 16
          /* DerType.Sequence */
        );
        const length = this.readLength();
        this.position += length;
        return new _DerReader(this.buffer.slice(start, this.position));
      }
      tryReadTagged(tagId) {
        if (this.position >= this.buffer.length) {
          return null;
        }
        const type = this.buffer[this.position];
        if ((type & 160) === 0 || (type & ~160) !== tagId) {
          return null;
        }
        const start = this.position;
        this.position++;
        const length = this.readLength();
        this.position += length;
        const taggedData = new _DerReader(this.buffer.slice(start, this.position), type);
        return taggedData;
      }
      /** Reads the type of the next value in the sequence WITHOUT advancing the reader position. */
      peek() {
        if (this.position >= this.buffer.length) {
          throw new Error("Read out of bounds.");
        }
        return this.buffer[this.position];
      }
      readLength() {
        let length = this.readByte();
        if (length === 128) {
          throw new Error("Indefinite-length encoding is not supported.");
        }
        if (length > 127) {
          const size = length & 127;
          if (size > 4) {
            throw new Error(`DER length size is ${size} and cannot be more than 4 bytes.`);
          }
          length = 0;
          for (let i = 0; i < size; i++) {
            const next = this.readByte();
            length = (length << 8) + next;
          }
          if (length < 0) {
            throw new Error("Corrupted data - negative length found");
          }
        }
        return length;
      }
      readByte() {
        if (this.position >= this.buffer.length) {
          throw new Error("Read out of bounds.");
        }
        return this.buffer[this.position++];
      }
      readBytes(length) {
        if (this.position + length > this.buffer.length) {
          throw new Error("Read out of bounds.");
        }
        const result = this.buffer.slice(this.position, this.position + length);
        this.position += length;
        return result;
      }
      readType(expectedType) {
        const type = this.readByte();
        if (type !== expectedType) {
          throw new Error(`Expected ${expectedType} data type, found : ${type}`);
        }
      }
    };
    exports2.DerReader = DerReader;
    var DerWriter = class _DerWriter {
      constructor(buffer, dataType = 32 | 16) {
        this.buffer = buffer;
        this.dataType = dataType;
        this.position = 0;
        this.buffer = buffer;
      }
      toBuffer() {
        const length = this.position;
        const lengthBytes = _DerWriter.getLength(length);
        this.ensureCapacity(1 + lengthBytes.length + length);
        const result = this.buffer.slice(0, 1 + lengthBytes.length + length);
        this.buffer.copy(result, 1 + lengthBytes.length);
        result[0] = this.dataType;
        lengthBytes.copy(result, 1, 0);
        this.buffer = this.buffer.slice(1 + lengthBytes.length, result.length);
        this.position = length;
        return result;
      }
      writeSequence(data) {
        this.writeBytes(data.toBuffer());
      }
      writeTagged(tagId, data) {
        if (tagId > 15)
          throw new Error("Invalid DER tag.");
        this.writeByte(160 | tagId);
        const lengthBytes = _DerWriter.getLength(data.position);
        this.writeBytes(lengthBytes);
        this.writeBytes(data.buffer.slice(0, data.position));
      }
      writeNull() {
        this.writeByte(
          5
          /* DerType.Null */
        );
        this.writeByte(0);
      }
      writeInteger(value) {
        this.writeByte(
          2
          /* DerType.Integer */
        );
        const integerBytes = value.toBytes();
        const lengthBytes = _DerWriter.getLength(integerBytes.length);
        this.writeBytes(lengthBytes);
        this.writeBytes(integerBytes);
      }
      writeOctetString(data) {
        this.writeByte(
          4
          /* DerType.OctetString */
        );
        const lengthBytes = _DerWriter.getLength(data.length);
        this.writeBytes(lengthBytes);
        this.writeBytes(data);
      }
      writeBitString(data) {
        this.writeByte(
          3
          /* DerType.BitString */
        );
        const lengthBytes = _DerWriter.getLength(1 + data.length);
        this.writeBytes(lengthBytes);
        this.writeByte(0);
        this.writeBytes(data);
      }
      writeObjectIdentifier(oid) {
        if (!oid)
          throw new TypeError("OID value is null or empty.");
        const values = oid.split(".").map(Number);
        if (values.length < 2 || values[0] > 3 || values[1] >= 40) {
          throw new Error(`Invalid OID: ${oid}`);
        }
        this.writeByte(
          6
          /* DerType.ObjectIdentifier */
        );
        let length = values.length - 1;
        for (let i = 2; i < values.length; i++) {
          let value = values[i];
          while (value > 128) {
            length++;
            value /= 128;
          }
        }
        const lengthBytes = _DerWriter.getLength(length);
        this.writeBytes(lengthBytes);
        this.writeByte(values[0] * 40 + values[1]);
        for (let i = 2; i < values.length; i++) {
          let value = values[i];
          if (value >= 128) {
            const bytes = [];
            bytes.push(value & 127);
            while (value >= 128) {
              value /= 128;
              bytes.push(128 | value & 127);
            }
            while (bytes.length > 0) {
              this.writeByte(bytes.pop());
            }
          } else {
            this.writeByte(value);
          }
        }
      }
      static getLength(length) {
        if (length > 127) {
          let size = 1;
          for (let val = length >> 8; val !== 0; val >>= 8) {
            size++;
          }
          const lengthBytes = _DerWriter.lengthBuffer.slice(0, size + 1);
          lengthBytes[0] = size | 128;
          for (let i = (size - 1) * 8, j = 1; i >= 0; i -= 8, j++) {
            lengthBytes[j] = length >> i;
          }
          return lengthBytes;
        } else {
          const lengthBytes = _DerWriter.lengthBuffer.slice(0, 1);
          lengthBytes[0] = length;
          return lengthBytes;
        }
      }
      writeByte(value) {
        this.ensureCapacity(this.position + 1);
        this.buffer[this.position++] = value;
      }
      writeBytes(value) {
        this.ensureCapacity(this.position + value.length);
        value.copy(this.buffer, this.position);
        this.position += value.length;
      }
      ensureCapacity(capacity) {
        if (this.buffer.length < capacity) {
          let newLength = Math.max(512, this.buffer.length * 2);
          while (newLength < capacity)
            newLength *= 2;
          const newBuffer = buffer_1.Buffer.alloc(newLength);
          this.buffer.copy(newBuffer, 0, 0, this.position);
          this.buffer = newBuffer;
        }
      }
    };
    exports2.DerWriter = DerWriter;
    DerWriter.lengthBuffer = buffer_1.Buffer.alloc(10);
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/node/keyFormatters.js
var require_keyFormatters = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/node/keyFormatters.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Sec1KeyFormatter = exports2.Pkcs1KeyFormatter = exports2.parsePem = exports2.formatPem = void 0;
    var bigInt_1 = require_bigInt();
    var derData_1 = require_derData();
    var ecdsaCurves_1 = require_ecdsaCurves();
    function formatPem(keyBytes, name) {
      const key = `-----BEGIN ${name}-----
` + keyBytes.toString("base64").match(/.{1,64}/g).join("\n") + `
-----END ${name}-----
`;
      return key;
    }
    exports2.formatPem = formatPem;
    function parsePem(key) {
      const keyBase64 = key.replace(/-+[^-\n]+KEY-+/g, "").replace(/\s/g, "");
      const keyBytes = Buffer.from(keyBase64, "base64");
      return keyBytes;
    }
    exports2.parsePem = parsePem;
    var Pkcs1KeyFormatter = class {
      static formatRsaPublic(rsa) {
        const writer = new derData_1.DerWriter(Buffer.alloc(1024));
        writer.writeInteger(rsa.modulus);
        writer.writeInteger(rsa.exponent);
        return writer.toBuffer();
      }
      static formatRsaPrivate(rsa) {
        if (!(rsa.d && rsa.p && rsa.q && rsa.dp && rsa.dq && rsa.qi)) {
          throw new Error("Missing private key parameters.");
        }
        const writer = new derData_1.DerWriter(Buffer.alloc(2048));
        writer.writeInteger(bigInt_1.BigInt.fromInt32(0));
        writer.writeInteger(rsa.modulus);
        writer.writeInteger(rsa.exponent);
        writer.writeInteger(rsa.d);
        writer.writeInteger(rsa.p);
        writer.writeInteger(rsa.q);
        writer.writeInteger(rsa.dp);
        writer.writeInteger(rsa.dq);
        writer.writeInteger(rsa.qi);
        return writer.toBuffer();
      }
      static parseRsaPublic(keyBytes) {
        const reader = new derData_1.DerReader(keyBytes);
        const modulus = reader.readInteger();
        const exponent = reader.readInteger();
        return { modulus, exponent };
      }
      static parseRsaPrivate(keyBytes) {
        const reader = new derData_1.DerReader(keyBytes);
        const version = reader.readInteger();
        const modulus = reader.readInteger();
        const exponent = reader.readInteger();
        const d = reader.readInteger();
        const p = reader.readInteger();
        const q = reader.readInteger();
        const dp = reader.readInteger();
        const dq = reader.readInteger();
        const qi = reader.readInteger();
        return { modulus, exponent, d, p, q, dp, dq, qi };
      }
    };
    exports2.Pkcs1KeyFormatter = Pkcs1KeyFormatter;
    var Sec1KeyFormatter = class _Sec1KeyFormatter {
      static formatECPublic(ec) {
        const curve = ecdsaCurves_1.curves.find((c) => c.oid === ec.curve.oid);
        const keySizeInBytes = Math.ceil(curve.keySize / 8);
        const writer = new derData_1.DerWriter(Buffer.alloc(512));
        const oidsWriter = new derData_1.DerWriter(Buffer.alloc(100));
        oidsWriter.writeObjectIdentifier(_Sec1KeyFormatter.ecPublicKeyOid);
        oidsWriter.writeObjectIdentifier(ec.curve.oid);
        writer.writeSequence(oidsWriter);
        const x = ec.x.toBytes({ unsigned: true, length: keySizeInBytes });
        const y = ec.y.toBytes({ unsigned: true, length: keySizeInBytes });
        const publicKeyData = Buffer.alloc(1 + x.length + y.length);
        publicKeyData[0] = 4;
        x.copy(publicKeyData, 1);
        y.copy(publicKeyData, 1 + x.length);
        writer.writeBitString(publicKeyData);
        return writer.toBuffer();
      }
      static formatECPrivate(ec) {
        const curve = ecdsaCurves_1.curves.find((c) => c.oid === ec.curve.oid);
        const keySizeInBytes = Math.ceil(curve.keySize / 8);
        const writer = new derData_1.DerWriter(Buffer.alloc(512));
        writer.writeInteger(bigInt_1.BigInt.fromInt32(1));
        writer.writeOctetString(ec.d.toBytes({ unsigned: true, length: keySizeInBytes }));
        const curveWriter = new derData_1.DerWriter(Buffer.alloc(100));
        curveWriter.writeObjectIdentifier(ec.curve.oid);
        writer.writeTagged(0, curveWriter);
        const x = ec.x.toBytes({ unsigned: true, length: keySizeInBytes });
        const y = ec.y.toBytes({ unsigned: true, length: keySizeInBytes });
        const publicKeyData = Buffer.alloc(1 + x.length + y.length);
        publicKeyData[0] = 4;
        x.copy(publicKeyData, 1);
        y.copy(publicKeyData, 1 + x.length);
        const keyWriter = new derData_1.DerWriter(Buffer.alloc(512));
        keyWriter.writeBitString(publicKeyData);
        writer.writeTagged(1, keyWriter);
        return writer.toBuffer();
      }
      static parseECPublic(keyBytes) {
        var _a2;
        const reader = new derData_1.DerReader(keyBytes);
        const oidsReader = reader.readSequence();
        const keyTypeOid = oidsReader.readObjectIdentifier();
        if (keyTypeOid !== _Sec1KeyFormatter.ecPublicKeyOid) {
          throw new Error(`Unexpected key type OID: ${keyTypeOid}`);
        }
        const curveOid = oidsReader.readObjectIdentifier();
        const curveName = (_a2 = ecdsaCurves_1.curves.find((c) => c.oid === curveOid)) === null || _a2 === void 0 ? void 0 : _a2.name;
        const xy = reader.readBitString();
        if (xy.length % 2 !== 1) {
          throw new Error(`Unexpected key data length: ${xy.length}`);
        }
        const x = bigInt_1.BigInt.fromBytes(xy.slice(1, 1 + (xy.length - 1) / 2), { unsigned: true });
        const y = bigInt_1.BigInt.fromBytes(xy.slice(1 + (xy.length - 1) / 2), { unsigned: true });
        const ec = {
          curve: { name: curveName, oid: curveOid },
          x,
          y
        };
        return ec;
      }
      static parseECPrivate(keyBytes) {
        var _a2;
        const reader = new derData_1.DerReader(keyBytes);
        const version = reader.readInteger().toInt32();
        if (version !== 1) {
          throw new Error(`Unsupported SEC1 format version: ${version}`);
        }
        const d = bigInt_1.BigInt.fromBytes(reader.readOctetString(), { unsigned: true });
        const curveReader = reader.tryReadTagged(0);
        if (!curveReader) {
          throw new Error("SEC1 curve info not found.");
        }
        const curveOid = curveReader.readObjectIdentifier();
        const curveName = (_a2 = ecdsaCurves_1.curves.find((c) => c.oid === curveOid)) === null || _a2 === void 0 ? void 0 : _a2.name;
        const publicKeyReader = reader.tryReadTagged(1);
        if (!publicKeyReader) {
          throw new Error("SEC1 public key data not found.");
        }
        const xy = publicKeyReader.readBitString();
        if (xy.length % 2 !== 1) {
          throw new Error(`Unexpected key data length: ${xy.length}`);
        }
        const x = bigInt_1.BigInt.fromBytes(xy.slice(1, 1 + (xy.length - 1) / 2), { unsigned: true });
        const y = bigInt_1.BigInt.fromBytes(xy.slice(1 + (xy.length - 1) / 2), { unsigned: true });
        const ec = {
          curve: { name: curveName, oid: curveOid },
          x,
          y,
          d
        };
        return ec;
      }
    };
    exports2.Sec1KeyFormatter = Sec1KeyFormatter;
    Sec1KeyFormatter.ecPublicKeyOid = "1.2.840.10045.2.1";
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/node/nodeRsa.js
var require_nodeRsa = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/node/nodeRsa.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NodeRsa = void 0;
    var crypto2 = require("crypto");
    var buffer_1 = require("buffer");
    var publicKeyAlgorithm_1 = require_publicKeyAlgorithm();
    var sshData_1 = require_sshData();
    var nodeHmac_1 = require_nodeHmac();
    var keyFormatters_1 = require_keyFormatters();
    var nodeVersionParts = process.versions.node.split(".").map((v) => parseInt(v, 10));
    var nodeGenerateKeyPairSupport = nodeVersionParts[0] > 10 || nodeVersionParts[0] === 10 && nodeVersionParts[1] >= 12;
    var nodeKeyObjectSupport = nodeVersionParts[0] > 11 || nodeVersionParts[0] === 11 && nodeVersionParts[1] >= 6;
    var NodeRsaKeyPair = class _NodeRsaKeyPair {
      /* @internal */
      constructor() {
        this.comment = null;
      }
      get hasPublicKey() {
        return !!this.publicKey;
      }
      get hasPrivateKey() {
        return !!this.privateKey;
      }
      get keyAlgorithmName() {
        return NodeRsa.keyAlgorithmName;
      }
      generate(keySizeInBits) {
        keySizeInBits = keySizeInBits !== null && keySizeInBits !== void 0 ? keySizeInBits : _NodeRsaKeyPair.defaultKeySize;
        if (nodeGenerateKeyPairSupport && nodeKeyObjectSupport) {
          return this.generateNodeKeyPairObjects(keySizeInBits);
        } else if (nodeGenerateKeyPairSupport) {
          return this.generateNodeKeyPairBuffers(keySizeInBits);
        } else {
          return this.generateExternalKeyPair(keySizeInBits);
        }
      }
      async generateNodeKeyPairObjects(keySizeInBits) {
        [this.publicKey, this.privateKey] = await new Promise((resolve8, reject) => {
          const keyGenParams = {
            modulusLength: keySizeInBits
          };
          try {
            crypto2.generateKeyPair("rsa", keyGenParams, (err, publicKey, privateKey) => {
              if (err) {
                reject(err);
              } else {
                resolve8([publicKey, privateKey]);
              }
            });
          } catch (err) {
            reject(err);
          }
        });
      }
      async generateNodeKeyPairBuffers(keySizeInBits) {
        [this.publicKey, this.privateKey] = await new Promise((resolve8, reject) => {
          const keyGenParams = {
            modulusLength: keySizeInBits,
            publicKeyEncoding: { type: "pkcs1", format: "pem" },
            privateKeyEncoding: {
              type: "pkcs1",
              format: "pem",
              cipher: void 0,
              passphrase: void 0
            }
          };
          try {
            crypto2.generateKeyPair("rsa", keyGenParams, (err, publicKey, privateKey) => {
              if (err) {
                reject(err);
              } else {
                resolve8([publicKey, privateKey]);
              }
            });
          } catch (err) {
            reject(err);
          }
        });
      }
      async generateExternalKeyPair(keySizeInBits) {
        const externRsa = await Promise.resolve().then(() => require("node-rsa"));
        const keyPair = new externRsa({ b: keySizeInBits });
        this.publicKey = keyPair.exportKey("pkcs1-public-pem");
        this.privateKey = keyPair.exportKey("pkcs1-private-pem");
        if (!this.publicKey.endsWith("\n"))
          this.publicKey += "\n";
        if (!this.privateKey.endsWith("\n"))
          this.privateKey += "\n";
      }
      async setPublicKeyBytes(keyBytes) {
        if (!keyBytes) {
          throw new TypeError("Buffer is required.");
        }
        const reader = new sshData_1.SshDataReader(keyBytes);
        const algorithmName = reader.readString("ascii");
        if (algorithmName !== this.keyAlgorithmName && algorithmName !== NodeRsa.rsaWithSha256 && algorithmName !== NodeRsa.rsaWithSha512) {
          throw new Error(`Invalid RSA key algorithm: ${algorithmName}`);
        }
        const exponent = reader.readBigInt();
        const modulus = reader.readBigInt();
        keyBytes = keyFormatters_1.Pkcs1KeyFormatter.formatRsaPublic({ modulus, exponent });
        if (nodeKeyObjectSupport) {
          this.publicKey = crypto2.createPublicKey({
            key: keyBytes,
            type: "pkcs1",
            format: "der"
          });
        } else {
          this.publicKey = (0, keyFormatters_1.formatPem)(keyBytes, "RSA PUBLIC KEY");
        }
      }
      async getPublicKeyBytes(algorithmName) {
        if (!this.publicKey) {
          return null;
        }
        if (!algorithmName) {
          algorithmName = this.keyAlgorithmName;
        }
        let keyBytes;
        if (typeof this.publicKey === "string") {
          keyBytes = (0, keyFormatters_1.parsePem)(this.publicKey);
        } else {
          keyBytes = this.publicKey.export({
            type: "pkcs1",
            format: "der"
          });
        }
        const parameters = keyFormatters_1.Pkcs1KeyFormatter.parseRsaPublic(keyBytes);
        const keyBuffer = buffer_1.Buffer.alloc(512);
        const keyWriter = new sshData_1.SshDataWriter(keyBuffer);
        keyWriter.writeString(algorithmName, "ascii");
        keyWriter.writeBigInt(parameters.exponent);
        keyWriter.writeBigInt(parameters.modulus);
        keyBytes = keyWriter.toBuffer();
        return keyBytes;
      }
      async importParameters(parameters) {
        if (nodeKeyObjectSupport) {
          this.publicKey = crypto2.createPublicKey({
            key: keyFormatters_1.Pkcs1KeyFormatter.formatRsaPublic(parameters),
            format: "der",
            type: "pkcs1"
          });
          if (parameters.d) {
            this.privateKey = crypto2.createPrivateKey({
              key: keyFormatters_1.Pkcs1KeyFormatter.formatRsaPrivate(parameters),
              format: "der",
              type: "pkcs1"
            });
          } else {
            this.privateKey = void 0;
          }
        } else {
          const publicKeyBytes = keyFormatters_1.Pkcs1KeyFormatter.formatRsaPublic(parameters);
          this.publicKey = (0, keyFormatters_1.formatPem)(publicKeyBytes, "RSA PUBLIC KEY");
          if (parameters.d) {
            const privateKeyBytes = keyFormatters_1.Pkcs1KeyFormatter.formatRsaPrivate(parameters);
            this.privateKey = (0, keyFormatters_1.formatPem)(privateKeyBytes, "RSA PRIVATE KEY");
          }
        }
      }
      async exportParameters() {
        var _a2, _b;
        if (!this.publicKey)
          throw new Error("Public key not set.");
        let keyBytes;
        if (nodeKeyObjectSupport) {
          keyBytes = ((_a2 = this.privateKey) !== null && _a2 !== void 0 ? _a2 : this.publicKey).export({
            format: "der",
            type: "pkcs1"
          });
        } else {
          keyBytes = (0, keyFormatters_1.parsePem)((_b = this.privateKey) !== null && _b !== void 0 ? _b : this.publicKey);
        }
        return this.privateKey ? keyFormatters_1.Pkcs1KeyFormatter.parseRsaPrivate(keyBytes) : keyFormatters_1.Pkcs1KeyFormatter.parseRsaPublic(keyBytes);
      }
      dispose() {
        this.publicKey = void 0;
        this.privateKey = void 0;
      }
    };
    NodeRsaKeyPair.defaultKeySize = 2048;
    var NodeRsa = class _NodeRsa extends publicKeyAlgorithm_1.PublicKeyAlgorithm {
      constructor(name, hashAlgorithmName) {
        super(name, _NodeRsa.keyAlgorithmName, hashAlgorithmName);
      }
      createKeyPair() {
        return new NodeRsaKeyPair();
      }
      async generateKeyPair(keySizeInBits) {
        const rsaKey = new NodeRsaKeyPair();
        await rsaKey.generate(keySizeInBits);
        return rsaKey;
      }
      createSigner(keyPair) {
        if (!(keyPair instanceof NodeRsaKeyPair)) {
          throw new TypeError("RSA key pair object expected.");
        }
        return new NodeRsaSignerVerifier(keyPair, _NodeRsa.convertHashAlgorithmName(this.hashAlgorithmName), nodeHmac_1.NodeHmac.getHashDigestLength(this.hashAlgorithmName));
      }
      createVerifier(keyPair) {
        if (!(keyPair instanceof NodeRsaKeyPair)) {
          throw new TypeError("RSA key pair object expected.");
        }
        return new NodeRsaSignerVerifier(keyPair, _NodeRsa.convertHashAlgorithmName(this.hashAlgorithmName), nodeHmac_1.NodeHmac.getHashDigestLength(this.hashAlgorithmName));
      }
      static convertHashAlgorithmName(hashAlgorithmName) {
        return hashAlgorithmName.replace("SHA2-", "SHA");
      }
    };
    exports2.NodeRsa = NodeRsa;
    NodeRsa.keyAlgorithmName = "ssh-rsa";
    NodeRsa.rsaWithSha256 = "rsa-sha2-256";
    NodeRsa.rsaWithSha512 = "rsa-sha2-512";
    NodeRsa.KeyPair = NodeRsaKeyPair;
    var NodeRsaSignerVerifier = class {
      constructor(keyPair, hashAlgorithmName, digestLength) {
        this.keyPair = keyPair;
        this.hashAlgorithmName = hashAlgorithmName;
        this.digestLength = digestLength;
      }
      async sign(data) {
        if (!this.keyPair.privateKey) {
          throw new Error("Private key not set.");
        }
        const signer = crypto2.createSign(this.hashAlgorithmName);
        signer.update(data);
        const signature = signer.sign(this.keyPair.privateKey);
        return signature;
      }
      async verify(data, signature) {
        if (!this.keyPair.publicKey) {
          throw new Error("Public key not set.");
        }
        const verifier = crypto2.createVerify(this.hashAlgorithmName);
        verifier.update(data);
        const result = verifier.verify(this.keyPair.publicKey, signature);
        return result;
      }
      dispose() {
      }
    };
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/node/nodeECDsa.js
var require_nodeECDsa = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/node/nodeECDsa.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NodeECDsa = void 0;
    var crypto2 = require("crypto");
    var buffer_1 = require("buffer");
    var publicKeyAlgorithm_1 = require_publicKeyAlgorithm();
    var ecdsaCurves_1 = require_ecdsaCurves();
    var bigInt_1 = require_bigInt();
    var derData_1 = require_derData();
    var sshData_1 = require_sshData();
    var keyFormatters_1 = require_keyFormatters();
    var nodeVersionParts = process.versions.node.split(".").map((v) => parseInt(v, 10));
    var nodeGenerateKeyPairSupport = nodeVersionParts[0] > 10 || nodeVersionParts[0] === 10 && nodeVersionParts[1] >= 12;
    var nodeKeyObjectSupport = nodeVersionParts[0] > 11 || nodeVersionParts[0] === 11 && nodeVersionParts[1] >= 6;
    var NodeECDsaKeyPair = class {
      /**
       * Constructs a new ECDSA key pair object.
       *
       * @param algorithmName Key pair algorithm name. If unspecified, the key pair object must be
       * initialized before use via `importParameters()`.
       */
      constructor(algorithmName) {
        this.comment = null;
        if (algorithmName) {
          this.algorithmName = algorithmName;
        }
      }
      get hasPublicKey() {
        return !!this.publicKey;
      }
      get hasPrivateKey() {
        return !!this.privateKey;
      }
      get keyAlgorithmName() {
        return this.algorithmName;
      }
      get algorithmName() {
        return this.algorithm;
      }
      set algorithmName(value) {
        const curveName = value.split("-")[2];
        this.curve = ecdsaCurves_1.curves.find((c) => c.name === curveName);
        if (!this.curve) {
          throw new Error("Invalid or unsupported ECDSA algorithm: " + value);
        }
        this.algorithm = value;
      }
      generate() {
        if (nodeGenerateKeyPairSupport && nodeKeyObjectSupport) {
          return this.generateNodeKeyPairObjects();
        } else if (nodeGenerateKeyPairSupport) {
          return this.generateNodeKeyPairBuffers();
        } else {
          return this.generateExternalKeyPair();
        }
      }
      async generateNodeKeyPairObjects() {
        [this.publicKey, this.privateKey] = await new Promise((resolve8, reject) => {
          const keyGenParams = {
            namedCurve: this.curve.shortName
          };
          try {
            crypto2.generateKeyPair("ec", keyGenParams, (err, publicKey, privateKey) => {
              if (err) {
                reject(err);
              } else {
                resolve8([publicKey, privateKey]);
              }
            });
          } catch (err) {
            reject(err);
          }
        });
      }
      async generateNodeKeyPairBuffers() {
        [this.publicKey, this.privateKey] = await new Promise((resolve8, reject) => {
          const keyGenParams = {
            namedCurve: this.curve.shortName,
            publicKeyEncoding: { type: "spki", format: "pem" },
            privateKeyEncoding: {
              type: "sec1",
              format: "pem",
              cipher: void 0,
              passphrase: void 0
            }
          };
          try {
            crypto2.generateKeyPair("ec", keyGenParams, (err, publicKey, privateKey) => {
              if (err) {
                reject(err);
              } else {
                resolve8([publicKey, privateKey]);
              }
            });
          } catch (err) {
            reject(err);
          }
        });
      }
      async generateExternalKeyPair() {
        throw new Error("This version of node does not support generating key pairs. Use node >= 10.12.");
      }
      async setPublicKeyBytes(keyBytes, algorithmName) {
        if (!keyBytes) {
          throw new TypeError("Buffer is required.");
        }
        const reader = new sshData_1.SshDataReader(keyBytes);
        const readAlgorithmName = reader.readString("ascii");
        this.algorithmName = algorithmName || readAlgorithmName;
        const curveName = reader.readString("ascii");
        this.algorithmName = `ecdsa-sha2-${curveName}`;
        const xy = reader.readBinary();
        const x = bigInt_1.BigInt.fromBytes(xy.slice(1, 1 + (xy.length - 1) / 2), { unsigned: true });
        const y = bigInt_1.BigInt.fromBytes(xy.slice(1 + (xy.length - 1) / 2), { unsigned: true });
        const derKeyBytes = keyFormatters_1.Sec1KeyFormatter.formatECPublic({
          curve: { name: this.curve.name, oid: this.curve.oid },
          x,
          y
        });
        if (nodeKeyObjectSupport) {
          this.publicKey = crypto2.createPublicKey({
            key: derKeyBytes,
            type: "spki",
            format: "der"
          });
        } else {
          this.publicKey = (0, keyFormatters_1.formatPem)(derKeyBytes, "PUBLIC KEY");
        }
      }
      async getPublicKeyBytes(algorithmName) {
        if (!this.publicKey) {
          return null;
        }
        let derKeyBytes;
        if (typeof this.publicKey === "string") {
          derKeyBytes = (0, keyFormatters_1.parsePem)(this.publicKey);
        } else {
          derKeyBytes = this.publicKey.export({
            type: "spki",
            format: "der"
          });
        }
        const ec = keyFormatters_1.Sec1KeyFormatter.parseECPublic(derKeyBytes);
        algorithmName = algorithmName || this.algorithmName || this.keyAlgorithmName;
        const keyWriter = new sshData_1.SshDataWriter(buffer_1.Buffer.alloc(512));
        keyWriter.writeString(algorithmName, "ascii");
        keyWriter.writeString(this.curve.name, "ascii");
        const keySizeInBytes = Math.ceil(this.curve.keySize / 8);
        const xBytes = ec.x.toBytes({ unsigned: true, length: keySizeInBytes });
        const yBytes = ec.y.toBytes({ unsigned: true, length: keySizeInBytes });
        keyWriter.writeUInt32(1 + xBytes.length + yBytes.length);
        keyWriter.writeByte(4);
        keyWriter.write(xBytes);
        keyWriter.write(yBytes);
        const keyBytes = keyWriter.toBuffer();
        return keyBytes;
      }
      async importParameters(parameters) {
        if (!parameters.curve)
          throw new TypeError("A curve is required.");
        let curve;
        if (parameters.curve.oid) {
          curve = ecdsaCurves_1.curves.find((c) => c.oid === parameters.curve.oid);
          if (!curve) {
            throw new Error(`Unsupported curve OID: ${parameters.curve.oid}`);
          }
        } else if (parameters.curve.name) {
          curve = ecdsaCurves_1.curves.find((c) => c.name === parameters.curve.name);
          if (!curve) {
            throw new Error(`Unsupported curve: ${parameters.curve.name}`);
          }
        } else {
          throw new TypeError("A curve OID or name is required.");
        }
        this.algorithmName = "ecdsa-sha2-" + curve.name;
        const publicKeyBytes = keyFormatters_1.Sec1KeyFormatter.formatECPublic(parameters);
        if (nodeKeyObjectSupport) {
          this.publicKey = crypto2.createPublicKey({
            key: publicKeyBytes,
            type: "spki",
            format: "der"
          });
        } else {
          this.publicKey = (0, keyFormatters_1.formatPem)(publicKeyBytes, "EC PUBLIC KEY");
        }
        if (parameters.d) {
          const privateKeyBytes = keyFormatters_1.Sec1KeyFormatter.formatECPrivate(parameters);
          if (nodeKeyObjectSupport) {
            this.privateKey = crypto2.createPrivateKey({
              key: privateKeyBytes,
              type: "sec1",
              format: "der"
            });
          } else {
            this.privateKey = (0, keyFormatters_1.formatPem)(privateKeyBytes, "EC PRIVATE KEY");
          }
        } else {
          this.privateKey = void 0;
        }
      }
      async exportParameters() {
        var _a2, _b;
        if (!this.publicKey) {
          throw new Error("Key is not present.");
        }
        let derKeyBytes;
        if (typeof this.publicKey === "string") {
          derKeyBytes = (0, keyFormatters_1.parsePem)((_a2 = this.privateKey) !== null && _a2 !== void 0 ? _a2 : this.publicKey);
        } else {
          derKeyBytes = ((_b = this.privateKey) !== null && _b !== void 0 ? _b : this.publicKey).export({
            type: this.privateKey ? "sec1" : "spki",
            format: "der"
          });
        }
        return this.privateKey ? keyFormatters_1.Sec1KeyFormatter.parseECPrivate(derKeyBytes) : keyFormatters_1.Sec1KeyFormatter.parseECPublic(derKeyBytes);
      }
      dispose() {
      }
    };
    var NodeECDsa = class _NodeECDsa extends publicKeyAlgorithm_1.PublicKeyAlgorithm {
      constructor(name, hashAlgorithmName) {
        super(
          name,
          name,
          // The key algorithm name is the same (unlike RSA).
          hashAlgorithmName
        );
      }
      createKeyPair() {
        return new NodeECDsaKeyPair(this.name);
      }
      async generateKeyPair() {
        const ecdsaKey = new NodeECDsaKeyPair(this.name);
        await ecdsaKey.generate();
        return ecdsaKey;
      }
      createSigner(keyPair) {
        if (!(keyPair instanceof NodeECDsaKeyPair)) {
          throw new TypeError("ECDSA key pair object expected.");
        }
        return new NodeECDsaSignerVerifier(keyPair, _NodeECDsa.convertHashAlgorithmName(this.hashAlgorithmName));
      }
      createVerifier(keyPair) {
        if (!(keyPair instanceof NodeECDsaKeyPair)) {
          throw new TypeError("ECDSA key pair object expected.");
        }
        return new NodeECDsaSignerVerifier(keyPair, _NodeECDsa.convertHashAlgorithmName(this.hashAlgorithmName));
      }
      static convertHashAlgorithmName(hashAlgorithmName) {
        return hashAlgorithmName.replace("SHA2-", "SHA");
      }
      /* @internal */
      static getSignatureLength(keySizeInBits) {
        const keySizeInBytes = Math.ceil(keySizeInBits / 8);
        return (4 + 1 + keySizeInBytes) * 2;
      }
    };
    exports2.NodeECDsa = NodeECDsa;
    NodeECDsa.ecdsaSha2Nistp256 = "ecdsa-sha2-nistp256";
    NodeECDsa.ecdsaSha2Nistp384 = "ecdsa-sha2-nistp384";
    NodeECDsa.ecdsaSha2Nistp521 = "ecdsa-sha2-nistp521";
    NodeECDsa.curves = ecdsaCurves_1.curves;
    NodeECDsa.KeyPair = NodeECDsaKeyPair;
    var NodeECDsaSignerVerifier = class {
      constructor(keyPair, hashAlgorithmName) {
        this.keyPair = keyPair;
        this.hashAlgorithmName = hashAlgorithmName;
      }
      get digestLength() {
        const curve = this.keyPair.curve;
        if (!curve) {
          return 0;
        } else {
          return NodeECDsa.getSignatureLength(curve.keySize);
        }
      }
      async sign(data) {
        if (!this.keyPair.privateKey) {
          throw new Error("Private key not set.");
        }
        const signer = crypto2.createSign(this.hashAlgorithmName);
        signer.update(data);
        let signature = signer.sign(this.keyPair.privateKey);
        const signatureReader = new derData_1.DerReader(signature);
        const x = signatureReader.readInteger();
        const y = signatureReader.readInteger();
        const keySizeInBytes = Math.ceil(this.keyPair.curve.keySize / 8);
        const signatureWriter = new sshData_1.SshDataWriter(buffer_1.Buffer.alloc(this.digestLength));
        signatureWriter.writeBinary(x.toBytes({ unsigned: true, length: keySizeInBytes + 1 }));
        signatureWriter.writeBinary(y.toBytes({ unsigned: true, length: keySizeInBytes + 1 }));
        signature = signatureWriter.toBuffer();
        return signature;
      }
      async verify(data, signature) {
        if (!this.keyPair.publicKey) {
          throw new Error("Public key not set.");
        }
        const signatureReader = new sshData_1.SshDataReader(signature);
        const x = signatureReader.readBigInt();
        const y = signatureReader.readBigInt();
        const signatureWriter = new derData_1.DerWriter(buffer_1.Buffer.alloc(signature.length));
        signatureWriter.writeInteger(x);
        signatureWriter.writeInteger(y);
        signature = signatureWriter.toBuffer();
        const verifier = crypto2.createVerify(this.hashAlgorithmName);
        verifier.update(data);
        const result = verifier.verify(this.keyPair.publicKey, signature);
        return result;
      }
      dispose() {
      }
    };
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/node/nodeEncryption.js
var require_nodeEncryption = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/node/nodeEncryption.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NodeEncryption = void 0;
    var crypto2 = require("crypto");
    var buffer_1 = require("buffer");
    var encryptionAlgorithm_1 = require_encryptionAlgorithm();
    var NodeEncryption = class _NodeEncryption extends encryptionAlgorithm_1.EncryptionAlgorithm {
      constructor(name, algorithmName, cipherMode, keySizeInBits) {
        super(name);
        this.algorithmName = algorithmName;
        this.cipherMode = cipherMode;
        this.keySizeInBits = keySizeInBits;
        if (algorithmName !== "AES") {
          throw new Error(`Unsupported encryption algorithm: ${algorithmName}`);
        }
        this.blockSizeInBits = _NodeEncryption.getBlockSize(algorithmName);
      }
      get keyLength() {
        return this.keySizeInBits / 8;
      }
      get blockLength() {
        return this.blockSizeInBits / 8;
      }
      async createCipher(isEncryption, key, iv) {
        let cipher;
        if (this.cipherMode === "CTR" || this.cipherMode === "CBC") {
          cipher = new NodeAesCipher(isEncryption, this.keySizeInBits, this.blockSizeInBits, key, iv, this.cipherMode);
        } else if (this.cipherMode === "GCM") {
          cipher = new NodeAesGcmCipher(isEncryption, this.keySizeInBits, this.blockSizeInBits, key, iv);
        } else {
          throw new Error(`Unsupported cipher mode: ${this.cipherMode}`);
        }
        return cipher;
      }
      static getBlockSize(algorithmName) {
        if (algorithmName === "AES") {
          return 128;
        } else {
          throw new Error(`Unsupported encryption algorithm: ${algorithmName}`);
        }
      }
    };
    exports2.NodeEncryption = NodeEncryption;
    var NodeAesCipher = class {
      constructor(isEncryption, keySizeInBits, blockSizeInBits, key, iv, cipherMode) {
        this.isEncryption = isEncryption;
        this.keySizeInBits = keySizeInBits;
        this.blockSizeInBits = blockSizeInBits;
        const nodeAlgorithm = `AES-${this.keySizeInBits}-${cipherMode}`;
        this.cipher = this.isEncryption ? crypto2.createCipheriv(nodeAlgorithm, key, iv) : crypto2.createDecipheriv(nodeAlgorithm, key, iv);
        this.cipher.setAutoPadding(false);
      }
      get blockLength() {
        return this.blockSizeInBits / 8;
      }
      transform(data) {
        const result = this.cipher.update(data);
        if (result.length !== data.length) {
          const message = `Result from encrypt/decrypt has invalid length ${result.length}, expected ${data.length}.`;
          throw new Error(message);
        }
        return Promise.resolve(result);
      }
      dispose() {
      }
    };
    var NodeAesGcmCipher = class {
      constructor(isEncryption, keySizeInBits, blockSizeInBits, key, iv) {
        this.isEncryption = isEncryption;
        this.keySizeInBits = keySizeInBits;
        this.blockSizeInBits = blockSizeInBits;
        this.tag = null;
        this.algorithmName = `aes-${this.keySizeInBits}-gcm`;
        this.key = buffer_1.Buffer.alloc(key.length);
        key.copy(this.key);
        this.nonce = buffer_1.Buffer.alloc(12);
        iv.copy(this.nonce, 0, 0, 12);
        this.associatedData = buffer_1.Buffer.alloc(4);
      }
      get blockLength() {
        return this.blockSizeInBits / 8;
      }
      get digestLength() {
        return 16;
      }
      get authenticatedEncryption() {
        return true;
      }
      transform(data) {
        if (data.length % this.blockLength !== 0) {
          const message = `Encrypt/decrypt input has invalid length ${data.length}, not a multiple of block size ${this.blockLength}.`;
          throw new Error(message);
        }
        const cipher = this.isEncryption ? crypto2.createCipheriv(this.algorithmName, this.key, this.nonce) : crypto2.createDecipheriv(this.algorithmName, this.key, this.nonce);
        const packetLength = data.length;
        this.associatedData[0] = packetLength >>> 24;
        this.associatedData[1] = packetLength >>> 16;
        this.associatedData[2] = packetLength >>> 8;
        this.associatedData[3] = packetLength;
        cipher.setAAD(this.associatedData);
        if (!this.isEncryption) {
          if (!this.tag) {
            throw new Error("AES-GCM tag was not set before decrypting.");
          }
          cipher.setAuthTag(this.tag);
        }
        const result = cipher.update(data);
        if (result.length !== data.length) {
          const message = `Result from encrypt/decrypt has invalid length ${result.length}, expected ${data.length}.`;
          throw new Error(message);
        }
        cipher.final();
        if (this.isEncryption) {
          this.tag = cipher.getAuthTag();
        } else {
          this.tag = null;
        }
        let k = 12;
        while (--k >= 4) {
          this.nonce[k]++;
          if (this.nonce[k] !== 0) {
            break;
          }
        }
        return Promise.resolve(result);
      }
      async sign(data) {
        if (!this.tag) {
          throw new Error("AES-GCM tag was not obtained by encrypting.");
        }
        return this.tag;
      }
      async verify(data, signature) {
        if (signature.length !== this.digestLength) {
          throw new Error("Incorrect AES-GCM tag length.");
        }
        this.tag = signature;
        return true;
      }
      dispose() {
      }
    };
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/node/nodeRandom.js
var require_nodeRandom = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/node/nodeRandom.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NodeRandom = void 0;
    var crypto2 = require("crypto");
    var NodeRandom = class {
      getBytes(buffer) {
        const randomBytes = crypto2.randomBytes(buffer.length);
        randomBytes.copy(buffer);
      }
    };
    exports2.NodeRandom = NodeRandom;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/sshAlgorithms.js
var require_sshAlgorithms = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/sshAlgorithms.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.algorithmNames = exports2.SshAlgorithms = exports2.Encryption = exports2.ECDsa = exports2.Rsa = exports2.HmacAlgorithm = exports2.EncryptionAlgorithm = exports2.PublicKeyAlgorithm = exports2.KeyExchangeAlgorithm = void 0;
    var keyExchangeAlgorithm_1 = require_keyExchangeAlgorithm();
    Object.defineProperty(exports2, "KeyExchangeAlgorithm", { enumerable: true, get: function() {
      return keyExchangeAlgorithm_1.KeyExchangeAlgorithm;
    } });
    var publicKeyAlgorithm_1 = require_publicKeyAlgorithm();
    Object.defineProperty(exports2, "PublicKeyAlgorithm", { enumerable: true, get: function() {
      return publicKeyAlgorithm_1.PublicKeyAlgorithm;
    } });
    var encryptionAlgorithm_1 = require_encryptionAlgorithm();
    Object.defineProperty(exports2, "EncryptionAlgorithm", { enumerable: true, get: function() {
      return encryptionAlgorithm_1.EncryptionAlgorithm;
    } });
    var hmacAlgorithm_1 = require_hmacAlgorithm();
    Object.defineProperty(exports2, "HmacAlgorithm", { enumerable: true, get: function() {
      return hmacAlgorithm_1.HmacAlgorithm;
    } });
    var useWebCrypto = typeof self === "object" && !!(typeof crypto === "object" && crypto.subtle);
    var webKeyExchange_1 = require_webKeyExchange();
    var webRsa_1 = require_webRsa();
    var webECDsa_1 = require_webECDsa();
    var webEncryption_1 = require_webEncryption();
    var webHmac_1 = require_webHmac();
    var webRandom_1 = require_webRandom();
    var DiffieHellman = useWebCrypto ? webKeyExchange_1.WebDiffieHellman : require_nodeKeyExchange().NodeDiffieHellman;
    var ECDiffieHellman = useWebCrypto ? webKeyExchange_1.WebECDiffieHellman : require_nodeKeyExchange().NodeECDiffieHellman;
    var Rsa = useWebCrypto ? webRsa_1.WebRsa : require_nodeRsa().NodeRsa;
    exports2.Rsa = Rsa;
    var ECDsa = useWebCrypto ? webECDsa_1.WebECDsa : require_nodeECDsa().NodeECDsa;
    exports2.ECDsa = ECDsa;
    var Encryption = useWebCrypto ? webEncryption_1.WebEncryption : require_nodeEncryption().NodeEncryption;
    exports2.Encryption = Encryption;
    var Hmac = useWebCrypto ? webHmac_1.WebHmac : require_nodeHmac().NodeHmac;
    var Random = useWebCrypto ? webRandom_1.WebRandom : require_nodeRandom().NodeRandom;
    var SshAlgorithms = class {
    };
    exports2.SshAlgorithms = SshAlgorithms;
    SshAlgorithms.keyExchange = {
      none: null,
      dhGroup14Sha256: new DiffieHellman("diffie-hellman-group14-sha256", 2048, "SHA2-256"),
      dhGroup16Sha512: new DiffieHellman("diffie-hellman-group16-sha512", 4096, "SHA2-512"),
      ecdhNistp256Sha256: new ECDiffieHellman("ecdh-sha2-nistp256", 256, "SHA2-256"),
      ecdhNistp384Sha384: new ECDiffieHellman("ecdh-sha2-nistp384", 384, "SHA2-384"),
      ecdhNistp521Sha512: new ECDiffieHellman("ecdh-sha2-nistp521", 521, "SHA2-512")
    };
    SshAlgorithms.publicKey = {
      none: null,
      rsaWithSha256: new Rsa("rsa-sha2-256", "SHA2-256"),
      rsaWithSha512: new Rsa("rsa-sha2-512", "SHA2-512"),
      ecdsaSha2Nistp256: new ECDsa("ecdsa-sha2-nistp256", "SHA2-256"),
      ecdsaSha2Nistp384: new ECDsa("ecdsa-sha2-nistp384", "SHA2-384"),
      ecdsaSha2Nistp521: new ECDsa("ecdsa-sha2-nistp521", "SHA2-512")
    };
    SshAlgorithms.encryption = {
      none: null,
      ////aes256Cbc: new Encryption('aes256-cbc', 'AES', 'CBC', 256) },
      aes256Ctr: new Encryption("aes256-ctr", "AES", "CTR", 256),
      aes256Gcm: new Encryption("aes256-gcm@openssh.com", "AES", "GCM", 256)
    };
    SshAlgorithms.hmac = {
      none: null,
      hmacSha256: new Hmac("hmac-sha2-256", "SHA2-256"),
      hmacSha512: new Hmac("hmac-sha2-512", "SHA2-512"),
      hmacSha256Etm: new Hmac("hmac-sha2-256-etm@openssh.com", "SHA2-256", true),
      hmacSha512Etm: new Hmac("hmac-sha2-512-etm@openssh.com", "SHA2-512", true)
    };
    SshAlgorithms.compression = {
      none: null
    };
    SshAlgorithms.random = new Random();
    function algorithmNames(list) {
      return list.map((a) => a ? a.name : "none");
    }
    exports2.algorithmNames = algorithmNames;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/trace.js
var require_trace = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/trace.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SshTraceEventIds = exports2.TraceLevel = void 0;
    var TraceLevel;
    (function(TraceLevel2) {
      TraceLevel2["Error"] = "error";
      TraceLevel2["Warning"] = "warning";
      TraceLevel2["Info"] = "info";
      TraceLevel2["Verbose"] = "verbose";
    })(TraceLevel = exports2.TraceLevel || (exports2.TraceLevel = {}));
    var baseEventId = 9e3;
    var SshTraceEventIds = class {
    };
    exports2.SshTraceEventIds = SshTraceEventIds;
    SshTraceEventIds.unknownError = baseEventId + 0;
    SshTraceEventIds.streamReadError = baseEventId + 1;
    SshTraceEventIds.streamWriteError = baseEventId + 2;
    SshTraceEventIds.streamCloseError = baseEventId + 3;
    SshTraceEventIds.sendMessageFailed = baseEventId + 4;
    SshTraceEventIds.receiveMessageFailed = baseEventId + 5;
    SshTraceEventIds.handleMessageFailed = baseEventId + 6;
    SshTraceEventIds.serverAuthenticationFailed = baseEventId + 7;
    SshTraceEventIds.clientAuthenticationFailed = baseEventId + 8;
    SshTraceEventIds.authenticationError = baseEventId + 9;
    SshTraceEventIds.channelWindowAdjustFailed = baseEventId + 10;
    SshTraceEventIds.channelWaitForWindowAdjust = baseEventId + 11;
    SshTraceEventIds.sessionReconnectInitFailed = baseEventId + 20;
    SshTraceEventIds.serverSessionReconnectFailed = baseEventId + 21;
    SshTraceEventIds.clientSessionReconnectFailed = baseEventId + 22;
    SshTraceEventIds.sessionRequestFailed = baseEventId + 23;
    SshTraceEventIds.channelRequestFailed = baseEventId + 24;
    SshTraceEventIds.serverListenFailed = baseEventId + 50;
    SshTraceEventIds.portForwardServerListenFailed = baseEventId + 51;
    SshTraceEventIds.portForwardRequestInvalid = baseEventId + 52;
    SshTraceEventIds.portForwardChannelInvalid = baseEventId + 53;
    SshTraceEventIds.portForwardChannelOpenFailed = baseEventId + 54;
    SshTraceEventIds.portForwardConnectionFailed = baseEventId + 55;
    SshTraceEventIds.metricsError = baseEventId + 61;
    SshTraceEventIds.keepAliveFailed = baseEventId + 62;
    SshTraceEventIds.keepAliveRequestReceived = baseEventId + 63;
    SshTraceEventIds.keepAliveResponseNotReceived = baseEventId + 64;
    SshTraceEventIds.protocolVersion = baseEventId + 100;
    SshTraceEventIds.sendingMessage = baseEventId + 101;
    SshTraceEventIds.receivingMessage = baseEventId + 102;
    SshTraceEventIds.sendingChannelData = baseEventId + 103;
    SshTraceEventIds.receivingChannelData = baseEventId + 104;
    SshTraceEventIds.sessionEncrypted = baseEventId + 110;
    SshTraceEventIds.sessionAuthenticating = baseEventId + 111;
    SshTraceEventIds.sessionAuthenticated = baseEventId + 112;
    SshTraceEventIds.sessionClosing = baseEventId + 113;
    SshTraceEventIds.sessionConnecting = baseEventId + 114;
    SshTraceEventIds.channelOpened = baseEventId + 120;
    SshTraceEventIds.channelOpenFailed = baseEventId + 121;
    SshTraceEventIds.channelEofReceived = baseEventId + 122;
    SshTraceEventIds.channelClosed = baseEventId + 123;
    SshTraceEventIds.serverListening = baseEventId + 150;
    SshTraceEventIds.serverClientConnected = baseEventId + 151;
    SshTraceEventIds.portForwardServerListening = baseEventId + 152;
    SshTraceEventIds.portForwardConnectionAccepted = baseEventId + 153;
    SshTraceEventIds.portForwardChannelOpened = baseEventId + 154;
    SshTraceEventIds.portForwardChannelClosed = baseEventId + 155;
    SshTraceEventIds.portForwardConnectionOpened = baseEventId + 156;
    SshTraceEventIds.portForwardConnectionClosed = baseEventId + 157;
    SshTraceEventIds.sessionDisconnected = baseEventId + 160;
    SshTraceEventIds.clientSessionReconnecting = baseEventId + 161;
    SshTraceEventIds.serverSessionReconnecting = baseEventId + 162;
    SshTraceEventIds.clientSessionStartReconnecting = baseEventId + 163;
    SshTraceEventIds.algorithmNegotiation = baseEventId + 170;
    SshTraceEventIds.debugMessage = baseEventId + 200;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/services/serviceActivation.js
var require_serviceActivation = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/services/serviceActivation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.findService = exports2.serviceActivation = void 0;
    function serviceActivation(activation) {
      return (constructor) => {
        if (!constructor.activations) {
          constructor.activations = [];
        }
        constructor.activations.push(activation);
      };
    }
    exports2.serviceActivation = serviceActivation;
    function findService(serviceConfigs, predicate) {
      for (const serviceType of serviceConfigs.keys()) {
        const activations = serviceType.activations;
        let foundActivation = false;
        for (const activation of activations) {
          foundActivation = true;
          if (predicate(activation)) {
            return serviceType;
          }
        }
        if (!foundActivation) {
          throw new Error(`SSH service type '${serviceType.name}' must have one or more 'serviceActivation' decorators.`);
        }
      }
      return null;
    }
    exports2.findService = findService;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/messages/sshMessage.js
var require_sshMessage = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/messages/sshMessage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SshMessage = void 0;
    var buffer_1 = require("buffer");
    var sshData_1 = require_sshData();
    var SshMessage = class {
      get messageType() {
        return 0;
      }
      toBuffer() {
        const writer = new sshData_1.SshDataWriter(buffer_1.Buffer.alloc(16));
        this.write(writer);
        return writer.toBuffer();
      }
      read(reader) {
        this.rawBytes = reader.buffer;
        const number = reader.readByte();
        if (number !== this.messageType) {
          throw new Error(`Message type ${number} is not valid.`);
        }
        this.onRead(reader);
      }
      write(writer) {
        if (this.rawBytes) {
          writer.write(this.rawBytes);
        } else {
          writer.writeByte(this.messageType);
          this.onWrite(writer);
        }
      }
      /**
       * Rewrites the message to its buffer to ensure the buffer has the correct values.
       * This should be called after modifying properties of a message that was (potentially)
       * received, before re-sending it.
       */
      rewrite() {
        if (this.rawBytes) {
          const writer = new sshData_1.SshDataWriter(buffer_1.Buffer.alloc(16));
          writer.writeByte(this.messageType);
          this.onWrite(writer);
          this.rawBytes = writer.toBuffer();
        }
      }
      onRead(reader) {
        throw new Error("Not supported.");
      }
      onWrite(writer) {
        throw new Error("Not supported.");
      }
      validateField(value, name) {
        if (typeof value === "undefined") {
          throw new Error(`${this.constructor.name} ${name} is required.`);
        }
        return value;
      }
      toString() {
        return this.constructor.name;
      }
      static create(config, messageType, messageContext, data) {
        let messageClass = config.messages.get(messageType);
        if (!messageClass && messageContext) {
          const contextMessageTypes = config.contextualMessages.get(messageContext);
          if (contextMessageTypes) {
            messageClass = contextMessageTypes.get(messageType);
          }
        }
        if (messageClass) {
          const message = new messageClass();
          message.read(new sshData_1.SshDataReader(data));
          return message;
        } else {
          return null;
        }
      }
      convertTo(otherMessage, copy = false) {
        const reader = new sshData_1.SshDataReader(copy ? buffer_1.Buffer.from(this.rawBytes) : this.rawBytes);
        otherMessage.read(reader);
        return otherMessage;
      }
    };
    exports2.SshMessage = SshMessage;
    SshMessage.index = /* @__PURE__ */ new Map();
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/messages/connectionMessages.js
var require_connectionMessages = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/messages/connectionMessages.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ChannelFailureMessage = exports2.ChannelSuccessMessage = exports2.ChannelSignalMessage = exports2.CommandRequestMessage = exports2.ChannelRequestMessage = exports2.ChannelRequestType = exports2.ChannelCloseMessage = exports2.ChannelEofMessage = exports2.ChannelExtendedDataMessage = exports2.ChannelDataMessage = exports2.ChannelWindowAdjustMessage = exports2.ChannelOpenFailureMessage = exports2.SshChannelOpenFailureReason = exports2.ChannelOpenConfirmationMessage = exports2.ChannelOpenMessage = exports2.ChannelMessage = exports2.ConnectionMessage = void 0;
    var sshMessage_1 = require_sshMessage();
    var sshData_1 = require_sshData();
    var ConnectionMessage = class extends sshMessage_1.SshMessage {
    };
    exports2.ConnectionMessage = ConnectionMessage;
    var ChannelMessage = class extends ConnectionMessage {
      get recipientChannel() {
        return this.recipientChannelValue;
      }
      set recipientChannel(value) {
        if (value !== this.recipientChannelValue) {
          this.recipientChannelValue = value;
          if (this.rawBytes) {
            sshData_1.SshDataWriter.writeUInt32(this.rawBytes, 1, value !== null && value !== void 0 ? value : 0);
          }
        }
      }
      onRead(reader) {
        this.recipientChannel = reader.readUInt32();
      }
      onWrite(writer) {
        writer.writeUInt32(this.validateField(this.recipientChannel, "recipient channel"));
      }
      toString() {
        return `${super.toString()} (recipientChannel=${this.recipientChannel})`;
      }
    };
    exports2.ChannelMessage = ChannelMessage;
    var ChannelOpenMessage = class _ChannelOpenMessage extends ConnectionMessage {
      get messageType() {
        return 90;
      }
      get senderChannel() {
        return this.senderChannelValue;
      }
      set senderChannel(value) {
        if (value !== this.senderChannelValue) {
          this.senderChannelValue = value;
          if (this.rawBytes && this.channelType) {
            sshData_1.SshDataWriter.writeUInt32(this.rawBytes, 1 + 4 + this.channelType.length, value !== null && value !== void 0 ? value : 0);
          }
        }
      }
      onRead(reader) {
        this.channelType = reader.readString("ascii");
        this.senderChannel = reader.readUInt32();
        this.maxWindowSize = reader.readUInt32();
        this.maxPacketSize = reader.readUInt32();
      }
      onWrite(writer) {
        writer.writeString(this.validateField(this.channelType, "channel type"), "ascii");
        writer.writeUInt32(this.validateField(this.senderChannel, "sender channel"));
        writer.writeUInt32(this.maxWindowSize || _ChannelOpenMessage.defaultMaxWindowSize);
        writer.writeUInt32(this.maxPacketSize || _ChannelOpenMessage.defaultMaxPacketSize);
      }
      toString() {
        return `${super.toString()}(channelType=${this.channelType}, senderChannel=${this.senderChannel})`;
      }
    };
    exports2.ChannelOpenMessage = ChannelOpenMessage;
    ChannelOpenMessage.defaultMaxPacketSize = 32 * 1024;
    ChannelOpenMessage.defaultMaxWindowSize = 1024 * 1024;
    var ChannelOpenConfirmationMessage = class extends ChannelMessage {
      get messageType() {
        return 91;
      }
      onRead(reader) {
        super.onRead(reader);
        this.senderChannel = reader.readUInt32();
        this.maxWindowSize = reader.readUInt32();
        this.maxPacketSize = reader.readUInt32();
      }
      onWrite(writer) {
        super.onWrite(writer);
        writer.writeUInt32(this.validateField(this.senderChannel, "sender channel"));
        writer.writeUInt32(this.validateField(this.maxWindowSize, "max window size"));
        writer.writeUInt32(this.validateField(this.maxPacketSize, "max packet size"));
      }
      toString() {
        return `${super.toString()}(senderChannel=${this.senderChannel})`;
      }
    };
    exports2.ChannelOpenConfirmationMessage = ChannelOpenConfirmationMessage;
    var SshChannelOpenFailureReason;
    (function(SshChannelOpenFailureReason2) {
      SshChannelOpenFailureReason2[SshChannelOpenFailureReason2["none"] = 0] = "none";
      SshChannelOpenFailureReason2[SshChannelOpenFailureReason2["administrativelyProhibited"] = 1] = "administrativelyProhibited";
      SshChannelOpenFailureReason2[SshChannelOpenFailureReason2["connectFailed"] = 2] = "connectFailed";
      SshChannelOpenFailureReason2[SshChannelOpenFailureReason2["unknownChannelType"] = 3] = "unknownChannelType";
      SshChannelOpenFailureReason2[SshChannelOpenFailureReason2["resourceShortage"] = 4] = "resourceShortage";
    })(SshChannelOpenFailureReason = exports2.SshChannelOpenFailureReason || (exports2.SshChannelOpenFailureReason = {}));
    var ChannelOpenFailureMessage = class extends ChannelMessage {
      get messageType() {
        return 92;
      }
      onRead(reader) {
        super.onRead(reader);
        this.reasonCode = reader.readUInt32();
        this.description = reader.readString("utf8");
        this.language = reader.readString("ascii");
      }
      onWrite(writer) {
        super.onWrite(writer);
        writer.writeUInt32(this.validateField(this.reasonCode, "reason code"));
        writer.writeString(this.description || "", "utf8");
        writer.writeString(this.language || "en", "ascii");
      }
      toString() {
        return `${super.toString()} (${SshChannelOpenFailureReason[this.reasonCode || 0]}: ${this.description})`;
      }
    };
    exports2.ChannelOpenFailureMessage = ChannelOpenFailureMessage;
    var ChannelWindowAdjustMessage = class extends ChannelMessage {
      get messageType() {
        return 93;
      }
      onRead(reader) {
        super.onRead(reader);
        this.bytesToAdd = reader.readUInt32();
      }
      onWrite(writer) {
        super.onWrite(writer);
        writer.writeUInt32(this.validateField(this.bytesToAdd, "bytes to add"));
      }
      toString() {
        return `${super.toString()} (bytesToAdd=${this.bytesToAdd})`;
      }
    };
    exports2.ChannelWindowAdjustMessage = ChannelWindowAdjustMessage;
    var ChannelDataMessage = class extends ChannelMessage {
      get messageType() {
        return 94;
      }
      onRead(reader) {
        super.onRead(reader);
        this.data = reader.readBinary();
      }
      onWrite(writer) {
        super.onWrite(writer);
        writer.writeBinary(this.validateField(this.data, "data"));
      }
      toString() {
        return this.data ? (0, sshData_1.formatBuffer)(this.data, "") : "[0]";
      }
    };
    exports2.ChannelDataMessage = ChannelDataMessage;
    var ChannelExtendedDataMessage = class extends ChannelMessage {
      get messageType() {
        return 95;
      }
      onRead(reader) {
        super.onRead(reader);
        this.dataTypeCode = reader.readUInt32();
        this.data = reader.readBinary();
      }
      onWrite(writer) {
        super.onWrite(writer);
        writer.writeUInt32(this.validateField(this.dataTypeCode, "data type code"));
        writer.writeBinary(this.validateField(this.data, "data"));
      }
      toString() {
        return `${super.toString()} (dataTypeCode=${this.dataTypeCode}, data=${this.data ? (0, sshData_1.formatBuffer)(this.data, "") : "[0]"})`;
      }
    };
    exports2.ChannelExtendedDataMessage = ChannelExtendedDataMessage;
    var ChannelEofMessage = class extends ChannelMessage {
      get messageType() {
        return 96;
      }
    };
    exports2.ChannelEofMessage = ChannelEofMessage;
    var ChannelCloseMessage = class extends ChannelMessage {
      get messageType() {
        return 97;
      }
    };
    exports2.ChannelCloseMessage = ChannelCloseMessage;
    var ChannelRequestType;
    (function(ChannelRequestType2) {
      ChannelRequestType2["command"] = "exec";
      ChannelRequestType2["shell"] = "shell";
      ChannelRequestType2["terminal"] = "pty-req";
      ChannelRequestType2["signal"] = "signal";
      ChannelRequestType2["exitSignal"] = "exit-signal";
      ChannelRequestType2["exitStatus"] = "exit-status";
    })(ChannelRequestType = exports2.ChannelRequestType || (exports2.ChannelRequestType = {}));
    var ChannelRequestMessage = class extends ChannelMessage {
      constructor(requestType, wantReply) {
        super();
        this.requestType = requestType;
        this.wantReply = wantReply !== null && wantReply !== void 0 ? wantReply : false;
      }
      get messageType() {
        return 98;
      }
      onRead(reader) {
        super.onRead(reader);
        this.requestType = reader.readString("ascii");
        this.wantReply = reader.readBoolean();
      }
      onWrite(writer) {
        if (typeof this.recipientChannel === "undefined") {
          this.recipientChannel = 0;
        }
        super.onWrite(writer);
        writer.writeString(this.validateField(this.requestType, "request type"), "ascii");
        writer.writeBoolean(this.wantReply);
      }
    };
    exports2.ChannelRequestMessage = ChannelRequestMessage;
    var CommandRequestMessage = class extends ChannelRequestMessage {
      constructor() {
        super();
        this.requestType = ChannelRequestType.command;
      }
      onRead(reader) {
        super.onRead(reader);
        this.command = reader.readString("utf8");
      }
      onWrite(writer) {
        super.onWrite(writer);
        writer.writeString(this.validateField(this.command, "command"), "utf8");
      }
      toString() {
        return `${super.toString()} (requestType=${this.requestType})`;
      }
    };
    exports2.CommandRequestMessage = CommandRequestMessage;
    var ChannelSignalMessage = class extends ChannelRequestMessage {
      constructor() {
        super();
      }
      get signal() {
        return this.signalValue;
      }
      set signal(value) {
        this.requestType = ChannelRequestType.signal;
        this.signalValue = value;
      }
      get exitSignal() {
        return this.signalValue;
      }
      set exitSignal(value) {
        this.requestType = ChannelRequestType.exitSignal;
        this.signalValue = value;
      }
      get errorMessage() {
        return this.errorMessageValue;
      }
      set errorMessage(value) {
        if (this.requestType !== ChannelRequestType.exitSignal) {
          throw new Error(`Error message property is only valid for ${ChannelRequestType.exitSignal} messages.`);
        }
        this.errorMessageValue = value;
      }
      get exitStatus() {
        return this.statusValue;
      }
      set exitStatus(value) {
        this.requestType = ChannelRequestType.exitStatus;
        this.statusValue = value;
      }
      onRead(reader) {
        super.onRead(reader);
        switch (this.requestType) {
          case ChannelRequestType.exitStatus:
            this.exitStatus = reader.readUInt32();
            break;
          case ChannelRequestType.signal:
            this.signal = reader.readString("ascii");
            break;
          case ChannelRequestType.exitSignal:
            this.exitSignal = reader.readString("ascii");
            reader.readBoolean();
            this.errorMessage = reader.readString("utf8");
            reader.readString("ascii");
            break;
          default:
            break;
        }
      }
      onWrite(writer) {
        if (!this.requestType) {
          throw new Error("Signal message request type not set.");
        }
        this.wantReply = false;
        super.onWrite(writer);
        switch (this.requestType) {
          case ChannelRequestType.exitStatus:
            writer.writeUInt32(this.validateField(this.exitStatus, "exit status"));
            break;
          case ChannelRequestType.signal:
            writer.writeString(this.validateField(this.signal, "signal"), "ascii");
            break;
          case ChannelRequestType.exitSignal:
            writer.writeString(this.validateField(this.exitSignal, "exit signal"), "ascii");
            writer.writeBoolean(false);
            writer.writeString(this.errorMessage || "", "utf8");
            writer.writeString("", "ascii");
            break;
          default:
            throw new Error(`Unknown signal message request type: ${this.requestType}`);
        }
      }
    };
    exports2.ChannelSignalMessage = ChannelSignalMessage;
    var ChannelSuccessMessage = class extends ChannelMessage {
      get messageType() {
        return 99;
      }
    };
    exports2.ChannelSuccessMessage = ChannelSuccessMessage;
    var ChannelFailureMessage = class extends ChannelMessage {
      get messageType() {
        return 100;
      }
    };
    exports2.ChannelFailureMessage = ChannelFailureMessage;
    sshMessage_1.SshMessage.index.set(90, ChannelOpenMessage);
    sshMessage_1.SshMessage.index.set(91, ChannelOpenConfirmationMessage);
    sshMessage_1.SshMessage.index.set(92, ChannelOpenFailureMessage);
    sshMessage_1.SshMessage.index.set(93, ChannelWindowAdjustMessage);
    sshMessage_1.SshMessage.index.set(94, ChannelDataMessage);
    sshMessage_1.SshMessage.index.set(95, ChannelExtendedDataMessage);
    sshMessage_1.SshMessage.index.set(96, ChannelEofMessage);
    sshMessage_1.SshMessage.index.set(97, ChannelCloseMessage);
    sshMessage_1.SshMessage.index.set(98, ChannelRequestMessage);
    sshMessage_1.SshMessage.index.set(99, ChannelSuccessMessage);
    sshMessage_1.SshMessage.index.set(100, ChannelFailureMessage);
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/messages/transportMessages.js
var require_transportMessages = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/messages/transportMessages.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SessionReconnectFailureMessage = exports2.SshReconnectFailureReason = exports2.SessionReconnectResponseMessage = exports2.SessionReconnectRequestMessage = exports2.SessionChannelRequestMessage = exports2.ExtensionInfoMessage = exports2.SessionRequestFailureMessage = exports2.SessionRequestSuccessMessage = exports2.SessionRequestMessage = exports2.ServiceAcceptMessage = exports2.ServiceRequestMessage = exports2.DebugMessage = exports2.UnimplementedMessage = exports2.IgnoreMessage = exports2.DisconnectMessage = exports2.SshDisconnectReason = void 0;
    var sshMessage_1 = require_sshMessage();
    var connectionMessages_1 = require_connectionMessages();
    var SshDisconnectReason;
    (function(SshDisconnectReason2) {
      SshDisconnectReason2[SshDisconnectReason2["none"] = 0] = "none";
      SshDisconnectReason2[SshDisconnectReason2["hostNotAllowedToConnect"] = 1] = "hostNotAllowedToConnect";
      SshDisconnectReason2[SshDisconnectReason2["protocolError"] = 2] = "protocolError";
      SshDisconnectReason2[SshDisconnectReason2["keyExchangeFailed"] = 3] = "keyExchangeFailed";
      SshDisconnectReason2[SshDisconnectReason2["reserved"] = 4] = "reserved";
      SshDisconnectReason2[SshDisconnectReason2["macError"] = 5] = "macError";
      SshDisconnectReason2[SshDisconnectReason2["compressionError"] = 6] = "compressionError";
      SshDisconnectReason2[SshDisconnectReason2["serviceNotAvailable"] = 7] = "serviceNotAvailable";
      SshDisconnectReason2[SshDisconnectReason2["protocolVersionNotSupported"] = 8] = "protocolVersionNotSupported";
      SshDisconnectReason2[SshDisconnectReason2["hostKeyNotVerifiable"] = 9] = "hostKeyNotVerifiable";
      SshDisconnectReason2[SshDisconnectReason2["connectionLost"] = 10] = "connectionLost";
      SshDisconnectReason2[SshDisconnectReason2["byApplication"] = 11] = "byApplication";
      SshDisconnectReason2[SshDisconnectReason2["tooManyConnections"] = 12] = "tooManyConnections";
      SshDisconnectReason2[SshDisconnectReason2["authCancelledByUser"] = 13] = "authCancelledByUser";
      SshDisconnectReason2[SshDisconnectReason2["noMoreAuthMethodsAvailable"] = 14] = "noMoreAuthMethodsAvailable";
      SshDisconnectReason2[SshDisconnectReason2["illegalUserName"] = 15] = "illegalUserName";
    })(SshDisconnectReason = exports2.SshDisconnectReason || (exports2.SshDisconnectReason = {}));
    var DisconnectMessage = class extends sshMessage_1.SshMessage {
      get messageType() {
        return 1;
      }
      onRead(reader) {
        this.reasonCode = reader.readUInt32();
        this.description = reader.readString("utf8");
        if (reader.available >= 4) {
          this.language = reader.readString("ascii");
        } else {
          this.language = null;
        }
      }
      onWrite(writer) {
        writer.writeUInt32(this.validateField(this.reasonCode, "reason code"));
        writer.writeString(this.description || "", "utf8");
        if (this.language) {
          writer.writeString(this.language, "ascii");
        }
      }
      toString() {
        return `${super.toString()} (${SshDisconnectReason[this.reasonCode || 0]}: ${this.description})`;
      }
    };
    exports2.DisconnectMessage = DisconnectMessage;
    var IgnoreMessage = class extends sshMessage_1.SshMessage {
      get messageType() {
        return 2;
      }
      onRead(reader) {
      }
      onWrite(writer) {
      }
    };
    exports2.IgnoreMessage = IgnoreMessage;
    var UnimplementedMessage = class extends sshMessage_1.SshMessage {
      get messageType() {
        return 3;
      }
      onRead(reader) {
        this.sequenceNumber = reader.readUInt32();
      }
      onWrite(writer) {
        writer.writeUInt32(this.validateField(this.sequenceNumber, "sequence number"));
      }
      toString() {
        return this.unimplementedMessageType ? `${super.toString()} (messageType=${this.unimplementedMessageType})` : `${super.toString()} (sequenceNumber=${this.sequenceNumber})`;
      }
    };
    exports2.UnimplementedMessage = UnimplementedMessage;
    var DebugMessage = class extends sshMessage_1.SshMessage {
      constructor(message) {
        super();
        this.alwaysDisplay = false;
        this.message = message;
      }
      get messageType() {
        return 4;
      }
      onRead(reader) {
        this.alwaysDisplay = reader.readBoolean();
        this.message = reader.readString("utf8");
        this.language = reader.readString("ascii");
      }
      onWrite(writer) {
        var _a2, _b;
        writer.writeBoolean(this.alwaysDisplay);
        writer.writeString((_a2 = this.message) !== null && _a2 !== void 0 ? _a2 : "", "utf8");
        writer.writeString((_b = this.language) !== null && _b !== void 0 ? _b : "", "ascii");
      }
      toString() {
        return `${super.toString()}: ${this.message}`;
      }
    };
    exports2.DebugMessage = DebugMessage;
    var ServiceRequestMessage = class extends sshMessage_1.SshMessage {
      get messageType() {
        return 5;
      }
      onRead(reader) {
        this.serviceName = reader.readString("ascii");
      }
      onWrite(writer) {
        writer.writeString(this.validateField(this.serviceName, "service name"), "ascii");
      }
    };
    exports2.ServiceRequestMessage = ServiceRequestMessage;
    var ServiceAcceptMessage = class extends sshMessage_1.SshMessage {
      get messageType() {
        return 6;
      }
      onRead(reader) {
        this.serviceName = reader.readString("ascii");
      }
      onWrite(writer) {
        writer.writeString(this.validateField(this.serviceName, "service name"), "ascii");
      }
    };
    exports2.ServiceAcceptMessage = ServiceAcceptMessage;
    var SessionRequestMessage = class extends sshMessage_1.SshMessage {
      constructor(requestType, wantReply) {
        super();
        this.requestType = requestType;
        this.wantReply = wantReply !== null && wantReply !== void 0 ? wantReply : false;
      }
      get messageType() {
        return 80;
      }
      onRead(reader) {
        this.requestType = reader.readString("ascii");
        this.wantReply = reader.readBoolean();
      }
      onWrite(writer) {
        writer.writeString(this.validateField(this.requestType, "request type"), "ascii");
        writer.writeBoolean(this.wantReply);
      }
      toString() {
        return `${super.toString()} (requestType=${this.requestType})`;
      }
    };
    exports2.SessionRequestMessage = SessionRequestMessage;
    var SessionRequestSuccessMessage = class extends sshMessage_1.SshMessage {
      get messageType() {
        return 81;
      }
      onRead(reader) {
      }
      onWrite(writer) {
      }
    };
    exports2.SessionRequestSuccessMessage = SessionRequestSuccessMessage;
    var SessionRequestFailureMessage = class extends sshMessage_1.SshMessage {
      get messageType() {
        return 82;
      }
      onRead(reader) {
      }
      onWrite(writer) {
      }
    };
    exports2.SessionRequestFailureMessage = SessionRequestFailureMessage;
    var ExtensionInfoMessage = class extends sshMessage_1.SshMessage {
      constructor() {
        super(...arguments);
        this.extensionInfo = {};
      }
      get messageType() {
        return 7;
      }
      onRead(reader) {
        const count = reader.readUInt32();
        this.extensionInfo = {};
        for (let i = 0; i < count; i++) {
          const key = reader.readString("ascii");
          const value = reader.readString("utf8");
          this.extensionInfo[key] = value;
        }
      }
      onWrite(writer) {
        const keys = Object.keys(this.extensionInfo);
        writer.writeUInt32(keys.length);
        for (const key of keys) {
          writer.writeString(key, "ascii");
          writer.writeString(this.extensionInfo[key] || "", "utf8");
        }
      }
      toString() {
        let extensionInfoDetails = "";
        for (const [key, value] of Object.entries(this.extensionInfo)) {
          if (extensionInfoDetails) {
            extensionInfoDetails += "; ";
          }
          extensionInfoDetails += key;
          if (value) {
            extensionInfoDetails += "=" + value;
          }
        }
        return `${super.toString()} (${extensionInfoDetails})`;
      }
    };
    exports2.ExtensionInfoMessage = ExtensionInfoMessage;
    ExtensionInfoMessage.serverIndicator = "ext-info-c";
    ExtensionInfoMessage.clientIndicator = "ext-info-c";
    var SessionChannelRequestMessage = class extends SessionRequestMessage {
      onRead(reader) {
        super.onRead(reader);
        this.senderChannel = reader.readUInt32();
        const request = new connectionMessages_1.ChannelRequestMessage();
        request.read(reader);
        this.request = request;
      }
      onWrite(writer) {
        super.onWrite(writer);
        writer.writeUInt32(this.validateField(this.senderChannel, "sender channel"));
        this.validateField(this.request, "request message").write(writer);
      }
    };
    exports2.SessionChannelRequestMessage = SessionChannelRequestMessage;
    var SessionReconnectRequestMessage = class extends SessionRequestMessage {
      onRead(reader) {
        super.onRead(reader);
        this.clientReconnectToken = reader.readBinary();
        this.lastReceivedSequenceNumber = reader.readUInt64();
      }
      onWrite(writer) {
        super.onWrite(writer);
        writer.writeBinary(this.validateField(this.clientReconnectToken, "clientReconnectToken"));
        writer.writeUInt64(this.validateField(this.lastReceivedSequenceNumber, "lastReceivedSequenceNumber"));
      }
    };
    exports2.SessionReconnectRequestMessage = SessionReconnectRequestMessage;
    var SessionReconnectResponseMessage = class extends SessionRequestSuccessMessage {
      onRead(reader) {
        super.onRead(reader);
        this.serverReconnectToken = reader.readBinary();
        this.lastReceivedSequenceNumber = reader.readUInt64();
      }
      onWrite(writer) {
        super.onWrite(writer);
        writer.writeBinary(this.validateField(this.serverReconnectToken, "serverReconnectToken"));
        writer.writeUInt64(this.validateField(this.lastReceivedSequenceNumber, "lastReceivedSequenceNumber"));
      }
    };
    exports2.SessionReconnectResponseMessage = SessionReconnectResponseMessage;
    var SshReconnectFailureReason;
    (function(SshReconnectFailureReason2) {
      SshReconnectFailureReason2[SshReconnectFailureReason2["none"] = 0] = "none";
      SshReconnectFailureReason2[SshReconnectFailureReason2["unknownServerFailure"] = 1] = "unknownServerFailure";
      SshReconnectFailureReason2[SshReconnectFailureReason2["sessionNotFound"] = 2] = "sessionNotFound";
      SshReconnectFailureReason2[SshReconnectFailureReason2["invalidClientReconnectToken"] = 3] = "invalidClientReconnectToken";
      SshReconnectFailureReason2[SshReconnectFailureReason2["serverDroppedMessages"] = 4] = "serverDroppedMessages";
      SshReconnectFailureReason2[SshReconnectFailureReason2["unknownClientFailure"] = 101] = "unknownClientFailure";
      SshReconnectFailureReason2[SshReconnectFailureReason2["differentServerHostKey"] = 102] = "differentServerHostKey";
      SshReconnectFailureReason2[SshReconnectFailureReason2["invalidServerReconnectToken"] = 103] = "invalidServerReconnectToken";
      SshReconnectFailureReason2[SshReconnectFailureReason2["clientDroppedMessages"] = 104] = "clientDroppedMessages";
    })(SshReconnectFailureReason = exports2.SshReconnectFailureReason || (exports2.SshReconnectFailureReason = {}));
    var SessionReconnectFailureMessage = class extends SessionRequestFailureMessage {
      onRead(reader) {
        if (reader.available > 0) {
          this.reasonCode = reader.readUInt32();
          this.description = reader.readString("utf8");
          this.language = reader.readString("ascii");
        }
      }
      onWrite(writer) {
        writer.writeUInt32(this.validateField(this.reasonCode, "reason code"));
        writer.writeString(this.description || "", "utf8");
        writer.writeString(this.language || "en", "ascii");
      }
      toString() {
        return `${super.toString()} (${SshReconnectFailureReason[this.reasonCode || 0]}: ${this.description})`;
      }
    };
    exports2.SessionReconnectFailureMessage = SessionReconnectFailureMessage;
    sshMessage_1.SshMessage.index.set(1, DisconnectMessage);
    sshMessage_1.SshMessage.index.set(2, IgnoreMessage);
    sshMessage_1.SshMessage.index.set(3, UnimplementedMessage);
    sshMessage_1.SshMessage.index.set(5, ServiceRequestMessage);
    sshMessage_1.SshMessage.index.set(6, ServiceAcceptMessage);
    sshMessage_1.SshMessage.index.set(7, ExtensionInfoMessage);
    sshMessage_1.SshMessage.index.set(80, SessionRequestMessage);
    sshMessage_1.SshMessage.index.set(81, SessionRequestSuccessMessage);
    sshMessage_1.SshMessage.index.set(82, SessionRequestFailureMessage);
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/metrics/channelMetrics.js
var require_channelMetrics = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/metrics/channelMetrics.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ChannelMetrics = void 0;
    var ChannelMetrics = class {
      /* @internal */
      constructor() {
        this.bytesSentSum = 0;
        this.bytesReceivedSum = 0;
      }
      /**
       * Gets the total cumulative number of bytes sent for the duration of the channel,
       * not including message framing, padding, and MAC bytes.
       */
      get bytesSent() {
        return this.bytesSentSum;
      }
      /**
       * Gets the total cumulative number of bytes received for the duration of the channel,
       * not including message framing, padding, and MAC bytes.
       */
      get bytesReceived() {
        return this.bytesReceivedSum;
      }
      /* @internal */
      addBytesSent(count) {
        this.bytesSentSum += count;
      }
      /* @internal */
      addBytesReceived(count) {
        this.bytesReceivedSum += count;
      }
      toString() {
        return `Bytes S/R: ${this.bytesSent} / ${this.bytesReceived}; `;
      }
    };
    exports2.ChannelMetrics = ChannelMetrics;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/util/promiseCompletionSource.js
var require_promiseCompletionSource = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/util/promiseCompletionSource.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PromiseCompletionSource = void 0;
    var PromiseCompletionSource = class {
      constructor() {
        this.promise = new Promise((resolve8, reject) => {
          this.resolve = resolve8;
          this.reject = reject;
        });
      }
      resolve(result) {
      }
      reject(e) {
      }
    };
    exports2.PromiseCompletionSource = PromiseCompletionSource;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/errors.js
var require_errors = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/errors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ObjectDisposedError = exports2.SshChannelError = exports2.SshReconnectError = exports2.SshConnectionError = void 0;
    var SshConnectionError = class extends Error {
      constructor(message, reason) {
        super(message);
        this.reason = reason;
      }
    };
    exports2.SshConnectionError = SshConnectionError;
    var SshReconnectError = class extends Error {
      constructor(message, reason) {
        super(message);
        this.reason = reason;
      }
    };
    exports2.SshReconnectError = SshReconnectError;
    var SshChannelError = class extends Error {
      constructor(message, reason) {
        super(message);
        this.reason = reason;
      }
    };
    exports2.SshChannelError = SshChannelError;
    var ObjectDisposedError = class extends Error {
      // eslint-disable-next-line @typescript-eslint/ban-types
      constructor(objectOrMessage) {
        var _a2, _b;
        let message;
        if (typeof objectOrMessage === "string") {
          message = objectOrMessage;
        } else if (typeof objectOrMessage === "function") {
          message = objectOrMessage.name + " disposed.";
        } else {
          message = ((_b = (_a2 = objectOrMessage === null || objectOrMessage === void 0 ? void 0 : objectOrMessage.constructor) === null || _a2 === void 0 ? void 0 : _a2.name) !== null && _b !== void 0 ? _b : "Object ") + " disposed.";
        }
        super(message);
      }
    };
    exports2.ObjectDisposedError = ObjectDisposedError;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/events/sshRequestEventArgs.js
var require_sshRequestEventArgs = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/events/sshRequestEventArgs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SshRequestEventArgs = void 0;
    var vscode_jsonrpc_1 = require_main();
    var SshRequestEventArgs = class {
      constructor(requestType, request, principal, cancellation) {
        this.requestType = requestType;
        this.request = request;
        this.principal = principal;
        this.cancellationValue = cancellation !== null && cancellation !== void 0 ? cancellation : vscode_jsonrpc_1.CancellationToken.None;
      }
      /**
       * Gets a token that is cancelled if the session ends before the request handler
       * completes.
       */
      get cancellation() {
        return this.cancellationValue;
      }
      /* @internal */
      set cancellation(value) {
        this.cancellationValue = value;
      }
      toString() {
        return `RequestType: ${this.requestType}` + this.request ? ` Request: ${this.request}` : "";
      }
    };
    exports2.SshRequestEventArgs = SshRequestEventArgs;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/events/sshChannelClosedEventArgs.js
var require_sshChannelClosedEventArgs = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/events/sshChannelClosedEventArgs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SshChannelClosedEventArgs = void 0;
    var SshChannelClosedEventArgs = class {
      constructor(exitStatusOrSignalOrError, errorMessage) {
        if (typeof exitStatusOrSignalOrError === "number") {
          this.exitStatus = exitStatusOrSignalOrError;
        } else if (typeof exitStatusOrSignalOrError === "string") {
          this.exitSignal = exitStatusOrSignalOrError;
          this.errorMessage = errorMessage;
        } else if (exitStatusOrSignalOrError instanceof Error) {
          this.error = exitStatusOrSignalOrError;
        }
      }
    };
    exports2.SshChannelClosedEventArgs = SshChannelClosedEventArgs;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/util/cancellation.js
var require_cancellation2 = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/util/cancellation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.withCancellation = exports2.CancellationError = exports2.CancellationTokenSource = exports2.CancellationToken = void 0;
    var vscode_jsonrpc_1 = require_main();
    Object.defineProperty(exports2, "CancellationToken", { enumerable: true, get: function() {
      return vscode_jsonrpc_1.CancellationToken;
    } });
    Object.defineProperty(exports2, "CancellationTokenSource", { enumerable: true, get: function() {
      return vscode_jsonrpc_1.CancellationTokenSource;
    } });
    var CancellationError = class extends Error {
      constructor(message) {
        super(message || "Operation cancelled.");
      }
    };
    exports2.CancellationError = CancellationError;
    function withCancellation(promise2, cancellation) {
      if (!cancellation) {
        return promise2;
      }
      return Promise.race([
        promise2,
        new Promise((resolve8, reject) => {
          if (cancellation.isCancellationRequested) {
            reject(new CancellationError());
          } else {
            cancellation.onCancellationRequested(() => {
              reject(new CancellationError());
            });
          }
        })
      ]);
    }
    exports2.withCancellation = withCancellation;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/util/semaphore.js
var require_semaphore = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/util/semaphore.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Semaphore = void 0;
    var promiseCompletionSource_1 = require_promiseCompletionSource();
    var cancellation_1 = require_cancellation2();
    var errors_1 = require_errors();
    var Semaphore = class {
      /**
       * Creates a new semaphore instance.
       * @param initialCount Optional initial count. Defaults to 0.
       */
      constructor(initialCount = 0) {
        this.completions = [];
        this.disposed = false;
        this.count = initialCount;
      }
      /**
       * Gets the current available count of the semaphore.
       */
      get currentCount() {
        return this.count;
      }
      /**
       * Releases the semaphore, increasing the available count or unblicking one or more awaiters.
       * @param releaseCount Optional specified count to release. Defaults to 1.
       * @returns The previous count (before release).
       */
      release(releaseCount = 1) {
        if (this.disposed)
          throw new errors_1.ObjectDisposedError(this);
        const previousCount = this.count;
        for (; releaseCount > 0; releaseCount--) {
          if (this.completions.length > 0) {
            const completion = this.completions.shift();
            completion.resolve(true);
          } else {
            this.count++;
          }
        }
        return previousCount;
      }
      /**
       * Releases the semaphore, but does not throw an `ObjectDisposedError` if it is already disposed.
       */
      tryRelease() {
        try {
          this.release();
        } catch (e) {
          if (!(e instanceof errors_1.ObjectDisposedError)) {
            throw e;
          }
        }
      }
      async wait(timeoutOrCancellation, cancellation) {
        const millisecondsTimeout = typeof timeoutOrCancellation === "number" ? timeoutOrCancellation : void 0;
        if (typeof cancellation === "undefined" && typeof timeoutOrCancellation === "object") {
          cancellation = timeoutOrCancellation;
        }
        if (this.disposed)
          throw new errors_1.ObjectDisposedError(this);
        if (cancellation === null || cancellation === void 0 ? void 0 : cancellation.isCancellationRequested)
          throw new cancellation_1.CancellationError();
        if (this.count > 0) {
          this.count--;
          return true;
        } else if (millisecondsTimeout === 0) {
          return false;
        } else {
          const completion = new promiseCompletionSource_1.PromiseCompletionSource();
          this.completions.push(completion);
          const promises2 = [completion.promise];
          if (millisecondsTimeout) {
            promises2.push(new Promise((resolve8) => setTimeout(() => resolve8(false), millisecondsTimeout)));
          }
          if (cancellation) {
            const cancellationCompletion = new promiseCompletionSource_1.PromiseCompletionSource();
            cancellation.onCancellationRequested(() => {
              cancellationCompletion.reject(new cancellation_1.CancellationError());
            });
            promises2.push(cancellationCompletion.promise);
          }
          if (await Promise.race(promises2)) {
            return true;
          } else {
            const completionIndex = this.completions.indexOf(completion);
            if (completionIndex >= 0)
              this.completions.splice(completionIndex, 1);
            return false;
          }
        }
      }
      /**
       * Disposes the semaphore and throws a diposed error to any awaiters.
       */
      dispose() {
        if (this.disposed)
          return;
        this.disposed = true;
        for (const completion of this.completions) {
          completion.reject(new errors_1.ObjectDisposedError(this));
        }
        this.completions.splice(0, this.completions.length);
        this.count = 0;
      }
    };
    exports2.Semaphore = Semaphore;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/pipeExtensions.js
var require_pipeExtensions = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/pipeExtensions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PipeExtensions = void 0;
    var buffer_1 = require("buffer");
    var vscode_jsonrpc_1 = require_main();
    var transportMessages_1 = require_transportMessages();
    var connectionMessages_1 = require_connectionMessages();
    var promiseCompletionSource_1 = require_promiseCompletionSource();
    var errors_1 = require_errors();
    var trace_1 = require_trace();
    var PipeExtensions = class _PipeExtensions {
      static async pipeSession(session, toSession) {
        if (!session)
          throw new TypeError("Session is required.");
        if (!toSession)
          throw new TypeError("Target session is required");
        const endCompletion = new promiseCompletionSource_1.PromiseCompletionSource();
        session.onRequest((e) => {
          e.responsePromise = _PipeExtensions.forwardSessionRequest(e, toSession, e.cancellation);
        });
        toSession.onRequest((e) => {
          e.responsePromise = _PipeExtensions.forwardSessionRequest(e, session, e.cancellation);
        });
        session.onChannelOpening((e) => {
          if (e.isRemoteRequest) {
            e.openingPromise = _PipeExtensions.forwardChannel(e, toSession, e.cancellation);
          }
        });
        toSession.onChannelOpening((e) => {
          if (e.isRemoteRequest) {
            e.openingPromise = _PipeExtensions.forwardChannel(e, session, e.cancellation);
          }
        });
        session.onClosed((e) => {
          endCompletion.resolve(_PipeExtensions.forwardSessionClose(toSession, e));
        });
        toSession.onClosed((e) => {
          endCompletion.resolve(_PipeExtensions.forwardSessionClose(session, e));
        });
        const endPromise = await endCompletion.promise;
        await endPromise;
      }
      static async pipeChannel(channel, toChannel) {
        if (!channel)
          throw new TypeError("Channel is required.");
        if (!toChannel)
          throw new TypeError("Target channel is required");
        const endCompletion = new promiseCompletionSource_1.PromiseCompletionSource();
        let closed = false;
        channel.onRequest((e) => {
          e.responsePromise = _PipeExtensions.forwardChannelRequest(e, toChannel, e.cancellation);
        });
        toChannel.onRequest((e) => {
          e.responsePromise = _PipeExtensions.forwardChannelRequest(e, channel, e.cancellation);
        });
        channel.onDataReceived((data) => {
          void _PipeExtensions.forwardData(channel, toChannel, data).catch();
        });
        toChannel.onDataReceived((data) => {
          void _PipeExtensions.forwardData(toChannel, channel, data).catch();
        });
        channel.onEof(() => {
          void _PipeExtensions.forwardData(channel, toChannel, buffer_1.Buffer.alloc(0)).catch();
        });
        toChannel.onEof(() => {
          void _PipeExtensions.forwardData(toChannel, channel, buffer_1.Buffer.alloc(0)).catch();
        });
        channel.onExtendedDataReceived((data) => {
          void _PipeExtensions.forwardExtendedData(channel, toChannel, data.dataTypeCode, data.data).catch();
        });
        toChannel.onExtendedDataReceived((data) => {
          void _PipeExtensions.forwardExtendedData(toChannel, channel, data.dataTypeCode, data.data).catch();
        });
        channel.onClosed((e) => {
          if (!closed) {
            closed = true;
            endCompletion.resolve(_PipeExtensions.forwardChannelClose(channel, toChannel, e));
          }
        });
        toChannel.onClosed((e) => {
          if (!closed) {
            closed = true;
            endCompletion.resolve(_PipeExtensions.forwardChannelClose(toChannel, channel, e));
          }
        });
        const endTask = await endCompletion.promise;
        await endTask;
      }
      static async forwardSessionRequest(e, toSession, cancellation) {
        if (!e.request.wantReply) {
          return toSession.request(e.request, cancellation).then(() => new transportMessages_1.SessionRequestSuccessMessage());
        }
        return toSession.requestResponse(e.request, transportMessages_1.SessionRequestSuccessMessage, transportMessages_1.SessionRequestFailureMessage, cancellation);
      }
      static async forwardChannel(e, toSession, cancellation) {
        var _a2;
        try {
          const toChannel = await toSession.openChannel(e.request, null, cancellation);
          void _PipeExtensions.pipeChannel(e.channel, toChannel).catch();
          return new connectionMessages_1.ChannelOpenConfirmationMessage();
        } catch (err) {
          if (!(err instanceof Error))
            throw err;
          const failureMessage = new connectionMessages_1.ChannelOpenFailureMessage();
          if (err instanceof errors_1.SshChannelError) {
            failureMessage.reasonCode = (_a2 = err.reason) !== null && _a2 !== void 0 ? _a2 : connectionMessages_1.SshChannelOpenFailureReason.connectFailed;
          } else {
            failureMessage.reasonCode = connectionMessages_1.SshChannelOpenFailureReason.connectFailed;
          }
          failureMessage.description = err.message;
          return failureMessage;
        }
      }
      static async forwardChannelRequest(e, toChannel, cancellation) {
        e.request.recipientChannel = toChannel.remoteChannelId;
        const result = await toChannel.request(e.request, cancellation);
        return result ? new connectionMessages_1.ChannelSuccessMessage() : new connectionMessages_1.ChannelFailureMessage();
      }
      static async forwardSessionClose(session, e) {
        var _a2;
        return session.close(e.reason, e.message, (_a2 = e.error) !== null && _a2 !== void 0 ? _a2 : void 0);
      }
      static async forwardData(channel, toChannel, data) {
        const buffer = buffer_1.Buffer.alloc(data.length);
        data.copy(buffer);
        const promise2 = toChannel.send(buffer, vscode_jsonrpc_1.CancellationToken.None);
        channel.adjustWindow(buffer.length);
        return promise2;
      }
      static async forwardExtendedData(channel, toChannel, dataTypeCode, data) {
        const buffer = buffer_1.Buffer.alloc(data.length);
        data.copy(buffer);
        const promise2 = toChannel.sendExtendedData(dataTypeCode, buffer, vscode_jsonrpc_1.CancellationToken.None);
        channel.adjustWindow(buffer.length);
        return promise2;
      }
      static async forwardChannelClose(fromChannel, toChannel, e) {
        const message = `Piping channel closure.
Source: ${fromChannel.session} ${fromChannel}
Destination: ${toChannel.session} ${toChannel}
`;
        toChannel.session.trace(trace_1.TraceLevel.Verbose, trace_1.SshTraceEventIds.channelClosed, message);
        if (e.error) {
          toChannel.close(e.error);
          return Promise.resolve();
        } else if (e.exitSignal) {
          return toChannel.close(e.exitSignal, e.errorMessage);
        } else if (typeof e.exitStatus === "number") {
          return toChannel.close(e.exitStatus);
        } else {
          return toChannel.close();
        }
      }
    };
    exports2.PipeExtensions = PipeExtensions;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/util/queue.js
var require_queue = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/util/queue.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Queue = void 0;
    var Queue2 = class {
      constructor() {
        this.array = new Array();
        this.first = 0;
        this.count = 0;
        this.version = 0;
      }
      /**
       * Gets the current size of the queue.
       */
      get size() {
        return this.count;
      }
      /**
       * Adds an item to the end of the queue.
       */
      enqueue(item) {
        if (this.count === this.array.length) {
          const newArray = new Array(Math.max(16, this.count * 2));
          for (let i = 0; i < this.count; i++) {
            newArray[i] = this.array[(this.first + i) % this.count];
          }
          this.array = newArray;
          this.first = 0;
        }
        this.array[(this.first + this.count) % this.array.length] = item;
        this.count++;
        this.version++;
      }
      /**
       * Removes an item from the front of the queue.
       * @returns The removed item, or `undefined` if the queue is empty.
       */
      dequeue() {
        if (this.count === 0)
          return void 0;
        const item = this.array[this.first];
        this.array[this.first] = void 0;
        this.first = (this.first + 1) % this.array.length;
        this.count--;
        this.version++;
        return item;
      }
      /**
       * Gets the item at the front of the queue without removing it.
       * @returns The front item, or `undefined` if the queue is empty.
       */
      peek() {
        if (this.count === 0)
          return void 0;
        const item = this.array[this.first];
        return item;
      }
      /**
       * Clears the queue.
       */
      clear() {
        this.first = 0;
        this.count = 0;
        this.array.fill(void 0);
        this.version++;
      }
      /**
       * Creates an iterator over the items in the queue.
       * (Any changes to the queue will invalidate the iterator.)
       */
      *[Symbol.iterator]() {
        const iteratorVersion = this.version;
        for (let i = 0; i < this.count; i++) {
          const item = this.array[(this.first + i) % this.array.length];
          yield item;
          if (this.version !== iteratorVersion) {
            throw new Error("Iterator is invalid due to changes in the collection.");
          }
        }
      }
    };
    exports2.Queue = Queue2;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/sshChannel.js
var require_sshChannel = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/sshChannel.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SshChannel = void 0;
    var vscode_jsonrpc_1 = require_main();
    var serviceActivation_1 = require_serviceActivation();
    var connectionMessages_1 = require_connectionMessages();
    var transportMessages_1 = require_transportMessages();
    var channelMetrics_1 = require_channelMetrics();
    var promiseCompletionSource_1 = require_promiseCompletionSource();
    var errors_1 = require_errors();
    var sshRequestEventArgs_1 = require_sshRequestEventArgs();
    var sshChannelClosedEventArgs_1 = require_sshChannelClosedEventArgs();
    var cancellation_1 = require_cancellation2();
    var semaphore_1 = require_semaphore();
    var trace_1 = require_trace();
    var pipeExtensions_1 = require_pipeExtensions();
    var queue_1 = require_queue();
    var SshChannel = class _SshChannel {
      /* @internal */
      constructor(connectionService, channelType, channelId, remoteChannelId, remoteMaxWindowSize, remoteMaxPacketSize, openMessage, openConfirmationMessage) {
        this.connectionService = connectionService;
        this.channelType = channelType;
        this.channelId = channelId;
        this.remoteChannelId = remoteChannelId;
        this.openMessage = openMessage;
        this.openConfirmationMessage = openConfirmationMessage;
        this.remoteClosed = false;
        this.localClosed = false;
        this.sentEof = false;
        this.disposed = false;
        this.openSendingWindowCompletionSource = null;
        this.requestCompletionSources = new queue_1.Queue();
        this.sendSemaphore = new semaphore_1.Semaphore(0);
        this.metrics = new channelMetrics_1.ChannelMetrics();
        this.dataReceivedEmitter = new vscode_jsonrpc_1.Emitter();
        this.extendedDataReceivedEmitter = new vscode_jsonrpc_1.Emitter();
        this.onDataReceived = this.dataReceivedEmitter.event;
        this.onExtendedDataReceived = this.extendedDataReceivedEmitter.event;
        this.eofEmitter = new vscode_jsonrpc_1.Emitter();
        this.onEof = this.eofEmitter.event;
        this.closedEmitter = new vscode_jsonrpc_1.Emitter();
        this.onClosed = this.closedEmitter.event;
        this.requestEmitter = new vscode_jsonrpc_1.Emitter();
        this.onRequest = this.requestEmitter.event;
        this.isMaxWindowSizeLocked = false;
        this.remoteWindowSize = remoteMaxWindowSize;
        this.maxWindowSizeValue = _SshChannel.defaultMaxWindowSize;
        this.windowSize = this.maxWindowSizeValue;
        this.maxPacketSize = Math.min(remoteMaxPacketSize, _SshChannel.defaultMaxPacketSize);
      }
      get session() {
        return this.connectionService.session;
      }
      get isClosed() {
        return this.localClosed || this.remoteClosed;
      }
      /**
       * Gets the maximum window size for received data. The other side will not send more
       * data than the window size until it receives an acknowledgement that some of the data was
       * received and processed by this side.
       */
      get maxWindowSize() {
        return this.maxWindowSizeValue;
      }
      /**
       * Sets the maximum window size for received data. The other side will not send more
       * data than the window size until it receives an acknowledgement that some of the data was
       * received and processed by this side.
       *
       * The default value is `defaultMaxWindowSize`. The value may be configured for a channel
       * opened by this side by setting `ChannelOpenMessage.maxWindowSize` in the message object
       * passed to `SshSession.openChannel()`, or for a channel opened by the other side by
       * assigning to this property while handling the `SshSession.onChannelOpening` event.
       * Changing the maximum window size at any other time is not valid because the other
       * side would not be aware of the change.
       */
      set maxWindowSize(value) {
        if (this.isMaxWindowSizeLocked) {
          throw new Error("Cannot change the max window size after opening the channel.");
        }
        if (value < this.maxPacketSize) {
          throw new Error("Maximum window size cannot be less than maximum packet size.");
        }
        this.maxWindowSizeValue = value;
      }
      /**
       * Sends a channel request and waits for a response.
       *
       * Note if `wantReply` is `false`, this method returns `true` immediately after sending the
       * request, without waiting for a reply.
       *
       * @returns The authorization status of the response; if false, the other side denied the
       * request.
       * @throws `ObjectDisposedError` if the channel was closed before sending the request.
       * @throws `SshChannelError` if the channel was closed while waiting for a reply to the request.
       */
      async request(request, cancellation) {
        if (!request)
          throw new TypeError("Request is required.");
        if (this.disposed)
          throw new errors_1.ObjectDisposedError(this);
        request.recipientChannel = this.remoteChannelId;
        if (!request.wantReply) {
          await this.session.sendMessage(request, cancellation);
          return true;
        }
        const requestCompletionSource = new promiseCompletionSource_1.PromiseCompletionSource();
        if (cancellation) {
          if (cancellation.isCancellationRequested)
            throw new cancellation_1.CancellationError();
          cancellation.onCancellationRequested(() => {
            requestCompletionSource.reject(new cancellation_1.CancellationError());
          });
        }
        this.requestCompletionSources.enqueue(requestCompletionSource);
        await this.session.sendMessage(request, cancellation);
        return await requestCompletionSource.promise;
      }
      async send(data, cancellation) {
        return this.sendCommon(data, void 0, cancellation);
      }
      async sendExtendedData(dataTypeCode, data, cancellation) {
        return this.sendCommon(data, dataTypeCode, cancellation);
      }
      async sendCommon(data, extendedDataType, cancellation) {
        if (this.disposed)
          throw new errors_1.ObjectDisposedError(this);
        if (data.length === 0) {
          await this.sendEof();
          return;
        } else if (this.sentEof) {
          throw new Error("Cannot send more data after EOF.");
        }
        await this.sendSemaphore.wait(cancellation);
        try {
          let offset = 0;
          let count = data.length;
          while (count > 0) {
            let packetSize = Math.min(Math.min(this.remoteWindowSize, this.maxPacketSize), count);
            while (packetSize === 0) {
              if (!this.openSendingWindowCompletionSource) {
                this.openSendingWindowCompletionSource = new promiseCompletionSource_1.PromiseCompletionSource();
              }
              this.session.trace(trace_1.TraceLevel.Warning, trace_1.SshTraceEventIds.channelWaitForWindowAdjust, `${this} send window is full. Waiting for window adjustment before sending.`);
              await (0, cancellation_1.withCancellation)(this.openSendingWindowCompletionSource.promise, cancellation);
              this.openSendingWindowCompletionSource = null;
              packetSize = Math.min(Math.min(this.remoteWindowSize, this.maxPacketSize), count);
            }
            let msg;
            if (extendedDataType !== void 0) {
              msg = new connectionMessages_1.ChannelExtendedDataMessage();
              msg.dataTypeCode = extendedDataType;
            } else {
              msg = new connectionMessages_1.ChannelDataMessage();
            }
            msg.recipientChannel = this.remoteChannelId;
            msg.data = Buffer.from(data.slice(offset, offset + packetSize));
            await this.session.sendMessage(msg, cancellation);
            this.remoteWindowSize -= packetSize;
            count -= packetSize;
            offset += packetSize;
            this.metrics.addBytesSent(packetSize);
          }
        } finally {
          this.sendSemaphore.tryRelease();
        }
      }
      /* @internal */
      enableSending() {
        this.sendSemaphore.tryRelease();
      }
      async sendEof(cancellation) {
        if (this.sentEof) {
          return;
        }
        await this.sendSemaphore.wait(cancellation);
        try {
          this.sentEof = true;
          const msg = new connectionMessages_1.ChannelEofMessage();
          msg.recipientChannel = this.remoteChannelId;
          await this.session.sendMessage(msg, cancellation);
        } finally {
          this.sendSemaphore.tryRelease();
        }
      }
      /* @internal */
      async handleRequest(request, cancellation) {
        if (!request.requestType) {
          throw new errors_1.SshConnectionError("Channel request type not specified.", transportMessages_1.SshDisconnectReason.protocolError);
        }
        if (request.requestType === connectionMessages_1.ChannelRequestType.exitStatus) {
          const signal = new connectionMessages_1.ChannelSignalMessage();
          request.convertTo(signal);
          this.exitStatus = signal.exitStatus;
          return true;
        } else if (request.requestType === connectionMessages_1.ChannelRequestType.exitSignal) {
          const signal = new connectionMessages_1.ChannelSignalMessage();
          request.convertTo(signal);
          this.exitSignal = signal.exitSignal;
          this.exitErrorMessage = signal.errorMessage;
          return true;
        } else if (request.requestType === connectionMessages_1.ChannelRequestType.signal) {
          const signal = new connectionMessages_1.ChannelSignalMessage();
          request.convertTo(signal);
        }
        const args = new sshRequestEventArgs_1.SshRequestEventArgs(request.requestType, request, this.session.principal, cancellation);
        const serviceType = (0, serviceActivation_1.findService)(this.session.config.services, (a) => (!a.channelType || a.channelType === this.channelType) && a.channelRequest === request.requestType);
        await this.sendSemaphore.wait(cancellation);
        try {
          let response = null;
          if (serviceType) {
            const service = this.session.activateService(serviceType);
            await service.onChannelRequest(this, args, cancellation);
          } else {
            this.requestEmitter.fire(args);
          }
          if (args.responsePromise) {
            response = await args.responsePromise;
            args.isAuthorized = response instanceof connectionMessages_1.ChannelSuccessMessage;
          }
          if (request.wantReply) {
            if (args.isAuthorized) {
              response = response !== null && response !== void 0 ? response : new connectionMessages_1.ChannelSuccessMessage();
              response.recipientChannel = this.remoteChannelId;
            } else {
              response = response !== null && response !== void 0 ? response : new connectionMessages_1.ChannelFailureMessage();
              response.recipientChannel = this.remoteChannelId;
            }
            await this.session.sendMessage(response, cancellation);
          }
        } finally {
          this.sendSemaphore.tryRelease();
        }
        return args.isAuthorized || false;
      }
      /* @internal */
      handleResponse(result) {
        const requestCompletionSource = this.requestCompletionSources.dequeue();
        if (requestCompletionSource) {
          requestCompletionSource.resolve(result);
        }
      }
      /* @internal */
      handleDataReceived(data) {
        this.metrics.addBytesReceived(data.length);
        this.dataReceivedEmitter.fire(data);
      }
      handleExtendedDataReceived(data) {
        this.metrics.addBytesReceived(data.data.length);
        this.extendedDataReceivedEmitter.fire(data);
      }
      /**
       * Adjusts the local receiving window size by the specified amount, notifying
       * the remote side that it is free to send more data.
       *
       * This method MUST be called either immediately or eventually by the
       * `onDataReceived` event handler as incoming data is processed.
       */
      adjustWindow(messageLength) {
        if (this.disposed)
          return;
        this.windowSize -= messageLength;
        if (this.windowSize <= this.maxWindowSizeValue / 2) {
          const windowAdjustMessage = new connectionMessages_1.ChannelWindowAdjustMessage();
          windowAdjustMessage.recipientChannel = this.remoteChannelId;
          windowAdjustMessage.bytesToAdd = this.maxWindowSizeValue - this.windowSize;
          this.windowSize = this.maxWindowSizeValue;
          this.session.sendMessage(windowAdjustMessage).catch((e) => {
            this.session.trace(trace_1.TraceLevel.Error, trace_1.SshTraceEventIds.channelWindowAdjustFailed, `Error sending window adjust message: ${e.message}`, e);
          });
        }
      }
      /* @internal */
      adjustRemoteWindow(bytesToAdd) {
        this.remoteWindowSize += bytesToAdd;
        if (this.openSendingWindowCompletionSource) {
          this.openSendingWindowCompletionSource.resolve(void 0);
        }
      }
      /* @internal */
      handleEof() {
        this.session.trace(trace_1.TraceLevel.Info, trace_1.SshTraceEventIds.channelEofReceived, `${this} EOF received.`);
        this.eofEmitter.fire();
      }
      close(exitStatusOrSignal, errorMessage, cancellation) {
        if (exitStatusOrSignal instanceof Error) {
          const error = exitStatusOrSignal;
          if (!this.localClosed) {
            this.localClosed = true;
            this.session.trace(trace_1.TraceLevel.Info, trace_1.SshTraceEventIds.channelClosed, `${this} Closed: ${error.message}`);
            this.closedEmitter.fire(new sshChannelClosedEventArgs_1.SshChannelClosedEventArgs(error));
          }
          this.disposeInternal();
          return;
        }
        if (typeof exitStatusOrSignal === "number") {
          return this.closeWithStatus(exitStatusOrSignal, errorMessage);
        } else if (typeof exitStatusOrSignal === "string") {
          return this.closeWithSignal(exitStatusOrSignal, errorMessage, cancellation);
        } else {
          return this.closeDefault(exitStatusOrSignal);
        }
      }
      async closeDefault(cancellation) {
        if (!this.remoteClosed && !this.localClosed) {
          this.remoteClosed = true;
          await this.sendSemaphore.wait(cancellation);
          try {
            const closeMessage = new connectionMessages_1.ChannelCloseMessage();
            closeMessage.recipientChannel = this.remoteChannelId;
            await this.session.sendMessage(closeMessage);
          } catch (e) {
          } finally {
            this.sendSemaphore.tryRelease();
          }
        }
        if (!this.localClosed) {
          this.localClosed = true;
          const closedMessage = this.raiseClosedEvent();
        }
        this.disposeInternal();
      }
      async closeWithStatus(exitStatus, cancellation) {
        if (!this.remoteClosed && !this.localClosed) {
          this.exitStatus = exitStatus;
          const signalMessage = new connectionMessages_1.ChannelSignalMessage();
          signalMessage.recipientChannel = this.remoteChannelId;
          signalMessage.exitStatus = exitStatus;
          await this.session.sendMessage(signalMessage);
        }
        await this.closeDefault(cancellation);
      }
      async closeWithSignal(exitSignal, errorMessage, cancellation) {
        if (!this.remoteClosed && !this.localClosed) {
          this.exitSignal = exitSignal;
          this.exitErrorMessage = errorMessage;
          const signalMessage = new connectionMessages_1.ChannelSignalMessage();
          signalMessage.recipientChannel = this.remoteChannelId;
          signalMessage.exitSignal = exitSignal;
          signalMessage.errorMessage = errorMessage;
          await this.session.sendMessage(signalMessage);
        }
        await this.closeDefault(cancellation);
      }
      /* @internal */
      handleClose() {
        if (!this.localClosed) {
          this.localClosed = true;
          const closedMessage = this.raiseClosedEvent(true);
        }
        this.disposeInternal();
      }
      raiseClosedEvent(closedByRemote = false) {
        const metricsMessage = ` (S: ${this.metrics.bytesSent}, R: ${this.metrics.bytesReceived})`;
        const originMessage = closedByRemote ? "remotely" : "locally";
        let closedMessage;
        let args;
        if (typeof this.exitStatus !== "undefined") {
          args = new sshChannelClosedEventArgs_1.SshChannelClosedEventArgs(this.exitStatus);
          closedMessage = `${this} closed ${originMessage}: status=${this.exitStatus}`;
        } else if (typeof this.exitSignal !== "undefined") {
          args = new sshChannelClosedEventArgs_1.SshChannelClosedEventArgs(this.exitSignal, this.exitErrorMessage);
          closedMessage = `${this} closed ${originMessage}: signal=${this.exitSignal} ${this.exitErrorMessage}`;
        } else {
          args = new sshChannelClosedEventArgs_1.SshChannelClosedEventArgs();
          closedMessage = `${this} closed ${originMessage}.`;
        }
        this.session.trace(trace_1.TraceLevel.Info, trace_1.SshTraceEventIds.channelClosed, closedMessage + metricsMessage);
        this.closedEmitter.fire(args);
        return closedMessage;
      }
      dispose() {
        if (!this.disposed && !this.localClosed) {
          if (!this.remoteClosed) {
            this.remoteClosed = true;
            const closeMessage = new connectionMessages_1.ChannelCloseMessage();
            closeMessage.recipientChannel = this.remoteChannelId;
            this.session.sendMessage(closeMessage).catch((e) => {
            });
          }
          const message = this.session.isClosed ? `${this.session} closed.` : `${this} disposed.`;
          this.session.trace(trace_1.TraceLevel.Info, trace_1.SshTraceEventIds.channelClosed, message);
          const args = new sshChannelClosedEventArgs_1.SshChannelClosedEventArgs("SIGABRT", message);
          this.localClosed = true;
          this.closedEmitter.fire(args);
        }
        this.disposeInternal();
      }
      disposeInternal() {
        if (this.disposed)
          return;
        this.disposed = true;
        this.cancelPendingRequests();
        this.connectionService.removeChannel(this);
        this.sendSemaphore.dispose();
      }
      /**
       * Pipes one SSH channel into another, relaying all data between them.
       * @param toChannel Channel to which the current channel will be connected via the pipe.
       * @returns A promise that resolves when the channels are closed.
       */
      pipe(toChannel) {
        return pipeExtensions_1.PipeExtensions.pipeChannel(this, toChannel);
      }
      cancelPendingRequests() {
        for (const completion of this.requestCompletionSources) {
          completion.resolve(false);
        }
      }
      toString() {
        return `SshChannel(Type: ${this.channelType}, Id: ${this.channelId}, RemoteId: ${this.remoteChannelId})`;
      }
    };
    exports2.SshChannel = SshChannel;
    SshChannel.sessionChannelType = "session";
    SshChannel.defaultMaxPacketSize = connectionMessages_1.ChannelOpenMessage.defaultMaxPacketSize;
    SshChannel.defaultMaxWindowSize = connectionMessages_1.ChannelOpenMessage.defaultMaxWindowSize;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/package.json
var require_package = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/package.json"(exports2, module2) {
    module2.exports = {
      name: "@microsoft/dev-tunnels-ssh",
      version: "3.12.12",
      description: "SSH library for Dev Tunnels",
      repository: "https://github.com/microsoft/dev-tunnels-ssh.git",
      keywords: [
        "SSH"
      ],
      author: "Microsoft",
      license: "MIT",
      dependencies: {
        buffer: "^5.2.1",
        debug: "^4.1.1",
        "diffie-hellman": "^5.0.3",
        "vscode-jsonrpc": "^4.0.0"
      },
      main: "./index.js"
    };
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/sshVersionInfo.js
var require_sshVersionInfo = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/sshVersionInfo.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SshVersionInfo = void 0;
    var packageJson = require_package();
    var packageName = packageJson.name.replace(/^@\w+\//, "");
    var packageVersion = packageJson.version;
    var SshVersionInfo = class _SshVersionInfo {
      /**
       * Attempts to parse an SSH version string into a version info object.
       */
      static tryParse(versionString) {
        if (!versionString) {
          throw new TypeError("Version string expected.");
        }
        if (!versionString.startsWith("SSH-")) {
          return null;
        }
        const firstDashIndex = 3;
        const secondDashIndex = versionString.indexOf("-", firstDashIndex + 1);
        if (secondDashIndex <= 0) {
          return null;
        }
        const protocolVersion = versionString.substring(firstDashIndex + 1, secondDashIndex);
        if (!/^\d+\.\d+$/.test(protocolVersion)) {
          return null;
        }
        let name;
        let version;
        const nameAndVersion = versionString.substring(secondDashIndex + 1);
        const spaceIndex = nameAndVersion.indexOf(" ");
        const lastUnderscoreBeforeSpace = nameAndVersion.lastIndexOf("_", spaceIndex >= 0 ? spaceIndex : nameAndVersion.length - 1);
        if (lastUnderscoreBeforeSpace >= 0) {
          name = nameAndVersion.substring(0, lastUnderscoreBeforeSpace).replace(/_/g, " ");
          version = nameAndVersion.substring(lastUnderscoreBeforeSpace + 1);
          for (let i = 0; i < version.length; i++) {
            const c = version[i];
            if (!(c >= "0" && c <= "9") && c !== ".") {
              version = version.substring(0, i);
              break;
            }
          }
          if (!/^\d+(\.\d+)*$/.test(version)) {
            version = null;
          }
        } else {
          name = nameAndVersion;
          version = null;
        }
        return new _SshVersionInfo(versionString, protocolVersion, name, version);
      }
      /**
       * Gets the version info for the current SSH library.
       */
      static getLocalVersion() {
        const protocolVersion = "2.0";
        const versionString = `SSH-${protocolVersion}-${packageName}_${packageVersion}`;
        return new _SshVersionInfo(versionString, protocolVersion, packageName, packageVersion);
      }
      constructor(versionString, protocolVersion, name, version) {
        this.versionString = versionString;
        this.protocolVersion = protocolVersion;
        this.name = name;
        this.version = version;
      }
      /** Returns the original SSH version string that was parsed. */
      toString() {
        return this.versionString;
      }
      /**
       * Gets a value indicating whether this version info represents some version of
       * this library.
       */
      get isVsSsh() {
        return this.isVsSshCS || this.isVsSshTS;
      }
      get isVsSshCS() {
        return this.name === "Microsoft.VisualStudio.Ssh" || this.name === "Microsoft.DevTunnels.Ssh";
      }
      get isVsSshTS() {
        return this.name === "vs-ssh" || this.name === "dev-tunnels-ssh";
      }
    };
    exports2.SshVersionInfo = SshVersionInfo;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/messages/kexMessages.js
var require_kexMessages = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/messages/kexMessages.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NewKeysMessage = exports2.KeyExchangeDhReplyMessage = exports2.KeyExchangeDhInitMessage = exports2.KeyExchangeInitMessage = exports2.KeyExchangeMessage = void 0;
    var buffer_1 = require("buffer");
    var sshMessage_1 = require_sshMessage();
    var sshAlgorithms_1 = require_sshAlgorithms();
    var KeyExchangeMessage = class extends sshMessage_1.SshMessage {
    };
    exports2.KeyExchangeMessage = KeyExchangeMessage;
    var keyExchangeInitCookieLength = 16;
    var KeyExchangeInitMessage = class _KeyExchangeInitMessage extends KeyExchangeMessage {
      get messageType() {
        return 20;
      }
      onRead(reader) {
        this.cookie = reader.read(keyExchangeInitCookieLength);
        this.keyExchangeAlgorithms = reader.readList("ascii");
        this.serverHostKeyAlgorithms = reader.readList("ascii");
        this.encryptionAlgorithmsClientToServer = reader.readList("ascii");
        this.encryptionAlgorithmsServerToClient = reader.readList("ascii");
        this.macAlgorithmsClientToServer = reader.readList("ascii");
        this.macAlgorithmsServerToClient = reader.readList("ascii");
        this.compressionAlgorithmsClientToServer = reader.readList("ascii");
        this.compressionAlgorithmsServerToClient = reader.readList("ascii");
        this.languagesClientToServer = reader.readList("ascii");
        this.languagesServerToClient = reader.readList("ascii");
        this.firstKexPacketFollows = reader.readBoolean();
        this.reserved = reader.readUInt32();
      }
      onWrite(writer) {
        var _a2;
        if (!this.cookie) {
          this.cookie = buffer_1.Buffer.alloc(keyExchangeInitCookieLength);
          sshAlgorithms_1.SshAlgorithms.random.getBytes(this.cookie);
        }
        writer.write(this.cookie);
        writer.writeList(this.keyExchangeAlgorithms || [], "ascii");
        writer.writeList(this.serverHostKeyAlgorithms || [], "ascii");
        writer.writeList(this.encryptionAlgorithmsClientToServer || [], "ascii");
        writer.writeList(this.encryptionAlgorithmsServerToClient || [], "ascii");
        writer.writeList(this.macAlgorithmsClientToServer || [], "ascii");
        writer.writeList(this.macAlgorithmsServerToClient || [], "ascii");
        writer.writeList(this.compressionAlgorithmsClientToServer || [], "ascii");
        writer.writeList(this.compressionAlgorithmsServerToClient || [], "ascii");
        writer.writeList(this.languagesClientToServer || [], "ascii");
        writer.writeList(this.languagesServerToClient || [], "ascii");
        writer.writeBoolean((_a2 = this.firstKexPacketFollows) !== null && _a2 !== void 0 ? _a2 : false);
        writer.writeUInt32(this.reserved || 0);
      }
      static CreateNone() {
        const noneArray = ["none"];
        const emptyArray = [""];
        const message = new _KeyExchangeInitMessage();
        message.cookie = buffer_1.Buffer.alloc(keyExchangeInitCookieLength);
        message.keyExchangeAlgorithms = noneArray;
        message.serverHostKeyAlgorithms = noneArray;
        message.encryptionAlgorithmsClientToServer = noneArray;
        message.encryptionAlgorithmsServerToClient = noneArray;
        message.macAlgorithmsClientToServer = noneArray;
        message.macAlgorithmsServerToClient = noneArray;
        message.compressionAlgorithmsClientToServer = noneArray;
        message.compressionAlgorithmsServerToClient = noneArray;
        message.languagesClientToServer = emptyArray;
        message.languagesServerToClient = emptyArray;
        message.rawBytes = message.toBuffer();
        return message;
      }
      get allowsNone() {
        const includesNone = (algorithms) => (algorithms === null || algorithms === void 0 ? void 0 : algorithms.includes("none")) === true;
        return includesNone(this.keyExchangeAlgorithms) && includesNone(this.serverHostKeyAlgorithms) && includesNone(this.encryptionAlgorithmsClientToServer) && includesNone(this.encryptionAlgorithmsServerToClient) && includesNone(this.macAlgorithmsClientToServer) && includesNone(this.macAlgorithmsServerToClient) && includesNone(this.compressionAlgorithmsClientToServer) && includesNone(this.compressionAlgorithmsServerToClient) && this.firstKexPacketFollows !== true;
      }
    };
    exports2.KeyExchangeInitMessage = KeyExchangeInitMessage;
    KeyExchangeInitMessage.none = KeyExchangeInitMessage.CreateNone();
    var KeyExchangeDhInitMessage = class extends KeyExchangeMessage {
      get messageType() {
        return 30;
      }
      onRead(reader) {
        this.e = reader.readBinary();
      }
      onWrite(writer) {
        writer.writeBinary(this.validateField(this.e, "E"));
      }
    };
    exports2.KeyExchangeDhInitMessage = KeyExchangeDhInitMessage;
    var KeyExchangeDhReplyMessage = class extends KeyExchangeMessage {
      get messageType() {
        return 31;
      }
      onRead(reader) {
        this.hostKey = reader.readBinary();
        this.f = reader.readBinary();
        this.signature = reader.readBinary();
      }
      onWrite(writer) {
        writer.writeBinary(this.validateField(this.hostKey, "host key"));
        writer.writeBinary(this.validateField(this.f, "F"));
        writer.writeBinary(this.validateField(this.signature, "signature"));
      }
    };
    exports2.KeyExchangeDhReplyMessage = KeyExchangeDhReplyMessage;
    var NewKeysMessage = class extends KeyExchangeMessage {
      get messageType() {
        return 21;
      }
      onRead(reader) {
      }
      onWrite(writer) {
      }
    };
    exports2.NewKeysMessage = NewKeysMessage;
    sshMessage_1.SshMessage.index.set(20, KeyExchangeInitMessage);
    sshMessage_1.SshMessage.index.set(30, KeyExchangeDhInitMessage);
    sshMessage_1.SshMessage.index.set(31, KeyExchangeDhReplyMessage);
    sshMessage_1.SshMessage.index.set(21, NewKeysMessage);
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/io/sshProtocol.js
var require_sshProtocol = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/io/sshProtocol.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SshProtocol = void 0;
    var buffer_1 = require("buffer");
    var queue_1 = require_queue();
    var semaphore_1 = require_semaphore();
    var sshMessage_1 = require_sshMessage();
    var sshData_1 = require_sshData();
    var transportMessages_1 = require_transportMessages();
    var kexMessages_1 = require_kexMessages();
    var connectionMessages_1 = require_connectionMessages();
    var errors_1 = require_errors();
    var trace_1 = require_trace();
    var SequencedMessage = class {
      constructor(sequence, message) {
        this.sequence = sequence;
        this.message = message;
      }
    };
    var SshProtocol = class _SshProtocol {
      constructor(stream, config, metrics, trace) {
        this.config = config;
        this.metrics = metrics;
        this.trace = trace;
        this.sessionSemaphore = new semaphore_1.Semaphore(1);
        this.inboundPacketSequence = 0;
        this.outboundPacketSequence = 0;
        this.inboundFlow = 0;
        this.outboundFlow = 0;
        this.recentSentMessages = new queue_1.Queue();
        this.sendWriter = new sshData_1.SshDataWriter(buffer_1.Buffer.alloc(1024));
        this.receiveWriter = new sshData_1.SshDataWriter(buffer_1.Buffer.alloc(1024));
        this.traceChannelData = false;
        this.extensions = null;
        this.kexService = null;
        this.algorithms = null;
        this.messageContext = null;
        this.outgoingMessagesHaveLatencyInfo = false;
        this.incomingMessagesHaveLatencyInfo = false;
        this.outgoingMessagesHaveReconnectInfo = false;
        this.incomingMessagesHaveReconnectInfo = false;
        this.stream = stream;
        this.traceChannelData = config.traceChannelData;
      }
      get lastIncomingSequence() {
        return this.inboundPacketSequence - 1;
      }
      getSentMessages(startingSequenceNumber) {
        if (startingSequenceNumber === this.outboundPacketSequence + 1) {
          return [];
        }
        if (this.recentSentMessages.size > 0 && startingSequenceNumber < this.recentSentMessages.peek().sequence) {
          return null;
        }
        const messagesToRetransmit = new Array();
        for (const sequencedMessage of this.recentSentMessages) {
          if (sequencedMessage.sequence >= startingSequenceNumber) {
            const message = sequencedMessage.message;
            if (!(message instanceof kexMessages_1.KeyExchangeMessage || message instanceof transportMessages_1.DisconnectMessage)) {
              messagesToRetransmit.push(message);
            }
          }
        }
        return messagesToRetransmit;
      }
      async writeProtocolVersion(version, cancellation) {
        const stream = this.stream;
        if (!stream)
          throw new Error("SSH session disconnected.");
        const data = buffer_1.Buffer.from(version + "\r\n");
        await stream.write(data, cancellation);
        this.metrics.addMessageSent(data.length);
        return Promise.resolve();
      }
      async readProtocolVersion(cancellation) {
        const stream = this.stream;
        if (!stream)
          throw new Error("SSH session disconnected.");
        const buffer = buffer_1.Buffer.alloc(255);
        let lineCount = 0;
        for (let i = 0; i < buffer.length; i++) {
          const byteBuffer = await stream.read(1, cancellation);
          if (!byteBuffer) {
            break;
          }
          buffer[i] = byteBuffer[0];
          const carriageReturn = 13;
          const lineFeed = 10;
          if (i > 0 && buffer[i - 1] === carriageReturn && buffer[i] === lineFeed) {
            const line = buffer.toString("utf8", 0, i - 1);
            if (line.startsWith("SSH-")) {
              this.metrics.addMessageReceived(i + 1);
              return line;
            } else if (lineCount > 20) {
              break;
            } else {
              lineCount++;
              i = -1;
            }
          }
        }
        throw new errors_1.SshConnectionError("Failed to read the protocol version", transportMessages_1.SshDisconnectReason.protocolError);
      }
      async handleNewKeys(cancellation) {
        try {
          await this.sessionSemaphore.wait(cancellation);
          this.inboundFlow = 0;
          this.outboundFlow = 0;
          this.algorithms = this.kexService.finishKeyExchange();
        } finally {
          this.sessionSemaphore.release();
        }
      }
      /**
       * Attempts to read from the stream until the buffer is full.
       * @returns True if the read succeeded, false if the stream was disposed.
       */
      async read(buffer, cancellation) {
        const stream = this.stream;
        if (!stream)
          return false;
        let bytesRead = 0;
        do {
          let data;
          try {
            data = await stream.read(buffer.length - bytesRead, cancellation);
          } catch (e) {
            if (!(e instanceof Error))
              throw e;
            if (stream.isDisposed)
              return false;
            stream.dispose();
            this.stream = null;
            this.trace(trace_1.TraceLevel.Error, trace_1.SshTraceEventIds.streamReadError, `Error reading from stream: ${e.message}`, e);
            throw new errors_1.SshConnectionError("Error reading from stream: " + e.message, transportMessages_1.SshDisconnectReason.connectionLost);
          }
          if (!data)
            return false;
          data.copy(buffer, bytesRead);
          bytesRead += data.length;
        } while (bytesRead < buffer.length);
        return true;
      }
      /**
       * Attempts to write data to the stream.
       * @returns True if the write succeeded, false if the stream was disposed.
       */
      async write(data, cancellation) {
        const stream = this.stream;
        if (!stream)
          return false;
        try {
          await stream.write(data, cancellation);
        } catch (e) {
          if (!(e instanceof Error))
            throw e;
          if (stream.isDisposed)
            return false;
          stream.dispose();
          this.stream = null;
          this.trace(trace_1.TraceLevel.Error, trace_1.SshTraceEventIds.streamWriteError, `Error writing to stream: ${e.message}`, e);
          throw new errors_1.SshConnectionError("Error writing to stream: " + e.message, transportMessages_1.SshDisconnectReason.connectionLost);
        }
        return true;
      }
      async considerReExchange(initial, cancellation) {
        const kexService = this.kexService;
        if (!kexService)
          return;
        let kexMessage = null;
        let kexGuessMessage = null;
        if (!kexService.exchanging && (initial || this.inboundFlow + this.outboundFlow > this.config.keyRotationThreshold)) {
          [kexMessage, kexGuessMessage] = await kexService.startKeyExchange(initial);
        }
        if (kexMessage) {
          await this.sendMessage(kexMessage, cancellation);
          if (kexGuessMessage) {
            await this.sendMessage(kexGuessMessage, cancellation);
          }
        }
      }
      async computeHmac(signer, payload, seq) {
        const writer = new sshData_1.SshDataWriter(buffer_1.Buffer.alloc(4 + payload.length));
        writer.writeUInt32(seq);
        writer.write(payload);
        const result = await signer.sign(writer.toBuffer());
        return result;
      }
      async verifyHmac(verifier, payload, seq, mac) {
        const writer = new sshData_1.SshDataWriter(buffer_1.Buffer.alloc(4 + payload.length));
        writer.writeUInt32(seq);
        writer.write(payload);
        const result = await verifier.verify(writer.toBuffer(), mac);
        return result;
      }
      async readAndVerifyHmac(verifier, data, macBuffer, cancellation) {
        if (!await this.read(macBuffer, cancellation)) {
          return false;
        }
        const verified = await this.verifyHmac(verifier, data, this.inboundPacketSequence, macBuffer);
        if (!verified) {
          throw new errors_1.SshConnectionError("Invalid MAC", transportMessages_1.SshDisconnectReason.macError);
        }
        return true;
      }
      /**
       * Attemps to write one message to the stream.
       * @returns `true` if writing succeeded, `false` if the stream was disposed.
       * @throws SshConnectionException if writing to the stream failed for any other reason.
       */
      async sendMessage(message, cancellation) {
        var _a2;
        const algorithms = this.algorithms;
        const compression = algorithms === null || algorithms === void 0 ? void 0 : algorithms.compressor;
        const encryption = algorithms === null || algorithms === void 0 ? void 0 : algorithms.cipher;
        const hmac = algorithms === null || algorithms === void 0 ? void 0 : algorithms.messageSigner;
        let result;
        await this.sessionSemaphore.wait(cancellation);
        try {
          const blockSize = encryption ? Math.max(8, encryption.blockLength) : 8;
          const payloadOffset = _SshProtocol.packetLengthSize + _SshProtocol.paddingLengthSize;
          this.sendWriter.position = payloadOffset;
          message.write(this.sendWriter);
          if (this.outgoingMessagesHaveReconnectInfo) {
            this.sendWriter.writeUInt64(this.lastIncomingSequence);
            if (this.outgoingMessagesHaveLatencyInfo) {
              const timeSinceLastReceivedMessage = Math.min(
                4294967295,
                // max uint32
                Math.round((this.metrics.time - this.lastIncomingTimestamp) * 1e3)
              );
              this.sendWriter.writeUInt32(timeSinceLastReceivedMessage);
            }
          }
          let payload = this.sendWriter.toBuffer().slice(payloadOffset);
          if (compression != null) {
            payload = compression.compress(payload);
          }
          const isLengthEncrypted = !((hmac === null || hmac === void 0 ? void 0 : hmac.encryptThenMac) || (hmac === null || hmac === void 0 ? void 0 : hmac.authenticatedEncryption));
          let paddingLength = blockSize - ((isLengthEncrypted ? _SshProtocol.packetLengthSize : 0) + _SshProtocol.paddingLengthSize + payload.length) % blockSize;
          if (paddingLength < 4) {
            paddingLength += blockSize;
          }
          const packetLength = _SshProtocol.paddingLengthSize + payload.length + paddingLength;
          this.sendWriter.position = 0;
          this.sendWriter.writeUInt32(packetLength);
          this.sendWriter.writeByte(paddingLength);
          if (compression != null) {
            this.sendWriter.write(payload);
          } else {
            this.sendWriter.position += payload.length;
          }
          this.sendWriter.writeRandom(paddingLength);
          payload = this.sendWriter.toBuffer();
          let mac = null;
          if ((hmac === null || hmac === void 0 ? void 0 : hmac.encryptThenMac) && encryption) {
            const packetWithoutLength = payload.slice(_SshProtocol.packetLengthSize, payload.length);
            const encryptedPacket = await encryption.transform(packetWithoutLength);
            encryptedPacket.copy(packetWithoutLength);
            mac = await this.computeHmac(hmac, payload, this.outboundPacketSequence);
          } else if (hmac === null || hmac === void 0 ? void 0 : hmac.authenticatedEncryption) {
            const packetWithoutLength = payload.slice(_SshProtocol.packetLengthSize, payload.length);
            const encryptedPacket = await encryption.transform(packetWithoutLength);
            encryptedPacket.copy(packetWithoutLength);
            mac = await hmac.sign(packetWithoutLength);
          } else {
            if (hmac) {
              mac = await this.computeHmac(hmac, payload, this.outboundPacketSequence);
            }
            if (encryption) {
              payload = await encryption.transform(payload);
            }
          }
          if (!(message instanceof connectionMessages_1.ChannelDataMessage)) {
            this.trace(trace_1.TraceLevel.Verbose, trace_1.SshTraceEventIds.sendingMessage, `Sending #${this.outboundPacketSequence} ${message}`);
          } else if (this.traceChannelData) {
            this.trace(trace_1.TraceLevel.Verbose, trace_1.SshTraceEventIds.sendingChannelData, `Sending #${this.outboundPacketSequence} ${message}`);
          }
          if (this.incomingMessagesHaveReconnectInfo) {
            const sequencedMessage = new SequencedMessage(this.outboundPacketSequence, message);
            sequencedMessage.sentTime = this.metrics.time;
            this.recentSentMessages.enqueue(sequencedMessage);
          }
          this.outboundPacketSequence++;
          this.outboundFlow += packetLength;
          if (mac) {
            const packet = buffer_1.Buffer.concat([payload, mac], payload.length + mac.length);
            result = await this.write(packet, cancellation);
          } else {
            result = await this.write(payload, cancellation);
          }
          this.metrics.addMessageSent(_SshProtocol.packetLengthSize + packetLength + ((_a2 = hmac === null || hmac === void 0 ? void 0 : hmac.digestLength) !== null && _a2 !== void 0 ? _a2 : 0));
        } finally {
          this.sessionSemaphore.release();
        }
        await this.considerReExchange(false, cancellation);
        return result;
      }
      /**
       * Attemps to read one message from the stream.
       * @returns The message, or `null` if the stream was disposed.
       * @throws SshConnectionError if reading from the stream failed for any other reason.
       */
      async receiveMessage(cancellation) {
        var _a2;
        const algorithms = this.algorithms;
        const encryption = algorithms === null || algorithms === void 0 ? void 0 : algorithms.decipher;
        const hmac = algorithms === null || algorithms === void 0 ? void 0 : algorithms.messageVerifier;
        const compression = algorithms === null || algorithms === void 0 ? void 0 : algorithms.decompressor;
        const isLengthEncrypted = !((hmac === null || hmac === void 0 ? void 0 : hmac.encryptThenMac) || (hmac === null || hmac === void 0 ? void 0 : hmac.authenticatedEncryption));
        const firstBlockSize = !isLengthEncrypted ? _SshProtocol.packetLengthSize : encryption ? Math.max(8, encryption.blockLength) : 8;
        this.receiveWriter.position = firstBlockSize;
        let firstBlock = this.receiveWriter.toBuffer();
        if (!await this.read(firstBlock, cancellation)) {
          return null;
        }
        this.lastIncomingTimestamp = this.metrics.time;
        if (encryption && isLengthEncrypted) {
          firstBlock = await encryption.transform(firstBlock);
          this.receiveWriter.position = 0;
          this.receiveWriter.write(firstBlock);
        }
        const receiveReader = new sshData_1.SshDataReader(firstBlock);
        const packetLength = receiveReader.readUInt32();
        if (packetLength > _SshProtocol.maxPacketLength) {
          throw new errors_1.SshConnectionError("Invalid packet length.", transportMessages_1.SshDisconnectReason.protocolError);
        }
        const packetBufferSize = _SshProtocol.packetLengthSize + packetLength;
        if (packetBufferSize > firstBlockSize) {
          this.receiveWriter.skip(packetBufferSize - firstBlockSize);
        }
        if (hmac) {
          this.receiveWriter.skip(hmac.digestLength);
        }
        const receiveBuffer = this.receiveWriter.toBuffer();
        const packetBuffer = receiveBuffer.slice(0, packetBufferSize);
        const macBuffer = receiveBuffer.slice(packetBufferSize);
        let followingBlocks = packetBuffer.slice(firstBlockSize, packetBufferSize);
        if (followingBlocks.length > 0) {
          if (!await this.read(followingBlocks, cancellation)) {
            return null;
          }
          if (hmac === null || hmac === void 0 ? void 0 : hmac.encryptThenMac) {
            if (!await this.readAndVerifyHmac(hmac, packetBuffer, macBuffer, cancellation)) {
              return null;
            }
          }
          if (encryption) {
            if (hmac === null || hmac === void 0 ? void 0 : hmac.authenticatedEncryption) {
              if (!await this.read(macBuffer, cancellation)) {
                return null;
              }
              await hmac.verify(followingBlocks, macBuffer);
            }
            try {
              followingBlocks = await encryption.transform(followingBlocks);
            } catch (e) {
              if (hmac === null || hmac === void 0 ? void 0 : hmac.authenticatedEncryption) {
                throw new errors_1.SshConnectionError("Invalid MAC", transportMessages_1.SshDisconnectReason.macError);
              } else {
                throw e;
              }
            }
            this.receiveWriter.position = firstBlockSize;
            this.receiveWriter.write(followingBlocks);
          }
        }
        if (hmac && !hmac.encryptThenMac && !hmac.authenticatedEncryption) {
          if (!await this.readAndVerifyHmac(hmac, packetBuffer, macBuffer, cancellation)) {
            return null;
          }
        }
        const paddingLength = packetBuffer[_SshProtocol.packetLengthSize];
        let payload = packetBuffer.slice(_SshProtocol.packetLengthSize + _SshProtocol.paddingLengthSize, _SshProtocol.packetLengthSize + (packetLength - paddingLength));
        if (compression) {
          payload = compression.decompress(payload);
        }
        if (this.incomingMessagesHaveReconnectInfo) {
          let lastSequenceSeenByRemote;
          let remoteTimeSinceLastReceived;
          if (this.incomingMessagesHaveLatencyInfo) {
            const reader = new sshData_1.SshDataReader(payload.slice(payload.length - 12, payload.length));
            lastSequenceSeenByRemote = reader.readUInt64();
            remoteTimeSinceLastReceived = reader.readUInt32() / 1e3;
            payload = payload.slice(0, payload.length - 12);
          } else {
            const reader = new sshData_1.SshDataReader(payload.slice(payload.length - 8, payload.length));
            lastSequenceSeenByRemote = reader.readUInt64();
            remoteTimeSinceLastReceived = 0;
            payload = payload.slice(0, payload.length - 8);
          }
          while (this.recentSentMessages.size > 0) {
            const oldestSequenceMessage = this.recentSentMessages.peek();
            if (oldestSequenceMessage.sequence > lastSequenceSeenByRemote) {
              break;
            }
            if (this.stream && this.incomingMessagesHaveLatencyInfo && oldestSequenceMessage.sequence === lastSequenceSeenByRemote) {
              const timeSinceSent = this.lastIncomingTimestamp - oldestSequenceMessage.sentTime;
              const roundTripLatency = timeSinceSent - remoteTimeSinceLastReceived;
              this.metrics.updateLatency(roundTripLatency, this.trace);
            }
            this.recentSentMessages.dequeue();
          }
        }
        const messageType = payload[0];
        let message = sshMessage_1.SshMessage.create(this.config, messageType, this.messageContext, payload);
        if (!message) {
          const unimplementedMessage = new transportMessages_1.UnimplementedMessage();
          unimplementedMessage.sequenceNumber = this.inboundPacketSequence;
          unimplementedMessage.unimplementedMessageType = messageType;
          message = unimplementedMessage;
        }
        if (!(message instanceof connectionMessages_1.ChannelDataMessage)) {
          this.trace(trace_1.TraceLevel.Verbose, trace_1.SshTraceEventIds.receivingMessage, `Receiving #${this.inboundPacketSequence} ${message}`);
        } else if (this.traceChannelData) {
          this.trace(trace_1.TraceLevel.Verbose, trace_1.SshTraceEventIds.receivingChannelData, `Receiving #${this.inboundPacketSequence} ${message}`);
        }
        await this.sessionSemaphore.wait(cancellation);
        this.inboundPacketSequence++;
        this.inboundFlow += packetLength;
        this.sessionSemaphore.release();
        this.metrics.addMessageReceived(_SshProtocol.packetLengthSize + packetLength + ((_a2 = hmac === null || hmac === void 0 ? void 0 : hmac.digestLength) !== null && _a2 !== void 0 ? _a2 : 0));
        await this.considerReExchange(false, cancellation);
        return message;
      }
      dispose() {
        try {
          if (this.stream)
            this.stream.close().catch((e) => {
              this.trace(trace_1.TraceLevel.Error, trace_1.SshTraceEventIds.streamCloseError, `Error closing stream: ${e.message}`, e);
            });
        } catch (e) {
          if (!(e instanceof Error))
            throw e;
          this.trace(trace_1.TraceLevel.Error, trace_1.SshTraceEventIds.streamCloseError, `Error closing stream: ${e.message}`, e);
        }
        this.stream = null;
        this.metrics.updateLatency(0);
        if (this.algorithms)
          this.algorithms.dispose();
      }
    };
    exports2.SshProtocol = SshProtocol;
    SshProtocol.maxPacketLength = 1024 * 1024;
    SshProtocol.packetLengthSize = 4;
    SshProtocol.paddingLengthSize = 1;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/services/sshService.js
var require_sshService = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/services/sshService.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SshService = void 0;
    var vscode_jsonrpc_1 = require_main();
    var sshSession_1 = require_sshSession();
    var SshService = class {
      constructor(session) {
        this.session = session;
        this.disposed = false;
        this.disposedEmitter = new vscode_jsonrpc_1.Emitter();
        this.onDisposed = this.disposedEmitter.event;
        if (!(session instanceof sshSession_1.SshSession)) {
          throw new TypeError("Session is not an instance of SshSession. (This may be due to a version mismatch between SSH packages.)");
        }
      }
      get trace() {
        return this.session.trace;
      }
      raiseReportProgress(progress) {
        this.session.raiseReportProgress(progress);
      }
      dispose() {
        if (this.disposed)
          return;
        this.disposed = true;
        this.disposedEmitter.fire();
      }
      /**
       * Services that are activated via session requests must override this method to handle
       * incoming session requests.
       *
       * Implementations must set `SshRequestEventArgs.isAuthorized` or
       * `SshRequestEventArgs.responsePromise` to indicate whether the request was allowed.
       */
      async onSessionRequest(request, cancellation) {
        this.session.raiseSessionRequest(request);
      }
      /**
       * Services that are activated via channel types must override this method to handle
       * incoming requests to open a channel.
       *
       * Implementations may set `SshChannelOpeningEventArgs.failureReason` or
       * `SshChannelOpeningEventArgs.openingPromise` to block opening of the channel.
       * The default behavior allows the channel to open.
       *
       * Requests on the opened channel will not be directed to `onChannelRequest`
       * unless the service also declares activation on specific channel request(s). Otherwise,
       * an implementation of this method may add any event-handlers to the
       * `SshChannelOpeningEventArgs.channel` including a request event handler.
       */
      async onChannelOpening(request, cancellation) {
        if (!request)
          throw new TypeError("Request is required.");
        return this.session.handleChannelOpening(request, cancellation, false);
      }
      /**
       * Services that are activated via channel requests must override this method to handle
       * incoming channel requests.
       *
       * Implementations must set `SshRequestEventArgs.isAuthorized` or
       * `SshRequestEventArgs.responsePromise` to indicate whether the request was allowed.
       */
      async onChannelRequest(channel, request, cancellation) {
      }
      /**
       * Sends any message.
       */
      async sendMessage(message, cancellation) {
        await this.session.sendMessage(message, cancellation);
      }
    };
    exports2.SshService = SshService;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/events/sshChannelOpeningEventArgs.js
var require_sshChannelOpeningEventArgs = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/events/sshChannelOpeningEventArgs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SshChannelOpeningEventArgs = void 0;
    var connectionMessages_1 = require_connectionMessages();
    var vscode_jsonrpc_1 = require_main();
    var SshChannelOpeningEventArgs = class {
      constructor(request, channel, isRemoteRequest, cancellation) {
        this.request = request;
        this.channel = channel;
        this.isRemoteRequest = isRemoteRequest;
        this.failureReason = connectionMessages_1.SshChannelOpenFailureReason.none;
        this.failureDescription = null;
        if (!request)
          throw new TypeError("A channel open message is required.");
        if (!channel)
          throw new TypeError("A channel is required.");
        this.cancellationValue = cancellation !== null && cancellation !== void 0 ? cancellation : vscode_jsonrpc_1.CancellationToken.None;
      }
      /**
       * Gets a token that is cancelled if the session ends before the request handler
       * completes.
       */
      get cancellation() {
        return this.cancellationValue;
      }
      /* @internal */
      set cancellation(value) {
        this.cancellationValue = value;
      }
      toString() {
        return `${this.channel.toString()}${this.failureReason ? " " + connectionMessages_1.SshChannelOpenFailureReason[this.failureReason] : ""}`;
      }
    };
    exports2.SshChannelOpeningEventArgs = SshChannelOpeningEventArgs;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/events/sshExtendedDataEventArgs.js
var require_sshExtendedDataEventArgs = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/events/sshExtendedDataEventArgs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SshExtendedDataEventArgs = exports2.SshExtendedDataType = void 0;
    var SshExtendedDataType;
    (function(SshExtendedDataType2) {
      SshExtendedDataType2[SshExtendedDataType2["STDERR"] = 1] = "STDERR";
    })(SshExtendedDataType = exports2.SshExtendedDataType || (exports2.SshExtendedDataType = {}));
    var SshExtendedDataEventArgs = class {
      constructor(dataTypeCode, data) {
        this.dataTypeCode = dataTypeCode;
        this.data = data;
      }
      toString() {
        return `${SshExtendedDataType[this.dataTypeCode]}: ${this.data.toString()}`;
      }
    };
    exports2.SshExtendedDataEventArgs = SshExtendedDataEventArgs;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/services/connectionService.js
var require_connectionService = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/services/connectionService.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var ConnectionService_1;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConnectionService = void 0;
    var sshService_1 = require_sshService();
    var connectionMessages_1 = require_connectionMessages();
    var promiseCompletionSource_1 = require_promiseCompletionSource();
    var sshChannel_1 = require_sshChannel();
    var cancellation_1 = require_cancellation2();
    var errors_1 = require_errors();
    var sshChannelOpeningEventArgs_1 = require_sshChannelOpeningEventArgs();
    var serviceActivation_1 = require_serviceActivation();
    var trace_1 = require_trace();
    var sshExtendedDataEventArgs_1 = require_sshExtendedDataEventArgs();
    var ConnectionService = ConnectionService_1 = class ConnectionService extends sshService_1.SshService {
      constructor(session) {
        super(session);
        this.channelCounter = 0;
        this.channelMap = /* @__PURE__ */ new Map();
        this.nonAcceptedChannels = /* @__PURE__ */ new Map();
        this.pendingChannels = /* @__PURE__ */ new Map();
        this.pendingAcceptChannels = /* @__PURE__ */ new Map();
      }
      get channels() {
        return Array.from(this.channelMap.values());
      }
      close(e) {
        let channelCompletions = [...this.pendingChannels.values()].map((pc) => pc.completionSource);
        if (this.pendingAcceptChannels.size > 0) {
          channelCompletions = channelCompletions.concat([...this.pendingAcceptChannels.values()].reduce((a, b) => a.concat(b)));
        }
        for (const channel of this.channelMap.values()) {
          channel.close(e);
        }
        for (const channelCompletion of channelCompletions) {
          channelCompletion.reject(e);
        }
      }
      dispose() {
        const channels = [...this.channelMap.values()];
        let channelCompletions = [...this.pendingChannels.values()].map((pc) => pc.completionSource);
        if (this.pendingAcceptChannels.size > 0) {
          channelCompletions = channelCompletions.concat([...this.pendingAcceptChannels.values()].reduce((a, b) => a.concat(b)));
        }
        for (const channel of channels) {
          channel.dispose();
        }
        for (const channelCompletion of channelCompletions) {
          channelCompletion.reject(new errors_1.ObjectDisposedError("Session closed."));
        }
        super.dispose();
      }
      async acceptChannel(channelType, cancellation) {
        const completionSource = new promiseCompletionSource_1.PromiseCompletionSource();
        let cancellationRegistration;
        if (cancellation) {
          if (cancellation.isCancellationRequested)
            throw new cancellation_1.CancellationError();
          cancellationRegistration = cancellation.onCancellationRequested(() => {
            const list = this.pendingAcceptChannels.get(channelType);
            if (list) {
              const index = list.findIndex((item) => Object.is(item, completionSource));
              if (index >= 0) {
                list.splice(index, 1);
              }
            }
            completionSource.reject(new cancellation_1.CancellationError());
          });
        }
        let channel = null;
        channel = Array.from(this.nonAcceptedChannels.values()).find((c) => c.channelType === channelType) || null;
        if (channel) {
          this.nonAcceptedChannels.delete(channel.channelId);
        } else {
          let list = this.pendingAcceptChannels.get(channelType);
          if (!list) {
            list = [];
            this.pendingAcceptChannels.set(channelType, list);
          }
          list.push(completionSource);
        }
        try {
          return channel || await completionSource.promise;
        } finally {
          if (cancellationRegistration)
            cancellationRegistration.dispose();
        }
      }
      async openChannel(openMessage, completionSource, cancellation) {
        const channelId = ++this.channelCounter;
        openMessage.senderChannel = channelId;
        let cancellationRegistration = null;
        if (cancellation) {
          if (cancellation.isCancellationRequested)
            throw new cancellation_1.CancellationError();
          cancellationRegistration = cancellation.onCancellationRequested(() => {
            if (this.pendingChannels.delete(channelId)) {
              completionSource.reject(new cancellation_1.CancellationError());
            }
          });
        }
        this.pendingChannels.set(channelId, {
          openMessage,
          completionSource,
          cancellationRegistration
        });
        await this.session.sendMessage(openMessage);
        return channelId;
      }
      handleMessage(message, cancellation) {
        if (message instanceof connectionMessages_1.ChannelDataMessage) {
          return this.handleDataMessage(message);
        } else if (message instanceof connectionMessages_1.ChannelExtendedDataMessage) {
          return this.handleExtendedDataMessage(message);
        } else if (message instanceof connectionMessages_1.ChannelWindowAdjustMessage) {
          return this.handleAdjustWindowMessage(message);
        } else if (message instanceof connectionMessages_1.ChannelEofMessage) {
          return this.handleEofMessage(message);
        } else if (message instanceof connectionMessages_1.ChannelOpenMessage) {
          return this.handleOpenMessage(message, cancellation);
        } else if (message instanceof connectionMessages_1.ChannelCloseMessage) {
          return this.handleCloseMessage(message);
        } else if (message instanceof connectionMessages_1.ChannelOpenConfirmationMessage) {
          return this.handleOpenConfirmationMessage(message, cancellation);
        } else if (message instanceof connectionMessages_1.ChannelOpenFailureMessage) {
          return this.handleOpenFailureMessage(message);
        } else if (message instanceof connectionMessages_1.ChannelRequestMessage) {
          return this.handleRequestMessage(message, cancellation);
        } else if (message instanceof connectionMessages_1.ChannelSuccessMessage) {
          return this.handleSuccessMessage(message);
        } else if (message instanceof connectionMessages_1.ChannelFailureMessage) {
          return this.handleFailureMessage(message);
        } else {
          throw new Error(`Message not implemented: ${message}`);
        }
      }
      async handleOpenMessage(message, cancellation) {
        var _a2;
        const senderChannel = message.senderChannel;
        if (!this.session.canAcceptRequests) {
          this.trace(trace_1.TraceLevel.Warning, trace_1.SshTraceEventIds.channelOpenFailed, "Channel open request blocked because the session is not yet authenticated.");
          const openFailureMessage = new connectionMessages_1.ChannelOpenFailureMessage();
          openFailureMessage.recipientChannel = senderChannel;
          openFailureMessage.reasonCode = connectionMessages_1.SshChannelOpenFailureReason.administrativelyProhibited;
          openFailureMessage.description = "Authenticate before opening channels.";
          await this.session.sendMessage(openFailureMessage, cancellation);
          return;
        } else if (!message.channelType) {
          const openFailureMessage = new connectionMessages_1.ChannelOpenFailureMessage();
          openFailureMessage.recipientChannel = senderChannel;
          openFailureMessage.reasonCode = connectionMessages_1.SshChannelOpenFailureReason.unknownChannelType;
          openFailureMessage.description = "Channel type not specified.";
          await this.session.sendMessage(openFailureMessage, cancellation);
          return;
        }
        message = message.convertTo(new connectionMessages_1.ChannelOpenMessage(), true);
        let confirmationMessage = new connectionMessages_1.ChannelOpenConfirmationMessage();
        const channelId = ++this.channelCounter;
        const channel = new sshChannel_1.SshChannel(this, message.channelType, channelId, senderChannel, message.maxWindowSize, message.maxPacketSize, message, confirmationMessage);
        let responseMessage;
        const args = new sshChannelOpeningEventArgs_1.SshChannelOpeningEventArgs(message, channel, true);
        try {
          await this.session.handleChannelOpening(args, cancellation);
          if (args.openingPromise) {
            responseMessage = await args.openingPromise;
          } else if (args.failureReason !== connectionMessages_1.SshChannelOpenFailureReason.none) {
            const failureMessage = new connectionMessages_1.ChannelOpenFailureMessage();
            failureMessage.reasonCode = args.failureReason;
            failureMessage.description = (_a2 = args.failureDescription) !== null && _a2 !== void 0 ? _a2 : void 0;
            responseMessage = failureMessage;
          } else {
            responseMessage = confirmationMessage;
          }
        } catch (e) {
          channel.dispose();
          throw e;
        }
        if (responseMessage instanceof connectionMessages_1.ChannelOpenFailureMessage) {
          responseMessage.recipientChannel = senderChannel;
          try {
            await this.session.sendMessage(responseMessage, cancellation);
          } finally {
            channel.dispose();
          }
          return;
        }
        if (this.session.isClosed) {
          channel.dispose();
          return;
        }
        channel.isMaxWindowSizeLocked = true;
        this.channelMap.set(channel.channelId, channel);
        confirmationMessage = responseMessage;
        confirmationMessage.recipientChannel = channel.remoteChannelId;
        confirmationMessage.senderChannel = channel.channelId;
        confirmationMessage.maxWindowSize = channel.maxWindowSize;
        confirmationMessage.maxPacketSize = channel.maxPacketSize;
        confirmationMessage.rewrite();
        channel.openConfirmationMessage = confirmationMessage;
        await this.session.sendMessage(confirmationMessage, cancellation);
        let accepted = false;
        const list = this.pendingAcceptChannels.get(channel.channelType);
        while (list && list.length > 0) {
          const acceptCompletionSource = list.shift();
          acceptCompletionSource.resolve(channel);
          accepted = true;
          break;
        }
        if (!accepted) {
          this.nonAcceptedChannels.set(channel.channelId, channel);
        }
        this.onChannelOpenCompleted(channel.channelId, channel);
        channel.enableSending();
      }
      handleCloseMessage(message) {
        const channel = this.findChannelById(message.recipientChannel);
        if (channel) {
          channel.handleClose();
        }
      }
      async handleOpenConfirmationMessage(message, cancellation) {
        var _a2;
        let completionSource = null;
        let openMessage;
        const pendingChannel = this.pendingChannels.get(message.recipientChannel);
        if (pendingChannel) {
          openMessage = pendingChannel.openMessage;
          completionSource = pendingChannel.completionSource;
          if (pendingChannel.cancellationRegistration) {
            pendingChannel.cancellationRegistration.dispose();
          }
          this.pendingChannels.delete(message.recipientChannel);
        } else if (this.channelMap.has(message.recipientChannel)) {
          throw new Error("Duplicate channel ID.");
        } else {
          throw new Error("Channel confirmation was not requested.");
        }
        message = message.convertTo(new connectionMessages_1.ChannelOpenConfirmationMessage(), true);
        const channel = new sshChannel_1.SshChannel(this, openMessage.channelType || sshChannel_1.SshChannel.sessionChannelType, message.recipientChannel, message.senderChannel, message.maxWindowSize, message.maxPacketSize, openMessage, message);
        if (typeof openMessage.maxWindowSize === "number") {
          channel.maxWindowSize = openMessage.maxWindowSize;
        }
        channel.isMaxWindowSizeLocked = true;
        this.channelMap.set(channel.channelId, channel);
        const args = new sshChannelOpeningEventArgs_1.SshChannelOpeningEventArgs(openMessage, channel, false);
        await this.session.handleChannelOpening(args, cancellation);
        if (completionSource) {
          if (args.failureReason === connectionMessages_1.SshChannelOpenFailureReason.none) {
            completionSource.resolve(channel);
          } else {
            completionSource.reject(new errors_1.SshChannelError((_a2 = args.failureDescription) !== null && _a2 !== void 0 ? _a2 : "Channel open failure.", args.failureReason));
            return;
          }
        } else {
          this.onChannelOpenCompleted(channel.channelId, channel);
        }
        channel.enableSending();
      }
      handleOpenFailureMessage(message) {
        let completionSource = null;
        const pendingChannel = this.pendingChannels.get(message.recipientChannel);
        if (pendingChannel) {
          completionSource = pendingChannel.completionSource;
          if (pendingChannel.cancellationRegistration) {
            pendingChannel.cancellationRegistration.dispose();
          }
          this.pendingChannels.delete(message.recipientChannel);
        }
        if (completionSource != null) {
          completionSource.reject(new errors_1.SshChannelError(message.description || "Channel open rejected.", message.reasonCode));
        } else {
          this.onChannelOpenCompleted(message.recipientChannel, null);
        }
      }
      async handleRequestMessage(message, cancellation) {
        const channel = this.tryGetChannelForMessage(message);
        if (!channel)
          return;
        await channel.handleRequest(message, cancellation);
      }
      handleSuccessMessage(message) {
        const channel = this.tryGetChannelForMessage(message);
        channel === null || channel === void 0 ? void 0 : channel.handleResponse(true);
      }
      handleFailureMessage(message) {
        const channel = this.tryGetChannelForMessage(message);
        channel === null || channel === void 0 ? void 0 : channel.handleResponse(false);
      }
      handleDataMessage(message) {
        const channel = this.tryGetChannelForMessage(message);
        channel === null || channel === void 0 ? void 0 : channel.handleDataReceived(message.data);
      }
      handleExtendedDataMessage(message) {
        const channel = this.tryGetChannelForMessage(message);
        channel === null || channel === void 0 ? void 0 : channel.handleExtendedDataReceived(new sshExtendedDataEventArgs_1.SshExtendedDataEventArgs(message.dataTypeCode, message.data));
      }
      handleAdjustWindowMessage(message) {
        const channel = this.tryGetChannelForMessage(message);
        channel === null || channel === void 0 ? void 0 : channel.adjustRemoteWindow(message.bytesToAdd);
      }
      handleEofMessage(message) {
        const channel = this.findChannelById(message.recipientChannel);
        channel === null || channel === void 0 ? void 0 : channel.handleEof();
      }
      onChannelOpenCompleted(channelId, channel) {
        if (channel) {
          this.trace(trace_1.TraceLevel.Info, trace_1.SshTraceEventIds.channelOpened, `${this.session} ChannelOpenCompleted(${channel})`);
        } else {
          this.trace(trace_1.TraceLevel.Warning, trace_1.SshTraceEventIds.channelOpenFailed, `${this.session} ChannelOpenCompleted(${channelId} failed)`);
        }
      }
      /**
       * Gets the channel object based on the message `recipientChannel` property.
       * Logs a warning if the channel was not found.
       */
      tryGetChannelForMessage(channelMessage) {
        const channel = this.findChannelById(channelMessage.recipientChannel);
        if (!channel) {
          const messageString = channelMessage instanceof connectionMessages_1.ChannelDataMessage ? "channel data message" : channelMessage.toString();
          this.trace(trace_1.TraceLevel.Warning, trace_1.SshTraceEventIds.channelRequestFailed, `Invalid channel ID ${channelMessage.recipientChannel} in ${messageString}.`);
        }
        return channel;
      }
      findChannelById(id) {
        var _a2;
        const channel = (_a2 = this.channelMap.get(id)) !== null && _a2 !== void 0 ? _a2 : null;
        return channel;
      }
      /* @internal */
      removeChannel(channel) {
        this.channelMap.delete(channel.channelId);
        this.pendingChannels.delete(channel.channelId);
      }
    };
    ConnectionService.serviceName = "ssh-connection";
    ConnectionService = ConnectionService_1 = __decorate([
      (0, serviceActivation_1.serviceActivation)({ serviceRequest: ConnectionService_1.serviceName })
    ], ConnectionService);
    exports2.ConnectionService = ConnectionService;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/messages/authenticationMessages.js
var require_authenticationMessages = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/messages/authenticationMessages.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AuthenticationSuccessMessage = exports2.AuthenticationFailureMessage = exports2.PasswordRequestMessage = exports2.PublicKeyOKMessage = exports2.AuthenticationInfoResponseMessage = exports2.AuthenticationInfoRequestMessage = exports2.PublicKeyRequestMessage = exports2.AuthenticationRequestMessage = exports2.AuthenticationMessage = void 0;
    var sshMessage_1 = require_sshMessage();
    var AuthenticationMessage = class extends sshMessage_1.SshMessage {
    };
    exports2.AuthenticationMessage = AuthenticationMessage;
    var AuthenticationRequestMessage = class extends AuthenticationMessage {
      get messageType() {
        return 50;
      }
      onRead(reader) {
        this.username = reader.readString("utf8");
        this.serviceName = reader.readString("ascii");
        this.methodName = reader.readString("ascii");
      }
      onWrite(writer) {
        writer.writeString(this.username || "", "utf8");
        writer.writeString(this.serviceName || "", "ascii");
        writer.writeString(this.validateField(this.methodName, "method name"), "ascii");
      }
      toString() {
        return super.toString() + ` (Method: ${this.methodName}, Username: ${this.username})`;
      }
    };
    exports2.AuthenticationRequestMessage = AuthenticationRequestMessage;
    var PublicKeyRequestMessage = class extends AuthenticationRequestMessage {
      constructor() {
        super();
        this.methodName = "publickey";
      }
      get hasSignature() {
        return this.signature && this.signature.length > 0 ? true : false;
      }
      onRead(reader) {
        super.onRead(reader);
        const hasSignature = reader.readBoolean();
        this.keyAlgorithmName = reader.readString("ascii");
        this.publicKey = reader.readBinary();
        if (hasSignature) {
          this.signature = reader.readBinary();
          this.payloadWithoutSignature = this.rawBytes.slice(0, this.rawBytes.length - this.signature.length - 4);
        } else {
          this.signature = void 0;
        }
      }
      onWrite(writer) {
        var _a2, _b;
        super.onWrite(writer);
        if (!this.keyAlgorithmName)
          throw new Error("Key algorithm name not set.");
        if (this.methodName === "hostbased") {
          writer.writeString(this.keyAlgorithmName, "ascii");
          writer.writeBinary(this.publicKey || Buffer.alloc(0));
          writer.writeString((_a2 = this.clientHostname) !== null && _a2 !== void 0 ? _a2 : "", "ascii");
          writer.writeString((_b = this.clientUsername) !== null && _b !== void 0 ? _b : "", "ascii");
          if (!this.hasSignature) {
            throw new Error("A signature is required for a host-based authentcation request.");
          }
          writer.writeBinary(this.signature);
        } else {
          writer.writeBoolean(this.hasSignature);
          writer.writeString(this.keyAlgorithmName, "ascii");
          writer.writeBinary(this.publicKey || Buffer.alloc(0));
          if (this.hasSignature) {
            writer.writeBinary(this.signature);
          }
        }
      }
    };
    exports2.PublicKeyRequestMessage = PublicKeyRequestMessage;
    var AuthenticationInfoRequestMessage = class extends AuthenticationMessage {
      get messageType() {
        return 60;
      }
      onRead(reader) {
        this.name = reader.readString("utf8");
        this.instruction = reader.readString("utf8");
        this.language = reader.readString("ascii");
        this.prompts = [];
        const promptsCount = reader.readUInt32();
        const promptStrings = [];
        for (let i = 0; i < promptsCount; i++) {
          promptStrings.push(reader.readString("utf8"));
        }
        for (let i = 0; i < promptsCount; i++) {
          this.prompts.push({
            prompt: promptStrings[i],
            echo: reader.readBoolean()
          });
        }
      }
      onWrite(writer) {
        var _a2, _b;
        writer.writeString(this.name || "", "utf8");
        writer.writeString(this.instruction || "", "utf8");
        writer.writeString(this.language || "", "ascii");
        const promptsCount = (_b = (_a2 = this.prompts) === null || _a2 === void 0 ? void 0 : _a2.length) !== null && _b !== void 0 ? _b : 0;
        writer.writeUInt32(promptsCount);
        for (let i = 0; i < promptsCount; i++) {
          writer.writeString(this.prompts[i].prompt || "", "utf8");
        }
        for (let i = 0; i < promptsCount; i++) {
          writer.writeBoolean(this.prompts[i].echo);
        }
      }
    };
    exports2.AuthenticationInfoRequestMessage = AuthenticationInfoRequestMessage;
    var AuthenticationInfoResponseMessage = class extends AuthenticationMessage {
      get messageType() {
        return 61;
      }
      onRead(reader) {
        this.responses = [];
        const responseCount = reader.readUInt32();
        for (let i = 0; i < responseCount; i++) {
          this.responses.push(reader.readString("utf8"));
        }
      }
      onWrite(writer) {
        var _a2, _b;
        const responseCount = (_b = (_a2 = this.responses) === null || _a2 === void 0 ? void 0 : _a2.length) !== null && _b !== void 0 ? _b : 0;
        writer.writeUInt32(responseCount);
        for (let i = 0; i < responseCount; i++) {
          writer.writeString(this.responses[i] || "", "utf8");
        }
      }
    };
    exports2.AuthenticationInfoResponseMessage = AuthenticationInfoResponseMessage;
    var PublicKeyOKMessage = class extends AuthenticationMessage {
      get messageType() {
        return 60;
      }
      onRead(reader) {
        this.keyAlgorithmName = reader.readString("ascii");
        this.publicKey = reader.readBinary();
      }
      onWrite(writer) {
        if (!this.keyAlgorithmName)
          throw new Error("Key algorithm name not set.");
        if (!this.publicKey)
          throw new Error("Public key not set.");
        writer.writeString(this.keyAlgorithmName, "ascii");
        writer.writeBinary(this.publicKey);
      }
    };
    exports2.PublicKeyOKMessage = PublicKeyOKMessage;
    var PasswordRequestMessage = class extends AuthenticationRequestMessage {
      constructor() {
        super();
        this.methodName = "password";
      }
      onRead(reader) {
        super.onRead(reader);
        reader.readBoolean();
        this.password = reader.readString("utf8");
      }
      onWrite(writer) {
        super.onWrite(writer);
        writer.writeBoolean(false);
        writer.writeString(this.password || "", "utf8");
      }
    };
    exports2.PasswordRequestMessage = PasswordRequestMessage;
    var AuthenticationFailureMessage = class extends AuthenticationMessage {
      constructor() {
        super(...arguments);
        this.partialSuccess = false;
      }
      get messageType() {
        return 51;
      }
      onRead(reader) {
        this.methodNames = reader.readList("ascii");
        this.partialSuccess = reader.readBoolean();
      }
      onWrite(writer) {
        writer.writeList(this.methodNames || [], "ascii");
        writer.writeBoolean(this.partialSuccess);
      }
    };
    exports2.AuthenticationFailureMessage = AuthenticationFailureMessage;
    var AuthenticationSuccessMessage = class extends AuthenticationMessage {
      get messageType() {
        return 52;
      }
      onRead(reader) {
      }
      onWrite(writer) {
      }
    };
    exports2.AuthenticationSuccessMessage = AuthenticationSuccessMessage;
    sshMessage_1.SshMessage.index.set(50, AuthenticationRequestMessage);
    sshMessage_1.SshMessage.index.set(51, AuthenticationFailureMessage);
    sshMessage_1.SshMessage.index.set(52, AuthenticationSuccessMessage);
    sshMessage_1.SshMessage.index.set([
      60,
      "publickey"
      /* AuthenticationMethod.publicKey */
    ], PublicKeyRequestMessage);
    sshMessage_1.SshMessage.index.set([
      60,
      "keyboard-interactive"
      /* AuthenticationMethod.keyboardInteractive */
    ], AuthenticationInfoRequestMessage);
    sshMessage_1.SshMessage.index.set([
      61,
      "keyboard-interactive"
      /* AuthenticationMethod.keyboardInteractive */
    ], AuthenticationInfoResponseMessage);
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/events/sshAuthenticatingEventArgs.js
var require_sshAuthenticatingEventArgs = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/events/sshAuthenticatingEventArgs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SshAuthenticatingEventArgs = exports2.SshAuthenticationType = void 0;
    var vscode_jsonrpc_1 = require_main();
    var SshAuthenticationType;
    (function(SshAuthenticationType2) {
      SshAuthenticationType2[SshAuthenticationType2["clientNone"] = 0] = "clientNone";
      SshAuthenticationType2[SshAuthenticationType2["clientHostBased"] = 1] = "clientHostBased";
      SshAuthenticationType2[SshAuthenticationType2["clientPassword"] = 2] = "clientPassword";
      SshAuthenticationType2[SshAuthenticationType2["clientPublicKeyQuery"] = 3] = "clientPublicKeyQuery";
      SshAuthenticationType2[SshAuthenticationType2["clientPublicKey"] = 4] = "clientPublicKey";
      SshAuthenticationType2[SshAuthenticationType2["clientInteractive"] = 5] = "clientInteractive";
      SshAuthenticationType2[SshAuthenticationType2["serverPublicKey"] = 10] = "serverPublicKey";
    })(SshAuthenticationType = exports2.SshAuthenticationType || (exports2.SshAuthenticationType = {}));
    var SshAuthenticatingEventArgs = class {
      constructor(authenticationType, { username, password, publicKey, clientHostname, clientUsername, infoRequest, infoResponse }, cancellation) {
        this.authenticationType = authenticationType;
        this.infoRequest = null;
        this.infoResponse = null;
        const validate = ({ usernameRequired, passwordRequired, publicKeyRequired, clientHostnameRequired, clientUsernameRequired }) => {
          if (typeof username === "string" !== !!usernameRequired)
            return false;
          if (typeof password === "string" !== !!passwordRequired)
            return false;
          if (!!publicKey !== !!publicKeyRequired)
            return false;
          if (typeof clientHostname === "string" !== !!clientHostnameRequired)
            return false;
          if (typeof clientUsername === "string" !== !!clientUsernameRequired)
            return false;
          return true;
        };
        let valid;
        switch (authenticationType) {
          case SshAuthenticationType.clientNone:
            valid = validate({ usernameRequired: true });
            break;
          case SshAuthenticationType.clientHostBased:
            valid = validate({
              usernameRequired: true,
              publicKeyRequired: true,
              clientHostnameRequired: true,
              clientUsernameRequired: true
            });
            break;
          case SshAuthenticationType.clientPassword:
            valid = validate({ usernameRequired: true, passwordRequired: true });
            break;
          case SshAuthenticationType.clientPublicKeyQuery:
          case SshAuthenticationType.clientPublicKey:
            valid = validate({ usernameRequired: true, publicKeyRequired: true });
            break;
          case SshAuthenticationType.serverPublicKey:
            valid = validate({ publicKeyRequired: true });
            break;
          case SshAuthenticationType.clientInteractive:
            valid = true;
            break;
          default:
            throw new Error(`Invalid authentication type: ${authenticationType}`);
        }
        if (!valid) {
          throw new Error(`Invalid arguments for authentication type: ${authenticationType}`);
        }
        this.username = username !== null && username !== void 0 ? username : null;
        this.password = password !== null && password !== void 0 ? password : null;
        this.publicKey = publicKey !== null && publicKey !== void 0 ? publicKey : null;
        this.clientHostname = clientHostname !== null && clientHostname !== void 0 ? clientHostname : null;
        this.clientUsername = clientUsername !== null && clientUsername !== void 0 ? clientUsername : null;
        this.infoRequest = infoRequest !== null && infoRequest !== void 0 ? infoRequest : null;
        this.infoResponse = infoResponse !== null && infoResponse !== void 0 ? infoResponse : null;
        this.cancellationValue = cancellation !== null && cancellation !== void 0 ? cancellation : vscode_jsonrpc_1.CancellationToken.None;
      }
      /**
       * Gets a token that is cancelled if the session ends before the authentication handler
       * completes.
       */
      get cancellation() {
        return this.cancellationValue;
      }
      /* @internal */
      set cancellation(value) {
        this.cancellationValue = value;
      }
      toString() {
        if (this.infoRequest) {
          return `Info request: ${this.infoRequest.name}`;
        } else if (this.infoResponse) {
          return `"${this.username}" info response`;
        } else if (this.password) {
          return `${this.username ? '"' + this.username + '" ' : ""}[password]`;
        } else if (this.publicKey) {
          return `${this.username ? '"' + this.username + '" ' : ""}[${this.publicKey.keyAlgorithmName}]`;
        } else {
          return `"${this.username}"`;
        }
      }
    };
    exports2.SshAuthenticatingEventArgs = SshAuthenticatingEventArgs;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/services/authenticationService.js
var require_authenticationService = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/services/authenticationService.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var AuthenticationService_1;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AuthenticationService = void 0;
    var sshService_1 = require_sshService();
    var authenticationMessages_1 = require_authenticationMessages();
    var vscode_jsonrpc_1 = require_main();
    var sshData_1 = require_sshData();
    var transportMessages_1 = require_transportMessages();
    var sshAuthenticatingEventArgs_1 = require_sshAuthenticatingEventArgs();
    var connectionService_1 = require_connectionService();
    var serviceActivation_1 = require_serviceActivation();
    var queue_1 = require_queue();
    var trace_1 = require_trace();
    var errors_1 = require_errors();
    var AuthenticationService = AuthenticationService_1 = class AuthenticationService extends sshService_1.SshService {
      constructor(session) {
        var _a2;
        super(session);
        this.currentRequestMessage = null;
        this.authenticationFailureCount = 0;
        this.disposeCancellationSource = new vscode_jsonrpc_1.CancellationTokenSource();
        const algorithmName = (_a2 = session.algorithms) === null || _a2 === void 0 ? void 0 : _a2.publicKeyAlgorithmName;
        if (!algorithmName) {
          throw new Error("Algorithms not initialized.");
        }
        this.publicKeyAlgorithmName = algorithmName;
      }
      handleMessage(message, cancellation) {
        if (message instanceof authenticationMessages_1.AuthenticationSuccessMessage) {
          return this.handleSuccessMessage(message);
        } else if (message instanceof authenticationMessages_1.AuthenticationFailureMessage) {
          return this.handleFailureMessage(message);
        } else if (message instanceof authenticationMessages_1.AuthenticationRequestMessage) {
          return this.handleAuthenticationRequestMessage(message, cancellation);
        } else if (message instanceof authenticationMessages_1.AuthenticationInfoRequestMessage) {
          return this.handleInfoRequestMessage(message, cancellation);
        } else if (message instanceof authenticationMessages_1.AuthenticationInfoResponseMessage) {
          return this.handleInfoResponseMessage(message, cancellation);
        } else if (message instanceof authenticationMessages_1.PublicKeyOKMessage) {
        } else {
        }
      }
      async handleAuthenticationRequestMessage(message, cancellation) {
        this.trace(trace_1.TraceLevel.Info, trace_1.SshTraceEventIds.sessionAuthenticating, `Authentication request: ${message.methodName}`);
        let methodName = message.methodName;
        if (!this.session.config.authenticationMethods.includes(methodName)) {
          methodName = null;
        }
        if (methodName === "publickey" || methodName === "hostbased") {
          const publicKeymessage = message.convertTo(new authenticationMessages_1.PublicKeyRequestMessage());
          this.setCurrentRequest(publicKeymessage);
          return this.handlePublicKeyRequestMessage(publicKeymessage, cancellation);
        } else if (methodName === "password") {
          const passwordMessage = message.convertTo(new authenticationMessages_1.PasswordRequestMessage());
          this.setCurrentRequest(passwordMessage);
          return this.handlePasswordRequestMessage(passwordMessage, cancellation);
        } else if (methodName === "keyboard-interactive") {
          this.setCurrentRequest(message);
          return this.beginInteractiveAuthentication(message, cancellation);
        } else if (methodName === "none") {
          this.setCurrentRequest(message);
          return this.handleAuthenticating(new sshAuthenticatingEventArgs_1.SshAuthenticatingEventArgs(sshAuthenticatingEventArgs_1.SshAuthenticationType.clientNone, {
            username: message.username
          }), cancellation);
        } else {
          this.setCurrentRequest(null);
          const failureMessage = new authenticationMessages_1.AuthenticationFailureMessage();
          failureMessage.methodNames = [
            "publickey",
            "password",
            "hostbased"
          ];
          await this.session.sendMessage(failureMessage, cancellation);
        }
      }
      setCurrentRequest(message) {
        var _a2;
        this.currentRequestMessage = message;
        const protocol = this.session.protocol;
        if (protocol) {
          protocol.messageContext = (_a2 = message === null || message === void 0 ? void 0 : message.methodName) !== null && _a2 !== void 0 ? _a2 : null;
        }
      }
      async handlePublicKeyRequestMessage(message, cancellation) {
        var _a2, _b, _c;
        const publicKeyAlg = this.session.config.getPublicKeyAlgorithm(message.keyAlgorithmName);
        if (!publicKeyAlg) {
          const failureMessage = new authenticationMessages_1.AuthenticationFailureMessage();
          failureMessage.methodNames = [
            "publickey",
            "password"
          ];
          await this.session.sendMessage(failureMessage, cancellation);
          return;
        }
        const publicKey = publicKeyAlg.createKeyPair();
        await publicKey.setPublicKeyBytes(message.publicKey);
        let args;
        if (message.methodName === "hostbased") {
          args = new sshAuthenticatingEventArgs_1.SshAuthenticatingEventArgs(sshAuthenticatingEventArgs_1.SshAuthenticationType.clientHostBased, {
            username: (_a2 = message.username) !== null && _a2 !== void 0 ? _a2 : "",
            publicKey,
            clientHostname: message.clientHostname,
            clientUsername: message.clientUsername
          });
        } else if (!message.hasSignature) {
          args = new sshAuthenticatingEventArgs_1.SshAuthenticatingEventArgs(sshAuthenticatingEventArgs_1.SshAuthenticationType.clientPublicKeyQuery, {
            username: (_b = message.username) !== null && _b !== void 0 ? _b : "",
            publicKey
          });
        } else {
          const signature = publicKeyAlg.readSignatureData(message.signature);
          const sessionId = this.session.sessionId;
          if (sessionId == null) {
            throw new Error("Session ID not initialized.");
          }
          const writer = new sshData_1.SshDataWriter(Buffer.alloc(sessionId.length + message.payloadWithoutSignature.length + 20));
          writer.writeBinary(sessionId);
          writer.write(message.payloadWithoutSignature);
          const signedData = writer.toBuffer();
          const verifier = publicKeyAlg.createVerifier(publicKey);
          const verified = await verifier.verify(signedData, signature);
          if (!verified) {
            await this.handleAuthenticationFailure("Public key authentication failed: invalid signature.", cancellation);
          }
          args = new sshAuthenticatingEventArgs_1.SshAuthenticatingEventArgs(sshAuthenticatingEventArgs_1.SshAuthenticationType.clientPublicKey, {
            username: (_c = message.username) !== null && _c !== void 0 ? _c : "",
            publicKey
          });
        }
        await this.handleAuthenticating(args, cancellation);
      }
      async handlePasswordRequestMessage(message, cancellation) {
        var _a2, _b;
        const args = new sshAuthenticatingEventArgs_1.SshAuthenticatingEventArgs(sshAuthenticatingEventArgs_1.SshAuthenticationType.clientPassword, {
          username: (_a2 = message.username) !== null && _a2 !== void 0 ? _a2 : "",
          password: (_b = message.password) !== null && _b !== void 0 ? _b : ""
        });
        await this.handleAuthenticating(args, cancellation);
      }
      async beginInteractiveAuthentication(message, cancellation) {
        const args = new sshAuthenticatingEventArgs_1.SshAuthenticatingEventArgs(sshAuthenticatingEventArgs_1.SshAuthenticationType.clientInteractive, {
          username: message.username
        });
        await this.handleAuthenticating(args, cancellation);
      }
      async handleInfoRequestMessage(message, cancellation) {
        const args = new sshAuthenticatingEventArgs_1.SshAuthenticatingEventArgs(sshAuthenticatingEventArgs_1.SshAuthenticationType.clientInteractive, {
          infoRequest: message
        });
        await this.handleAuthenticating(args, cancellation);
      }
      async handleInfoResponseMessage(message, cancellation) {
        var _a2;
        const args = new sshAuthenticatingEventArgs_1.SshAuthenticatingEventArgs(sshAuthenticatingEventArgs_1.SshAuthenticationType.clientInteractive, {
          username: (_a2 = this.currentRequestMessage) === null || _a2 === void 0 ? void 0 : _a2.username,
          infoResponse: message
        });
        await this.handleAuthenticating(args, cancellation);
      }
      async handleAuthenticating(args, cancellation) {
        var _a2;
        if (!this.currentRequestMessage) {
          throw new errors_1.SshConnectionError("No current authentication request.", transportMessages_1.SshDisconnectReason.protocolError);
        }
        args.cancellation = this.disposeCancellationSource.token;
        let authenticatedPrincipal = null;
        try {
          authenticatedPrincipal = await this.session.raiseAuthenticatingEvent(args);
        } catch (e) {
          if (!(e instanceof Error))
            throw e;
          this.trace(trace_1.TraceLevel.Error, trace_1.SshTraceEventIds.authenticationError, `Error while authenticating client: ${e.message}`, e);
          authenticatedPrincipal = null;
        }
        if (authenticatedPrincipal) {
          if (args.authenticationType === sshAuthenticatingEventArgs_1.SshAuthenticationType.clientPublicKeyQuery) {
            const publicKeyRequest = this.currentRequestMessage;
            const okMessage = new authenticationMessages_1.PublicKeyOKMessage();
            okMessage.keyAlgorithmName = publicKeyRequest.keyAlgorithmName;
            okMessage.publicKey = publicKeyRequest.publicKey;
            this.setCurrentRequest(null);
            await this.session.sendMessage(okMessage, cancellation);
          } else {
            this.session.principal = authenticatedPrincipal;
            const serviceName = this.currentRequestMessage.serviceName;
            if (serviceName) {
              this.session.activateService(serviceName);
            }
            this.trace(trace_1.TraceLevel.Info, trace_1.SshTraceEventIds.sessionAuthenticated, `${sshAuthenticatingEventArgs_1.SshAuthenticationType[args.authenticationType]} authentication succeeded.`);
            this.setCurrentRequest(null);
            await this.session.sendMessage(new authenticationMessages_1.AuthenticationSuccessMessage(), cancellation);
            (_a2 = this.session) === null || _a2 === void 0 ? void 0 : _a2.handleClientAuthenticated();
          }
        } else if (args.authenticationType === sshAuthenticatingEventArgs_1.SshAuthenticationType.clientInteractive && !this.session.isClientSession && args.infoRequest) {
          await this.sendMessage(args.infoRequest, cancellation);
        } else if (args.authenticationType === sshAuthenticatingEventArgs_1.SshAuthenticationType.clientInteractive && this.session.isClientSession && args.infoResponse) {
          await this.sendMessage(args.infoResponse, cancellation);
        } else {
          this.setCurrentRequest(null);
          await this.handleAuthenticationFailure(`${sshAuthenticatingEventArgs_1.SshAuthenticationType[args.authenticationType]} authentication failed.`);
        }
      }
      async handleAuthenticationFailure(message, cancellation) {
        this.authenticationFailureCount++;
        this.trace(trace_1.TraceLevel.Warning, trace_1.SshTraceEventIds.clientAuthenticationFailed, message);
        const failureMessage = new authenticationMessages_1.AuthenticationFailureMessage();
        failureMessage.methodNames = this.session.config.authenticationMethods;
        await this.session.sendMessage(failureMessage, cancellation);
        if (this.authenticationFailureCount >= this.session.config.maxClientAuthenticationAttempts) {
          await this.session.close(transportMessages_1.SshDisconnectReason.noMoreAuthMethodsAvailable, "Authentication failed.");
        }
      }
      async authenticateClient(credentials, cancellation) {
        var _a2, _b, _c, _d;
        this.clientAuthenticationMethods = new queue_1.Queue();
        const configuredMethods = this.session.config.authenticationMethods;
        if (configuredMethods.includes(
          "publickey"
          /* AuthenticationMethod.publicKey */
        )) {
          for (const publicKey of (_a2 = credentials.publicKeys) !== null && _a2 !== void 0 ? _a2 : []) {
            if (!publicKey)
              continue;
            const username = (_b = credentials.username) !== null && _b !== void 0 ? _b : "";
            let privateKey = publicKey;
            const privateKeyProvider = credentials.privateKeyProvider;
            this.clientAuthenticationMethods.enqueue({
              method: "publickey",
              handler: async (cancellation2) => {
                if (!privateKey.hasPrivateKey) {
                  if (privateKeyProvider == null) {
                    throw new Error("A private key provider is required.");
                  }
                  privateKey = await privateKeyProvider(publicKey, cancellation2 !== null && cancellation2 !== void 0 ? cancellation2 : vscode_jsonrpc_1.CancellationToken.None);
                }
                if (privateKey) {
                  await this.requestPublicKeyAuthentication(username, privateKey, cancellation2);
                } else {
                  await this.session.close(transportMessages_1.SshDisconnectReason.authCancelledByUser);
                }
              }
            });
          }
        }
        if (configuredMethods.includes(
          "password"
          /* AuthenticationMethod.password */
        )) {
          const passwordCredentialProvider = credentials.passwordProvider;
          if (passwordCredentialProvider) {
            this.clientAuthenticationMethods.enqueue({
              method: "password",
              handler: async (cancellation2) => {
                var _a3;
                const passwordCredentialPromise = passwordCredentialProvider(cancellation2 !== null && cancellation2 !== void 0 ? cancellation2 : vscode_jsonrpc_1.CancellationToken.None);
                const passwordCredential = passwordCredentialPromise ? await passwordCredentialPromise : null;
                if (passwordCredential) {
                  await this.requestPasswordAuthentication((_a3 = passwordCredential[0]) !== null && _a3 !== void 0 ? _a3 : "", passwordCredential[1], cancellation2);
                } else {
                  await this.session.close(transportMessages_1.SshDisconnectReason.authCancelledByUser);
                }
              }
            });
          } else if (credentials.password) {
            const username = (_c = credentials.username) !== null && _c !== void 0 ? _c : "";
            const password = credentials.password;
            this.clientAuthenticationMethods.enqueue({
              method: "password",
              handler: async (cancellation2) => {
                await this.requestPasswordAuthentication(username, password, cancellation2);
              }
            });
          }
        }
        if (this.clientAuthenticationMethods.size === 0) {
          const username = (_d = credentials.username) !== null && _d !== void 0 ? _d : "";
          if (configuredMethods.includes(
            "none"
            /* AuthenticationMethod.none */
          )) {
            this.clientAuthenticationMethods.enqueue({
              method: "none",
              handler: async (cancellation2) => {
                await this.requestUsernameAuthentication(username, cancellation2);
              }
            });
          }
          if (configuredMethods.includes(
            "keyboard-interactive"
            /* AuthenticationMethod.keyboardInteractive */
          )) {
            this.clientAuthenticationMethods.enqueue({
              method: "keyboard-interactive",
              handler: async (cancellation2) => {
                await this.requestInteractiveAuthentication(username, cancellation2);
              }
            });
          }
          if (this.clientAuthenticationMethods.size === 0) {
            throw new Error("Could not prepare request for authentication method(s): " + configuredMethods.join(", ") + ". Supply client credentials or enable none or interactive authentication methods.");
          }
        }
        this.session.activateService(connectionService_1.ConnectionService);
        const firstAuthMethod = this.clientAuthenticationMethods.dequeue();
        await firstAuthMethod.handler(cancellation);
      }
      async requestUsernameAuthentication(username, cancellation) {
        const authMessage = new authenticationMessages_1.AuthenticationRequestMessage();
        authMessage.serviceName = connectionService_1.ConnectionService.serviceName;
        authMessage.methodName = "none";
        authMessage.username = username;
        this.setCurrentRequest(authMessage);
        await this.session.sendMessage(authMessage, cancellation);
      }
      async requestPublicKeyAuthentication(username, key, cancellation) {
        const algorithm = this.session.config.publicKeyAlgorithms.find((a) => (a === null || a === void 0 ? void 0 : a.keyAlgorithmName) === key.keyAlgorithmName);
        if (!algorithm) {
          throw new Error(`Public key algorithm '${key.keyAlgorithmName}' is not in session config.`);
        }
        const authMessage = new authenticationMessages_1.PublicKeyRequestMessage();
        authMessage.serviceName = connectionService_1.ConnectionService.serviceName;
        authMessage.username = username;
        authMessage.keyAlgorithmName = algorithm.name;
        authMessage.publicKey = await key.getPublicKeyBytes(algorithm.name);
        authMessage.signature = await this.createAuthenticationSignature(authMessage, algorithm, key);
        this.setCurrentRequest(authMessage);
        await this.session.sendMessage(authMessage, cancellation);
      }
      async requestPasswordAuthentication(username, password, cancellation) {
        const authMessage = new authenticationMessages_1.PasswordRequestMessage();
        authMessage.serviceName = connectionService_1.ConnectionService.serviceName;
        authMessage.username = username;
        authMessage.password = password;
        this.setCurrentRequest(authMessage);
        await this.session.sendMessage(authMessage, cancellation);
      }
      async requestInteractiveAuthentication(username, cancellation) {
        const authMessage = new authenticationMessages_1.AuthenticationRequestMessage();
        authMessage.serviceName = connectionService_1.ConnectionService.serviceName;
        authMessage.methodName = "keyboard-interactive";
        authMessage.username = username;
        this.setCurrentRequest(authMessage);
        await this.session.sendMessage(authMessage, cancellation);
      }
      async handleFailureMessage(message) {
        var _a2, _b;
        this.setCurrentRequest(null);
        while ((_a2 = this.clientAuthenticationMethods) === null || _a2 === void 0 ? void 0 : _a2.size) {
          const nextAuthMethod = this.clientAuthenticationMethods.dequeue();
          if ((_b = message.methodNames) === null || _b === void 0 ? void 0 : _b.includes(nextAuthMethod.method)) {
            await nextAuthMethod.handler(this.disposeCancellationSource.token);
            return;
          }
        }
        this.session.onAuthenticationComplete(false);
      }
      handleSuccessMessage(message) {
        this.setCurrentRequest(null);
        this.session.onAuthenticationComplete(true);
      }
      async createAuthenticationSignature(requestMessage, algorithm, key) {
        const sessionId = this.session.sessionId;
        if (sessionId == null) {
          throw new Error("Session ID not initialized.");
        }
        const writer = new sshData_1.SshDataWriter(Buffer.alloc(requestMessage.publicKey.length + (requestMessage.username || "").length + 400));
        writer.writeBinary(sessionId);
        writer.writeByte(requestMessage.messageType);
        writer.writeString(requestMessage.username || "", "utf8");
        writer.writeString(requestMessage.serviceName || "", "ascii");
        writer.writeString("publickey", "ascii");
        writer.writeBoolean(true);
        writer.writeString(requestMessage.keyAlgorithmName, "ascii");
        writer.writeBinary(requestMessage.publicKey);
        const signer = algorithm.createSigner(key);
        const signature = await signer.sign(writer.toBuffer());
        return algorithm.createSignatureData(signature);
      }
      dispose() {
        try {
          this.disposeCancellationSource.cancel();
          this.disposeCancellationSource.dispose();
        } catch (_a2) {
        }
        super.dispose();
      }
    };
    AuthenticationService.serviceName = "ssh-userauth";
    AuthenticationService = AuthenticationService_1 = __decorate([
      (0, serviceActivation_1.serviceActivation)({ serviceRequest: AuthenticationService_1.serviceName })
    ], AuthenticationService);
    exports2.AuthenticationService = AuthenticationService;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/metrics/sessionMetrics.js
var require_sessionMetrics = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/metrics/sessionMetrics.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SessionMetrics = void 0;
    var vscode_jsonrpc_1 = require_main();
    var trace_1 = require_trace();
    var SessionMetrics = class {
      /* @internal */
      constructor() {
        this.startTime = 0;
        this.messagesSentCount = 0;
        this.messagesReceivedCount = 0;
        this.bytesSentSum = 0;
        this.bytesReceivedSum = 0;
        this.reconnectionsCount = 0;
        this.currentLatency = 0;
        this.minLatency = 0;
        this.maxLatency = 0;
        this.latencySum = 0;
        this.latencyCount = 0;
        this.messageSentEmitter = new vscode_jsonrpc_1.Emitter();
        this.onMessageSent = this.messageSentEmitter.event;
        this.messageReceivedEmitter = new vscode_jsonrpc_1.Emitter();
        this.onMessageReceived = this.messageReceivedEmitter.event;
        this.latencyUpdatedEmitter = new vscode_jsonrpc_1.Emitter();
        this.onLatencyUpdated = this.latencyUpdatedEmitter.event;
        this.sessionClosedEmitter = new vscode_jsonrpc_1.Emitter();
        this.onSessionClosed = this.sessionClosedEmitter.event;
        if (typeof performance === "object" && typeof performance.now === "function") {
          Object.defineProperty(this, "time", { get: this.browserTime });
        } else if (typeof process === "object" && typeof process.hrtime === "function") {
          Object.defineProperty(this, "time", { get: this.nodejsTime });
        }
        this.startTime = this.time;
      }
      /**
       * Gets the current stopwatch value in milliseconds (possibly including fractional milliseconds),
       * used for measuring latency.
       */
      /* @internal */
      get time() {
        return Date.now() - this.startTime;
      }
      browserTime() {
        return performance.now() - this.startTime;
      }
      nodejsTime() {
        const [s, ns] = process.hrtime();
        return s * 1e3 + ns / 1e6 - this.startTime;
      }
      /**
       * Gets the total cumulative number of messages sent for the duration of the session,
       * including all channels and non-channel protocol messages.
       */
      get messagesSent() {
        return this.messagesSentCount;
      }
      /**
       * Gets the total cumulative number of messages received for the duration of the session,
       * including all channels and non-channel protocol messages.
       */
      get messagesReceived() {
        return this.messagesReceivedCount;
      }
      /**
       * Gets the total cumulative number of bytes sent for the duration of the session,
       * including all channels and non-channel protocol messages, and including message
       * framing, padding, and MAC bytes.
       */
      get bytesSent() {
        return this.bytesSentSum;
      }
      /**
       * Gets the total cumulative number of bytes received for the duration of the session,
       * including all channels and non-channel protocol messages, and including message
       * framing, padding, and MAC bytes.
       */
      get bytesReceived() {
        return this.bytesReceivedSum;
      }
      /**
       * Gets the number of times the session has reconnected.
       * </summary>
       * <remarks>
       * Reconnection requires both sides to support the
       * <see cref="SshProtocolExtensionNames.SessionReconnect" /> protocol extension.
       */
      get reconnections() {
        return this.reconnectionsCount;
      }
      /**
       * Gets the average measured round-trip connection latency between client and server
       * over the duration of the session, in milliseconds.
       * </summary>
       * <remarks>
       * Latency measurement requires both sides to support the
       * <see cref="SshProtocolExtensionNames.SessionLatency" /> protocol extension.
       * If not supported, this Sum will be 0.
       */
      get latencyAverageMs() {
        return this.latencyCount === 0 ? 0 : this.latencySum / this.latencyCount;
      }
      /**
       * Gets the minimum measured round-trip connection latency between client and server
       * over the duration of the session, in milliseconds.
       * </summary>
       * <remarks>
       * Latency measurement requires both sides to support the
       * <see cref="SshProtocolExtensionNames.SessionLatency" /> protocol extension.
       * If not supported, this Sum will be 0.
       */
      get latencyMinMs() {
        return this.minLatency;
      }
      /**
       * Gets the maximum measured round-trip connection latency between client and server
       * over the duration of the session, in milliseconds.
       * </summary>
       * <remarks>
       * Latency measurement requires both sides to support the
       * <see cref="SshProtocolExtensionNames.SessionLatency" /> protocol extension.
       * If not supported, this Sum will be 0.
       */
      get latencyMaxMs() {
        return this.maxLatency;
      }
      /**
       * Gets the most recent measurement of round-trip connection latency between client and
       * server, in milliseconds.
       * </summary>
       * <remarks>
       * Latency measurement requires both sides to support the
       * <see cref="SshProtocolExtensionNames.SessionLatency" /> protocol extension.
       * If not supported or the session is not currently connected, this Sum will be 0.
       */
      get latencyCurrentMs() {
        return this.currentLatency;
      }
      /* @internal */
      addMessageSent(size) {
        this.messagesSentCount++;
        this.bytesSentSum += size;
        this.messageSentEmitter.fire({ time: this.time, size });
      }
      /* @internal */
      addMessageReceived(size) {
        this.messagesReceivedCount++;
        this.bytesReceivedSum += size;
        this.messageReceivedEmitter.fire({ time: this.time, size });
      }
      /* @internal */
      addReconnection() {
        this.reconnectionsCount++;
      }
      /* @internal */
      updateLatency(latencyMs, trace) {
        if (latencyMs < 0) {
          if (trace) {
            trace(trace_1.TraceLevel.Warning, trace_1.SshTraceEventIds.metricsError, `Measured latency was negative: ${latencyMs} us`);
          }
          return;
        }
        this.currentLatency = latencyMs;
        if (latencyMs === 0) {
          return;
        }
        if (this.minLatency === 0 || latencyMs < this.minLatency) {
          this.minLatency = latencyMs;
        }
        if (this.maxLatency === 0 || latencyMs > this.maxLatency) {
          this.maxLatency = latencyMs;
        }
        this.latencySum += latencyMs;
        this.latencyCount++;
        this.latencyUpdatedEmitter.fire({ time: this.time, latency: latencyMs });
      }
      /* @internal */
      close() {
        this.currentLatency = 0;
        this.sessionClosedEmitter.fire();
      }
      toString() {
        let s = `Messages S/R: ${this.messagesSent} / ${this.messagesReceived}; Bytes S/R: ${this.bytesSent} / ${this.bytesReceived}; Reconnections: ${this.reconnections}; `;
        const precision = this.minLatency >= 10 ? 1 : this.minLatency >= 1 ? 10 : 100;
        if (this.maxLatency > 0) {
          const min = Math.round(this.minLatency * precision) / precision;
          const avg = Math.round(this.latencySum / this.latencyCount * precision) / precision;
          const max = Math.round(this.maxLatency * precision) / precision;
          s += `Latency Min-Avg-Max: ${min} - ${avg} - ${max} ms; `;
        }
        if (this.currentLatency > 0) {
          const current = Math.round(this.currentLatency * precision) / precision;
          s += `Current Latency: ${current} ms; `;
        }
        return s;
      }
    };
    exports2.SessionMetrics = SessionMetrics;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/events/sshSessionClosedEventArgs.js
var require_sshSessionClosedEventArgs = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/events/sshSessionClosedEventArgs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SshSessionClosedEventArgs = void 0;
    var transportMessages_1 = require_transportMessages();
    var SshSessionClosedEventArgs = class {
      constructor(reason, message, error) {
        this.reason = reason;
        this.message = message;
        this.error = error;
        if (!message)
          throw new TypeError("A disconnect message is required.");
      }
      toString() {
        return `${transportMessages_1.SshDisconnectReason[this.reason]}: ${this.message}`;
      }
    };
    exports2.SshSessionClosedEventArgs = SshSessionClosedEventArgs;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/progress.js
var require_progress = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/progress.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Progress = void 0;
    var Progress;
    (function(Progress2) {
      Progress2["OpeningClientConnectionToRelay"] = "OpeningClientConnectionToRelay";
      Progress2["OpenedClientConnectionToRelay"] = "OpenedClientConnectionToRelay";
      Progress2["OpeningHostConnectionToRelay"] = "OpeningHostConnectionToRelay";
      Progress2["OpenedHostConnectionToRelay"] = "OpenedHostConnectionToRelay";
      Progress2["OpeningSshSessionConnection"] = "OpeningSshSessionConnection";
      Progress2["OpenedSshSessionConnection"] = "OpenedSshSessionConnection";
      Progress2["StartingProtocolVersionExchange"] = "StartingProtocolVersionExchange";
      Progress2["CompletedProtocolVersionExchange"] = "CompletedProtocolVersionExchange";
      Progress2["StartingKeyExchange"] = "StartingKeyExchange";
      Progress2["CompletedKeyExchange"] = "CompletedKeyExchange";
      Progress2["StartingSessionAuthentication"] = "StartingSessionAuthentication";
      Progress2["CompletedSessionAuthentication"] = "CompletedSessionAuthentication";
    })(Progress = exports2.Progress || (exports2.Progress = {}));
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/events/sshReportProgressEventArgs.js
var require_sshReportProgressEventArgs = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/events/sshReportProgressEventArgs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SshReportProgressEventArgs = void 0;
    var SshReportProgressEventArgs = class {
      constructor(progress, sessionNumber) {
        this.progress = progress;
        this.sessionNumber = sessionNumber;
      }
      toString() {
        return `Progress: ${this.progress}` + this.sessionNumber ? ` Session number: ${this.sessionNumber}` : "";
      }
    };
    exports2.SshReportProgressEventArgs = SshReportProgressEventArgs;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/sshSession.js
var require_sshSession = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/sshSession.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SshSession = void 0;
    var trace_1 = require_trace();
    var buffer_1 = require("buffer");
    var vscode_jsonrpc_1 = require_main();
    var sshSessionConfiguration_1 = require_sshSessionConfiguration();
    var sshChannel_1 = require_sshChannel();
    var sshVersionInfo_1 = require_sshVersionInfo();
    var sshProtocol_1 = require_sshProtocol();
    var keyExchangeService_1 = require_keyExchangeService();
    var serviceActivation_1 = require_serviceActivation();
    var connectionService_1 = require_connectionService();
    var authenticationService_1 = require_authenticationService();
    var sshMessage_1 = require_sshMessage();
    var kexMessages_1 = require_kexMessages();
    var connectionMessages_1 = require_connectionMessages();
    var authenticationMessages_1 = require_authenticationMessages();
    var transportMessages_1 = require_transportMessages();
    var sessionMetrics_1 = require_sessionMetrics();
    var promiseCompletionSource_1 = require_promiseCompletionSource();
    var sshSessionClosedEventArgs_1 = require_sshSessionClosedEventArgs();
    var sshRequestEventArgs_1 = require_sshRequestEventArgs();
    var sshAlgorithms_1 = require_sshAlgorithms();
    var cancellation_1 = require_cancellation2();
    var errors_1 = require_errors();
    var semaphore_1 = require_semaphore();
    var pipeExtensions_1 = require_pipeExtensions();
    var queue_1 = require_queue();
    var progress_1 = require_progress();
    var sshReportProgressEventArgs_1 = require_sshReportProgressEventArgs();
    var sessionCounter = 0;
    var SshSession = class _SshSession {
      get algorithms() {
        return this.protocol ? this.protocol.algorithms : null;
      }
      /**
       * Gets an object containing claims about the server or client on the
       * other end of the session, or `null` if the session is not authenticated.
       *
       * This property is initially `null` for an unauthenticated session. On
       * successful authentication, the session Authenticating event handler
       * provides a Task that returns a principal that is stored here.
       */
      get principal() {
        return this.principalValue;
      }
      /* @internal */
      set principal(value) {
        this.principalValue = value;
      }
      constructor(config, isClientSession) {
        this.config = config;
        this.remoteVersion = null;
        this.activatedServices = /* @__PURE__ */ new Map();
        this.connectionService = null;
        this.requestHandlers = new queue_1.Queue();
        this.blockedMessages = [];
        this.blockedMessagesSemaphore = new semaphore_1.Semaphore(1);
        this.connected = false;
        this.disposed = false;
        this.keepAliveResponseReceived = false;
        this.keepAliveFailureCount = 0;
        this.keepAliveSuccessCount = 0;
        this.metrics = new sessionMetrics_1.SessionMetrics();
        this.reconnecting = false;
        this.sessionId = null;
        this.principalValue = null;
        this.authenticatingEmitter = new vscode_jsonrpc_1.Emitter();
        this.onAuthenticating = this.authenticatingEmitter.event;
        this.closedEmitter = new vscode_jsonrpc_1.Emitter();
        this.onClosed = this.closedEmitter.event;
        this.disconnectedEmitter = new vscode_jsonrpc_1.Emitter();
        this.onDisconnected = this.disconnectedEmitter.event;
        this.serviceActivatedEmitter = new vscode_jsonrpc_1.Emitter();
        this.onServiceActivated = this.serviceActivatedEmitter.event;
        this.channelOpeningEmitter = new vscode_jsonrpc_1.Emitter();
        this.onChannelOpening = this.channelOpeningEmitter.event;
        this.requestEmitter = new vscode_jsonrpc_1.Emitter();
        this.onRequest = this.requestEmitter.event;
        this.reportProgressEmitter = new vscode_jsonrpc_1.Emitter();
        this.onReportProgress = this.reportProgressEmitter.event;
        this.keepAliveFailedEmitter = new vscode_jsonrpc_1.Emitter();
        this.onKeepAliveFailed = this.keepAliveFailedEmitter.event;
        this.keepAliveSucceededEmitter = new vscode_jsonrpc_1.Emitter();
        this.onKeepAliveSucceeded = this.keepAliveSucceededEmitter.event;
        this.trace = (level, eventId, msg, err) => {
        };
        this.isClientSession = isClientSession;
        this.sessionNumber = ++sessionCounter;
        if (!config)
          throw new TypeError("Session configuration is required.");
        if (!config.keyExchangeAlgorithms.find((a) => !!a)) {
          if (config.encryptionAlgorithms.length > 0 && config.encryptionAlgorithms.indexOf(null) < 0) {
            throw new Error("Encryption requires a key-exchange algorithm to be configured.");
          } else if (config.hmacAlgorithms.length > 0 && config.hmacAlgorithms.indexOf(null) < 0) {
            throw new Error("HMAC requires a key-exchange algorithm to be configured.");
          } else if (config.publicKeyAlgorithms.length > 0 && config.publicKeyAlgorithms.indexOf(null) < 0) {
            throw new Error("Host authentication requires a key-exchange algorithm to be configured.");
          }
          this.kexService = null;
          this.activateService(connectionService_1.ConnectionService);
        } else {
          this.kexService = new keyExchangeService_1.KeyExchangeService(this);
        }
        config.onConfigurationChanged(() => {
          const protocol = this.protocol;
          if (protocol) {
            protocol.traceChannelData = config.traceChannelData;
          }
          if (this.connected && !this.disposed) {
            this.startKeepAliveTimer();
          }
        });
      }
      get isConnected() {
        return this.connected;
      }
      get isClosed() {
        return this.disposed;
      }
      get services() {
        return [...this.activatedServices.values()];
      }
      get channels() {
        var _a2, _b;
        return (_b = (_a2 = this.connectionService) === null || _a2 === void 0 ? void 0 : _a2.channels) !== null && _b !== void 0 ? _b : [];
      }
      get protocolExtensions() {
        var _a2;
        return ((_a2 = this.protocol) === null || _a2 === void 0 ? void 0 : _a2.extensions) || null;
      }
      /**
       * Gets an activated service instance by type.
       *
       * @returns The service instance, or `null` if the service has not been activated.
       */
      getService(serviceType) {
        const service = this.activatedServices.get(serviceType);
        return service ? service : null;
      }
      /* @internal */
      activateService(serviceTypeOrName) {
        let serviceType;
        if (typeof serviceTypeOrName === "function") {
          serviceType = serviceTypeOrName;
        } else {
          const serviceName = serviceTypeOrName;
          serviceType = (0, serviceActivation_1.findService)(this.config.services, (a) => a.serviceRequest === serviceName);
          if (!serviceType) {
            return null;
          }
        }
        let activatedService = this.activatedServices.get(serviceType);
        if (!activatedService) {
          if (!this.config.services.has(serviceType)) {
            throw new Error(`Service type not configured: ${serviceType.name}`);
          }
          const serviceConfig = this.config.services.get(serviceType);
          activatedService = new serviceType(this, serviceConfig);
          if (serviceType === connectionService_1.ConnectionService) {
            this.connectionService = activatedService;
          }
          this.activatedServices.set(serviceType, activatedService);
          this.serviceActivatedEmitter.fire(activatedService);
        }
        return activatedService;
      }
      async connect(stream, cancellation) {
        if (!stream)
          throw new TypeError("A session stream is required.");
        if (this.disposed)
          throw new errors_1.ObjectDisposedError(this);
        if (!this.connectPromise) {
          this.connectPromise = this.doConnect(stream, cancellation);
        }
        await this.connectPromise;
      }
      async doConnect(stream, cancellation) {
        this.trace(trace_1.TraceLevel.Info, trace_1.SshTraceEventIds.sessionConnecting, `${this} ${this.reconnecting ? "re" : ""}connecting...`);
        this.raiseReportProgress(progress_1.Progress.OpeningSshSessionConnection);
        this.protocol = new sshProtocol_1.SshProtocol(stream, this.config, this.metrics, this.trace);
        this.protocol.kexService = this.kexService;
        this.raiseReportProgress(progress_1.Progress.StartingProtocolVersionExchange);
        await this.exchangeVersions(cancellation);
        if (this.kexService) {
          await this.encrypt(cancellation);
        } else {
          await this.sendMessage(kexMessages_1.KeyExchangeInitMessage.none, cancellation);
          await (0, cancellation_1.withCancellation)(this.versionExchangePromise, cancellation);
          this.raiseReportProgress(progress_1.Progress.CompletedProtocolVersionExchange);
          this.connected = true;
        }
        this.processMessages().catch((e) => {
          this.trace(trace_1.TraceLevel.Error, trace_1.SshTraceEventIds.unknownError, `Unhandled error processing messages: ${e.message}`, e);
        });
        this.startKeepAliveTimer();
        this.raiseReportProgress(progress_1.Progress.OpenedSshSessionConnection);
      }
      async exchangeVersions(cancellation) {
        const writePromise = this.protocol.writeProtocolVersion(_SshSession.localVersion.toString(), cancellation);
        const readPromise = this.protocol.readProtocolVersion(cancellation);
        this.versionExchangePromise = readPromise.then(async (remoteVersion) => {
          this.trace(trace_1.TraceLevel.Info, trace_1.SshTraceEventIds.protocolVersion, `Local version: ${_SshSession.localVersion}, remote version: ${remoteVersion}`);
          let errorMessage;
          const remoteVersionInfo = sshVersionInfo_1.SshVersionInfo.tryParse(remoteVersion);
          if (remoteVersionInfo) {
            this.remoteVersion = remoteVersionInfo;
            if (remoteVersionInfo.protocolVersion === "2.0") {
              return;
            }
            errorMessage = `Remote SSH version ${this.remoteVersion} is not supported. This library only supports SSH v2.0.`;
          } else {
            errorMessage = `Could not parse remote SSH version ${remoteVersion}`;
          }
          await this.close(transportMessages_1.SshDisconnectReason.protocolVersionNotSupported, errorMessage, new Error(errorMessage));
        });
        await writePromise;
      }
      async encrypt(cancellation) {
        var _a2, _b;
        const protocol = this.protocol;
        if (!protocol)
          throw new errors_1.ObjectDisposedError(this);
        await protocol.considerReExchange(true, cancellation);
        await (0, cancellation_1.withCancellation)(this.versionExchangePromise, cancellation);
        this.raiseReportProgress(progress_1.Progress.CompletedProtocolVersionExchange);
        this.connected = true;
        this.raiseReportProgress(progress_1.Progress.StartingKeyExchange);
        let message = null;
        while (!this.isClosed && !((_a2 = this.protocol) === null || _a2 === void 0 ? void 0 : _a2.algorithms) && !(message instanceof transportMessages_1.DisconnectMessage)) {
          message = await protocol.receiveMessage(cancellation);
          if (!message) {
            break;
          }
          await this.handleMessage(message, cancellation);
        }
        this.raiseReportProgress(progress_1.Progress.CompletedKeyExchange);
        if (!((_b = this.protocol) === null || _b === void 0 ? void 0 : _b.algorithms)) {
          throw new errors_1.SshConnectionError("Session closed while encrypting.", transportMessages_1.SshDisconnectReason.connectionLost);
        } else if (this.protocol.algorithms.cipher) {
          this.trace(trace_1.TraceLevel.Info, trace_1.SshTraceEventIds.sessionEncrypted, `${this} encrypted.`);
        }
      }
      /* @internal */
      async processMessages() {
        var _a2;
        this.connected = true;
        while (!this.disposed) {
          const protocol = this.protocol;
          if (!protocol) {
            break;
          }
          let message = null;
          try {
            message = await protocol.receiveMessage();
          } catch (e) {
            if (!(e instanceof Error))
              throw e;
            let reason = transportMessages_1.SshDisconnectReason.protocolError;
            if (e instanceof errors_1.SshConnectionError) {
              reason = (_a2 = e.reason) !== null && _a2 !== void 0 ? _a2 : reason;
            } else {
              this.trace(trace_1.TraceLevel.Error, trace_1.SshTraceEventIds.receiveMessageFailed, `Error receiving message: ${e.message}`, e);
            }
            await this.close(reason, e.message, e);
          }
          if (!message) {
            await this.close(transportMessages_1.SshDisconnectReason.connectionLost, "Connection lost.");
            break;
          }
          let messageSuccess = false;
          try {
            await this.handleMessage(message);
            messageSuccess = true;
          } catch (e) {
            if (!(e instanceof Error))
              throw e;
            this.trace(trace_1.TraceLevel.Error, trace_1.SshTraceEventIds.handleMessageFailed, `Error handling ${message}: ${e.message}`, e);
            await this.close(transportMessages_1.SshDisconnectReason.protocolError, e.message, e);
          }
          if (messageSuccess) {
            this.keepAliveResponseReceived = true;
            this.startKeepAliveTimer();
          }
        }
        this.connected = false;
      }
      /**
       * Checks whether the session is in a state that allows requests, such as session requests
       * and open-channel requests.
       *
       * A session with disabled crypto (no key-exchange service) always allows requests. A
       * session with enabled crypto does not allow requests until the first key-exchange has
       * completed (algorithms are negotiated). If the negotiated algorithms enabled encryption,
       * then the session must be authenticated (have a principal) before allowing requests.
       */
      /* @internal */
      get canAcceptRequests() {
        var _a2;
        return !this.kexService || !!((_a2 = this.protocol) === null || _a2 === void 0 ? void 0 : _a2.algorithms) && (!this.protocol.algorithms.cipher || !!this.principal);
      }
      async sendMessage(message, cancellation) {
        var _a2, _b;
        if (!message)
          throw new TypeError("Message expected.");
        if (cancellation && cancellation.isCancellationRequested)
          throw new cancellation_1.CancellationError();
        const protocol = this.protocol;
        if (!protocol || this.disposed) {
          throw new errors_1.ObjectDisposedError(this);
        }
        if (this.kexService && this.kexService.exchanging && message.messageType > 4 && (message.messageType < 20 || message.messageType > 49)) {
          this.blockedMessages.push(message);
          return;
        }
        await this.blockedMessagesSemaphore.wait(cancellation);
        let result;
        try {
          result = await protocol.sendMessage(message, cancellation);
          this.blockedMessagesSemaphore.release();
        } catch (e) {
          this.blockedMessagesSemaphore.release();
          if (e instanceof errors_1.SshConnectionError) {
            const ce = e;
            if (ce.reason === transportMessages_1.SshDisconnectReason.connectionLost && ((_a2 = this.protocolExtensions) === null || _a2 === void 0 ? void 0 : _a2.has(sshSessionConfiguration_1.SshProtocolExtensionNames.sessionReconnect))) {
              return;
            }
          }
          if (!(e instanceof Error))
            throw e;
          this.trace(trace_1.TraceLevel.Error, trace_1.SshTraceEventIds.sendMessageFailed, `Error sending ${message}: ${e.message}`, e);
          throw e;
        }
        if (!result) {
          if (!((_b = this.protocolExtensions) === null || _b === void 0 ? void 0 : _b.has(sshSessionConfiguration_1.SshProtocolExtensionNames.sessionReconnect))) {
            throw new errors_1.SshConnectionError("Session disconnected.", transportMessages_1.SshDisconnectReason.connectionLost);
          }
        }
      }
      /**
       * Handles an incoming message. Can be overridden by subclasses to handle additional
       * message types that are registered via `SshSessionConfiguration.messages`.
       */
      handleMessage(message, cancellation) {
        var _a2;
        if (message instanceof connectionMessages_1.ConnectionMessage && this.connectionService) {
          return this.connectionService.handleMessage(message, cancellation);
        } else if (message instanceof kexMessages_1.NewKeysMessage) {
          return this.handleNewKeysMessage(message, cancellation);
        } else if (message instanceof kexMessages_1.KeyExchangeMessage) {
          return this.handleKeyExchangeMessage(message, cancellation);
        } else if (message instanceof authenticationMessages_1.AuthenticationMessage) {
          return (_a2 = this.getService(authenticationService_1.AuthenticationService)) === null || _a2 === void 0 ? void 0 : _a2.handleMessage(message, cancellation);
        } else if (message instanceof transportMessages_1.ServiceRequestMessage) {
          return this.handleServiceRequestMessage(message, cancellation);
        } else if (message instanceof transportMessages_1.ServiceAcceptMessage) {
          return this.handleServiceAcceptMessage(message, cancellation);
        } else if (message instanceof transportMessages_1.SessionRequestMessage) {
          return this.handleRequestMessage(message, cancellation);
        } else if (message instanceof transportMessages_1.SessionRequestSuccessMessage) {
          return this.handleRequestSuccessMessage(message);
        } else if (message instanceof transportMessages_1.SessionRequestFailureMessage) {
          return this.handleRequestFailureMessage(message);
        } else if (message instanceof transportMessages_1.ExtensionInfoMessage) {
          return this.handleExtensionInfoMessage(message, cancellation);
        } else if (message instanceof transportMessages_1.DisconnectMessage) {
          return this.handleDisconnectMessage(message);
        } else if (message instanceof transportMessages_1.UnimplementedMessage) {
          return this.handleUnimplementedMessage(message, cancellation);
        } else if (message instanceof transportMessages_1.DebugMessage) {
          return this.handleDebugMessage(message);
        } else if (message instanceof transportMessages_1.IgnoreMessage) {
          return;
        } else if (message instanceof sshMessage_1.SshMessage) {
          throw new Error(`Unhandled message type: ${message.constructor.name}`);
        } else {
          throw new TypeError("Message argument was " + (message ? "invalid type." : "null."));
        }
      }
      /* @internal */
      async handleRequestMessage(message, cancellation) {
        var _a2;
        let result = false;
        let response = null;
        if (message.requestType === "initial-channel-request@microsoft.com" && this.config.protocolExtensions.includes(sshSessionConfiguration_1.SshProtocolExtensionNames.openChannelRequest)) {
          const sessionChannelRequest = message.convertTo(new transportMessages_1.SessionChannelRequestMessage());
          const remoteChannelId = sessionChannelRequest.senderChannel;
          const channel = this.channels.find((c) => c.remoteChannelId === remoteChannelId);
          if (channel && sessionChannelRequest.request) {
            sessionChannelRequest.request.wantReply = false;
            result = await channel.handleRequest(sessionChannelRequest.request, cancellation);
          }
        } else if (message.requestType === "enable-session-reconnect@microsoft.com" && ((_a2 = this.config.protocolExtensions) === null || _a2 === void 0 ? void 0 : _a2.includes(sshSessionConfiguration_1.SshProtocolExtensionNames.sessionReconnect))) {
          if (!this.protocol.incomingMessagesHaveReconnectInfo) {
            this.protocol.incomingMessagesHaveReconnectInfo = true;
            this.protocol.incomingMessagesHaveLatencyInfo = this.protocol.extensions.has(sshSessionConfiguration_1.SshProtocolExtensionNames.sessionLatency);
            result = true;
          }
        } else if (message.requestType === "keepalive@openssh.com") {
          this.trace(trace_1.TraceLevel.Verbose, trace_1.SshTraceEventIds.keepAliveRequestReceived, `${this} Keep-alive request received`);
          result = true;
        } else if (!this.canAcceptRequests) {
          this.trace(trace_1.TraceLevel.Warning, trace_1.SshTraceEventIds.sessionRequestFailed, "Session request blocked because the session is not yet authenticated.");
          result = false;
        } else {
          const args = new sshRequestEventArgs_1.SshRequestEventArgs(message.requestType || "", message, this.principal, cancellation);
          const serviceType = (0, serviceActivation_1.findService)(this.config.services, (a) => a.sessionRequest === message.requestType);
          if (serviceType) {
            const service = this.activateService(serviceType);
            await service.onSessionRequest(args, cancellation);
          } else {
            this.raiseSessionRequest(args);
          }
          if (args.responsePromise) {
            response = await args.responsePromise;
            result = response instanceof transportMessages_1.SessionRequestSuccessMessage;
          } else {
            result = args.isAuthorized || false;
          }
        }
        if (message.wantReply) {
          if (result) {
            if (!(response instanceof transportMessages_1.SessionRequestSuccessMessage)) {
              response = new transportMessages_1.SessionRequestSuccessMessage();
            }
          } else {
            if (!(response instanceof transportMessages_1.SessionRequestFailureMessage)) {
              response = new transportMessages_1.SessionRequestFailureMessage();
            }
          }
          await this.sendMessage(response, cancellation);
        }
      }
      /* @internal */
      raiseReportProgress(progress) {
        const args = new sshReportProgressEventArgs_1.SshReportProgressEventArgs(progress, this.sessionNumber);
        this.reportProgressEmitter.fire(args);
      }
      /* @internal */
      raiseSessionRequest(args) {
        this.requestEmitter.fire(args);
      }
      /* @internal */
      async handleServiceRequestMessage(message, cancellation) {
      }
      /* @internal */
      async handleServiceAcceptMessage(message, cancellation) {
      }
      async handleKeyExchangeMessage(message, cancellation) {
        if (this.kexService) {
          await this.kexService.handleMessage(message, cancellation);
        } else if (!(message instanceof kexMessages_1.KeyExchangeInitMessage && message.allowsNone)) {
          await this.close(transportMessages_1.SshDisconnectReason.keyExchangeFailed, "Encryption is disabled.");
        }
      }
      /* @internal */
      async handleNewKeysMessage(message, cancellation) {
        var _a2;
        try {
          await this.blockedMessagesSemaphore.wait(cancellation);
          await this.protocol.handleNewKeys(cancellation);
          if ((_a2 = this.algorithms) === null || _a2 === void 0 ? void 0 : _a2.isExtensionInfoRequested) {
            await this.sendExtensionInfo(cancellation);
          }
          try {
            while (this.blockedMessages.length > 0) {
              const blockedMessage = this.blockedMessages.shift();
              if (!this.protocol)
                throw new errors_1.ObjectDisposedError(this);
              await this.protocol.sendMessage(blockedMessage, cancellation);
            }
          } catch (e) {
            if (!(e instanceof Error))
              throw e;
            await this.close(transportMessages_1.SshDisconnectReason.protocolError, void 0, e);
          }
        } finally {
          this.blockedMessagesSemaphore.release();
        }
      }
      async handleUnimplementedMessage(message, cancellation) {
        if (message.unimplementedMessageType !== void 0) {
          await this.sendMessage(message, cancellation);
        } else {
        }
      }
      handleDebugMessage(message) {
        if (message.message) {
          this.trace(message.alwaysDisplay ? trace_1.TraceLevel.Info : trace_1.TraceLevel.Verbose, trace_1.SshTraceEventIds.debugMessage, message.message);
        }
      }
      startKeepAliveTimer() {
        if (this.keepAliveTimer) {
          clearTimeout(this.keepAliveTimer);
          this.keepAliveTimer = void 0;
        }
        const timeoutInSeconds = this.config.keepAliveTimeoutInSeconds;
        if (!timeoutInSeconds || timeoutInSeconds <= 0 || this.disposed || !this.connected) {
          return;
        }
        this.keepAliveTimer = setTimeout(async () => {
          try {
            await this.onKeepAliveTimeout();
          } catch (error) {
            this.trace(trace_1.TraceLevel.Error, trace_1.SshTraceEventIds.unknownError, `Error in keep-alive timeout: ${error instanceof Error ? error.message : error}`, error instanceof Error ? error : void 0);
          }
        }, timeoutInSeconds * 1e3);
      }
      async onKeepAliveTimeout() {
        if (this.disposed || !this.connected) {
          if (this.keepAliveTimer) {
            clearTimeout(this.keepAliveTimer);
            this.keepAliveTimer = void 0;
          }
          return;
        }
        if (!this.canAcceptRequests) {
          this.startKeepAliveTimer();
          return;
        }
        if (!this.keepAliveResponseReceived) {
          this.keepAliveSuccessCount = 0;
          this.keepAliveFailureCount++;
          this.trace(trace_1.TraceLevel.Warning, trace_1.SshTraceEventIds.keepAliveResponseNotReceived, `${this} Keep-alive response not received (failure #${this.keepAliveFailureCount})`);
          this.keepAliveFailedEmitter.fire(this.keepAliveFailureCount);
        } else {
          this.keepAliveFailureCount = 0;
          this.keepAliveSuccessCount++;
          this.keepAliveSucceededEmitter.fire(this.keepAliveSuccessCount);
        }
        this.keepAliveResponseReceived = false;
        try {
          const request = new transportMessages_1.SessionRequestMessage();
          request.requestType = "keepalive@openssh.com";
          request.wantReply = true;
          await this.sendMessage(request);
        } catch (error) {
          this.keepAliveSuccessCount = 0;
          this.keepAliveFailureCount++;
          this.keepAliveFailedEmitter.fire(this.keepAliveFailureCount);
        }
        if (!this.disposed && this.connected) {
          this.startKeepAliveTimer();
        }
      }
      /* @internal */
      async raiseAuthenticatingEvent(args) {
        this.trace(trace_1.TraceLevel.Info, trace_1.SshTraceEventIds.sessionAuthenticating, `${this} Authenticating(${args})`);
        this.raiseReportProgress(progress_1.Progress.StartingSessionAuthentication);
        this.authenticatingEmitter.fire(args);
        let authPromise = args.authenticationPromise;
        if (!authPromise) {
          authPromise = Promise.resolve(null);
        }
        const principal = await authPromise;
        this.raiseReportProgress(progress_1.Progress.CompletedSessionAuthentication);
        return principal;
      }
      /**
       * Sends a session request and waits for a response.
       *
       * Note if `wantReply` is `false`, this method returns `true` immediately after sending
       * the request, without waiting for a response.
       *
       * @returns The authorization status of the response; if `false`, the other side denied the
       * request.
       */
      async request(request, cancellation) {
        if (!request)
          throw new TypeError("Request is required.");
        if (!request.wantReply) {
          await this.sendMessage(request, cancellation);
          return true;
        }
        const response = await this.requestResponse(request, transportMessages_1.SessionRequestSuccessMessage, transportMessages_1.SessionRequestFailureMessage, cancellation);
        return response instanceof transportMessages_1.SessionRequestSuccessMessage;
      }
      /**
       * Sends a session request and waits for a specific type of success or failure message.
       *
       * @returns The success or failure response message.
       */
      async requestResponse(request, successType, failureType, cancellation) {
        if (!request)
          throw new TypeError("Request is required.");
        if (!successType)
          throw new TypeError("Success response type is required.");
        if (!failureType)
          throw new TypeError("Failure response type is required.");
        request.wantReply = true;
        const requestHandler = (err, result) => {
          var _a2, _b;
          if (err) {
            requestCompletionSource.reject(err);
          } else if (requestHandler.isCancelled) {
            return;
          } else if (result instanceof transportMessages_1.SessionRequestFailureMessage) {
            const failure = (_a2 = result === null || result === void 0 ? void 0 : result.convertTo(new failureType(), true)) !== null && _a2 !== void 0 ? _a2 : null;
            requestCompletionSource.resolve(failure);
          } else if (result instanceof transportMessages_1.SessionRequestSuccessMessage) {
            const success = (_b = result === null || result === void 0 ? void 0 : result.convertTo(new successType(), true)) !== null && _b !== void 0 ? _b : null;
            requestCompletionSource.resolve(success);
          } else {
            requestCompletionSource.reject(new Error("Unknown response message type."));
          }
        };
        const requestCompletionSource = new promiseCompletionSource_1.PromiseCompletionSource();
        if (cancellation) {
          if (cancellation.isCancellationRequested)
            throw new cancellation_1.CancellationError();
          cancellation.onCancellationRequested(() => {
            requestHandler.isCancelled = true;
            requestCompletionSource.reject(new cancellation_1.CancellationError());
          });
        }
        this.requestHandlers.enqueue(requestHandler);
        await this.sendMessage(request, cancellation);
        return await requestCompletionSource.promise;
      }
      handleRequestSuccessMessage(message) {
        this.invokeRequestHandler(message, void 0, void 0);
      }
      handleRequestFailureMessage(message) {
        this.invokeRequestHandler(void 0, message, void 0);
      }
      invokeRequestHandler(success, failure, error) {
        let requestHandler;
        while (requestHandler = this.requestHandlers.dequeue()) {
          requestHandler(error, success !== null && success !== void 0 ? success : failure);
          if (!error) {
            break;
          }
        }
      }
      async acceptChannel(channelTypeOrCancellation, cancellation) {
        const channelType = typeof channelTypeOrCancellation === "string" ? channelTypeOrCancellation : void 0;
        if (!cancellation && typeof channelTypeOrCancellation === "object")
          cancellation = channelTypeOrCancellation;
        this.activateService(connectionService_1.ConnectionService);
        const acceptPromise = this.connectionService.acceptChannel(channelType || sshChannel_1.SshChannel.sessionChannelType, cancellation);
        return await acceptPromise;
      }
      async openChannel(channelTypeOrOpenMessageOrCancellation, initialRequestOrCancellation, cancellation) {
        let openMessage;
        if (typeof channelTypeOrOpenMessageOrCancellation === "string" || channelTypeOrOpenMessageOrCancellation === null) {
          openMessage = new connectionMessages_1.ChannelOpenMessage();
          openMessage.channelType = channelTypeOrOpenMessageOrCancellation !== null && channelTypeOrOpenMessageOrCancellation !== void 0 ? channelTypeOrOpenMessageOrCancellation : sshChannel_1.SshChannel.sessionChannelType;
        } else if (channelTypeOrOpenMessageOrCancellation instanceof connectionMessages_1.ChannelOpenMessage) {
          openMessage = channelTypeOrOpenMessageOrCancellation;
        } else {
          openMessage = new connectionMessages_1.ChannelOpenMessage();
          openMessage.channelType = sshChannel_1.SshChannel.sessionChannelType;
          cancellation = channelTypeOrOpenMessageOrCancellation;
        }
        if (initialRequestOrCancellation instanceof connectionMessages_1.ChannelRequestMessage) {
          return await this.openChannelWithInitialRequest(openMessage, initialRequestOrCancellation, cancellation);
        } else if (!cancellation && initialRequestOrCancellation !== null) {
          cancellation = initialRequestOrCancellation;
        }
        this.activateService(connectionService_1.ConnectionService);
        const completionSource = new promiseCompletionSource_1.PromiseCompletionSource();
        await this.connectionService.openChannel(openMessage, completionSource, cancellation);
        return await completionSource.promise;
      }
      async openChannelWithInitialRequest(openMessage, initialRequest, cancellation) {
        var _a2;
        this.activateService(connectionService_1.ConnectionService);
        const completionSource = new promiseCompletionSource_1.PromiseCompletionSource();
        const channelId = await this.connectionService.openChannel(openMessage, completionSource, cancellation);
        if (cancellation) {
          if (cancellation.isCancellationRequested)
            throw new cancellation_1.CancellationError();
          cancellation.onCancellationRequested(() => completionSource.reject(new cancellation_1.CancellationError()));
        }
        let channel;
        let requestResult;
        const isExtensionSupported = this.config.protocolExtensions.includes(sshSessionConfiguration_1.SshProtocolExtensionNames.openChannelRequest) && ((_a2 = this.protocolExtensions) === null || _a2 === void 0 ? void 0 : _a2.has(sshSessionConfiguration_1.SshProtocolExtensionNames.openChannelRequest));
        if (isExtensionSupported === false) {
          channel = await completionSource.promise;
          requestResult = await channel.request(initialRequest, cancellation);
        } else {
          const wantReply = initialRequest.wantReply || isExtensionSupported === void 0;
          const sessionRequest = new transportMessages_1.SessionChannelRequestMessage();
          sessionRequest.requestType = "initial-channel-request@microsoft.com";
          sessionRequest.senderChannel = channelId;
          sessionRequest.request = initialRequest;
          sessionRequest.wantReply = wantReply;
          const requestPromise = this.request(sessionRequest, cancellation);
          channel = await completionSource.promise;
          if (!wantReply) {
            requestResult = true;
          } else {
            requestResult = await requestPromise;
            if (!requestResult && isExtensionSupported === void 0) {
              requestResult = await channel.request(initialRequest);
            }
          }
        }
        if (!requestResult) {
          await channel.close();
          throw new Error("The initial channel request was denied.");
        }
        return channel;
      }
      /* @internal */
      async handleChannelOpening(args, cancellation, resolveService = true) {
        if (resolveService) {
          const serviceType = (0, serviceActivation_1.findService)(this.config.services, (a) => a.channelType === args.channel.channelType && !a.channelRequest);
          if (serviceType) {
            const service = this.activateService(serviceType);
            await service.onChannelOpening(args, cancellation);
            return;
          }
        }
        args.cancellation = cancellation !== null && cancellation !== void 0 ? cancellation : vscode_jsonrpc_1.CancellationToken.None;
        this.channelOpeningEmitter.fire(args);
      }
      /* @internal */
      async sendExtensionInfo(cancellation) {
        if (!this.protocol)
          return;
        const message = new transportMessages_1.ExtensionInfoMessage();
        message.extensionInfo = {};
        for (const extensionName of this.config.protocolExtensions) {
          if (extensionName === sshSessionConfiguration_1.SshProtocolExtensionNames.serverSignatureAlgorithms) {
            const publicKeyAlgorithms = Array.from(new Set((0, sshAlgorithms_1.algorithmNames)(this.config.publicKeyAlgorithms))).join(",");
            message.extensionInfo[extensionName] = publicKeyAlgorithms;
          } else {
            message.extensionInfo[extensionName] = "";
          }
        }
        await this.protocol.sendMessage(message, cancellation);
      }
      async handleExtensionInfoMessage(message, cancellation) {
        if (!this.protocol) {
          return;
        }
        this.protocol.extensions = /* @__PURE__ */ new Map();
        const proposedExtensions = message.extensionInfo;
        if (!proposedExtensions) {
          return;
        }
        for (const extensionName of this.config.protocolExtensions) {
          const proposedExtension = message.extensionInfo[extensionName];
          if (typeof proposedExtension === "string") {
            this.protocol.extensions.set(extensionName, proposedExtension);
          }
        }
        if (this.protocol.extensions.has(sshSessionConfiguration_1.SshProtocolExtensionNames.sessionReconnect)) {
          await this.enableReconnect(cancellation);
        }
      }
      async close(reason, message, error) {
        var _a2, _b, _c;
        if (this.disposed || !this.connected) {
          return;
        }
        this.connected = false;
        this.trace(trace_1.TraceLevel.Info, trace_1.SshTraceEventIds.sessionClosing, `${this} Close(${transportMessages_1.SshDisconnectReason[reason]}, "${message || ""}")`);
        if (reason !== transportMessages_1.SshDisconnectReason.connectionLost) {
          try {
            const disconnectMessage = new transportMessages_1.DisconnectMessage();
            disconnectMessage.reasonCode = reason;
            disconnectMessage.description = message || "";
            await ((_a2 = this.protocol) === null || _a2 === void 0 ? void 0 : _a2.sendMessage(disconnectMessage));
          } catch (e) {
          }
        } else if (this.handleDisconnected()) {
          (_b = this.protocol) === null || _b === void 0 ? void 0 : _b.dispose();
          this.trace(trace_1.TraceLevel.Info, trace_1.SshTraceEventIds.sessionDisconnected, `${this} disconnected.`);
          this.disconnectedEmitter.fire();
          return;
        }
        this.disposed = true;
        this.closedError = error;
        error = error !== null && error !== void 0 ? error : new errors_1.SshConnectionError(message, reason);
        if (error) {
          (_c = this.connectionService) === null || _c === void 0 ? void 0 : _c.close(error);
        }
        this.closedEmitter.fire(new sshSessionClosedEventArgs_1.SshSessionClosedEventArgs(reason, message || "Disconnected.", error));
        this.dispose();
      }
      /* @internal */
      handleDisconnected() {
        var _a2, _b;
        this.connectPromise = void 0;
        (_a2 = this.kexService) === null || _a2 === void 0 ? void 0 : _a2.abortKeyExchange();
        if (!((_b = this.protocolExtensions) === null || _b === void 0 ? void 0 : _b.has(sshSessionConfiguration_1.SshProtocolExtensionNames.sessionReconnect))) {
          return false;
        }
        return true;
      }
      async handleDisconnectMessage(message) {
        var _a2;
        const description = message.description || "Received disconnect message.";
        await this.close((_a2 = message.reasonCode) !== null && _a2 !== void 0 ? _a2 : transportMessages_1.SshDisconnectReason.none, description);
      }
      dispose(error) {
        var _a2, _b;
        const closedError = error !== null && error !== void 0 ? error : this.closedError instanceof errors_1.SshConnectionError ? this.closedError : new errors_1.SshConnectionError(this.constructor.name + " disposed.");
        if (!this.disposed) {
          this.trace(trace_1.TraceLevel.Info, trace_1.SshTraceEventIds.sessionClosing, `${this} disposed.`);
          this.disposed = true;
          if (this.keepAliveTimer) {
            clearTimeout(this.keepAliveTimer);
            this.keepAliveTimer = void 0;
          }
          this.closedEmitter.fire(new sshSessionClosedEventArgs_1.SshSessionClosedEventArgs(transportMessages_1.SshDisconnectReason.none, closedError.message, closedError));
        }
        this.invokeRequestHandler(void 0, void 0, closedError);
        this.metrics.close();
        (_a2 = this.connectionService) === null || _a2 === void 0 ? void 0 : _a2.dispose();
        for (const service of this.activatedServices.values()) {
          if (service !== this.connectionService) {
            service.dispose();
          }
        }
        this.activatedServices.clear();
        (_b = this.protocol) === null || _b === void 0 ? void 0 : _b.dispose();
        this.protocol = void 0;
      }
      /* @internal */
      async enableReconnect(cancellation) {
        var _a2;
        try {
          await this.blockedMessagesSemaphore.wait();
          if ((_a2 = this.kexService) === null || _a2 === void 0 ? void 0 : _a2.exchanging) {
            this.trace(trace_1.TraceLevel.Error, trace_1.SshTraceEventIds.sessionReconnectInitFailed, "Failed to initialize session reconnect because a key-exchange was in-progress.");
          } else {
            const enableReconnectMessage = new transportMessages_1.SessionRequestMessage("enable-session-reconnect@microsoft.com", false);
            await this.protocol.sendMessage(enableReconnectMessage, cancellation);
            if (this.protocol) {
              this.protocol.outgoingMessagesHaveReconnectInfo = true;
              this.protocol.outgoingMessagesHaveLatencyInfo = this.protocol.extensions.has(sshSessionConfiguration_1.SshProtocolExtensionNames.sessionLatency);
            }
          }
          this.blockedMessagesSemaphore.release();
        } catch (e) {
          this.blockedMessagesSemaphore.release();
          if (e instanceof Error) {
            await this.close(transportMessages_1.SshDisconnectReason.protocolError, void 0, e);
          }
          throw e;
        }
      }
      /* @internal */
      async createReconnectToken(previousSessionId, newSessionId) {
        const reconnectToken = await this.algorithms.signer.sign(buffer_1.Buffer.concat([previousSessionId, newSessionId]));
        return reconnectToken;
      }
      /* @internal */
      async verifyReconnectToken(previousSessionId, newSessionId, reconnectToken) {
        const result = await this.algorithms.verifier.verify(buffer_1.Buffer.concat([previousSessionId, newSessionId]), reconnectToken);
        return result;
      }
      /**
       * Pipes one SSH session into another, relaying all data between them.
       *
       * Any new channels opened from the remote side of either session will be piped into a
       * new channel in the other session. Any channels opened before connecting the session pipe,
       * or any channels opened from the local side, will not be piped.
       *
       * @param toSession Session to which the current session will be connected via the pipe.
       * @returns A promise that resolves when the sessions are closed.
       */
      pipe(toSession) {
        return pipeExtensions_1.PipeExtensions.pipeSession(this, toSession);
      }
      toString() {
        return this.constructor.name;
      }
    };
    exports2.SshSession = SshSession;
    SshSession.localVersion = sshVersionInfo_1.SshVersionInfo.getLocalVersion();
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/sshSessionAlgorithms.js
var require_sshSessionAlgorithms = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/sshSessionAlgorithms.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SshSessionAlgorithms = void 0;
    var SshSessionAlgorithms = class {
      dispose() {
        if (this.cipher)
          this.cipher.dispose();
        if (this.decipher)
          this.decipher.dispose();
        if (this.signer)
          this.signer.dispose();
        if (this.verifier)
          this.verifier.dispose();
      }
    };
    exports2.SshSessionAlgorithms = SshSessionAlgorithms;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/services/keyExchangeService.js
var require_keyExchangeService = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/services/keyExchangeService.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var KeyExchangeService_1;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.KeyExchangeService = void 0;
    var buffer_1 = require("buffer");
    var sshSession_1 = require_sshSession();
    var sshService_1 = require_sshService();
    var bigInt_1 = require_bigInt();
    var kexMessages_1 = require_kexMessages();
    var sshAlgorithms_1 = require_sshAlgorithms();
    var sshData_1 = require_sshData();
    var errors_1 = require_errors();
    var transportMessages_1 = require_transportMessages();
    var sshSessionAlgorithms_1 = require_sshSessionAlgorithms();
    var vscode_jsonrpc_1 = require_main();
    var connectionService_1 = require_connectionService();
    var serviceActivation_1 = require_serviceActivation();
    var trace_1 = require_trace();
    var ExchangeContext = class {
    };
    var serverExtensionInfoSignal = "ext-info-s";
    var clientExtensionInfoSignal = "ext-info-c";
    var KeyExchangeService = KeyExchangeService_1 = class KeyExchangeService extends sshService_1.SshService {
      constructor(session) {
        super(session);
        this.isInitialExchange = false;
        this.exchangeContext = null;
      }
      get exchanging() {
        return !!this.exchangeContext;
      }
      async startKeyExchange(isInitialExchange) {
        this.isInitialExchange = isInitialExchange;
        this.exchangeContext = new ExchangeContext();
        const kexInitMessage = this.createKeyExchangeInitMessage();
        let kexGuessMessage = null;
        if (this.session.isClientSession) {
          if (isInitialExchange && this.session.config.enableKeyExchangeGuess) {
            kexGuessMessage = await this.createKeyExchangeGuessMessage();
            kexInitMessage.firstKexPacketFollows = !!kexGuessMessage;
          }
          this.exchangeContext.clientKexInitPayload = kexInitMessage.toBuffer();
        } else {
          this.exchangeContext.serverKexInitPayload = kexInitMessage.toBuffer();
        }
        return [kexInitMessage, kexGuessMessage];
      }
      finishKeyExchange() {
        var _a2;
        if (!this.exchangeContext) {
          throw new errors_1.SshConnectionError("Key exchange not started.", transportMessages_1.SshDisconnectReason.protocolError);
        }
        const newAlgorithms = this.exchangeContext.newAlgorithms;
        if (!newAlgorithms) {
          throw new errors_1.SshConnectionError("Key exchange not completed.", transportMessages_1.SshDisconnectReason.protocolError);
        }
        newAlgorithms.isExtensionInfoRequested = (_a2 = this.exchangeContext) === null || _a2 === void 0 ? void 0 : _a2.isExtensionInfoRequested;
        this.exchangeContext = null;
        return newAlgorithms;
      }
      abortKeyExchange() {
        this.exchangeContext = null;
      }
      createKeyExchangeInitMessage() {
        const extinfo = this.session.isClientSession ? clientExtensionInfoSignal : serverExtensionInfoSignal;
        const config = this.session.config;
        const message = new kexMessages_1.KeyExchangeInitMessage();
        message.keyExchangeAlgorithms = (0, sshAlgorithms_1.algorithmNames)(config.keyExchangeAlgorithms).concat(extinfo);
        message.serverHostKeyAlgorithms = this.getPublicKeyAlgorithms();
        message.encryptionAlgorithmsClientToServer = message.encryptionAlgorithmsServerToClient = (0, sshAlgorithms_1.algorithmNames)(config.encryptionAlgorithms);
        message.macAlgorithmsClientToServer = message.macAlgorithmsServerToClient = (0, sshAlgorithms_1.algorithmNames)(config.hmacAlgorithms);
        message.compressionAlgorithmsClientToServer = message.compressionAlgorithmsServerToClient = (0, sshAlgorithms_1.algorithmNames)(config.compressionAlgorithms);
        message.languagesClientToServer = [""];
        message.languagesServerToClient = [""];
        message.firstKexPacketFollows = false;
        message.reserved = 0;
        return message;
      }
      /**
       * Gets the list of public key algorithms that the current session can support.
       * For a server session the list is filtered based on the available private keys.
       */
      getPublicKeyAlgorithms() {
        var _a2, _b;
        let publicKeyAlgorithms = [...this.session.config.publicKeyAlgorithms];
        if (publicKeyAlgorithms.length > 1 && !this.session.isClientSession) {
          const privateKeyAlgorithms = (_b = (_a2 = this.session.credentials) === null || _a2 === void 0 ? void 0 : _a2.publicKeys) === null || _b === void 0 ? void 0 : _b.map((k) => k.keyAlgorithmName);
          if (privateKeyAlgorithms) {
            publicKeyAlgorithms = publicKeyAlgorithms.filter((a) => a && privateKeyAlgorithms.includes(a.keyAlgorithmName));
          }
        }
        const publicKeyAlgorithmNames = (0, sshAlgorithms_1.algorithmNames)(publicKeyAlgorithms);
        return publicKeyAlgorithmNames;
      }
      async createKeyExchangeGuessMessage() {
        if (!this.exchangeContext) {
          throw new Error("Key exchange was not started.");
        }
        const kexAlgorithm = this.session.config.keyExchangeAlgorithms[0];
        if (!kexAlgorithm) {
          return null;
        }
        this.exchangeContext.keyExchange = kexAlgorithm.name;
        this.exchangeContext.exchange = kexAlgorithm.createKeyExchange();
        this.exchangeContext.exchangeValue = await this.exchangeContext.exchange.startKeyExchange();
        const guess = new kexMessages_1.KeyExchangeDhInitMessage();
        guess.e = this.exchangeContext.exchangeValue;
        return guess;
      }
      handleMessage(message, cancellation) {
        if (message instanceof kexMessages_1.KeyExchangeInitMessage) {
          return this.handleInitMessage(message, cancellation);
        } else if (message instanceof kexMessages_1.KeyExchangeDhInitMessage) {
          return this.handleDhInitMessage(message, cancellation);
        } else if (message instanceof kexMessages_1.KeyExchangeDhReplyMessage) {
          return this.handleDhReplyMessage(message, cancellation);
        } else {
          throw new Error(`Message not implemented: ${message}`);
        }
      }
      async handleInitMessage(message, cancellation) {
        var _a2, _b, _c, _d;
        if (!this.exchangeContext) {
          throw new Error("Key exchange was not started.");
        }
        const config = this.session.config;
        this.exchangeContext.keyExchange = this.chooseAlgorithm("KeyExchange", (0, sshAlgorithms_1.algorithmNames)(config.keyExchangeAlgorithms), message.keyExchangeAlgorithms);
        if (this.exchangeContext.keyExchange === "none") {
          this.trace(trace_1.TraceLevel.Info, trace_1.SshTraceEventIds.algorithmNegotiation, "Client and server negotiated no security. Cancelling key-exchange.");
          this.session.activateService(connectionService_1.ConnectionService);
          this.exchangeContext.newAlgorithms = new sshSessionAlgorithms_1.SshSessionAlgorithms();
          await this.session.handleNewKeysMessage(new kexMessages_1.NewKeysMessage(), cancellation);
          return;
        }
        this.exchangeContext.publicKey = this.chooseAlgorithm("PublicKey", this.getPublicKeyAlgorithms(), message.serverHostKeyAlgorithms);
        this.exchangeContext.clientEncryption = this.chooseAlgorithm("ClientEncryption", (0, sshAlgorithms_1.algorithmNames)(config.encryptionAlgorithms), message.encryptionAlgorithmsClientToServer);
        this.exchangeContext.serverEncryption = this.chooseAlgorithm("ServerEncryption", (0, sshAlgorithms_1.algorithmNames)(config.encryptionAlgorithms), message.encryptionAlgorithmsServerToClient);
        this.exchangeContext.clientHmac = this.chooseAlgorithm("ClientHmac", (0, sshAlgorithms_1.algorithmNames)(config.hmacAlgorithms), message.macAlgorithmsClientToServer);
        this.exchangeContext.serverHmac = this.chooseAlgorithm("ServerHmac", (0, sshAlgorithms_1.algorithmNames)(config.hmacAlgorithms), message.macAlgorithmsServerToClient);
        this.exchangeContext.clientCompression = this.chooseAlgorithm("ClientCompression", (0, sshAlgorithms_1.algorithmNames)(config.compressionAlgorithms), message.compressionAlgorithmsClientToServer);
        this.exchangeContext.serverCompression = this.chooseAlgorithm("ServerCompression", (0, sshAlgorithms_1.algorithmNames)(config.compressionAlgorithms), message.compressionAlgorithmsServerToClient);
        if (this.session.isClientSession) {
          this.exchangeContext.serverKexInitPayload = message.toBuffer();
          const alreadySentGuess = !!this.exchangeContext.exchangeValue;
          const negotiatedKexAlgorithmIsPreferred = this.exchangeContext.keyExchange === ((_a2 = config.keyExchangeAlgorithms[0]) === null || _a2 === void 0 ? void 0 : _a2.name);
          if (!alreadySentGuess || !negotiatedKexAlgorithmIsPreferred) {
            const kexAlgorithm = config.getKeyExchangeAlgorithm(this.exchangeContext.keyExchange);
            this.exchangeContext.exchange = kexAlgorithm.createKeyExchange();
            this.exchangeContext.exchangeValue = await this.exchangeContext.exchange.startKeyExchange();
            const reply = new kexMessages_1.KeyExchangeDhInitMessage();
            reply.e = this.exchangeContext.exchangeValue;
            await this.session.sendMessage(reply, cancellation);
          } else {
            this.trace(trace_1.TraceLevel.Verbose, trace_1.SshTraceEventIds.algorithmNegotiation, "Already sent correct guess for key-exchange init.");
          }
          this.exchangeContext.isExtensionInfoRequested = this.isInitialExchange && ((_b = message.keyExchangeAlgorithms) === null || _b === void 0 ? void 0 : _b.includes(serverExtensionInfoSignal));
        } else {
          if (message.firstKexPacketFollows) {
            const negotiatedKexAlgorithmIsPreferred = this.exchangeContext.keyExchange === ((_c = message.keyExchangeAlgorithms) === null || _c === void 0 ? void 0 : _c[0]);
            const guessResult = negotiatedKexAlgorithmIsPreferred ? "correct" : "incorrect";
            this.trace(trace_1.TraceLevel.Verbose, trace_1.SshTraceEventIds.algorithmNegotiation, `Client's KeyExchange guess was ${guessResult}.`);
            this.exchangeContext.discardGuessedInit = !negotiatedKexAlgorithmIsPreferred;
          }
          this.exchangeContext.clientKexInitPayload = message.toBuffer();
          this.exchangeContext.isExtensionInfoRequested = this.isInitialExchange && ((_d = message.keyExchangeAlgorithms) === null || _d === void 0 ? void 0 : _d.includes(clientExtensionInfoSignal));
        }
      }
      async handleDhInitMessage(message, cancellation) {
        var _a2, _b, _c, _d, _e;
        if (this.session.isClientSession) {
          return;
        }
        const serverSession = this.session;
        if (!this.exchangeContext || !this.exchangeContext.keyExchange || !this.exchangeContext.publicKey) {
          throw new errors_1.SshConnectionError("Key exchange not started.", transportMessages_1.SshDisconnectReason.protocolError);
        }
        if (this.exchangeContext.discardGuessedInit) {
          this.exchangeContext.discardGuessedInit = false;
          return;
        }
        const kexAlg = this.session.config.getKeyExchangeAlgorithm(this.exchangeContext.keyExchange);
        if (!kexAlg) {
          throw new errors_1.SshConnectionError("Key exchange not supported for algorithm: " + this.exchangeContext.keyExchange, transportMessages_1.SshDisconnectReason.keyExchangeFailed);
        }
        const publicKeyAlg = this.session.config.getPublicKeyAlgorithm(this.exchangeContext.publicKey);
        if (!publicKeyAlg) {
          throw new errors_1.SshConnectionError("Public key algorithm not supported: " + this.exchangeContext.publicKey, transportMessages_1.SshDisconnectReason.keyExchangeFailed);
        }
        let privateKey = null;
        if ((_a2 = serverSession.credentials) === null || _a2 === void 0 ? void 0 : _a2.publicKeys) {
          const publicKey = serverSession.credentials.publicKeys.find((k) => k.keyAlgorithmName === publicKeyAlg.keyAlgorithmName);
          privateKey = publicKey !== null && publicKey !== void 0 ? publicKey : null;
          if ((privateKey === null || privateKey === void 0 ? void 0 : privateKey.hasPrivateKey) === false) {
            if (!serverSession.credentials.privateKeyProvider) {
              throw new Error("A private key provider is required.");
            }
            privateKey = await serverSession.credentials.privateKeyProvider(publicKey, cancellation !== null && cancellation !== void 0 ? cancellation : vscode_jsonrpc_1.CancellationToken.None);
          }
        }
        if (privateKey == null) {
          throw new errors_1.SshConnectionError("Private key not found for algorithm: " + this.exchangeContext.publicKey, transportMessages_1.SshDisconnectReason.keyExchangeFailed);
        }
        const clientEncryption = this.session.config.getEncryptionAlgorithm(this.exchangeContext.clientEncryption);
        const serverEncryption = this.session.config.getEncryptionAlgorithm(this.exchangeContext.serverEncryption);
        const serverHmac = this.session.config.getHmacAlgorithm(this.exchangeContext.serverHmac);
        const clientHmac = this.session.config.getHmacAlgorithm(this.exchangeContext.clientHmac);
        const keyExchange = kexAlg.createKeyExchange();
        const clientExchangeValue = message.e || buffer_1.Buffer.alloc(0);
        const serverExchangeValue = await keyExchange.startKeyExchange();
        const sharedSecret = await keyExchange.decryptKeyExchange(clientExchangeValue);
        const hostKeyAndCerts = await privateKey.getPublicKeyBytes(publicKeyAlg.name);
        if (!hostKeyAndCerts) {
          throw new errors_1.SshConnectionError("Public key not set.", transportMessages_1.SshDisconnectReason.keyExchangeFailed);
        }
        const exchangeHash = await this.computeExchangeHash(keyExchange, hostKeyAndCerts, clientExchangeValue, serverExchangeValue, sharedSecret);
        if (!this.session.sessionId) {
          this.session.sessionId = exchangeHash;
        }
        const [clientCipherIV, serverCipherIV, clientCipherKey, serverCipherKey, clientHmacKey, serverHmacKey] = await this.computeKeys(keyExchange, sharedSecret, exchangeHash, clientEncryption, serverEncryption, clientHmac, serverHmac);
        const cipher = (_b = await (serverEncryption === null || serverEncryption === void 0 ? void 0 : serverEncryption.createCipher(true, serverCipherKey, serverCipherIV))) !== null && _b !== void 0 ? _b : null;
        const decipher = (_c = await (clientEncryption === null || clientEncryption === void 0 ? void 0 : clientEncryption.createCipher(false, clientCipherKey, clientCipherIV))) !== null && _c !== void 0 ? _c : null;
        const signer = (_d = await (serverHmac === null || serverHmac === void 0 ? void 0 : serverHmac.createSigner(serverHmacKey))) !== null && _d !== void 0 ? _d : null;
        const verifier = (_e = await (clientHmac === null || clientHmac === void 0 ? void 0 : clientHmac.createVerifier(clientHmacKey))) !== null && _e !== void 0 ? _e : null;
        const algorithms = new sshSessionAlgorithms_1.SshSessionAlgorithms();
        algorithms.publicKeyAlgorithmName = this.exchangeContext.publicKey;
        algorithms.cipher = cipher;
        algorithms.decipher = decipher;
        algorithms.signer = signer;
        algorithms.verifier = verifier;
        algorithms.messageSigner = (cipher === null || cipher === void 0 ? void 0 : cipher.authenticatedEncryption) ? cipher : signer;
        algorithms.messageVerifier = (decipher === null || decipher === void 0 ? void 0 : decipher.authenticatedEncryption) ? decipher : verifier;
        algorithms.compressor = this.session.config.getCompressionAlgorithm(this.exchangeContext.serverCompression);
        algorithms.decompressor = this.session.config.getCompressionAlgorithm(this.exchangeContext.clientCompression);
        this.exchangeContext.newAlgorithms = algorithms;
        if (clientCipherIV)
          clientCipherIV.fill(0);
        if (clientCipherKey)
          clientCipherKey.fill(0);
        if (clientHmacKey)
          clientHmacKey.fill(0);
        if (serverCipherIV)
          serverCipherIV.fill(0);
        if (serverCipherKey)
          serverCipherKey.fill(0);
        if (serverHmacKey)
          serverHmacKey.fill(0);
        const exchangeSigner = publicKeyAlg.createSigner(privateKey);
        let signature = await exchangeSigner.sign(exchangeHash);
        signature = publicKeyAlg.createSignatureData(signature);
        const reply = new kexMessages_1.KeyExchangeDhReplyMessage();
        reply.hostKey = hostKeyAndCerts;
        reply.f = serverExchangeValue;
        reply.signature = signature;
        await this.session.sendMessage(reply, cancellation);
        await this.session.sendMessage(new kexMessages_1.NewKeysMessage(), cancellation);
      }
      async handleDhReplyMessage(message, cancellation) {
        var _a2, _b, _c, _d;
        if (!this.session.isClientSession) {
          return;
        }
        if (!this.exchangeContext) {
          throw new errors_1.SshConnectionError("Key exchange was not started.", transportMessages_1.SshDisconnectReason.protocolError);
        }
        const config = this.session.config;
        const keyExchange = this.exchangeContext.exchange;
        const publicKeyAlgorithmName = this.exchangeContext.publicKey;
        const publicKeyAlg = config.getPublicKeyAlgorithm(publicKeyAlgorithmName);
        const clientEncryption = config.getEncryptionAlgorithm(this.exchangeContext.clientEncryption);
        const serverEncryption = config.getEncryptionAlgorithm(this.exchangeContext.serverEncryption);
        const serverHmac = config.getHmacAlgorithm(this.exchangeContext.serverHmac);
        const clientHmac = config.getHmacAlgorithm(this.exchangeContext.clientHmac);
        const clientExchangeValue = this.exchangeContext.exchangeValue;
        const serverExchangeValue = message.f;
        if (!keyExchange || !clientExchangeValue) {
          throw new errors_1.SshConnectionError("Failed to initialize crypto after key exchange.", transportMessages_1.SshDisconnectReason.keyExchangeFailed);
        }
        this.hostKey = publicKeyAlg.createKeyPair();
        await this.hostKey.setPublicKeyBytes(message.hostKey);
        const sharedSecret = await keyExchange.decryptKeyExchange(serverExchangeValue);
        const hostKeyAndCerts = message.hostKey;
        const exchangeHash = await this.computeExchangeHash(keyExchange, hostKeyAndCerts, clientExchangeValue, serverExchangeValue, sharedSecret);
        const signature = publicKeyAlg.readSignatureData(message.signature);
        const exchangeVerifier = publicKeyAlg.createVerifier(this.hostKey);
        let verified;
        try {
          verified = await exchangeVerifier.verify(exchangeHash, signature);
        } catch (e) {
          if (!(e instanceof Error))
            throw e;
          this.trace(trace_1.TraceLevel.Error, trace_1.SshTraceEventIds.serverAuthenticationFailed, `Server public key verification error: ${e.message}`, e);
          throw new errors_1.SshConnectionError(`Server public key verification failed: ${e.message}`, transportMessages_1.SshDisconnectReason.hostKeyNotVerifiable);
        }
        if (verified) {
          this.trace(trace_1.TraceLevel.Verbose, trace_1.SshTraceEventIds.sessionAuthenticated, "Server public key verification succeeded.");
        } else {
          this.trace(trace_1.TraceLevel.Warning, trace_1.SshTraceEventIds.serverAuthenticationFailed, "Server public key verification failed.");
          throw new errors_1.SshConnectionError("Server public key verification failed.", transportMessages_1.SshDisconnectReason.hostKeyNotVerifiable);
        }
        if (this.session.sessionId == null) {
          this.session.sessionId = exchangeHash;
        }
        const [clientCipherIV, serverCipherIV, clientCipherKey, serverCipherKey, clientHmacKey, serverHmacKey] = await this.computeKeys(keyExchange, sharedSecret, exchangeHash, clientEncryption, serverEncryption, clientHmac, serverHmac);
        const cipher = (_a2 = await (clientEncryption === null || clientEncryption === void 0 ? void 0 : clientEncryption.createCipher(true, clientCipherKey, clientCipherIV))) !== null && _a2 !== void 0 ? _a2 : null;
        const decipher = (_b = await (serverEncryption === null || serverEncryption === void 0 ? void 0 : serverEncryption.createCipher(false, serverCipherKey, serverCipherIV))) !== null && _b !== void 0 ? _b : null;
        const signer = (_c = await (clientHmac === null || clientHmac === void 0 ? void 0 : clientHmac.createSigner(clientHmacKey))) !== null && _c !== void 0 ? _c : null;
        const verifier = (_d = await (serverHmac === null || serverHmac === void 0 ? void 0 : serverHmac.createVerifier(serverHmacKey))) !== null && _d !== void 0 ? _d : null;
        const algorithms = new sshSessionAlgorithms_1.SshSessionAlgorithms();
        algorithms.publicKeyAlgorithmName = publicKeyAlgorithmName;
        algorithms.cipher = cipher;
        algorithms.decipher = decipher;
        algorithms.signer = signer;
        algorithms.verifier = verifier;
        algorithms.messageSigner = (cipher === null || cipher === void 0 ? void 0 : cipher.authenticatedEncryption) ? cipher : signer;
        algorithms.messageVerifier = (decipher === null || decipher === void 0 ? void 0 : decipher.authenticatedEncryption) ? decipher : verifier;
        algorithms.compressor = config.getCompressionAlgorithm(this.exchangeContext.clientCompression);
        algorithms.decompressor = config.getCompressionAlgorithm(this.exchangeContext.serverCompression);
        this.exchangeContext.newAlgorithms = algorithms;
        if (clientCipherIV)
          clientCipherIV.fill(0);
        if (clientCipherKey)
          clientCipherKey.fill(0);
        if (clientHmacKey)
          clientHmacKey.fill(0);
        if (serverCipherIV)
          serverCipherIV.fill(0);
        if (serverCipherKey)
          serverCipherKey.fill(0);
        if (serverHmacKey)
          serverHmacKey.fill(0);
        await this.session.sendMessage(new kexMessages_1.NewKeysMessage(), cancellation);
      }
      chooseAlgorithm(label, localAlgorithms, remoteAlgorithms) {
        let serverAlgorithms;
        let clientAlgorithms;
        if (this.session.isClientSession) {
          serverAlgorithms = remoteAlgorithms || [];
          clientAlgorithms = localAlgorithms;
        } else {
          serverAlgorithms = localAlgorithms;
          clientAlgorithms = remoteAlgorithms || [];
        }
        const negotiationDetail = `${label} negotiation: Server (${serverAlgorithms.join(", ")}) Client (${clientAlgorithms.join(", ")})`;
        for (const client of clientAlgorithms) {
          for (const server of serverAlgorithms) {
            if (server === client) {
              const result = server;
              this.trace(trace_1.TraceLevel.Info, trace_1.SshTraceEventIds.algorithmNegotiation, `${negotiationDetail} => ${result}`);
              return result;
            }
          }
        }
        throw new Error(`Failed ${negotiationDetail}`);
      }
      async computeExchangeHash(kex, hostKeyAndCerts, clientExchangeValue, serverExchangeValue, sharedSecret) {
        if (!this.session.remoteVersion) {
          throw new Error("Key exchange not completed.");
        }
        const writer = new sshData_1.SshDataWriter(buffer_1.Buffer.alloc(2048));
        if (this.session.isClientSession) {
          writer.writeString(sshSession_1.SshSession.localVersion.toString(), "ascii");
          writer.writeString(this.session.remoteVersion.toString(), "ascii");
        } else {
          writer.writeString(this.session.remoteVersion.toString(), "ascii");
          writer.writeString(sshSession_1.SshSession.localVersion.toString(), "ascii");
        }
        writer.writeBinary(this.exchangeContext.clientKexInitPayload);
        writer.writeBinary(this.exchangeContext.serverKexInitPayload);
        writer.writeBinary(hostKeyAndCerts);
        writer.writeBigInt(bigInt_1.BigInt.fromBytes(clientExchangeValue, { unsigned: true }));
        writer.writeBigInt(bigInt_1.BigInt.fromBytes(serverExchangeValue, { unsigned: true }));
        writer.writeBigInt(bigInt_1.BigInt.fromBytes(sharedSecret, { unsigned: true }));
        const hash = await kex.sign(writer.toBuffer());
        return hash;
      }
      async computeKeys(keyExchange, sharedSecret, exchangeHash, clientEncryption, serverEncryption, clientHmac, serverHmac) {
        var _a2, _b;
        const writer = new sshData_1.SshDataWriter(buffer_1.Buffer.alloc(4 + sharedSecret.length + exchangeHash.length + Math.max(1 + ((_b = (_a2 = this.session.sessionId) === null || _a2 === void 0 ? void 0 : _a2.length) !== null && _b !== void 0 ? _b : 0), keyExchange.digestLength)));
        writer.writeBinary(sharedSecret);
        writer.write(exchangeHash);
        const offset = writer.position;
        const clientCipherIV = clientEncryption && await this.computeKey(keyExchange, writer, offset, clientEncryption.blockLength, "A");
        const serverCipherIV = serverEncryption && await this.computeKey(keyExchange, writer, offset, serverEncryption.blockLength, "B");
        const clientCipherKey = clientEncryption && await this.computeKey(keyExchange, writer, offset, clientEncryption.keyLength, "C");
        const serverCipherKey = serverEncryption && await this.computeKey(keyExchange, writer, offset, serverEncryption.keyLength, "D");
        const clientHmacKey = clientHmac && await this.computeKey(keyExchange, writer, offset, clientHmac.keyLength, "E");
        const serverHmacKey = serverHmac && await this.computeKey(keyExchange, writer, offset, serverHmac.keyLength, "F");
        return [
          clientCipherIV,
          serverCipherIV,
          clientCipherKey,
          serverCipherKey,
          clientHmacKey,
          serverHmacKey
        ];
      }
      async computeKey(keyExchange, writer, writerOffset, blockSize, letter) {
        const keyBuffer = buffer_1.Buffer.alloc(blockSize);
        let keyBufferIndex = 0;
        let currentHashLength = 0;
        let currentHash = null;
        if (!this.session.sessionId) {
          throw new Error("Session ID not set.");
        }
        while (keyBufferIndex < blockSize) {
          writer.position = writerOffset;
          if (!currentHash) {
            writer.writeByte(letter.charCodeAt(0));
            writer.write(this.session.sessionId);
          } else {
            writer.write(currentHash);
          }
          currentHash = await keyExchange.sign(writer.toBuffer());
          currentHashLength = Math.min(currentHash.length, blockSize - keyBufferIndex);
          currentHash.copy(keyBuffer, keyBufferIndex);
          keyBufferIndex += currentHashLength;
        }
        if (currentHash) {
          currentHash.fill(0);
        }
        return keyBuffer;
      }
    };
    KeyExchangeService.serviceName = "ssh-keyexchange";
    KeyExchangeService = KeyExchangeService_1 = __decorate([
      (0, serviceActivation_1.serviceActivation)({ serviceRequest: KeyExchangeService_1.serviceName })
    ], KeyExchangeService);
    exports2.KeyExchangeService = KeyExchangeService;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/sshSessionConfiguration.js
var require_sshSessionConfiguration = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/sshSessionConfiguration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SshSessionConfiguration = exports2.SshProtocolExtensionNames = void 0;
    var vscode_jsonrpc_1 = require_main();
    var sshAlgorithms_1 = require_sshAlgorithms();
    var keyExchangeService_1 = require_keyExchangeService();
    var connectionService_1 = require_connectionService();
    var authenticationService_1 = require_authenticationService();
    var sshMessage_1 = require_sshMessage();
    var SshProtocolExtensionNames;
    (function(SshProtocolExtensionNames2) {
      SshProtocolExtensionNames2["serverSignatureAlgorithms"] = "server-sig-algs";
      SshProtocolExtensionNames2["openChannelRequest"] = "open-channel-request@microsoft.com";
      SshProtocolExtensionNames2["sessionReconnect"] = "session-reconnect@microsoft.com";
      SshProtocolExtensionNames2["sessionLatency"] = "session-latency@microsoft.com";
    })(SshProtocolExtensionNames = exports2.SshProtocolExtensionNames || (exports2.SshProtocolExtensionNames = {}));
    var SshSessionConfiguration = class {
      constructor(useSecurity = true) {
        this.protocolExtensions = [];
        this.services = /* @__PURE__ */ new Map();
        this.authenticationMethods = [];
        this.messages = /* @__PURE__ */ new Map();
        this.contextualMessages = /* @__PURE__ */ new Map();
        this.keyExchangeAlgorithms = [];
        this.publicKeyAlgorithms = [];
        this.encryptionAlgorithms = [];
        this.hmacAlgorithms = [];
        this.compressionAlgorithms = [];
        this.traceChannelDataValue = false;
        this.configurationChangedEmitter = new vscode_jsonrpc_1.Emitter();
        this.onConfigurationChanged = this.configurationChangedEmitter.event;
        this.maxClientAuthenticationAttempts = 5;
        this.enableKeyExchangeGuess = false;
        this.keepAliveTimeoutInSecondsValue = 0;
        this.keyRotationThreshold = 512 * 1024 * 1024;
        this.protocolExtensions.push(SshProtocolExtensionNames.serverSignatureAlgorithms);
        this.protocolExtensions.push(SshProtocolExtensionNames.openChannelRequest);
        this.services.set(keyExchangeService_1.KeyExchangeService, null);
        this.services.set(connectionService_1.ConnectionService, null);
        this.services.set(authenticationService_1.AuthenticationService, null);
        this.authenticationMethods.push(
          "none",
          "password",
          "publickey",
          "keyboard-interactive"
          /* AuthenticationMethod.keyboardInteractive */
        );
        for (const [messageKey, messageType] of sshMessage_1.SshMessage.index) {
          if (typeof messageKey === "number") {
            this.messages.set(messageKey, messageType);
          } else {
            const [messageNumber, messageContext] = messageKey;
            let contextMessageTypes = this.contextualMessages.get(messageContext);
            if (!contextMessageTypes) {
              contextMessageTypes = /* @__PURE__ */ new Map();
              this.contextualMessages.set(messageContext, contextMessageTypes);
            }
            contextMessageTypes.set(messageNumber, messageType);
          }
        }
        if (useSecurity) {
          this.keyExchangeAlgorithms.push(sshAlgorithms_1.SshAlgorithms.keyExchange.ecdhNistp384Sha384);
          this.keyExchangeAlgorithms.push(sshAlgorithms_1.SshAlgorithms.keyExchange.ecdhNistp256Sha256);
          this.keyExchangeAlgorithms.push(sshAlgorithms_1.SshAlgorithms.keyExchange.dhGroup16Sha512);
          this.keyExchangeAlgorithms.push(sshAlgorithms_1.SshAlgorithms.keyExchange.dhGroup14Sha256);
          this.publicKeyAlgorithms.push(sshAlgorithms_1.SshAlgorithms.publicKey.rsaWithSha512);
          this.publicKeyAlgorithms.push(sshAlgorithms_1.SshAlgorithms.publicKey.rsaWithSha256);
          this.publicKeyAlgorithms.push(sshAlgorithms_1.SshAlgorithms.publicKey.ecdsaSha2Nistp384);
          this.publicKeyAlgorithms.push(sshAlgorithms_1.SshAlgorithms.publicKey.ecdsaSha2Nistp256);
          this.encryptionAlgorithms.push(sshAlgorithms_1.SshAlgorithms.encryption.aes256Gcm);
          this.encryptionAlgorithms.push(sshAlgorithms_1.SshAlgorithms.encryption.aes256Ctr);
          this.hmacAlgorithms.push(sshAlgorithms_1.SshAlgorithms.hmac.hmacSha512Etm);
          this.hmacAlgorithms.push(sshAlgorithms_1.SshAlgorithms.hmac.hmacSha256Etm);
          this.hmacAlgorithms.push(sshAlgorithms_1.SshAlgorithms.hmac.hmacSha512);
          this.hmacAlgorithms.push(sshAlgorithms_1.SshAlgorithms.hmac.hmacSha256);
        } else {
          this.keyExchangeAlgorithms.push(sshAlgorithms_1.SshAlgorithms.keyExchange.none);
          this.publicKeyAlgorithms.push(sshAlgorithms_1.SshAlgorithms.publicKey.none);
          this.encryptionAlgorithms.push(sshAlgorithms_1.SshAlgorithms.encryption.none);
          this.hmacAlgorithms.push(sshAlgorithms_1.SshAlgorithms.hmac.none);
        }
        this.compressionAlgorithms.push(sshAlgorithms_1.SshAlgorithms.compression.none);
      }
      /**
       * Adds a service to the configuration.
       */
      addService(serviceType, serviceConfig) {
        if (this.services.has(serviceType)) {
          throw new Error("Duplicate service entry.");
        }
        this.services.set(serviceType, serviceConfig);
      }
      getKeyExchangeAlgorithm(name) {
        return this.getAlgorithm(name, this.keyExchangeAlgorithms);
      }
      getPublicKeyAlgorithm(name) {
        return this.getAlgorithm(name, this.publicKeyAlgorithms);
      }
      getEncryptionAlgorithm(name) {
        return this.getAlgorithm(name, this.encryptionAlgorithms);
      }
      getHmacAlgorithm(name) {
        return this.getAlgorithm(name, this.hmacAlgorithms);
      }
      getCompressionAlgorithm(name) {
        return this.getAlgorithm(name, this.compressionAlgorithms);
      }
      getAlgorithm(name, collection) {
        const algorithm = collection.find((a) => a ? a.name === name : false);
        if (!algorithm) {
          if (name === "none") {
            return null;
          }
          throw new Error("Algorithm not found: " + name);
        }
        return algorithm;
      }
      get traceChannelData() {
        return this.traceChannelDataValue;
      }
      /**
       * Enables tracing of all channel data messages.
       *
       * Unlike other configuration, this option may be adjusted any time while the session
       * is active. Channel data tracing produces a large volume of trace events, so it is
       * primarily meant only for debugging.
       */
      set traceChannelData(value) {
        if (value !== this.traceChannelDataValue) {
          this.traceChannelDataValue = value;
          this.configurationChangedEmitter.fire();
        }
      }
      get keepAliveTimeoutInSeconds() {
        return this.keepAliveTimeoutInSecondsValue;
      }
      set keepAliveTimeoutInSeconds(value) {
        if (this.keepAliveTimeoutInSecondsValue !== value) {
          this.keepAliveTimeoutInSecondsValue = value;
          this.configurationChangedEmitter.fire();
        }
      }
    };
    exports2.SshSessionConfiguration = SshSessionConfiguration;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/sshClientSession.js
var require_sshClientSession = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/sshClientSession.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SshClientSession = void 0;
    var sshSession_1 = require_sshSession();
    var transportMessages_1 = require_transportMessages();
    var sshAuthenticatingEventArgs_1 = require_sshAuthenticatingEventArgs();
    var promiseCompletionSource_1 = require_promiseCompletionSource();
    var cancellation_1 = require_cancellation2();
    var sshSessionConfiguration_1 = require_sshSessionConfiguration();
    var authenticationService_1 = require_authenticationService();
    var connectionService_1 = require_connectionService();
    var errors_1 = require_errors();
    var trace_1 = require_trace();
    var SshClientSession = class extends sshSession_1.SshSession {
      constructor(config) {
        super(config, true);
        this.serviceRequests = /* @__PURE__ */ new Map();
        this.clientAuthCompletion = null;
      }
      /**
       * Attempts to authenticate both the server and client.
       *
       * This method must be called only after encrypting the session. It is equivalent
       * to calling both `authenticateServer()` and `authenticateClient()` and waiting on
       * both results.
       *
       * @returns `true` if authentication succeeded, `false` if it failed.
       */
      async authenticate(clientCredentials, cancellation) {
        const serverAuthenticated = await this.authenticateServer(cancellation);
        if (!serverAuthenticated) {
          return false;
        }
        const clientAuthenticated = await this.authenticateClient(clientCredentials, cancellation);
        if (!clientAuthenticated) {
          return false;
        }
        return true;
      }
      /**
       * Triggers server authentication by invoking the `authenticating` event with
       * the verified server host key.
       *
       * This method must be called only after encrypting the session. It does not wait for any
       * further message exchange with the server, since the server host key would have already
       * been obtained during the key-exchange.
       *
       * @returns `true` if authentication succeeded, `false` if it failed.
       */
      async authenticateServer(cancellation) {
        if (!(this.kexService && this.kexService.hostKey)) {
          throw new Error("Encrypt the session before authenticating.");
        }
        try {
          this.principal = await this.raiseAuthenticatingEvent(new sshAuthenticatingEventArgs_1.SshAuthenticatingEventArgs(sshAuthenticatingEventArgs_1.SshAuthenticationType.serverPublicKey, {
            publicKey: this.kexService.hostKey
          }, cancellation));
        } catch (e) {
          if (!(e instanceof Error))
            throw e;
          this.trace(trace_1.TraceLevel.Error, trace_1.SshTraceEventIds.authenticationError, `Error while authenticating server: ${e.message}`, e);
          throw e;
        }
        if (!this.principal) {
          await this.close(transportMessages_1.SshDisconnectReason.hostKeyNotVerifiable, "Server authentication failed.");
          this.trace(trace_1.TraceLevel.Warning, trace_1.SshTraceEventIds.serverAuthenticationFailed, `${this} server authentication failed.`);
          return false;
        }
        this.trace(trace_1.TraceLevel.Info, trace_1.SshTraceEventIds.sessionAuthenticated, `${this} server authenticated.`);
        return true;
      }
      /* @internal */
      authenticateClient(credentials, callbackOrCancellation, cancellation) {
        if (!credentials) {
          throw new TypeError("A credentials object is required.");
        }
        if (typeof callbackOrCancellation === "function") {
          return this.authenticateClientWithCompletion(credentials, callbackOrCancellation, cancellation);
        } else {
          return new Promise((resolve8, reject) => this.authenticateClientWithCompletion(credentials, (err, result) => {
            if (err)
              reject(err);
            else
              resolve8(result);
          }, callbackOrCancellation));
        }
      }
      async authenticateClientWithCompletion(credentials, callback2, cancellation) {
        this.clientAuthCompletion = new promiseCompletionSource_1.PromiseCompletionSource();
        this.clientAuthCompletion.promise.then((result) => callback2(void 0, result), (err) => callback2(err));
        if (cancellation) {
          if (cancellation.isCancellationRequested)
            throw new cancellation_1.CancellationError();
          cancellation.onCancellationRequested((e) => {
            if (this.clientAuthCompletion) {
              this.clientAuthCompletion.reject(new cancellation_1.CancellationError());
            }
          });
        }
        let authService = this.getService(authenticationService_1.AuthenticationService);
        if (!authService) {
          const serviceRequestMessage = new transportMessages_1.ServiceRequestMessage();
          serviceRequestMessage.serviceName = authenticationService_1.AuthenticationService.serviceName;
          await this.sendMessage(serviceRequestMessage, cancellation);
          authService = this.activateService(authenticationService_1.AuthenticationService);
        }
        await authService.authenticateClient(credentials, cancellation);
      }
      /* @internal */
      onAuthenticationComplete(success) {
        if (success) {
          this.trace(trace_1.TraceLevel.Info, trace_1.SshTraceEventIds.sessionAuthenticated, `${this} client authenticated.`);
        } else {
          this.trace(trace_1.TraceLevel.Warning, trace_1.SshTraceEventIds.clientAuthenticationFailed, `${this} client authentication failed.`);
        }
        if (this.clientAuthCompletion) {
          this.clientAuthCompletion.resolve(success);
          this.clientAuthCompletion = null;
        }
      }
      /**
       * Sends a request for a service and waits for a response.
       *
       * @param serviceName Name of the service to be requested.
       * @param cancellation Optional cancellation token.
       * @returns A promise that resolves when the service request has been accepted.
       *
       * If the server does not accept the service request, it will disconnect the session.
       */
      async requestService(serviceName, cancellation) {
        let sendRequest = false;
        let completion = this.serviceRequests.get(serviceName);
        if (!completion) {
          completion = new promiseCompletionSource_1.PromiseCompletionSource();
          this.serviceRequests.set(serviceName, completion);
          sendRequest = true;
        }
        if (sendRequest) {
          const requestMessage = new transportMessages_1.ServiceRequestMessage();
          requestMessage.serviceName = serviceName;
          await this.sendMessage(requestMessage, cancellation);
        }
        await completion.promise;
      }
      /* @internal */
      async handleServiceAcceptMessage(message, cancellation) {
        const completion = this.serviceRequests.get(message.serviceName);
        completion === null || completion === void 0 ? void 0 : completion.resolve(true);
      }
      async openChannel(channelTypeOrOpenMessageOrCancellation, initialRequestOrCancellation, cancellation) {
        if (!this.connectionService) {
          const serviceRequestMessage = new transportMessages_1.ServiceRequestMessage();
          serviceRequestMessage.serviceName = connectionService_1.ConnectionService.serviceName;
          await this.sendMessage(serviceRequestMessage, cancellation);
        }
        return await super.openChannel(channelTypeOrOpenMessageOrCancellation, initialRequestOrCancellation, cancellation);
      }
      /* @internal */
      handleDisconnected() {
        if (this.reconnecting) {
          this.reconnecting = false;
          return false;
        }
        return super.handleDisconnected();
      }
      /**
       * Call instead of `connect()` to reconnect to a prior session instead of connecting
       * a new session.
       * @param stream A new stream that has just (re-) connected to the server.
       * @param cancellation Optional cancellation token.
       * @returns True if reconnect succeeded, false if the server declined the reconnect
       * request or reconnect session validation failed. In the case of a false return value,
       * retrying is unlikely to succeed.
       * @throws {SshConnectionError} There was a problem connecting to or communicating with
       * the server; retrying may still succeed if connectivity is restored.
       * @throws {SshReconnectError} Reconnect failed for some reason other than a communication
       * issue: see the `failureReason` property of the error. Retrying is unlikely to succeed,
       * unless the specific error condition can be addressed.
       */
      async reconnect(stream, cancellation) {
        this.trace(trace_1.TraceLevel.Verbose, trace_1.SshTraceEventIds.clientSessionReconnecting, "Attempting to reconnect...");
        if (this.isClosed) {
          throw new errors_1.ObjectDisposedError(this);
        } else if (this.isConnected) {
          throw new Error("Already connected.");
        }
        if (!this.protocol) {
          throw new Error("The session was never previously connected.");
        }
        if (this.reconnecting) {
          throw new Error("Already reconnecting.");
        }
        this.reconnecting = true;
        try {
          await this.reconnectInternal(stream, cancellation);
        } finally {
          this.reconnecting = false;
        }
      }
      async reconnectInternal(stream, cancellation) {
        var _a2, _b, _c, _d, _e, _f;
        const previousSessionId = this.sessionId;
        const previousProtocolInstance = this.protocol;
        const previousHostKey = (_a2 = this.kexService) === null || _a2 === void 0 ? void 0 : _a2.hostKey;
        if (!previousSessionId || !previousProtocolInstance || !this.kexService || !previousHostKey || !((_b = previousProtocolInstance.extensions) === null || _b === void 0 ? void 0 : _b.has(sshSessionConfiguration_1.SshProtocolExtensionNames.sessionReconnect))) {
          throw new Error("Reconnect was not enabled for this session.");
        }
        let newSessionId;
        try {
          this.sessionId = null;
          await this.connect(stream, cancellation);
          if (!this.sessionId || !this.algorithms || !this.algorithms.signer) {
            throw new Error("Session is not encrypted.");
          }
          const newHostKey = this.kexService.hostKey;
          const newHostPublicKey = !newHostKey ? null : await newHostKey.getPublicKeyBytes();
          const previousHostPublicKey = await previousHostKey.getPublicKeyBytes();
          if (!newHostPublicKey || !previousHostPublicKey || !newHostPublicKey.equals(previousHostPublicKey)) {
            const message = "The server host key is different.";
            this.trace(trace_1.TraceLevel.Error, trace_1.SshTraceEventIds.clientSessionReconnectFailed, `Reconnection failed: ${message}`);
            throw new errors_1.SshReconnectError(message, transportMessages_1.SshReconnectFailureReason.differentServerHostKey);
          }
          newSessionId = this.sessionId;
        } catch (e) {
          this.protocol = previousProtocolInstance;
          super.handleDisconnected();
          throw e;
        } finally {
          this.sessionId = previousSessionId;
          this.kexService.hostKey = previousHostKey;
        }
        const reconnectToken = await this.createReconnectToken(previousSessionId, newSessionId);
        const reconnectRequest = new transportMessages_1.SessionReconnectRequestMessage();
        reconnectRequest.requestType = "session-reconnect@microsoft.com";
        reconnectRequest.clientReconnectToken = reconnectToken;
        reconnectRequest.lastReceivedSequenceNumber = previousProtocolInstance.lastIncomingSequence;
        reconnectRequest.wantReply = true;
        const response = await this.requestResponse(reconnectRequest, transportMessages_1.SessionReconnectResponseMessage, transportMessages_1.SessionReconnectFailureMessage, cancellation);
        if (response instanceof transportMessages_1.SessionReconnectFailureMessage) {
          const reason = (_c = response.reasonCode) !== null && _c !== void 0 ? _c : transportMessages_1.SshReconnectFailureReason.unknownServerFailure;
          const message = (_d = response.description) !== null && _d !== void 0 ? _d : "The server rejected the reconnect request.";
          this.trace(trace_1.TraceLevel.Error, trace_1.SshTraceEventIds.clientSessionReconnectFailed, `Reconnection failed: ${message}`);
          this.protocol = previousProtocolInstance;
          throw new errors_1.SshReconnectError(message, reason);
        }
        if (!this.verifyReconnectToken(previousSessionId, newSessionId, (_e = response.serverReconnectToken) !== null && _e !== void 0 ? _e : Buffer.alloc(0))) {
          const message = "The reconnect token provided by the server was invalid.";
          this.trace(trace_1.TraceLevel.Error, trace_1.SshTraceEventIds.clientSessionReconnectFailed, `Reconnection failed: ${message}`);
          throw new errors_1.SshReconnectError(message, transportMessages_1.SshReconnectFailureReason.invalidServerReconnectToken);
        }
        this.trace(trace_1.TraceLevel.Info, trace_1.SshTraceEventIds.clientSessionReconnecting, "Reconnect request was accepted by the server.");
        const messagesToResend = previousProtocolInstance.getSentMessages(((_f = response.lastReceivedSequenceNumber) !== null && _f !== void 0 ? _f : 0) + 1);
        if (!messagesToResend) {
          const message = "Client is unable to re-send messages requested by the server.";
          this.trace(trace_1.TraceLevel.Error, trace_1.SshTraceEventIds.clientSessionReconnectFailed, `Reconnection failed: ${message}`);
          throw new errors_1.SshReconnectError(message, transportMessages_1.SshReconnectFailureReason.clientDroppedMessages);
        }
        let count = 0;
        for (const message of messagesToResend) {
          await this.sendMessage(message, cancellation);
          count++;
        }
        previousProtocolInstance.dispose();
        this.metrics.addReconnection();
        this.trace(trace_1.TraceLevel.Info, trace_1.SshTraceEventIds.clientSessionReconnecting, `${this} reconnected. Re-sent ${count} dropped messages.`);
      }
      dispose() {
        if (this.clientAuthCompletion) {
          this.clientAuthCompletion.reject(new errors_1.ObjectDisposedError(this));
        }
        super.dispose();
      }
    };
    exports2.SshClientSession = SshClientSession;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/sshServerSession.js
var require_sshServerSession = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/sshServerSession.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SshServerSession = void 0;
    var sshSession_1 = require_sshSession();
    var vscode_jsonrpc_1 = require_main();
    var transportMessages_1 = require_transportMessages();
    var errors_1 = require_errors();
    var sshSessionConfiguration_1 = require_sshSessionConfiguration();
    var trace_1 = require_trace();
    var SshServerSession = class extends sshSession_1.SshSession {
      constructor(config, reconnectableSessions) {
        super(config, false);
        this.clientAuthenticatedEmitter = new vscode_jsonrpc_1.Emitter();
        this.onClientAuthenticated = this.clientAuthenticatedEmitter.event;
        this.reconnectedEmitter = new vscode_jsonrpc_1.Emitter();
        this.onReconnected = this.reconnectedEmitter.event;
        this.credentials = { publicKeys: [] };
        const enableReconnect = config.protocolExtensions.includes(sshSessionConfiguration_1.SshProtocolExtensionNames.sessionReconnect);
        if (enableReconnect && !reconnectableSessions) {
          throw new Error("When reconnect is enabled, server sessions require a reference to a shared collection to track reconnectable sessions.");
        } else if (!enableReconnect && reconnectableSessions) {
          throw new Error("When reconnect is not enabled, the reconnectable sessions collection is not applicable.");
        }
        this.reconnectableSessions = reconnectableSessions;
      }
      /* @internal */
      async handleServiceRequestMessage(message, cancellation) {
        const service = this.activateService(message.serviceName);
        if (service) {
          const acceptMessage = new transportMessages_1.ServiceAcceptMessage();
          acceptMessage.serviceName = message.serviceName;
          await this.sendMessage(acceptMessage, cancellation);
        } else {
          throw new errors_1.SshConnectionError(`Service "${message.serviceName}" not available.`, transportMessages_1.SshDisconnectReason.serviceNotAvailable);
        }
      }
      /* @internal */
      async handleRequestMessage(message, cancellation) {
        var _a2;
        if (message.requestType === "session-reconnect@microsoft.com" && ((_a2 = this.config.protocolExtensions) === null || _a2 === void 0 ? void 0 : _a2.includes(sshSessionConfiguration_1.SshProtocolExtensionNames.sessionReconnect))) {
          const reconnectRequest = message.convertTo(new transportMessages_1.SessionReconnectRequestMessage());
          await this.reconnect(reconnectRequest, cancellation);
          return;
        }
        await super.handleRequestMessage(message, cancellation);
      }
      /* @internal */
      handleClientAuthenticated() {
        this.clientAuthenticatedEmitter.fire();
      }
      /* @internal */
      async enableReconnect(cancellation) {
        await super.enableReconnect(cancellation);
        if (!this.reconnectableSessions.includes(this)) {
          this.reconnectableSessions.push(this);
        }
      }
      /* @internal */
      handleDisconnected() {
        if (this.reconnecting) {
          return true;
        }
        return super.handleDisconnected();
      }
      /**
       * Attempts to reconnect the client to a disconnected server session.
       *
       * If reconnection is successful, the current server session is disposed because the client
       * gets reconnected to a different server session.
       */
      /* @internal */
      async reconnect(reconnectRequest, cancellation) {
        var _a2, _b, _c;
        if (!this.reconnectableSessions) {
          throw new Error("Disconnected sessions collection should have been initialized when reconnect is enabled.");
        }
        let reconnectSession;
        for (const reconnectableSession of this.reconnectableSessions) {
          if (reconnectableSession !== this && await this.verifyReconnectToken(reconnectableSession.sessionId, this.sessionId, (_a2 = reconnectRequest.clientReconnectToken) !== null && _a2 !== void 0 ? _a2 : Buffer.alloc(0))) {
            reconnectSession = reconnectableSession;
            this.reconnectableSessions.splice(this.reconnectableSessions.indexOf(reconnectSession), 1);
            break;
          }
        }
        if (!reconnectSession || reconnectSession.isClosed) {
          const message = "Requested reconnect session was not found or the reconnect token provided by the client was invalid.";
          this.trace(trace_1.TraceLevel.Error, trace_1.SshTraceEventIds.serverSessionReconnectFailed, `Reconnect failed: ${message}`);
          const failure = new transportMessages_1.SessionReconnectFailureMessage();
          failure.reasonCode = transportMessages_1.SshReconnectFailureReason.sessionNotFound;
          failure.description = message;
          await this.sendMessage(failure, cancellation);
          return;
        }
        const messagesToResend = reconnectSession.protocol.getSentMessages(((_b = reconnectRequest.lastReceivedSequenceNumber) !== null && _b !== void 0 ? _b : 0) + 1);
        if (!messagesToResend) {
          this.reconnectableSessions.push(reconnectSession);
          const message = "Server is unable to re-send messages requested by the client.";
          this.trace(trace_1.TraceLevel.Error, trace_1.SshTraceEventIds.serverSessionReconnectFailed, `Reconnect failed: ${message}`);
          const failure = new transportMessages_1.SessionReconnectFailureMessage();
          failure.reasonCode = transportMessages_1.SshReconnectFailureReason.serverDroppedMessages;
          failure.description = message;
          await this.sendMessage(failure, cancellation);
          return;
        }
        const responseMessage = new transportMessages_1.SessionReconnectResponseMessage();
        responseMessage.serverReconnectToken = await this.createReconnectToken(reconnectSession.sessionId, this.sessionId);
        responseMessage.lastReceivedSequenceNumber = reconnectSession.protocol.lastIncomingSequence;
        await this.sendMessage(responseMessage, cancellation);
        try {
          reconnectSession.reconnecting = true;
          (_c = reconnectSession.protocol) === null || _c === void 0 ? void 0 : _c.dispose();
          while (reconnectSession.isConnected) {
            await new Promise((resolve8) => setTimeout(() => resolve8(), 5));
          }
          reconnectSession.protocol = this.protocol;
          reconnectSession.protocol.kexService = reconnectSession.kexService;
          this.protocol = void 0;
          for (const message of messagesToResend) {
            await reconnectSession.sendMessage(message, cancellation);
          }
          this.dispose(new errors_1.SshConnectionError("Reconnected.", transportMessages_1.SshDisconnectReason.none));
        } finally {
          reconnectSession.reconnecting = false;
        }
        this.reconnectableSessions.push(reconnectSession);
        reconnectSession.metrics.addReconnection();
        reconnectSession.processMessages().catch((e) => {
          this.trace(trace_1.TraceLevel.Error, trace_1.SshTraceEventIds.unknownError, `Unhandled error processing messages: ${e.message}`, e);
        });
        this.trace(trace_1.TraceLevel.Info, trace_1.SshTraceEventIds.serverSessionReconnecting, `${reconnectSession} reconnected. Re-sent ${messagesToResend.length} dropped messages.`);
        reconnectSession.reconnectedEmitter.fire();
      }
      dispose(error) {
        if (this.reconnectableSessions) {
          const index = this.reconnectableSessions.indexOf(this);
          if (index >= 0) {
            this.reconnectableSessions.splice(index, 1);
          }
        }
        super.dispose(error);
      }
    };
    exports2.SshServerSession = SshServerSession;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/sshStream.js
var require_sshStream = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/sshStream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SshStream = void 0;
    var promiseCompletionSource_1 = require_promiseCompletionSource();
    var stream_1 = require("stream");
    var SshStream = class extends stream_1.Duplex {
      constructor(channel) {
        let readPaused = null;
        super({
          async write(chunk, encoding, cb) {
            let error;
            try {
              let buffer;
              if (typeof chunk === "string") {
                buffer = Buffer.from(chunk, encoding);
              } else if (chunk instanceof Buffer || chunk instanceof Uint8Array) {
                buffer = chunk;
              } else {
                throw new Error("Unsupported chunk type: " + typeof chunk);
              }
              await channel.send(buffer);
            } catch (e) {
              if (!(e instanceof Error))
                throw e;
              error = e;
            }
            if (cb) {
              cb(error);
            }
          },
          async writev(chunks, cb) {
            let error;
            try {
              if (chunks.length === 1) {
                return this.write(chunks[0].chunk, chunks[0].encoding, cb);
              } else {
                let BufferReduce = function(accumulator, chunk) {
                  if (chunk.chunk instanceof Buffer || chunk.chunk instanceof Uint8Array) {
                    return accumulator + chunk.chunk.length;
                  } else {
                    throw new Error("Unsupported chunk type: " + typeof chunk.chunk);
                  }
                };
                const totalLength = chunks.reduce(BufferReduce, 0);
                const singleBuffer = Buffer.alloc(totalLength);
                let singleBufferIndex = 0;
                for (let i = 0; i < chunks.length; i++) {
                  chunks[i].chunk.copy(singleBuffer, singleBufferIndex);
                  singleBufferIndex += chunks[i].chunk.length;
                }
                await channel.send(singleBuffer);
              }
            } catch (e) {
              if (!(e instanceof Error))
                throw e;
              error = e;
            }
            if (cb) {
              cb(error);
            }
          },
          async final(cb) {
            let error;
            try {
              await channel.close();
            } catch (e) {
              if (!(e instanceof Error))
                throw e;
              error = e;
            }
            if (cb) {
              cb(error);
            }
          },
          read() {
            if (readPaused) {
              readPaused.resolve();
              readPaused = null;
            }
          }
        });
        channel.onDataReceived(async (data) => {
          const buffer = Buffer.alloc(data.length);
          data.copy(buffer);
          const result = this.push(buffer);
          if (!result) {
            if (!readPaused) {
              readPaused = new promiseCompletionSource_1.PromiseCompletionSource();
            }
            await readPaused.promise;
          }
          channel.adjustWindow(buffer.length);
        });
        channel.onClosed(() => {
          this.push(null);
        });
        this.channel = channel;
      }
      /**
       * Destroys the stream and closes the underlying SSH channel.
       */
      destroy(error) {
        void this.channel.close().catch();
        super.destroy(error);
        return this;
      }
      toString() {
        return `SshStream(Channel Type: ${this.channel.channelType}, Id: ${this.channel.channelId}, RemoteId: ${this.channel.remoteChannelId})`;
      }
    };
    exports2.SshStream = SshStream;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/streams.js
var require_streams = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/streams.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WebSocketStream = exports2.NodeStream = exports2.BaseStream = void 0;
    var buffer_1 = require("buffer");
    var vscode_jsonrpc_1 = require_main();
    var cancellation_1 = require_cancellation2();
    var errors_1 = require_errors();
    function handleCancellation(reject, cancellation) {
      if (cancellation) {
        if (cancellation.isCancellationRequested) {
          reject(new cancellation_1.CancellationError());
        } else {
          cancellation.onCancellationRequested(() => {
            reject(new cancellation_1.CancellationError());
          });
        }
      }
    }
    var BaseStream = class {
      constructor() {
        this.incomingData = [];
        this.pendingReads = [];
        this.error = null;
        this.disposed = false;
        this.closedEmitter = new vscode_jsonrpc_1.Emitter();
        this.closed = this.closedEmitter.event;
      }
      onData(data) {
        while (this.pendingReads.length > 0) {
          const read = this.pendingReads.shift();
          if (read.count >= data.length) {
            read.resolve(data);
            return;
          } else {
            const readData = data.slice(0, read.count);
            data = data.slice(read.count);
            read.resolve(readData);
          }
        }
        this.incomingData.push(data);
      }
      onEnd() {
        while (this.pendingReads.length > 0) {
          const read = this.pendingReads.shift();
          read.resolve(null);
        }
        this.incomingData.push(buffer_1.Buffer.alloc(0));
      }
      onError(error) {
        if (!this.error) {
          this.error = error;
        }
        while (this.pendingReads.length > 0) {
          const read = this.pendingReads.shift();
          read.reject(error);
        }
      }
      async read(count, cancellation) {
        if (this.disposed)
          throw new errors_1.ObjectDisposedError(this);
        if (this.incomingData.length > 0) {
          let data = this.incomingData[0];
          if (data.length === 0) {
            return null;
          } else if (count >= data.length) {
            this.incomingData.shift();
          } else {
            this.incomingData[0] = data.slice(count);
            data = data.slice(0, count);
          }
          return data;
        } else if (this.error) {
          throw this.error;
        } else {
          return await new Promise((resolve8, reject) => {
            if (cancellation) {
              if (cancellation.isCancellationRequested) {
                reject(new cancellation_1.CancellationError());
                return;
              }
              cancellation.onCancellationRequested(() => {
                for (let i = 0; i < this.pendingReads.length; i++) {
                  if (Object.is(cancellation, this.pendingReads[i].cancellation)) {
                    const read = this.pendingReads.splice(i--, 1)[0];
                    read.reject(new cancellation_1.CancellationError());
                  }
                }
              });
            }
            this.pendingReads.push({ count, resolve: resolve8, reject, cancellation });
          });
        }
      }
      dispose() {
        if (!this.disposed) {
          this.disposed = true;
          const error = new errors_1.ObjectDisposedError(this);
          this.onError(error);
          this.fireOnClose(error);
        }
      }
      fireOnClose(error) {
        this.closedEmitter.fire({ error });
      }
      get isDisposed() {
        return this.disposed;
      }
    };
    exports2.BaseStream = BaseStream;
    var NodeStream = class extends BaseStream {
      constructor(duplexOrReadStream, writeStream) {
        super();
        if (!duplexOrReadStream)
          throw new TypeError("Duplex or Readable/Writable stream are required.");
        this.readStream = duplexOrReadStream;
        this.writeStream = writeStream || duplexOrReadStream;
        this.readStream.on("data", this.onData.bind(this));
        this.readStream.on("end", this.onEnd.bind(this));
        this.readStream.on("error", this.onError.bind(this));
        this.readStream.on("close", () => {
          this.onEnd();
          this.fireOnClose();
        });
      }
      async write(data, cancellation) {
        if (!data)
          throw new TypeError("Data is required.");
        if (this.disposed)
          throw new errors_1.ObjectDisposedError(this);
        return new Promise((resolve8, reject) => {
          handleCancellation(reject, cancellation);
          this.writeStream.write(data, (err) => {
            if (!err) {
              resolve8();
            } else {
              reject(err);
            }
          });
        });
      }
      async close(error, cancellation) {
        if (this.disposed)
          throw new errors_1.ObjectDisposedError(this);
        await new Promise((resolve8, reject) => {
          handleCancellation(reject, cancellation);
          this.writeStream.end(resolve8);
        });
        this.disposed = true;
        this.onError(error || new errors_1.ObjectDisposedError(this));
        this.closedEmitter.fire({ error });
      }
      dispose() {
        if (!this.disposed) {
          const error = new errors_1.ObjectDisposedError(this);
          this.readStream.destroy(error);
          this.writeStream.destroy(error);
        }
        super.dispose();
      }
    };
    exports2.NodeStream = NodeStream;
    var WebSocketStream = class extends BaseStream {
      constructor(websocket) {
        super();
        this.websocket = websocket;
        if (!websocket)
          throw new TypeError("WebSocket is required.");
        if (typeof websocket.binaryType === "string" && websocket.binaryType !== "arraybuffer") {
          throw new Error("WebSocket must use arraybuffer binary type.");
        }
        websocket.onmessage = (e) => {
          this.onData(buffer_1.Buffer.from(e.data));
        };
        websocket.onclose = (e) => {
          if (e.wasClean) {
            this.onEnd();
          } else {
            const error = new Error(e.reason);
            error.code = e.code;
            this.onError(error);
          }
        };
      }
      get protocol() {
        return this.websocket.protocol;
      }
      async write(data, cancellation) {
        if (!data)
          throw new TypeError("Data is required.");
        if (this.disposed)
          throw new errors_1.ObjectDisposedError(this);
        if ("readyState" in this.websocket) {
          if (this.websocket.readyState === 2 || this.websocket.readyState === 3) {
            throw new DOMException("WebSocket is already in CLOSING or CLOSED state.", "InvalidStateError");
          }
        }
        this.websocket.send(data);
      }
      async close(error, cancellation) {
        if (this.disposed)
          throw new errors_1.ObjectDisposedError(this);
        if (!error) {
          this.websocket.close();
        } else {
          const code = typeof error.code === "number" ? error.code : void 0;
          this.websocket.close(code, error.message);
        }
        this.disposed = true;
        this.closedEmitter.fire({ error });
        this.onError(error || new Error("Stream closed."));
      }
      dispose() {
        if (!this.disposed) {
          this.websocket.close();
        }
        super.dispose();
      }
    };
    exports2.WebSocketStream = WebSocketStream;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/sshRpcMessageStream.js
var require_sshRpcMessageStream = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/sshRpcMessageStream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SshRpcMessageStream = void 0;
    var rpc = require_main();
    var buffer_1 = require("buffer");
    var sshData_1 = require_sshData();
    var contentLengthHeaderPrefix = "Content-Length: ";
    var headersSeparator = "\r\n\r\n";
    var SshRpcMessageReader = class {
      constructor(channel) {
        this.channel = channel;
        this.errorEmitter = new rpc.Emitter();
        this.closeEmitter = new rpc.Emitter();
        this.partialMessageEmitter = new rpc.Emitter();
        this.callback = null;
        this.messageBuffer = new sshData_1.SshDataWriter(buffer_1.Buffer.alloc(1024));
        this.headersLength = null;
        this.messageLength = null;
        this.onError = this.errorEmitter.event;
        this.onClose = this.closeEmitter.event;
        this.onPartialMessage = this.partialMessageEmitter.event;
        this.eventRegistration = this.channel.onDataReceived(this.onDataReceived.bind(this));
        this.channel.onClosed((e) => {
          if (e.error) {
            this.errorEmitter.fire(e.error);
          }
          this.closeEmitter.fire();
        });
      }
      listen(callback2) {
        this.callback = callback2;
        return rpc.Disposable.create(() => {
          this.callback = null;
        });
      }
      dispose() {
        if (this.eventRegistration) {
          this.eventRegistration.dispose();
        }
      }
      onDataReceived(data) {
        this.messageBuffer.write(data);
        this.channel.adjustWindow(data.length);
        data = this.messageBuffer.toBuffer();
        if (this.messageLength === null) {
          const headersEnd = data.indexOf(headersSeparator);
          if (headersEnd < 0) {
            return;
          }
          const headers = data.slice(0, headersEnd).toString();
          if (!headers.startsWith(contentLengthHeaderPrefix)) {
            throw new Error(`Message does not start with JSON-RPC headers.
${headers}`);
          }
          this.headersLength = headersEnd + headersSeparator.length;
          this.messageLength = parseInt(headers.substr(contentLengthHeaderPrefix.length, headersEnd - contentLengthHeaderPrefix.length), 10);
        }
        const position = this.messageBuffer.position;
        const totalLength = this.headersLength + this.messageLength;
        if (position >= totalLength) {
          if (this.callback) {
            const messageJson = data.slice(this.headersLength, totalLength).toString();
            let message;
            try {
              message = JSON.parse(messageJson);
            } catch (e) {
              if (!(e instanceof Error))
                throw e;
              throw new Error(`Failed to parse JSON-RPC message: ${e.message}
${messageJson}`);
            }
            this.callback(message);
          }
          this.messageLength = null;
          this.messageBuffer.position = 0;
          if (position > totalLength) {
            this.onDataReceived(data.slice(totalLength));
          }
        }
      }
    };
    var SshRpcMessageWriter = class {
      constructor(channel) {
        this.channel = channel;
        this.errorEmitter = new rpc.Emitter();
        this.closeEmitter = new rpc.Emitter();
        this.onError = this.errorEmitter.event;
        this.onClose = this.closeEmitter.event;
        this.channel.onClosed((e) => {
          if (e.error) {
            this.errorEmitter.fire([
              e.error,
              e.errorMessage && { jsonrpc: e.errorMessage } || void 0,
              e.exitStatus
            ]);
          }
          this.closeEmitter.fire();
        });
      }
      write(message) {
        const messageJson = JSON.stringify(message);
        const messageData = buffer_1.Buffer.from(messageJson);
        const headerData = buffer_1.Buffer.from(contentLengthHeaderPrefix + messageData.length + headersSeparator);
        const data = buffer_1.Buffer.alloc(headerData.length + messageData.length);
        headerData.copy(data, 0);
        messageData.copy(data, headerData.length);
        return this.channel.send(data).catch((e) => {
          this.errorEmitter.fire([e, void 0, void 0]);
        });
      }
      end() {
      }
      dispose() {
      }
    };
    var SshRpcMessageStream = class {
      constructor(channel) {
        this.reader = new SshRpcMessageReader(channel);
        this.writer = new SshRpcMessageWriter(channel);
      }
    };
    exports2.SshRpcMessageStream = SshRpcMessageStream;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/metrics/sessionContour.js
var require_sessionContour = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/metrics/sessionContour.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SessionContour = void 0;
    var errors_1 = require_errors();
    var queue_1 = require_queue();
    var semaphore_1 = require_semaphore();
    var SessionContour = class _SessionContour {
      /**
       * Creates a new instance of the `SessionContour` class.
       *
       * @param maxIntervals Maximum number of metric intervals to record,
       * defaults to 256. Must be a power of two.
       */
      constructor(maxIntervals = 256) {
        this.intervalMs = _SessionContour.initialInterval;
        this.count = 0;
        this.updateQueue = new queue_1.Queue();
        this.updateSemaphore = new semaphore_1.Semaphore(0);
        this.disposed = false;
        if (maxIntervals < 2 || (maxIntervals & maxIntervals - 1) !== 0) {
          throw new Error("Contour intervals must be a power of two.");
        }
        this.maxIntervals = maxIntervals;
        this.intervalBytesSent = new Array(maxIntervals);
        this.intervalBytesReceived = new Array(maxIntervals);
        this.intervalLatencyMin = new Array(maxIntervals);
        this.intervalLatencyMax = new Array(maxIntervals);
        this.intervalLatencySum = new Array(maxIntervals);
        this.intervalLatencyCount = new Array(maxIntervals);
        this.intervalLatencyAvg = new Array(maxIntervals);
        this.intervalBytesSent.fill(0);
        this.intervalBytesReceived.fill(0);
        this.intervalLatencyMin.fill(0);
        this.intervalLatencyMax.fill(0);
        this.intervalLatencySum.fill(0);
        this.intervalLatencyCount.fill(0);
        this.intervalLatencyAvg.fill(0);
      }
      /**
       * Gets the current number of contour intervals with recorded metrics. This is always
       * less than `maxIntervals`.
       */
      get intervalCount() {
        return this.count;
      }
      /**
       * Gets the current time span of each contour interval, in milliseconds. This interval time
       * span is doubled as necesary such that the entire duration of the session is always covered
       * by fewer intervals than the maximum.
       */
      get interval() {
        return this.intervalMs;
      }
      /**
       * Gets the total number of bytes sent for each interval during the session,
       * including all channels and non-channel protocol messages, and including message
       * framing, padding, and MAC bytes. The number of values is equal to `intervalCount`.
       */
      get bytesSent() {
        return this.intervalBytesSent.slice(0, this.count);
      }
      /**
       * Gets the total number of bytes received for each interval during the session,
       * including all channels and non-channel protocol messages, and including message
       * framing, padding, and MAC bytes. The number of values is equal to `intervalCount`.
       */
      get bytesReceived() {
        return this.intervalBytesReceived.slice(0, this.count);
      }
      /**
       * Gets the minimum recorded round-trip connection latency between client and server for
       * each interval during the session. The number of values is equal to `intervalCount`.
       */
      get latencyMinMs() {
        return this.intervalLatencyMin.slice(0, this.count);
      }
      /**
       * Gets the maximum recorded round-trip connection latency between client and server for
       * each interval during the session. The number of values is equal to `intervalCount`.
       */
      get latencyMaxMs() {
        return this.intervalLatencyMax.slice(0, this.count);
      }
      /**
       * Gets the average recorded round-trip connection latency between client and server for
       * each interval during the session. The number of values is equal to `intervalCount`.
       */
      get latencyAverageMs() {
        return this.intervalLatencyAvg.slice(0, this.count);
      }
      onMessageSent(e) {
        this.updateQueue.enqueue({
          time: e.time,
          bytesSent: e.size
        });
        this.updateSemaphore.tryRelease();
      }
      onMessageReceived(e) {
        this.updateQueue.enqueue({
          time: e.time,
          bytesReceived: e.size
        });
        this.updateSemaphore.tryRelease();
      }
      onLatencyUpdated(e) {
        this.updateQueue.enqueue(e);
        this.updateSemaphore.tryRelease();
      }
      onSessionClosed() {
        this.updateSemaphore.tryRelease();
      }
      /**
       * Starts collecting session metrics, and processes the metrics in a backgroud loop until
       * cancelled or until the session is closed or the `SessionContour` instance is disposed.
       */
      async collectMetrics(sessionMetrics, cancellation) {
        if (!sessionMetrics)
          throw new TypeError("A session metrics object is required.");
        if (this.disposed)
          throw new errors_1.ObjectDisposedError(this);
        const eventRegistrations = [];
        eventRegistrations.push(sessionMetrics.onMessageSent(this.onMessageSent.bind(this)));
        eventRegistrations.push(sessionMetrics.onMessageReceived(this.onMessageReceived.bind(this)));
        eventRegistrations.push(sessionMetrics.onLatencyUpdated(this.onLatencyUpdated.bind(this)));
        eventRegistrations.push(sessionMetrics.onSessionClosed(this.onSessionClosed.bind(this)));
        try {
          while (!(cancellation === null || cancellation === void 0 ? void 0 : cancellation.isCancellationRequested)) {
            try {
              await this.updateSemaphore.wait(cancellation);
            } catch (e) {
              break;
            }
            const update = this.updateQueue.dequeue();
            if (!update) {
              break;
            }
            const intervalIndex = this.updateInterval(update.time);
            if (update.bytesSent) {
              this.intervalBytesSent[intervalIndex] += update.bytesSent;
            }
            if (update.bytesReceived) {
              this.intervalBytesReceived[intervalIndex] += update.bytesReceived;
            }
            const latency = update.latency;
            if (latency) {
              if (!this.intervalLatencyMin[intervalIndex] || latency < this.intervalLatencyMin[intervalIndex]) {
                this.intervalLatencyMin[intervalIndex] = latency;
              }
              if (!this.intervalLatencyMax[intervalIndex] || latency > this.intervalLatencyMax[intervalIndex]) {
                this.intervalLatencyMax[intervalIndex] = latency;
              }
              this.intervalLatencySum[intervalIndex] += latency;
              this.intervalLatencyCount[intervalIndex]++;
              this.intervalLatencyAvg[intervalIndex] = this.intervalLatencySum[intervalIndex] / this.intervalLatencyCount[intervalIndex];
            }
          }
          if (this.disposed) {
            this.updateSemaphore.dispose();
          }
        } finally {
          for (const eventRegistration of eventRegistrations) {
            eventRegistration.dispose();
          }
        }
      }
      updateInterval(time) {
        let intervalIndex = Math.floor(time / this.intervalMs);
        if (intervalIndex >= this.intervalCount) {
          while (intervalIndex >= this.maxIntervals) {
            this.expandIntervals();
            intervalIndex = Math.floor(time / this.intervalMs);
          }
          this.count = intervalIndex + 1;
        }
        return intervalIndex;
      }
      expandIntervals() {
        const combineLatency = (a, b, f) => a === 0 ? b : b === 0 ? a : f(a, b);
        const halfMaxIntervals = this.maxIntervals / 2;
        for (let i = 0; i < halfMaxIntervals; i++) {
          const iA = 2 * i;
          const iB = 2 * i + 1;
          this.intervalBytesSent[i] = this.intervalBytesSent[iA] + this.intervalBytesSent[iB];
          this.intervalBytesReceived[i] = this.intervalBytesReceived[iA] + this.intervalBytesReceived[iB];
          this.intervalLatencyMin[i] = combineLatency(this.intervalLatencyMin[iA], this.intervalLatencyMin[iB], Math.min);
          this.intervalLatencyMax[i] = combineLatency(this.intervalLatencyMax[iA], this.intervalLatencyMax[iB], Math.max);
          this.intervalLatencySum[i] = this.intervalLatencySum[iA] + this.intervalLatencySum[iB];
          const countSum = this.intervalLatencyCount[iA] + this.intervalLatencyCount[iB];
          this.intervalLatencyCount[i] = countSum;
          this.intervalLatencyAvg[i] = countSum === 0 ? 0 : this.intervalLatencySum[i] / this.intervalLatencyCount[i];
        }
        this.intervalBytesSent.fill(0, halfMaxIntervals, this.maxIntervals);
        this.intervalBytesReceived.fill(0, halfMaxIntervals, this.maxIntervals);
        this.intervalLatencyMin.fill(0, halfMaxIntervals, this.maxIntervals);
        this.intervalLatencyMax.fill(0, halfMaxIntervals, this.maxIntervals);
        this.intervalLatencySum.fill(0, halfMaxIntervals, this.maxIntervals);
        this.intervalLatencyCount.fill(0, halfMaxIntervals, this.maxIntervals);
        this.intervalLatencyAvg.fill(0, halfMaxIntervals, this.maxIntervals);
        this.intervalMs *= 2;
      }
      dispose() {
        this.disposed = true;
        this.updateSemaphore.tryRelease();
      }
      /**
       * Serializes the session contour into a compact form suitable for recording in
       * logs or telemetry.
       *
       * This compact serialization format uses one byte per metric per interval, so there is
       * some loss of precision, but generally not so much that it affects a visualization. A
       * scale factor for each metric is automatically determined and included in the serialized
       * header. The size of the serialized encoded data will be a little under 7 bytes per
       * interval. With the default interval maximum (256), that comes out to less than 1.75 KB.
       *
       * Use the code in `SessionContour.kql` to decode and chart this output in
       * Azure Data Explorer.
       */
      export() {
        const getScale = (values) => Math.max(0, Math.ceil(Math.log2(Math.max(...values) / 255)));
        const applyReverseScale = (value, scale) => Math.round(value / Math.pow(2, scale));
        const bytes = Buffer.alloc(3 + (2 + this.intervalCount) * 5);
        const version = 1;
        const timeScale = Math.log2(this.interval / _SessionContour.initialInterval);
        bytes[0] = version;
        bytes[1] = 5;
        bytes[2] = timeScale;
        bytes[3] = getScale(this.latencyMinMs);
        bytes[4] = getScale(this.latencyMaxMs);
        bytes[5] = getScale(this.latencyAverageMs);
        bytes[6] = getScale(this.bytesSent);
        bytes[7] = getScale(this.bytesReceived);
        bytes[8] = SessionMetric.latencyMin;
        bytes[9] = SessionMetric.latencyMax;
        bytes[10] = SessionMetric.latencyAverage;
        bytes[11] = SessionMetric.bytesSent;
        bytes[12] = SessionMetric.bytesReceived;
        for (let i = 0; i < this.intervalCount; i++) {
          const offset = 13 + 5 * i;
          bytes[offset + 0] = applyReverseScale(this.intervalLatencyMin[i], bytes[3]);
          bytes[offset + 1] = applyReverseScale(this.intervalLatencyMax[i], bytes[4]);
          bytes[offset + 2] = applyReverseScale(this.intervalLatencyAvg[i], bytes[5]);
          bytes[offset + 3] = applyReverseScale(this.intervalBytesSent[i], bytes[6]);
          bytes[offset + 4] = applyReverseScale(this.intervalBytesReceived[i], bytes[7]);
        }
        return bytes.toString("base64");
      }
      /**
       * Deserializes a session contour that was previously exported.
       *
       * Due to loss in precision, some values in the deserialized contour will not exactly match
       * the original, but they will be close.
       */
      static import(contourBase64) {
        const bytes = Buffer.from(contourBase64, "base64");
        if (bytes.length < 3) {
          throw new Error("Invalid session contour string.");
        }
        const version = bytes[0];
        const metricsPerInterval = bytes[1];
        const timeScale = bytes[2];
        if (version !== 1) {
          throw new Error(`Unsupported session contour version: ${version}`);
        }
        const intervalCount = (bytes.length - 3) / metricsPerInterval - 2;
        if (intervalCount < 1 || bytes.length !== 3 + metricsPerInterval * (intervalCount + 2)) {
          throw new Error("Incomplete session contour string.");
        }
        const maxIntervals = Math.pow(2, Math.ceil(Math.log2(intervalCount)));
        const sessionContour = new _SessionContour(maxIntervals);
        sessionContour.intervalMs = Math.pow(2, timeScale) * _SessionContour.initialInterval;
        sessionContour.count = intervalCount;
        const scales = new Array(metricsPerInterval);
        for (let m = 0; m < metricsPerInterval; m++) {
          scales[m] = Math.pow(2, bytes[3 + m]);
        }
        const ids = new Array(metricsPerInterval);
        for (let m = 0; m < metricsPerInterval; m++) {
          ids[m] = bytes[3 + metricsPerInterval + m];
        }
        for (let i = 0; i < intervalCount; i++) {
          const offset = 3 + (2 + i) * metricsPerInterval;
          for (let m = 0; m < metricsPerInterval; m++) {
            switch (ids[m]) {
              case SessionMetric.latencyMin:
                sessionContour.intervalLatencyMin[i] = bytes[offset + m] * scales[m];
                break;
              case SessionMetric.latencyMax:
                sessionContour.intervalLatencyMax[i] = bytes[offset + m] * scales[m];
                break;
              case SessionMetric.latencyAverage:
                sessionContour.intervalLatencyAvg[i] = sessionContour.intervalLatencySum[i] = bytes[offset + m] * scales[m];
                sessionContour.intervalLatencyCount[i] = bytes[offset + m] === 0 ? 0 : 1;
                break;
              case SessionMetric.bytesSent:
                sessionContour.intervalBytesSent[i] = bytes[offset + m] * scales[m];
                break;
              case SessionMetric.bytesReceived:
                sessionContour.intervalBytesReceived[i] = bytes[offset + m] * scales[m];
                break;
              default:
                break;
            }
          }
        }
        return sessionContour;
      }
    };
    exports2.SessionContour = SessionContour;
    SessionContour.initialInterval = 1e3;
    var SessionMetric;
    (function(SessionMetric2) {
      SessionMetric2[SessionMetric2["none"] = 0] = "none";
      SessionMetric2[SessionMetric2["latencyMin"] = 1] = "latencyMin";
      SessionMetric2[SessionMetric2["latencyMax"] = 2] = "latencyMax";
      SessionMetric2[SessionMetric2["latencyAverage"] = 3] = "latencyAverage";
      SessionMetric2[SessionMetric2["bytesSent"] = 11] = "bytesSent";
      SessionMetric2[SessionMetric2["bytesReceived"] = 12] = "bytesReceived";
    })(SessionMetric || (SessionMetric = {}));
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/multiChannelStream.js
var require_multiChannelStream = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/multiChannelStream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MultiChannelStream = void 0;
    var vscode_jsonrpc_1 = require_main();
    var sshChannel_1 = require_sshChannel();
    var sshStream_1 = require_sshStream();
    var sshSession_1 = require_sshSession();
    var sshSessionConfiguration_1 = require_sshSessionConfiguration();
    var transportMessages_1 = require_transportMessages();
    var trace_1 = require_trace();
    var connectionMessages_1 = require_connectionMessages();
    var sshReportProgressEventArgs_1 = require_sshReportProgressEventArgs();
    var MultiChannelStream = class {
      /**
       * Creates a new multi-channel stream over an underlying transport stream.
       * @param transportStream Stream that is used to multiplex all the channels.
       */
      constructor(transportStream) {
        this.transportStream = transportStream;
        this.disposed = false;
        this.disposables = [];
        this.reportProgressEmitter = new vscode_jsonrpc_1.Emitter();
        this.onReportProgress = this.reportProgressEmitter.event;
        this.channelMaxWindowSize = sshChannel_1.SshChannel.defaultMaxWindowSize;
        this.closedEmitter = new vscode_jsonrpc_1.Emitter();
        this.onClosed = this.closedEmitter.event;
        this.channelOpeningEmitter = new vscode_jsonrpc_1.Emitter();
        this.onChannelOpening = this.channelOpeningEmitter.event;
        if (!transportStream)
          throw new TypeError("transportStream is required.");
        const noSecurityConfig = new sshSessionConfiguration_1.SshSessionConfiguration(false);
        this.session = new sshSession_1.SshSession(noSecurityConfig);
        this.session.onReportProgress((args) => this.raiseReportProgress(args.progress, args.sessionNumber), this, this.disposables);
        this.session.onClosed(this.onSessionClosed, this, this.disposables);
        this.session.onChannelOpening(this.onSessionChannelOpening, this, this.disposables);
      }
      get trace() {
        return this.session.trace;
      }
      set trace(trace) {
        this.session.trace = trace;
      }
      raiseReportProgress(progress, sessionNumber) {
        const args = new sshReportProgressEventArgs_1.SshReportProgressEventArgs(progress, sessionNumber);
        this.reportProgressEmitter.fire(args);
      }
      get isClosed() {
        return this.disposed || this.session.isClosed;
      }
      /**
       * Initiates the SSH session over the transport stream by exchanging initial messages with the
       * remote peer. Waits for the protocol version exchange and key exchange. Additional message
       * processing is kicked off as a background promise chain.
       * @param cancellation optional cancellation token.
       */
      async connect(cancellation) {
        await this.session.connect(this.transportStream, cancellation);
      }
      /**
       * Asynchronously waits for the other side to open a channel.
       * @param channelType optional channel type
       * @param cancellation optional cancellation token.
       */
      async acceptChannel(channelType, cancellation) {
        await this.session.connect(this.transportStream, cancellation);
        const channel = await this.session.acceptChannel(channelType, cancellation);
        return channel;
      }
      /**
       * Asynchronously waits for the other side to open a channel.
       * @param channelType optional channel type
       * @param cancellation optional cancellation token.
       */
      async acceptStream(channelType, cancellation) {
        return this.createStream(await this.acceptChannel(channelType, cancellation));
      }
      /**
       * Opens a channel and asynchronously waits for the other side to accept it.
       * @param channelType optional channel type
       * @param cancellation optional cancellation token.
       */
      async openChannel(channelType, cancellation) {
        await this.session.connect(this.transportStream, cancellation);
        const openMessage = new connectionMessages_1.ChannelOpenMessage();
        openMessage.channelType = channelType !== null && channelType !== void 0 ? channelType : sshChannel_1.SshChannel.sessionChannelType;
        openMessage.maxWindowSize = this.channelMaxWindowSize;
        const channel = await this.session.openChannel(openMessage, null, cancellation);
        return channel;
      }
      /**
       * Opens a channel and asynchronously waits for the other side to accept it.
       * @param channelType optional channel type
       * @param cancellation optional cancellation token.
       */
      async openStream(channelType, cancellation) {
        return this.createStream(await this.openChannel(channelType, cancellation));
      }
      /**
       * Creates a stream instance for a channel. May be overridden to create a `SshStream` subclass.
       */
      createStream(channel) {
        return new sshStream_1.SshStream(channel);
      }
      /**
       * Connects, waits until the session closes or `cancellation` is cancelled, and then disposes the
       * session and the transport stream.
       * @param cancellation optional cancellation token.
       */
      async connectAndRunUntilClosed(cancellation) {
        const disposables = [];
        const sessionClosedPromise = new Promise((resolve8, reject) => {
          cancellation === null || cancellation === void 0 ? void 0 : cancellation.onCancellationRequested(reject, null, disposables);
          this.session.onClosed(resolve8, null, disposables);
        });
        try {
          await this.connect(cancellation);
          await sessionClosedPromise;
        } finally {
          disposables.forEach((d) => d.dispose());
          await this.close();
        }
      }
      dispose() {
        if (!this.disposed) {
          this.disposed = true;
          this.session.dispose();
          this.unsubscribe();
          try {
            if (this.transportStream)
              this.transportStream.close().catch((e) => {
                this.trace(trace_1.TraceLevel.Error, trace_1.SshTraceEventIds.streamCloseError, `Error closing transport stream: ${e.message}`, e);
              });
          } catch (e) {
            if (!(e instanceof Error))
              throw e;
            this.trace(trace_1.TraceLevel.Error, trace_1.SshTraceEventIds.streamCloseError, `Error closing transport stream: ${e.message}`, e);
          }
        }
      }
      async close() {
        if (!this.disposed) {
          this.disposed = true;
          await this.session.close(transportMessages_1.SshDisconnectReason.none, "SshSession disposed");
          this.session.dispose();
          this.unsubscribe();
          await this.transportStream.close();
        }
      }
      onSessionClosed(e) {
        this.unsubscribe();
        this.closedEmitter.fire(e);
      }
      onSessionChannelOpening(e) {
        if (e.isRemoteRequest) {
          e.channel.maxWindowSize = this.channelMaxWindowSize;
        }
        this.channelOpeningEmitter.fire(e);
      }
      unsubscribe() {
        this.disposables.forEach((d) => d.dispose());
        this.disposables = [];
      }
    };
    exports2.MultiChannelStream = MultiChannelStream;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/secureStream.js
var require_secureStream = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/secureStream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SecureStream = void 0;
    var vscode_jsonrpc_1 = require_main();
    var streams_1 = require_streams();
    var sshStream_1 = require_sshStream();
    var sshSessionConfiguration_1 = require_sshSessionConfiguration();
    var transportMessages_1 = require_transportMessages();
    var trace_1 = require_trace();
    var sshClientSession_1 = require_sshClientSession();
    var sshServerSession_1 = require_sshServerSession();
    var errors_1 = require_errors();
    var stream_1 = require("stream");
    var promiseCompletionSource_1 = require_promiseCompletionSource();
    var SecureStream = class extends stream_1.Duplex {
      /**
       * Creates a new encrypted and authenticated stream over an underlying transport stream.
       * @param transportStream Stream that is used to multiplex all the channels.
       * @param credentials Client or server credentials for authenticating the secure connection.
       * @param reconnectableSessions Optional parameter that enables the stream to be reconnected
       * with a new transport stream after a temporary disconnection. For a stream client it is
       * a boolean value; for a stream server it must be an array.
       */
      constructor(transportStream, credentials, reconnectableSessions) {
        super({
          write(chunk, encoding, cb) {
            this.connectCompletion.promise.then((stream) => {
              if (!stream) {
                cb(new errors_1.ObjectDisposedError("SecureStream"));
              } else {
                stream._write(chunk, encoding, cb);
              }
            }, cb);
          },
          writev(chunks, cb) {
            this.connectCompletion.promise.then((stream) => {
              if (!stream) {
                cb(new errors_1.ObjectDisposedError("SecureStream"));
              } else {
                stream._writev(chunks, cb);
              }
            }, cb);
          },
          final(cb) {
            this.connectCompletion.promise.then((stream) => {
              if (!stream) {
                cb(new errors_1.ObjectDisposedError("SecureStream"));
              } else {
                stream._final(cb);
              }
            }, cb);
          },
          read(size) {
            this.connectCompletion.promise.then((stream) => {
              if (!stream) {
                this.push(null);
              } else {
                stream._read(size);
              }
            }, (e) => {
            });
          }
        });
        this.transportStream = transportStream;
        this.clientCredentials = null;
        this.serverCredentials = null;
        this.connectCompletion = new promiseCompletionSource_1.PromiseCompletionSource();
        this.disposed = false;
        this.disposables = [];
        this.disconnectedEmitter = new vscode_jsonrpc_1.Emitter();
        this.onDisconnected = this.disconnectedEmitter.event;
        this.closedEmitter = new vscode_jsonrpc_1.Emitter();
        this.onClosed = this.closedEmitter.event;
        if (!transportStream)
          throw new TypeError("A transport stream is required.");
        if (!credentials)
          throw new TypeError("Client or server credentials are required.");
        const sessionConfig = new sshSessionConfiguration_1.SshSessionConfiguration(true);
        if (reconnectableSessions) {
          sessionConfig.protocolExtensions.push(sshSessionConfiguration_1.SshProtocolExtensionNames.sessionReconnect);
        }
        if ("username" in credentials) {
          if (typeof reconnectableSessions !== "undefined" && typeof reconnectableSessions !== "boolean") {
            throw new TypeError("SecureStream client reconnectable sessions must be a boolean.");
          }
          this.clientCredentials = credentials;
          this.session = new sshClientSession_1.SshClientSession(sessionConfig);
        } else if (credentials.publicKeys) {
          if (typeof reconnectableSessions !== "undefined" && !Array.isArray(reconnectableSessions)) {
            throw new TypeError("SecureStream server reconnectable sessions must be an array.");
          }
          this.serverCredentials = credentials;
          this.session = new sshServerSession_1.SshServerSession(sessionConfig, reconnectableSessions);
        } else {
          throw new TypeError("Client or server credentials are required.");
        }
        this.session.onDisconnected(this.onSessionDisconnected, this, this.disposables);
        this.session.onClosed(this.onSessionClosed, this, this.disposables);
      }
      get trace() {
        return this.session.trace;
      }
      set trace(trace) {
        this.session.trace = trace;
      }
      get isClosed() {
        return this.disposed || this.session.isClosed;
      }
      onAuthenticating(listener, thisArgs, disposables) {
        return this.session.onAuthenticating(listener, thisArgs, disposables);
      }
      /**
       * Initiates the SSH session over the transport stream by exchanging initial messages with the
       * remote peer. Waits for the protocol version exchange and key exchange. Additional message
       * processing is kicked off as a background promise chain.
       * @param cancellation optional cancellation token.
       */
      async connect(cancellation) {
        let sessionConnected = false;
        try {
          if (this.serverCredentials) {
            const serverSession = this.session;
            serverSession.credentials = this.serverCredentials;
          }
          let stream = this.transportStream;
          if (stream instanceof stream_1.Duplex) {
            stream = new streams_1.NodeStream(stream);
          }
          await this.session.connect(stream, cancellation);
          sessionConnected = true;
          let channel = null;
          if (this.clientCredentials) {
            const clientSession = this.session;
            if (!await clientSession.authenticateServer(cancellation)) {
              throw new errors_1.SshConnectionError("Server authentication failed.", transportMessages_1.SshDisconnectReason.hostKeyNotVerifiable);
            }
            if (!await clientSession.authenticateClient(this.clientCredentials, cancellation)) {
              throw new errors_1.SshConnectionError("Client authentication failed.", transportMessages_1.SshDisconnectReason.noMoreAuthMethodsAvailable);
            }
            channel = await this.session.openChannel(cancellation);
          } else {
            channel = await this.session.acceptChannel(cancellation);
          }
          this.stream = this.createStream(channel);
          this.stream.on("data", (data) => this.emit("data", data));
          this.stream.on("end", () => this.emit("end"));
          this.stream.on("close", () => this.emit("close"));
          this.stream.on("error", () => this.emit("error"));
          channel.onClosed(() => this.dispose());
          this.connectCompletion.resolve(this.stream);
        } catch (e) {
          if (!(e instanceof Error))
            throw e;
          if (e instanceof errors_1.ObjectDisposedError && this.session.isClosed) {
            this.connectCompletion.resolve(null);
          } else {
            let disconnectReason = e instanceof errors_1.SshConnectionError ? e.reason : void 0;
            disconnectReason !== null && disconnectReason !== void 0 ? disconnectReason : disconnectReason = transportMessages_1.SshDisconnectReason.protocolError;
            await this.session.close(disconnectReason, e.message, e);
            this.connectCompletion.reject(e);
            throw e;
          }
        }
      }
      /**
       * Re-initiates the SSH session over a NEW transport stream by exchanging initial messages
       * with the remote server. Waits for the secure reconnect handshake to complete. Additional
       * message processing is kicked off as a background task chain.
       *
       * Applies only to a secure stream client. (The secure stream server handles reconnections
       * automatically during the session handshake.)
       */
      async reconnect(transportStream, cancellation) {
        if (!(this.session instanceof sshClientSession_1.SshClientSession)) {
          throw new Error("Cannot reconnect SecureStream server.");
        }
        if (!transportStream)
          throw new TypeError("A transport stream is required.");
        this.transportStream = transportStream;
        let stream = this.transportStream;
        if (stream instanceof stream_1.Duplex) {
          stream = new streams_1.NodeStream(stream);
        }
        await this.session.reconnect(stream, cancellation);
      }
      /**
       * Creates a stream instance for a channel. May be overridden to create a `SshStream` subclass.
       */
      createStream(channel) {
        return new sshStream_1.SshStream(channel);
      }
      dispose() {
        if (!this.disposed) {
          const sessionWasConnected = this.session.isConnected || this.session.isClosed;
          this.disposed = true;
          this.session.dispose();
          this.unsubscribe();
          try {
            if (!sessionWasConnected && this.transportStream) {
              if (this.transportStream instanceof stream_1.Duplex) {
                this.transportStream.end();
                this.transportStream.destroy();
              } else {
                this.transportStream.close().catch((e) => {
                  this.trace(trace_1.TraceLevel.Error, trace_1.SshTraceEventIds.streamCloseError, `Error closing transport stream: ${e.message}`, e);
                });
              }
            }
          } catch (e) {
            if (!(e instanceof Error))
              throw e;
            this.trace(trace_1.TraceLevel.Error, trace_1.SshTraceEventIds.streamCloseError, `Error closing transport stream: ${e.message}`, e);
          }
        }
      }
      async close() {
        if (!this.disposed) {
          this.disposed = true;
          await this.session.close(transportMessages_1.SshDisconnectReason.none, this.session.constructor.name + " disposed.");
          this.session.dispose();
          this.unsubscribe();
          if (this.transportStream instanceof stream_1.Duplex) {
            await new Promise((resolve8) => {
              this.transportStream.end(resolve8);
            });
          } else {
            await this.transportStream.close();
          }
        }
      }
      onSessionDisconnected() {
        this.disconnectedEmitter.fire();
      }
      onSessionClosed(e) {
        this.unsubscribe();
        this.closedEmitter.fire(e);
      }
      unsubscribe() {
        this.disposables.forEach((d) => d.dispose());
        this.disposables = [];
      }
    };
    exports2.SecureStream = SecureStream;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh/index.js
var require_dev_tunnels_ssh = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CommandRequestMessage = exports2.ChannelRequestType = exports2.ChannelRequestMessage = exports2.ChannelOpenConfirmationMessage = exports2.ChannelOpenMessage = exports2.ChannelOpenFailureMessage = exports2.ChannelMessage = exports2.SshChannelOpenFailureReason = exports2.SessionChannelRequestMessage = exports2.ServiceAcceptMessage = exports2.ServiceRequestMessage = exports2.SshReconnectFailureReason = exports2.SshDisconnectReason = exports2.SessionRequestFailureMessage = exports2.SessionRequestSuccessMessage = exports2.DebugMessage = exports2.SessionRequestMessage = exports2.PasswordRequestMessage = exports2.PublicKeyOKMessage = exports2.PublicKeyRequestMessage = exports2.AuthenticationInfoResponseMessage = exports2.AuthenticationInfoRequestMessage = exports2.AuthenticationFailureMessage = exports2.AuthenticationSuccessMessage = exports2.AuthenticationRequestMessage = exports2.AuthenticationMessage = exports2.SshMessage = exports2.SshExtendedDataEventArgs = exports2.SshExtendedDataType = exports2.SshChannelClosedEventArgs = exports2.SshSessionClosedEventArgs = exports2.SshChannelOpeningEventArgs = exports2.SshReportProgressEventArgs = exports2.SshRequestEventArgs = exports2.SshAuthenticatingEventArgs = exports2.SshAuthenticationType = exports2.serviceActivation = exports2.SshService = exports2.SshRpcMessageStream = exports2.WebSocketStream = exports2.NodeStream = exports2.BaseStream = exports2.SshStream = exports2.SshChannel = exports2.SshServerSession = exports2.SshClientSession = exports2.SshSession = exports2.SshVersionInfo = exports2.SshProtocolExtensionNames = exports2.SshSessionConfiguration = void 0;
    exports2.Progress = exports2.SshTraceEventIds = exports2.TraceLevel = exports2.SecureStream = exports2.MultiChannelStream = exports2.SessionContour = exports2.ChannelMetrics = exports2.SessionMetrics = exports2.Queue = exports2.Semaphore = exports2.PromiseCompletionSource = exports2.CancellationError = exports2.CancellationTokenSource = exports2.CancellationToken = exports2.ObjectDisposedError = exports2.SshReconnectError = exports2.SshConnectionError = exports2.SshChannelError = exports2.BigInt = exports2.DerWriter = exports2.DerReader = exports2.formatBuffer = exports2.SshDataWriter = exports2.SshDataReader = exports2.ECDsa = exports2.Rsa = exports2.Encryption = exports2.HmacAlgorithm = exports2.EncryptionAlgorithm = exports2.PublicKeyAlgorithm = exports2.KeyExchangeAlgorithm = exports2.SshAlgorithms = void 0;
    var sshSessionConfiguration_1 = require_sshSessionConfiguration();
    Object.defineProperty(exports2, "SshSessionConfiguration", { enumerable: true, get: function() {
      return sshSessionConfiguration_1.SshSessionConfiguration;
    } });
    Object.defineProperty(exports2, "SshProtocolExtensionNames", { enumerable: true, get: function() {
      return sshSessionConfiguration_1.SshProtocolExtensionNames;
    } });
    var sshVersionInfo_1 = require_sshVersionInfo();
    Object.defineProperty(exports2, "SshVersionInfo", { enumerable: true, get: function() {
      return sshVersionInfo_1.SshVersionInfo;
    } });
    var sshSession_1 = require_sshSession();
    Object.defineProperty(exports2, "SshSession", { enumerable: true, get: function() {
      return sshSession_1.SshSession;
    } });
    var sshClientSession_1 = require_sshClientSession();
    Object.defineProperty(exports2, "SshClientSession", { enumerable: true, get: function() {
      return sshClientSession_1.SshClientSession;
    } });
    var sshServerSession_1 = require_sshServerSession();
    Object.defineProperty(exports2, "SshServerSession", { enumerable: true, get: function() {
      return sshServerSession_1.SshServerSession;
    } });
    var sshChannel_1 = require_sshChannel();
    Object.defineProperty(exports2, "SshChannel", { enumerable: true, get: function() {
      return sshChannel_1.SshChannel;
    } });
    var sshStream_1 = require_sshStream();
    Object.defineProperty(exports2, "SshStream", { enumerable: true, get: function() {
      return sshStream_1.SshStream;
    } });
    var streams_1 = require_streams();
    Object.defineProperty(exports2, "BaseStream", { enumerable: true, get: function() {
      return streams_1.BaseStream;
    } });
    Object.defineProperty(exports2, "NodeStream", { enumerable: true, get: function() {
      return streams_1.NodeStream;
    } });
    Object.defineProperty(exports2, "WebSocketStream", { enumerable: true, get: function() {
      return streams_1.WebSocketStream;
    } });
    var sshRpcMessageStream_1 = require_sshRpcMessageStream();
    Object.defineProperty(exports2, "SshRpcMessageStream", { enumerable: true, get: function() {
      return sshRpcMessageStream_1.SshRpcMessageStream;
    } });
    var sshService_1 = require_sshService();
    Object.defineProperty(exports2, "SshService", { enumerable: true, get: function() {
      return sshService_1.SshService;
    } });
    var serviceActivation_1 = require_serviceActivation();
    Object.defineProperty(exports2, "serviceActivation", { enumerable: true, get: function() {
      return serviceActivation_1.serviceActivation;
    } });
    var sshAuthenticatingEventArgs_1 = require_sshAuthenticatingEventArgs();
    Object.defineProperty(exports2, "SshAuthenticationType", { enumerable: true, get: function() {
      return sshAuthenticatingEventArgs_1.SshAuthenticationType;
    } });
    Object.defineProperty(exports2, "SshAuthenticatingEventArgs", { enumerable: true, get: function() {
      return sshAuthenticatingEventArgs_1.SshAuthenticatingEventArgs;
    } });
    var sshRequestEventArgs_1 = require_sshRequestEventArgs();
    Object.defineProperty(exports2, "SshRequestEventArgs", { enumerable: true, get: function() {
      return sshRequestEventArgs_1.SshRequestEventArgs;
    } });
    var sshReportProgressEventArgs_1 = require_sshReportProgressEventArgs();
    Object.defineProperty(exports2, "SshReportProgressEventArgs", { enumerable: true, get: function() {
      return sshReportProgressEventArgs_1.SshReportProgressEventArgs;
    } });
    var sshChannelOpeningEventArgs_1 = require_sshChannelOpeningEventArgs();
    Object.defineProperty(exports2, "SshChannelOpeningEventArgs", { enumerable: true, get: function() {
      return sshChannelOpeningEventArgs_1.SshChannelOpeningEventArgs;
    } });
    var sshSessionClosedEventArgs_1 = require_sshSessionClosedEventArgs();
    Object.defineProperty(exports2, "SshSessionClosedEventArgs", { enumerable: true, get: function() {
      return sshSessionClosedEventArgs_1.SshSessionClosedEventArgs;
    } });
    var sshChannelClosedEventArgs_1 = require_sshChannelClosedEventArgs();
    Object.defineProperty(exports2, "SshChannelClosedEventArgs", { enumerable: true, get: function() {
      return sshChannelClosedEventArgs_1.SshChannelClosedEventArgs;
    } });
    var sshExtendedDataEventArgs_1 = require_sshExtendedDataEventArgs();
    Object.defineProperty(exports2, "SshExtendedDataType", { enumerable: true, get: function() {
      return sshExtendedDataEventArgs_1.SshExtendedDataType;
    } });
    Object.defineProperty(exports2, "SshExtendedDataEventArgs", { enumerable: true, get: function() {
      return sshExtendedDataEventArgs_1.SshExtendedDataEventArgs;
    } });
    var sshMessage_1 = require_sshMessage();
    Object.defineProperty(exports2, "SshMessage", { enumerable: true, get: function() {
      return sshMessage_1.SshMessage;
    } });
    var authenticationMessages_1 = require_authenticationMessages();
    Object.defineProperty(exports2, "AuthenticationMessage", { enumerable: true, get: function() {
      return authenticationMessages_1.AuthenticationMessage;
    } });
    Object.defineProperty(exports2, "AuthenticationRequestMessage", { enumerable: true, get: function() {
      return authenticationMessages_1.AuthenticationRequestMessage;
    } });
    Object.defineProperty(exports2, "AuthenticationSuccessMessage", { enumerable: true, get: function() {
      return authenticationMessages_1.AuthenticationSuccessMessage;
    } });
    Object.defineProperty(exports2, "AuthenticationFailureMessage", { enumerable: true, get: function() {
      return authenticationMessages_1.AuthenticationFailureMessage;
    } });
    Object.defineProperty(exports2, "AuthenticationInfoRequestMessage", { enumerable: true, get: function() {
      return authenticationMessages_1.AuthenticationInfoRequestMessage;
    } });
    Object.defineProperty(exports2, "AuthenticationInfoResponseMessage", { enumerable: true, get: function() {
      return authenticationMessages_1.AuthenticationInfoResponseMessage;
    } });
    Object.defineProperty(exports2, "PublicKeyRequestMessage", { enumerable: true, get: function() {
      return authenticationMessages_1.PublicKeyRequestMessage;
    } });
    Object.defineProperty(exports2, "PublicKeyOKMessage", { enumerable: true, get: function() {
      return authenticationMessages_1.PublicKeyOKMessage;
    } });
    Object.defineProperty(exports2, "PasswordRequestMessage", { enumerable: true, get: function() {
      return authenticationMessages_1.PasswordRequestMessage;
    } });
    var transportMessages_1 = require_transportMessages();
    Object.defineProperty(exports2, "SessionRequestMessage", { enumerable: true, get: function() {
      return transportMessages_1.SessionRequestMessage;
    } });
    Object.defineProperty(exports2, "DebugMessage", { enumerable: true, get: function() {
      return transportMessages_1.DebugMessage;
    } });
    Object.defineProperty(exports2, "SessionRequestSuccessMessage", { enumerable: true, get: function() {
      return transportMessages_1.SessionRequestSuccessMessage;
    } });
    Object.defineProperty(exports2, "SessionRequestFailureMessage", { enumerable: true, get: function() {
      return transportMessages_1.SessionRequestFailureMessage;
    } });
    Object.defineProperty(exports2, "SshDisconnectReason", { enumerable: true, get: function() {
      return transportMessages_1.SshDisconnectReason;
    } });
    Object.defineProperty(exports2, "SshReconnectFailureReason", { enumerable: true, get: function() {
      return transportMessages_1.SshReconnectFailureReason;
    } });
    Object.defineProperty(exports2, "ServiceRequestMessage", { enumerable: true, get: function() {
      return transportMessages_1.ServiceRequestMessage;
    } });
    Object.defineProperty(exports2, "ServiceAcceptMessage", { enumerable: true, get: function() {
      return transportMessages_1.ServiceAcceptMessage;
    } });
    Object.defineProperty(exports2, "SessionChannelRequestMessage", { enumerable: true, get: function() {
      return transportMessages_1.SessionChannelRequestMessage;
    } });
    var connectionMessages_1 = require_connectionMessages();
    Object.defineProperty(exports2, "SshChannelOpenFailureReason", { enumerable: true, get: function() {
      return connectionMessages_1.SshChannelOpenFailureReason;
    } });
    Object.defineProperty(exports2, "ChannelMessage", { enumerable: true, get: function() {
      return connectionMessages_1.ChannelMessage;
    } });
    Object.defineProperty(exports2, "ChannelOpenFailureMessage", { enumerable: true, get: function() {
      return connectionMessages_1.ChannelOpenFailureMessage;
    } });
    Object.defineProperty(exports2, "ChannelOpenMessage", { enumerable: true, get: function() {
      return connectionMessages_1.ChannelOpenMessage;
    } });
    Object.defineProperty(exports2, "ChannelOpenConfirmationMessage", { enumerable: true, get: function() {
      return connectionMessages_1.ChannelOpenConfirmationMessage;
    } });
    Object.defineProperty(exports2, "ChannelRequestMessage", { enumerable: true, get: function() {
      return connectionMessages_1.ChannelRequestMessage;
    } });
    Object.defineProperty(exports2, "ChannelRequestType", { enumerable: true, get: function() {
      return connectionMessages_1.ChannelRequestType;
    } });
    Object.defineProperty(exports2, "CommandRequestMessage", { enumerable: true, get: function() {
      return connectionMessages_1.CommandRequestMessage;
    } });
    var sshAlgorithms_1 = require_sshAlgorithms();
    Object.defineProperty(exports2, "SshAlgorithms", { enumerable: true, get: function() {
      return sshAlgorithms_1.SshAlgorithms;
    } });
    Object.defineProperty(exports2, "KeyExchangeAlgorithm", { enumerable: true, get: function() {
      return sshAlgorithms_1.KeyExchangeAlgorithm;
    } });
    Object.defineProperty(exports2, "PublicKeyAlgorithm", { enumerable: true, get: function() {
      return sshAlgorithms_1.PublicKeyAlgorithm;
    } });
    Object.defineProperty(exports2, "EncryptionAlgorithm", { enumerable: true, get: function() {
      return sshAlgorithms_1.EncryptionAlgorithm;
    } });
    Object.defineProperty(exports2, "HmacAlgorithm", { enumerable: true, get: function() {
      return sshAlgorithms_1.HmacAlgorithm;
    } });
    Object.defineProperty(exports2, "Encryption", { enumerable: true, get: function() {
      return sshAlgorithms_1.Encryption;
    } });
    Object.defineProperty(exports2, "Rsa", { enumerable: true, get: function() {
      return sshAlgorithms_1.Rsa;
    } });
    Object.defineProperty(exports2, "ECDsa", { enumerable: true, get: function() {
      return sshAlgorithms_1.ECDsa;
    } });
    var sshData_1 = require_sshData();
    Object.defineProperty(exports2, "SshDataReader", { enumerable: true, get: function() {
      return sshData_1.SshDataReader;
    } });
    Object.defineProperty(exports2, "SshDataWriter", { enumerable: true, get: function() {
      return sshData_1.SshDataWriter;
    } });
    Object.defineProperty(exports2, "formatBuffer", { enumerable: true, get: function() {
      return sshData_1.formatBuffer;
    } });
    var derData_1 = require_derData();
    Object.defineProperty(exports2, "DerReader", { enumerable: true, get: function() {
      return derData_1.DerReader;
    } });
    Object.defineProperty(exports2, "DerWriter", { enumerable: true, get: function() {
      return derData_1.DerWriter;
    } });
    var bigInt_1 = require_bigInt();
    Object.defineProperty(exports2, "BigInt", { enumerable: true, get: function() {
      return bigInt_1.BigInt;
    } });
    var errors_1 = require_errors();
    Object.defineProperty(exports2, "SshChannelError", { enumerable: true, get: function() {
      return errors_1.SshChannelError;
    } });
    Object.defineProperty(exports2, "SshConnectionError", { enumerable: true, get: function() {
      return errors_1.SshConnectionError;
    } });
    Object.defineProperty(exports2, "SshReconnectError", { enumerable: true, get: function() {
      return errors_1.SshReconnectError;
    } });
    Object.defineProperty(exports2, "ObjectDisposedError", { enumerable: true, get: function() {
      return errors_1.ObjectDisposedError;
    } });
    var cancellation_1 = require_cancellation2();
    Object.defineProperty(exports2, "CancellationToken", { enumerable: true, get: function() {
      return cancellation_1.CancellationToken;
    } });
    Object.defineProperty(exports2, "CancellationTokenSource", { enumerable: true, get: function() {
      return cancellation_1.CancellationTokenSource;
    } });
    Object.defineProperty(exports2, "CancellationError", { enumerable: true, get: function() {
      return cancellation_1.CancellationError;
    } });
    var promiseCompletionSource_1 = require_promiseCompletionSource();
    Object.defineProperty(exports2, "PromiseCompletionSource", { enumerable: true, get: function() {
      return promiseCompletionSource_1.PromiseCompletionSource;
    } });
    var semaphore_1 = require_semaphore();
    Object.defineProperty(exports2, "Semaphore", { enumerable: true, get: function() {
      return semaphore_1.Semaphore;
    } });
    var queue_1 = require_queue();
    Object.defineProperty(exports2, "Queue", { enumerable: true, get: function() {
      return queue_1.Queue;
    } });
    var sessionMetrics_1 = require_sessionMetrics();
    Object.defineProperty(exports2, "SessionMetrics", { enumerable: true, get: function() {
      return sessionMetrics_1.SessionMetrics;
    } });
    var channelMetrics_1 = require_channelMetrics();
    Object.defineProperty(exports2, "ChannelMetrics", { enumerable: true, get: function() {
      return channelMetrics_1.ChannelMetrics;
    } });
    var sessionContour_1 = require_sessionContour();
    Object.defineProperty(exports2, "SessionContour", { enumerable: true, get: function() {
      return sessionContour_1.SessionContour;
    } });
    var multiChannelStream_1 = require_multiChannelStream();
    Object.defineProperty(exports2, "MultiChannelStream", { enumerable: true, get: function() {
      return multiChannelStream_1.MultiChannelStream;
    } });
    var secureStream_1 = require_secureStream();
    Object.defineProperty(exports2, "SecureStream", { enumerable: true, get: function() {
      return secureStream_1.SecureStream;
    } });
    var trace_1 = require_trace();
    Object.defineProperty(exports2, "TraceLevel", { enumerable: true, get: function() {
      return trace_1.TraceLevel;
    } });
    Object.defineProperty(exports2, "SshTraceEventIds", { enumerable: true, get: function() {
      return trace_1.SshTraceEventIds;
    } });
    var progress_1 = require_progress();
    Object.defineProperty(exports2, "Progress", { enumerable: true, get: function() {
      return progress_1.Progress;
    } });
  }
});

// ../../node_modules/@microsoft/dev-tunnels-contracts/tunnelAccessScopes.js
var require_tunnelAccessScopes = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-contracts/tunnelAccessScopes.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TunnelAccessScopes = void 0;
    var TunnelAccessScopes2;
    (function(TunnelAccessScopes3) {
      TunnelAccessScopes3["Create"] = "create";
      TunnelAccessScopes3["Manage"] = "manage";
      TunnelAccessScopes3["ManagePorts"] = "manage:ports";
      TunnelAccessScopes3["Host"] = "host";
      TunnelAccessScopes3["Inspect"] = "inspect";
      TunnelAccessScopes3["Connect"] = "connect";
    })(TunnelAccessScopes2 = exports2.TunnelAccessScopes || (exports2.TunnelAccessScopes = {}));
  }
});

// ../../node_modules/@microsoft/dev-tunnels-contracts/tunnelAccessControlStatics.js
var require_tunnelAccessControlStatics = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-contracts/tunnelAccessControlStatics.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateScopes = void 0;
    var tunnelAccessScopes_1 = require_tunnelAccessScopes();
    var allScopes = [
      tunnelAccessScopes_1.TunnelAccessScopes.Manage,
      tunnelAccessScopes_1.TunnelAccessScopes.ManagePorts,
      tunnelAccessScopes_1.TunnelAccessScopes.Host,
      tunnelAccessScopes_1.TunnelAccessScopes.Inspect,
      tunnelAccessScopes_1.TunnelAccessScopes.Connect
    ];
    function validateScopes(scopes, validScopes, allowMultiple) {
      if (!Array.isArray(scopes)) {
        throw new TypeError("A scopes array was expected.");
      }
      if (allowMultiple) {
        scopes = scopes.map((s) => s.split(" ")).reduce((a, b) => a.concat(b), []);
      }
      scopes.forEach((scope) => {
        if (!scope) {
          throw new Error("Tunnel access scopes include a null/empty item.");
        } else if (!allScopes.includes(scope)) {
          throw new Error("Invalid tunnel access scope: " + scope);
        }
      });
      if (Array.isArray(validScopes)) {
        scopes.forEach((scope) => {
          if (!validScopes.includes(scope)) {
            throw new Error("Tunnel access scope is invalid for current request: scope");
          }
        });
      }
    }
    exports2.validateScopes = validateScopes;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-contracts/tunnelAccessControl.js
var require_tunnelAccessControl = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-contracts/tunnelAccessControl.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TunnelAccessControl = void 0;
    var tunnelAccessControlStatics_1 = require_tunnelAccessControlStatics();
    exports2.TunnelAccessControl = {
      validateScopes: tunnelAccessControlStatics_1.validateScopes
    };
  }
});

// ../../node_modules/@microsoft/dev-tunnels-contracts/tunnelAccessControlEntry.js
var require_tunnelAccessControlEntry = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-contracts/tunnelAccessControlEntry.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TunnelAccessControlEntry = void 0;
    var TunnelAccessControlEntry;
    (function(TunnelAccessControlEntry2) {
      let Providers;
      (function(Providers2) {
        Providers2["Microsoft"] = "microsoft";
        Providers2["GitHub"] = "github";
        Providers2["Ssh"] = "ssh";
        Providers2["IPv4"] = "ipv4";
        Providers2["IPv6"] = "ipv6";
        Providers2["ServiceTag"] = "service-tag";
      })(Providers = TunnelAccessControlEntry2.Providers || (TunnelAccessControlEntry2.Providers = {}));
    })(TunnelAccessControlEntry = exports2.TunnelAccessControlEntry || (exports2.TunnelAccessControlEntry = {}));
  }
});

// ../../node_modules/@microsoft/dev-tunnels-contracts/tunnelAccessControlEntryType.js
var require_tunnelAccessControlEntryType = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-contracts/tunnelAccessControlEntryType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TunnelAccessControlEntryType = void 0;
    var TunnelAccessControlEntryType;
    (function(TunnelAccessControlEntryType2) {
      TunnelAccessControlEntryType2["None"] = "None";
      TunnelAccessControlEntryType2["Anonymous"] = "Anonymous";
      TunnelAccessControlEntryType2["Users"] = "Users";
      TunnelAccessControlEntryType2["Groups"] = "Groups";
      TunnelAccessControlEntryType2["Organizations"] = "Organizations";
      TunnelAccessControlEntryType2["Repositories"] = "Repositories";
      TunnelAccessControlEntryType2["PublicKeys"] = "PublicKeys";
      TunnelAccessControlEntryType2["IPAddressRanges"] = "IPAddressRanges";
    })(TunnelAccessControlEntryType = exports2.TunnelAccessControlEntryType || (exports2.TunnelAccessControlEntryType = {}));
  }
});

// ../../node_modules/@microsoft/dev-tunnels-contracts/tunnelConnectionMode.js
var require_tunnelConnectionMode = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-contracts/tunnelConnectionMode.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TunnelConnectionMode = void 0;
    var TunnelConnectionMode;
    (function(TunnelConnectionMode2) {
      TunnelConnectionMode2["LocalNetwork"] = "LocalNetwork";
      TunnelConnectionMode2["TunnelRelay"] = "TunnelRelay";
    })(TunnelConnectionMode = exports2.TunnelConnectionMode || (exports2.TunnelConnectionMode = {}));
  }
});

// ../../node_modules/@microsoft/dev-tunnels-contracts/tunnelEndpointStatics.js
var require_tunnelEndpointStatics = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-contracts/tunnelEndpointStatics.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getPortSshCommand = exports2.getPortUri = void 0;
    var tunnelEndpoint_1 = require_tunnelEndpoint();
    function getPortUri(endpoint, portNumber) {
      if (!endpoint) {
        throw new TypeError("A tunnel endpoint is required.");
      }
      if (typeof portNumber !== "number" && !endpoint.tunnelUri) {
        return endpoint.tunnelUri;
      }
      if (typeof portNumber !== "number" || !endpoint.portUriFormat) {
        return void 0;
      }
      return endpoint.portUriFormat.replace(tunnelEndpoint_1.portToken, portNumber.toString());
    }
    exports2.getPortUri = getPortUri;
    function getPortSshCommand(endpoint, portNumber) {
      if (!endpoint) {
        throw new TypeError("A tunnel endpoint is required.");
      }
      if (typeof portNumber !== "number" && !endpoint.tunnelSshCommand) {
        return endpoint.tunnelSshCommand;
      }
      if (typeof portNumber !== "number" || !endpoint.portSshCommandFormat) {
        return void 0;
      }
      return endpoint.portSshCommandFormat.replace(tunnelEndpoint_1.portToken, portNumber.toString());
    }
    exports2.getPortSshCommand = getPortSshCommand;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-contracts/tunnelEndpoint.js
var require_tunnelEndpoint = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-contracts/tunnelEndpoint.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TunnelEndpoint = exports2.portToken = void 0;
    exports2.portToken = "{port}";
    var tunnelEndpointStatics_1 = require_tunnelEndpointStatics();
    exports2.TunnelEndpoint = {
      portToken: exports2.portToken,
      getPortUri: tunnelEndpointStatics_1.getPortUri,
      getPortSshCommand: tunnelEndpointStatics_1.getPortSshCommand
    };
  }
});

// ../../node_modules/@microsoft/dev-tunnels-contracts/tunnelEvent.js
var require_tunnelEvent = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-contracts/tunnelEvent.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TunnelEvent = exports2.error = exports2.warning = exports2.info = void 0;
    exports2.info = "info";
    exports2.warning = "warning";
    exports2.error = "error";
    exports2.TunnelEvent = {
      info: exports2.info,
      warning: exports2.warning,
      error: exports2.error
    };
  }
});

// ../../node_modules/@microsoft/dev-tunnels-contracts/tunnelHeaderNames.js
var require_tunnelHeaderNames = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-contracts/tunnelHeaderNames.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TunnelHeaderNames = void 0;
    var TunnelHeaderNames;
    (function(TunnelHeaderNames2) {
      TunnelHeaderNames2["XTunnelAuthorization"] = "X-Tunnel-Authorization";
      TunnelHeaderNames2["XRequestID"] = "X-Request-ID";
      TunnelHeaderNames2["XGithubSshKey"] = "X-Github-Ssh-Key";
      TunnelHeaderNames2["XTunnelSkipAntiPhishingPage"] = "X-Tunnel-Skip-AntiPhishing-Page";
    })(TunnelHeaderNames = exports2.TunnelHeaderNames || (exports2.TunnelHeaderNames = {}));
  }
});

// ../../node_modules/@microsoft/dev-tunnels-contracts/tunnelProtocol.js
var require_tunnelProtocol = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-contracts/tunnelProtocol.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TunnelProtocol = void 0;
    var TunnelProtocol;
    (function(TunnelProtocol2) {
      TunnelProtocol2["Auto"] = "auto";
      TunnelProtocol2["Tcp"] = "tcp";
      TunnelProtocol2["Udp"] = "udp";
      TunnelProtocol2["Ssh"] = "ssh";
      TunnelProtocol2["Rdp"] = "rdp";
      TunnelProtocol2["Http"] = "http";
      TunnelProtocol2["Https"] = "https";
    })(TunnelProtocol = exports2.TunnelProtocol || (exports2.TunnelProtocol = {}));
  }
});

// ../../node_modules/@microsoft/dev-tunnels-contracts/tunnelServicePropertiesStatics.js
var require_tunnelServicePropertiesStatics = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-contracts/tunnelServicePropertiesStatics.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.environment = exports2.development = exports2.staging = exports2.production = void 0;
    var tunnelServiceProperties_1 = require_tunnelServiceProperties();
    exports2.production = {
      serviceUri: `https://${tunnelServiceProperties_1.prodDnsName}/`,
      serviceAppId: tunnelServiceProperties_1.prodFirstPartyAppId,
      serviceInternalAppId: tunnelServiceProperties_1.prodThirdPartyAppId,
      gitHubAppClientId: tunnelServiceProperties_1.prodGitHubAppClientId
    };
    exports2.staging = {
      serviceUri: `https://${tunnelServiceProperties_1.ppeDnsName}/`,
      serviceAppId: tunnelServiceProperties_1.ppeFirstPartyAppId,
      serviceInternalAppId: tunnelServiceProperties_1.ppeThirdPartyAppId,
      gitHubAppClientId: tunnelServiceProperties_1.nonProdGitHubAppClientId
    };
    exports2.development = {
      serviceUri: `https://${tunnelServiceProperties_1.devDnsName}/`,
      serviceAppId: tunnelServiceProperties_1.devFirstPartyAppId,
      serviceInternalAppId: tunnelServiceProperties_1.devThirdPartyAppId,
      gitHubAppClientId: tunnelServiceProperties_1.nonProdGitHubAppClientId
    };
    function environment(environmentName) {
      if (!environmentName) {
        throw new Error(`Invalid argument: ${environmentName}`);
      }
      switch (environmentName.toLowerCase()) {
        case "prod":
        case "production":
          return exports2.production;
        case "ppe":
        case "preprod":
          return exports2.staging;
        case "dev":
        case "development":
          return exports2.development;
        default:
          throw new Error(`Invalid service environment: ${environmentName}`);
      }
    }
    exports2.environment = environment;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-contracts/tunnelServiceProperties.js
var require_tunnelServiceProperties = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-contracts/tunnelServiceProperties.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TunnelServiceProperties = exports2.nonProdGitHubAppClientId = exports2.prodGitHubAppClientId = exports2.devThirdPartyAppId = exports2.ppeThirdPartyAppId = exports2.prodThirdPartyAppId = exports2.devFirstPartyAppId = exports2.ppeFirstPartyAppId = exports2.prodFirstPartyAppId = exports2.devDnsName = exports2.ppeDnsName = exports2.prodDnsName = void 0;
    exports2.prodDnsName = "global.rel.tunnels.api.visualstudio.com";
    exports2.ppeDnsName = "global.rel.tunnels.ppe.api.visualstudio.com";
    exports2.devDnsName = "global.ci.tunnels.dev.api.visualstudio.com";
    exports2.prodFirstPartyAppId = "46da2f7e-b5ef-422a-88d4-2a7f9de6a0b2";
    exports2.ppeFirstPartyAppId = "54c45752-bacd-424a-b928-652f3eca2b18";
    exports2.devFirstPartyAppId = "9c63851a-ba2b-40a5-94bd-890be43b9284";
    exports2.prodThirdPartyAppId = "ce65d243-a913-4cae-a7dd-cb52e9f77647";
    exports2.ppeThirdPartyAppId = "544167a6-f431-4518-aac6-2fd50071928e";
    exports2.devThirdPartyAppId = "a118c979-0249-44bb-8f95-eb0457127aeb";
    exports2.prodGitHubAppClientId = "Iv1.e7b89e013f801f03";
    exports2.nonProdGitHubAppClientId = "Iv1.b231c327f1eaa229";
    var tunnelServicePropertiesStatics_1 = require_tunnelServicePropertiesStatics();
    exports2.TunnelServiceProperties = {
      production: tunnelServicePropertiesStatics_1.production,
      staging: tunnelServicePropertiesStatics_1.staging,
      development: tunnelServicePropertiesStatics_1.development,
      environment: tunnelServicePropertiesStatics_1.environment
    };
  }
});

// ../../node_modules/@microsoft/dev-tunnels-contracts/tunnelConstraints.js
var require_tunnelConstraints = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-contracts/tunnelConstraints.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TunnelConstraints = void 0;
    var TunnelConstraints;
    (function(TunnelConstraints2) {
      TunnelConstraints2.clusterIdMinLength = 3;
      TunnelConstraints2.clusterIdMaxLength = 12;
      TunnelConstraints2.oldTunnelIdLength = 8;
      TunnelConstraints2.newTunnelIdMinLength = 3;
      TunnelConstraints2.newTunnelIdMaxLength = 60;
      TunnelConstraints2.tunnelAliasLength = 8;
      TunnelConstraints2.tunnelNameMinLength = 3;
      TunnelConstraints2.tunnelNameMaxLength = 60;
      TunnelConstraints2.descriptionMaxLength = 400;
      TunnelConstraints2.eventDetailsMaxLength = 4e3;
      TunnelConstraints2.maxEventProperties = 100;
      TunnelConstraints2.eventPropertyValueMaxLength = 4e3;
      TunnelConstraints2.labelMinLength = 1;
      TunnelConstraints2.labelMaxLength = 50;
      TunnelConstraints2.maxLabels = 100;
      TunnelConstraints2.tunnelDomainMinLength = 4;
      TunnelConstraints2.tunnelDomainMaxLength = 180;
      TunnelConstraints2.tunnelMaxPorts = 1e3;
      TunnelConstraints2.accessControlMaxEntries = 40;
      TunnelConstraints2.accessControlMaxSubjects = 100;
      TunnelConstraints2.accessControlSubjectMaxLength = 200;
      TunnelConstraints2.accessControlSubjectNameMaxLength = 200;
      TunnelConstraints2.accessControlMaxScopes = 10;
      TunnelConstraints2.eventNamePattern = "^[a-z0-9_]{3,80}$";
      TunnelConstraints2.eventSeverityPattern = "^(info)|(warning)|(error)$";
      TunnelConstraints2.eventPropertyNamePattern = "^[a-zA-Z0-9_.]{3,200}$";
      TunnelConstraints2.clusterIdPattern = "^(([a-z]{3,4}[0-9]{1,3})|asse|aue|brs|euw|use)$";
      TunnelConstraints2.clusterIdRegex = new RegExp(TunnelConstraints2.clusterIdPattern);
      TunnelConstraints2.clusterIdPrefixRegex = new RegExp(TunnelConstraints2.clusterIdPattern.replace("$", "\\."));
      TunnelConstraints2.oldTunnelIdChars = "0123456789bcdfghjklmnpqrstvwxz";
      TunnelConstraints2.oldTunnelIdPattern = "[" + TunnelConstraints2.oldTunnelIdChars + "]{8}";
      TunnelConstraints2.oldTunnelIdRegex = new RegExp(TunnelConstraints2.oldTunnelIdPattern);
      TunnelConstraints2.newTunnelIdChars = "0123456789abcdefghijklmnopqrstuvwxyz-";
      TunnelConstraints2.newTunnelIdPattern = "[a-z0-9][a-z0-9-]{1,58}[a-z0-9]";
      TunnelConstraints2.newTunnelIdRegex = new RegExp(TunnelConstraints2.newTunnelIdPattern);
      TunnelConstraints2.tunnelAliasChars = "0123456789bcdfghjklmnpqrstvwxz";
      TunnelConstraints2.tunnelAliasPattern = "[" + TunnelConstraints2.tunnelAliasChars + "]{3,60}";
      TunnelConstraints2.tunnelAliasRegex = new RegExp(TunnelConstraints2.tunnelAliasPattern);
      TunnelConstraints2.tunnelNamePattern = "([a-z0-9][a-z0-9-]{1,58}[a-z0-9])|(^$)";
      TunnelConstraints2.tunnelNameRegex = new RegExp(TunnelConstraints2.tunnelNamePattern);
      TunnelConstraints2.labelPattern = "[\\w-=]{1,50}";
      TunnelConstraints2.labelRegex = new RegExp(TunnelConstraints2.labelPattern);
      TunnelConstraints2.tunnelDomainPattern = "[0-9a-z][0-9a-z-.]{1,158}[0-9a-z]|(^$)";
      TunnelConstraints2.tunnelDomainRegex = new RegExp(TunnelConstraints2.tunnelDomainPattern);
      TunnelConstraints2.accessControlSubjectPattern = "[0-9a-zA-Z-._:/@]{0,200}";
      TunnelConstraints2.accessControlSubjectRegex = new RegExp(TunnelConstraints2.accessControlSubjectPattern);
      TunnelConstraints2.accessControlSubjectNamePattern = `[ \\w\\d-.,/'"_@()<>]{0,200}`;
      TunnelConstraints2.accessControlSubjectNameRegex = new RegExp(TunnelConstraints2.accessControlSubjectNamePattern);
    })(TunnelConstraints = exports2.TunnelConstraints || (exports2.TunnelConstraints = {}));
  }
});

// ../../node_modules/@microsoft/dev-tunnels-contracts/tunnelProgress.js
var require_tunnelProgress = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-contracts/tunnelProgress.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TunnelProgress = void 0;
    var TunnelProgress;
    (function(TunnelProgress2) {
      TunnelProgress2["StartingRefreshPorts"] = "StartingRefreshPorts";
      TunnelProgress2["CompletedRefreshPorts"] = "CompletedRefreshPorts";
      TunnelProgress2["StartingRequestUri"] = "StartingRequestUri";
      TunnelProgress2["StartingRequestConfig"] = "StartingRequestConfig";
      TunnelProgress2["StartingSendTunnelRequest"] = "StartingSendTunnelRequest";
      TunnelProgress2["CompletedSendTunnelRequest"] = "CompletedSendTunnelRequest";
      TunnelProgress2["StartingCreateTunnelPort"] = "StartingCreateTunnelPort";
      TunnelProgress2["CompletedCreateTunnelPort"] = "CompletedCreateTunnelPort";
      TunnelProgress2["StartingGetTunnelPort"] = "StartingGetTunnelPort";
      TunnelProgress2["CompletedGetTunnelPort"] = "CompletedGetTunnelPort";
    })(TunnelProgress = exports2.TunnelProgress || (exports2.TunnelProgress = {}));
  }
});

// ../../node_modules/@microsoft/dev-tunnels-contracts/index.js
var require_dev_tunnels_contracts = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-contracts/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TunnelProgress = exports2.TunnelConstraints = exports2.TunnelServiceProperties = exports2.TunnelProtocol = exports2.TunnelHeaderNames = exports2.TunnelEvent = exports2.TunnelEndpoint = exports2.TunnelConnectionMode = exports2.TunnelAccessScopes = exports2.TunnelAccessControlEntryType = exports2.TunnelAccessControlEntry = exports2.TunnelAccessControl = void 0;
    var tunnelAccessControl_1 = require_tunnelAccessControl();
    Object.defineProperty(exports2, "TunnelAccessControl", { enumerable: true, get: function() {
      return tunnelAccessControl_1.TunnelAccessControl;
    } });
    var tunnelAccessControlEntry_1 = require_tunnelAccessControlEntry();
    Object.defineProperty(exports2, "TunnelAccessControlEntry", { enumerable: true, get: function() {
      return tunnelAccessControlEntry_1.TunnelAccessControlEntry;
    } });
    var tunnelAccessControlEntryType_1 = require_tunnelAccessControlEntryType();
    Object.defineProperty(exports2, "TunnelAccessControlEntryType", { enumerable: true, get: function() {
      return tunnelAccessControlEntryType_1.TunnelAccessControlEntryType;
    } });
    var tunnelAccessScopes_1 = require_tunnelAccessScopes();
    Object.defineProperty(exports2, "TunnelAccessScopes", { enumerable: true, get: function() {
      return tunnelAccessScopes_1.TunnelAccessScopes;
    } });
    var tunnelConnectionMode_1 = require_tunnelConnectionMode();
    Object.defineProperty(exports2, "TunnelConnectionMode", { enumerable: true, get: function() {
      return tunnelConnectionMode_1.TunnelConnectionMode;
    } });
    var tunnelEndpoint_1 = require_tunnelEndpoint();
    Object.defineProperty(exports2, "TunnelEndpoint", { enumerable: true, get: function() {
      return tunnelEndpoint_1.TunnelEndpoint;
    } });
    var tunnelEvent_1 = require_tunnelEvent();
    Object.defineProperty(exports2, "TunnelEvent", { enumerable: true, get: function() {
      return tunnelEvent_1.TunnelEvent;
    } });
    var tunnelHeaderNames_1 = require_tunnelHeaderNames();
    Object.defineProperty(exports2, "TunnelHeaderNames", { enumerable: true, get: function() {
      return tunnelHeaderNames_1.TunnelHeaderNames;
    } });
    var tunnelProtocol_1 = require_tunnelProtocol();
    Object.defineProperty(exports2, "TunnelProtocol", { enumerable: true, get: function() {
      return tunnelProtocol_1.TunnelProtocol;
    } });
    var tunnelServiceProperties_1 = require_tunnelServiceProperties();
    Object.defineProperty(exports2, "TunnelServiceProperties", { enumerable: true, get: function() {
      return tunnelServiceProperties_1.TunnelServiceProperties;
    } });
    var tunnelConstraints_1 = require_tunnelConstraints();
    Object.defineProperty(exports2, "TunnelConstraints", { enumerable: true, get: function() {
      return tunnelConstraints_1.TunnelConstraints;
    } });
    var tunnelProgress_1 = require_tunnelProgress();
    Object.defineProperty(exports2, "TunnelProgress", { enumerable: true, get: function() {
      return tunnelProgress_1.TunnelProgress;
    } });
  }
});

// ../../node_modules/@microsoft/dev-tunnels-management/tunnelManagementClient.js
var require_tunnelManagementClient = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-management/tunnelManagementClient.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TunnelAuthenticationSchemes = void 0;
    var TunnelAuthenticationSchemes = class {
    };
    exports2.TunnelAuthenticationSchemes = TunnelAuthenticationSchemes;
    TunnelAuthenticationSchemes.aad = "aad";
    TunnelAuthenticationSchemes.github = "github";
    TunnelAuthenticationSchemes.tunnel = "tunnel";
  }
});

// ../../node_modules/@microsoft/dev-tunnels-management/tunnelAccessTokenProperties.js
var require_tunnelAccessTokenProperties = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-management/tunnelAccessTokenProperties.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TunnelAccessTokenProperties = void 0;
    var TunnelAccessTokenProperties = class _TunnelAccessTokenProperties {
      constructor(clusterId, tunnelId, tunnelPorts, scopes, issuer, expiration) {
        this.clusterId = clusterId;
        this.tunnelId = tunnelId;
        this.tunnelPorts = tunnelPorts;
        this.scopes = scopes;
        this.issuer = issuer;
        this.expiration = expiration;
      }
      toString() {
        let s = "";
        if (this.tunnelId) {
          s += "tunnel=";
          s += this.tunnelId;
          if (this.clusterId) {
            s += ".";
            s += this.clusterId;
          }
        }
        if (this.tunnelPorts && this.tunnelPorts.length > 0) {
          if (s.length > 0)
            s += ", ";
          if (this.tunnelPorts.length === 1) {
            s += `port=${this.tunnelPorts[0]}`;
          } else {
            s += `ports=[${this.tunnelPorts.join(", ")}]`;
          }
        }
        if (this.scopes) {
          if (s.length > 0)
            s += ", ";
          s += `scopes=[${this.scopes.join(", ")}]`;
        }
        if (this.issuer) {
          if (s.length > 0)
            s += ", ";
          s += "issuer=";
          s += this.issuer;
        }
        if (this.expiration) {
          if (s.length > 0)
            s += ", ";
          s += `expiration=${this.expiration.toString().replace(".000Z", "Z")}`;
        }
        return s;
      }
      /**
       * Checks if the tunnel access token expiration claim is in the past.
       * Note: uses client's system time for the validation.
       * (Does not throw if the token is an invalid format.)
       */
      static validateTokenExpiration(token) {
        const t = _TunnelAccessTokenProperties.tryParse(token);
        if (t === null || t === void 0 ? void 0 : t.expiration) {
          if (t.expiration < /* @__PURE__ */ new Date()) {
            throw new Error("The access token is expired: " + t);
          }
        }
      }
      /**
       * Attempts to parse a tunnel access token (JWT). This does NOT validate the token
       * signature or any claims.
       */
      static tryParse(token) {
        if (typeof token !== "string")
          throw new TypeError("Token string expected.");
        const tokenParts = token.split(".");
        if (tokenParts.length !== 3) {
          return null;
        }
        const tokenBodyJson = _TunnelAccessTokenProperties.base64UrlDecode(tokenParts[1]);
        if (!tokenBodyJson) {
          return null;
        }
        try {
          const tokenJson = JSON.parse(tokenBodyJson);
          const clusterId = tokenJson.clusterId;
          const tunnelId = tokenJson.tunnelId;
          const ports = tokenJson.tunnelPorts;
          const scp = tokenJson.scp;
          const iss = tokenJson.iss;
          const exp = tokenJson.exp;
          return new _TunnelAccessTokenProperties(clusterId, tunnelId, typeof ports === "number" ? [ports] : ports, scp === null || scp === void 0 ? void 0 : scp.split(" "), iss, typeof exp === "number" ? new Date(exp * 1e3) : void 0);
        } catch (_a2) {
          return null;
        }
      }
      /**
       * Gets the tunnal access token trace string.
       * 'none' if null or undefined, parsed token info if can be parsed, or 'token' if cannot be parsed.
       */
      static getTokenTrace(token) {
        var _a2, _b;
        return !token ? "none" : (_b = (_a2 = _TunnelAccessTokenProperties.tryParse(token)) === null || _a2 === void 0 ? void 0 : _a2.toString()) !== null && _b !== void 0 ? _b : "token";
      }
      /**
       * Gets a tunnel access token that matches any of the provided access token scopes.
       * @param tunnel The tunnel to get the access tokens from.
       * @param accessTokenScopes What scopes the token needs to have.
       * @returns Tunnel access token if found; otherwise, undefined.
       */
      static getTunnelAccessToken(tunnel, accessTokenScopes) {
        if (!(tunnel === null || tunnel === void 0 ? void 0 : tunnel.accessTokens) || !accessTokenScopes) {
          return;
        }
        if (!Array.isArray(accessTokenScopes)) {
          accessTokenScopes = [accessTokenScopes];
        }
        for (const scope of accessTokenScopes) {
          for (const [key, accessToken] of Object.entries(tunnel.accessTokens)) {
            if (accessToken && key.split(" ").includes(scope)) {
              return accessToken;
            }
          }
        }
      }
      static base64UrlDecode(encodedString) {
        encodedString = encodedString.replace("-", "+");
        while (encodedString.length % 4 !== 0) {
          encodedString += "=";
        }
        try {
          const result = atob(encodedString);
          return result;
        } catch (_a2) {
          return null;
        }
      }
    };
    exports2.TunnelAccessTokenProperties = TunnelAccessTokenProperties;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-management/package.json
var require_package2 = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-management/package.json"(exports2, module2) {
    module2.exports = {
      name: "@microsoft/dev-tunnels-management",
      version: "1.3.6",
      description: "Tunnels library for Visual Studio tools",
      keywords: [
        "Tunnels"
      ],
      author: "Microsoft",
      license: "MIT",
      dependencies: {
        buffer: "^5.2.1",
        debug: "^4.1.1",
        "vscode-jsonrpc": "^4.0.0",
        "@microsoft/dev-tunnels-contracts": "^1.3.6",
        axios: "^1.8.4"
      },
      main: "./index.js"
    };
  }
});

// ../../node_modules/@microsoft/dev-tunnels-management/version.js
var require_version = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-management/version.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.tunnelSdkUserAgent = void 0;
    var packageJson = require_package2();
    var packageVersion = packageJson.version;
    exports2.tunnelSdkUserAgent = `Dev-Tunnels-Service-TypeScript-SDK/${packageVersion}`;
  }
});

// ../../node_modules/delayed-stream/lib/delayed_stream.js
var require_delayed_stream = __commonJS({
  "../../node_modules/delayed-stream/lib/delayed_stream.js"(exports2, module2) {
    "use strict";
    var Stream = require("stream").Stream;
    var util2 = require("util");
    module2.exports = DelayedStream;
    function DelayedStream() {
      this.source = null;
      this.dataSize = 0;
      this.maxDataSize = 1024 * 1024;
      this.pauseStream = true;
      this._maxDataSizeExceeded = false;
      this._released = false;
      this._bufferedEvents = [];
    }
    util2.inherits(DelayedStream, Stream);
    DelayedStream.create = function(source, options) {
      var delayedStream = new this();
      options = options || {};
      for (var option in options) {
        delayedStream[option] = options[option];
      }
      delayedStream.source = source;
      var realEmit = source.emit;
      source.emit = function() {
        delayedStream._handleEmit(arguments);
        return realEmit.apply(source, arguments);
      };
      source.on("error", function() {
      });
      if (delayedStream.pauseStream) {
        source.pause();
      }
      return delayedStream;
    };
    Object.defineProperty(DelayedStream.prototype, "readable", {
      configurable: true,
      enumerable: true,
      get: function() {
        return this.source.readable;
      }
    });
    DelayedStream.prototype.setEncoding = function() {
      return this.source.setEncoding.apply(this.source, arguments);
    };
    DelayedStream.prototype.resume = function() {
      if (!this._released) {
        this.release();
      }
      this.source.resume();
    };
    DelayedStream.prototype.pause = function() {
      this.source.pause();
    };
    DelayedStream.prototype.release = function() {
      this._released = true;
      this._bufferedEvents.forEach(function(args) {
        this.emit.apply(this, args);
      }.bind(this));
      this._bufferedEvents = [];
    };
    DelayedStream.prototype.pipe = function() {
      var r = Stream.prototype.pipe.apply(this, arguments);
      this.resume();
      return r;
    };
    DelayedStream.prototype._handleEmit = function(args) {
      if (this._released) {
        this.emit.apply(this, args);
        return;
      }
      if (args[0] === "data") {
        this.dataSize += args[1].length;
        this._checkIfMaxDataSizeExceeded();
      }
      this._bufferedEvents.push(args);
    };
    DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
      if (this._maxDataSizeExceeded) {
        return;
      }
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
      this._maxDataSizeExceeded = true;
      var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
      this.emit("error", new Error(message));
    };
  }
});

// ../../node_modules/combined-stream/lib/combined_stream.js
var require_combined_stream = __commonJS({
  "../../node_modules/combined-stream/lib/combined_stream.js"(exports2, module2) {
    "use strict";
    var util2 = require("util");
    var Stream = require("stream").Stream;
    var DelayedStream = require_delayed_stream();
    module2.exports = CombinedStream;
    function CombinedStream() {
      this.writable = false;
      this.readable = true;
      this.dataSize = 0;
      this.maxDataSize = 2 * 1024 * 1024;
      this.pauseStreams = true;
      this._released = false;
      this._streams = [];
      this._currentStream = null;
      this._insideLoop = false;
      this._pendingNext = false;
    }
    util2.inherits(CombinedStream, Stream);
    CombinedStream.create = function(options) {
      var combinedStream = new this();
      options = options || {};
      for (var option in options) {
        combinedStream[option] = options[option];
      }
      return combinedStream;
    };
    CombinedStream.isStreamLike = function(stream) {
      return typeof stream !== "function" && typeof stream !== "string" && typeof stream !== "boolean" && typeof stream !== "number" && !Buffer.isBuffer(stream);
    };
    CombinedStream.prototype.append = function(stream) {
      var isStreamLike = CombinedStream.isStreamLike(stream);
      if (isStreamLike) {
        if (!(stream instanceof DelayedStream)) {
          var newStream = DelayedStream.create(stream, {
            maxDataSize: Infinity,
            pauseStream: this.pauseStreams
          });
          stream.on("data", this._checkDataSize.bind(this));
          stream = newStream;
        }
        this._handleErrors(stream);
        if (this.pauseStreams) {
          stream.pause();
        }
      }
      this._streams.push(stream);
      return this;
    };
    CombinedStream.prototype.pipe = function(dest, options) {
      Stream.prototype.pipe.call(this, dest, options);
      this.resume();
      return dest;
    };
    CombinedStream.prototype._getNext = function() {
      this._currentStream = null;
      if (this._insideLoop) {
        this._pendingNext = true;
        return;
      }
      this._insideLoop = true;
      try {
        do {
          this._pendingNext = false;
          this._realGetNext();
        } while (this._pendingNext);
      } finally {
        this._insideLoop = false;
      }
    };
    CombinedStream.prototype._realGetNext = function() {
      var stream = this._streams.shift();
      if (typeof stream == "undefined") {
        this.end();
        return;
      }
      if (typeof stream !== "function") {
        this._pipeNext(stream);
        return;
      }
      var getStream = stream;
      getStream(function(stream2) {
        var isStreamLike = CombinedStream.isStreamLike(stream2);
        if (isStreamLike) {
          stream2.on("data", this._checkDataSize.bind(this));
          this._handleErrors(stream2);
        }
        this._pipeNext(stream2);
      }.bind(this));
    };
    CombinedStream.prototype._pipeNext = function(stream) {
      this._currentStream = stream;
      var isStreamLike = CombinedStream.isStreamLike(stream);
      if (isStreamLike) {
        stream.on("end", this._getNext.bind(this));
        stream.pipe(this, { end: false });
        return;
      }
      var value = stream;
      this.write(value);
      this._getNext();
    };
    CombinedStream.prototype._handleErrors = function(stream) {
      var self2 = this;
      stream.on("error", function(err) {
        self2._emitError(err);
      });
    };
    CombinedStream.prototype.write = function(data) {
      this.emit("data", data);
    };
    CombinedStream.prototype.pause = function() {
      if (!this.pauseStreams) {
        return;
      }
      if (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == "function") this._currentStream.pause();
      this.emit("pause");
    };
    CombinedStream.prototype.resume = function() {
      if (!this._released) {
        this._released = true;
        this.writable = true;
        this._getNext();
      }
      if (this.pauseStreams && this._currentStream && typeof this._currentStream.resume == "function") this._currentStream.resume();
      this.emit("resume");
    };
    CombinedStream.prototype.end = function() {
      this._reset();
      this.emit("end");
    };
    CombinedStream.prototype.destroy = function() {
      this._reset();
      this.emit("close");
    };
    CombinedStream.prototype._reset = function() {
      this.writable = false;
      this._streams = [];
      this._currentStream = null;
    };
    CombinedStream.prototype._checkDataSize = function() {
      this._updateDataSize();
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
      var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
      this._emitError(new Error(message));
    };
    CombinedStream.prototype._updateDataSize = function() {
      this.dataSize = 0;
      var self2 = this;
      this._streams.forEach(function(stream) {
        if (!stream.dataSize) {
          return;
        }
        self2.dataSize += stream.dataSize;
      });
      if (this._currentStream && this._currentStream.dataSize) {
        this.dataSize += this._currentStream.dataSize;
      }
    };
    CombinedStream.prototype._emitError = function(err) {
      this._reset();
      this.emit("error", err);
    };
  }
});

// ../../node_modules/mime-db/db.json
var require_db = __commonJS({
  "../../node_modules/mime-db/db.json"(exports2, module2) {
    module2.exports = {
      "application/1d-interleaved-parityfec": {
        source: "iana"
      },
      "application/3gpdash-qoe-report+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/3gpp-ims+xml": {
        source: "iana",
        compressible: true
      },
      "application/3gpphal+json": {
        source: "iana",
        compressible: true
      },
      "application/3gpphalforms+json": {
        source: "iana",
        compressible: true
      },
      "application/a2l": {
        source: "iana"
      },
      "application/ace+cbor": {
        source: "iana"
      },
      "application/activemessage": {
        source: "iana"
      },
      "application/activity+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-directory+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcost+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcostparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointprop+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointpropparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-error+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamcontrol+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamparams+json": {
        source: "iana",
        compressible: true
      },
      "application/aml": {
        source: "iana"
      },
      "application/andrew-inset": {
        source: "iana",
        extensions: ["ez"]
      },
      "application/applefile": {
        source: "iana"
      },
      "application/applixware": {
        source: "apache",
        extensions: ["aw"]
      },
      "application/at+jwt": {
        source: "iana"
      },
      "application/atf": {
        source: "iana"
      },
      "application/atfx": {
        source: "iana"
      },
      "application/atom+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atom"]
      },
      "application/atomcat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomcat"]
      },
      "application/atomdeleted+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomdeleted"]
      },
      "application/atomicmail": {
        source: "iana"
      },
      "application/atomsvc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomsvc"]
      },
      "application/atsc-dwd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dwd"]
      },
      "application/atsc-dynamic-event-message": {
        source: "iana"
      },
      "application/atsc-held+xml": {
        source: "iana",
        compressible: true,
        extensions: ["held"]
      },
      "application/atsc-rdt+json": {
        source: "iana",
        compressible: true
      },
      "application/atsc-rsat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsat"]
      },
      "application/atxml": {
        source: "iana"
      },
      "application/auth-policy+xml": {
        source: "iana",
        compressible: true
      },
      "application/bacnet-xdd+zip": {
        source: "iana",
        compressible: false
      },
      "application/batch-smtp": {
        source: "iana"
      },
      "application/bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/beep+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/calendar+json": {
        source: "iana",
        compressible: true
      },
      "application/calendar+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xcs"]
      },
      "application/call-completion": {
        source: "iana"
      },
      "application/cals-1840": {
        source: "iana"
      },
      "application/captive+json": {
        source: "iana",
        compressible: true
      },
      "application/cbor": {
        source: "iana"
      },
      "application/cbor-seq": {
        source: "iana"
      },
      "application/cccex": {
        source: "iana"
      },
      "application/ccmp+xml": {
        source: "iana",
        compressible: true
      },
      "application/ccxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ccxml"]
      },
      "application/cdfx+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdfx"]
      },
      "application/cdmi-capability": {
        source: "iana",
        extensions: ["cdmia"]
      },
      "application/cdmi-container": {
        source: "iana",
        extensions: ["cdmic"]
      },
      "application/cdmi-domain": {
        source: "iana",
        extensions: ["cdmid"]
      },
      "application/cdmi-object": {
        source: "iana",
        extensions: ["cdmio"]
      },
      "application/cdmi-queue": {
        source: "iana",
        extensions: ["cdmiq"]
      },
      "application/cdni": {
        source: "iana"
      },
      "application/cea": {
        source: "iana"
      },
      "application/cea-2018+xml": {
        source: "iana",
        compressible: true
      },
      "application/cellml+xml": {
        source: "iana",
        compressible: true
      },
      "application/cfw": {
        source: "iana"
      },
      "application/city+json": {
        source: "iana",
        compressible: true
      },
      "application/clr": {
        source: "iana"
      },
      "application/clue+xml": {
        source: "iana",
        compressible: true
      },
      "application/clue_info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cms": {
        source: "iana"
      },
      "application/cnrp+xml": {
        source: "iana",
        compressible: true
      },
      "application/coap-group+json": {
        source: "iana",
        compressible: true
      },
      "application/coap-payload": {
        source: "iana"
      },
      "application/commonground": {
        source: "iana"
      },
      "application/conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cose": {
        source: "iana"
      },
      "application/cose-key": {
        source: "iana"
      },
      "application/cose-key-set": {
        source: "iana"
      },
      "application/cpl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cpl"]
      },
      "application/csrattrs": {
        source: "iana"
      },
      "application/csta+xml": {
        source: "iana",
        compressible: true
      },
      "application/cstadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/csvm+json": {
        source: "iana",
        compressible: true
      },
      "application/cu-seeme": {
        source: "apache",
        extensions: ["cu"]
      },
      "application/cwt": {
        source: "iana"
      },
      "application/cybercash": {
        source: "iana"
      },
      "application/dart": {
        compressible: true
      },
      "application/dash+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpd"]
      },
      "application/dash-patch+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpp"]
      },
      "application/dashdelta": {
        source: "iana"
      },
      "application/davmount+xml": {
        source: "iana",
        compressible: true,
        extensions: ["davmount"]
      },
      "application/dca-rft": {
        source: "iana"
      },
      "application/dcd": {
        source: "iana"
      },
      "application/dec-dx": {
        source: "iana"
      },
      "application/dialog-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/dicom": {
        source: "iana"
      },
      "application/dicom+json": {
        source: "iana",
        compressible: true
      },
      "application/dicom+xml": {
        source: "iana",
        compressible: true
      },
      "application/dii": {
        source: "iana"
      },
      "application/dit": {
        source: "iana"
      },
      "application/dns": {
        source: "iana"
      },
      "application/dns+json": {
        source: "iana",
        compressible: true
      },
      "application/dns-message": {
        source: "iana"
      },
      "application/docbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dbk"]
      },
      "application/dots+cbor": {
        source: "iana"
      },
      "application/dskpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/dssc+der": {
        source: "iana",
        extensions: ["dssc"]
      },
      "application/dssc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdssc"]
      },
      "application/dvcs": {
        source: "iana"
      },
      "application/ecmascript": {
        source: "iana",
        compressible: true,
        extensions: ["es", "ecma"]
      },
      "application/edi-consent": {
        source: "iana"
      },
      "application/edi-x12": {
        source: "iana",
        compressible: false
      },
      "application/edifact": {
        source: "iana",
        compressible: false
      },
      "application/efi": {
        source: "iana"
      },
      "application/elm+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/elm+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.cap+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/emergencycalldata.comment+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.control+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.deviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.ecall.msd": {
        source: "iana"
      },
      "application/emergencycalldata.providerinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.serviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.subscriberinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.veds+xml": {
        source: "iana",
        compressible: true
      },
      "application/emma+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emma"]
      },
      "application/emotionml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emotionml"]
      },
      "application/encaprtp": {
        source: "iana"
      },
      "application/epp+xml": {
        source: "iana",
        compressible: true
      },
      "application/epub+zip": {
        source: "iana",
        compressible: false,
        extensions: ["epub"]
      },
      "application/eshop": {
        source: "iana"
      },
      "application/exi": {
        source: "iana",
        extensions: ["exi"]
      },
      "application/expect-ct-report+json": {
        source: "iana",
        compressible: true
      },
      "application/express": {
        source: "iana",
        extensions: ["exp"]
      },
      "application/fastinfoset": {
        source: "iana"
      },
      "application/fastsoap": {
        source: "iana"
      },
      "application/fdt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fdt"]
      },
      "application/fhir+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fhir+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fido.trusted-apps+json": {
        compressible: true
      },
      "application/fits": {
        source: "iana"
      },
      "application/flexfec": {
        source: "iana"
      },
      "application/font-sfnt": {
        source: "iana"
      },
      "application/font-tdpfr": {
        source: "iana",
        extensions: ["pfr"]
      },
      "application/font-woff": {
        source: "iana",
        compressible: false
      },
      "application/framework-attributes+xml": {
        source: "iana",
        compressible: true
      },
      "application/geo+json": {
        source: "iana",
        compressible: true,
        extensions: ["geojson"]
      },
      "application/geo+json-seq": {
        source: "iana"
      },
      "application/geopackage+sqlite3": {
        source: "iana"
      },
      "application/geoxacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/gltf-buffer": {
        source: "iana"
      },
      "application/gml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["gml"]
      },
      "application/gpx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["gpx"]
      },
      "application/gxf": {
        source: "apache",
        extensions: ["gxf"]
      },
      "application/gzip": {
        source: "iana",
        compressible: false,
        extensions: ["gz"]
      },
      "application/h224": {
        source: "iana"
      },
      "application/held+xml": {
        source: "iana",
        compressible: true
      },
      "application/hjson": {
        extensions: ["hjson"]
      },
      "application/http": {
        source: "iana"
      },
      "application/hyperstudio": {
        source: "iana",
        extensions: ["stk"]
      },
      "application/ibe-key-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pkg-reply+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pp-data": {
        source: "iana"
      },
      "application/iges": {
        source: "iana"
      },
      "application/im-iscomposing+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/index": {
        source: "iana"
      },
      "application/index.cmd": {
        source: "iana"
      },
      "application/index.obj": {
        source: "iana"
      },
      "application/index.response": {
        source: "iana"
      },
      "application/index.vnd": {
        source: "iana"
      },
      "application/inkml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ink", "inkml"]
      },
      "application/iotp": {
        source: "iana"
      },
      "application/ipfix": {
        source: "iana",
        extensions: ["ipfix"]
      },
      "application/ipp": {
        source: "iana"
      },
      "application/isup": {
        source: "iana"
      },
      "application/its+xml": {
        source: "iana",
        compressible: true,
        extensions: ["its"]
      },
      "application/java-archive": {
        source: "apache",
        compressible: false,
        extensions: ["jar", "war", "ear"]
      },
      "application/java-serialized-object": {
        source: "apache",
        compressible: false,
        extensions: ["ser"]
      },
      "application/java-vm": {
        source: "apache",
        compressible: false,
        extensions: ["class"]
      },
      "application/javascript": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["js", "mjs"]
      },
      "application/jf2feed+json": {
        source: "iana",
        compressible: true
      },
      "application/jose": {
        source: "iana"
      },
      "application/jose+json": {
        source: "iana",
        compressible: true
      },
      "application/jrd+json": {
        source: "iana",
        compressible: true
      },
      "application/jscalendar+json": {
        source: "iana",
        compressible: true
      },
      "application/json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["json", "map"]
      },
      "application/json-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/json-seq": {
        source: "iana"
      },
      "application/json5": {
        extensions: ["json5"]
      },
      "application/jsonml+json": {
        source: "apache",
        compressible: true,
        extensions: ["jsonml"]
      },
      "application/jwk+json": {
        source: "iana",
        compressible: true
      },
      "application/jwk-set+json": {
        source: "iana",
        compressible: true
      },
      "application/jwt": {
        source: "iana"
      },
      "application/kpml-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/kpml-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/ld+json": {
        source: "iana",
        compressible: true,
        extensions: ["jsonld"]
      },
      "application/lgr+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lgr"]
      },
      "application/link-format": {
        source: "iana"
      },
      "application/load-control+xml": {
        source: "iana",
        compressible: true
      },
      "application/lost+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lostxml"]
      },
      "application/lostsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/lpf+zip": {
        source: "iana",
        compressible: false
      },
      "application/lxf": {
        source: "iana"
      },
      "application/mac-binhex40": {
        source: "iana",
        extensions: ["hqx"]
      },
      "application/mac-compactpro": {
        source: "apache",
        extensions: ["cpt"]
      },
      "application/macwriteii": {
        source: "iana"
      },
      "application/mads+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mads"]
      },
      "application/manifest+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["webmanifest"]
      },
      "application/marc": {
        source: "iana",
        extensions: ["mrc"]
      },
      "application/marcxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mrcx"]
      },
      "application/mathematica": {
        source: "iana",
        extensions: ["ma", "nb", "mb"]
      },
      "application/mathml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mathml"]
      },
      "application/mathml-content+xml": {
        source: "iana",
        compressible: true
      },
      "application/mathml-presentation+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-associated-procedure-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-deregister+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-envelope+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-protection-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-reception-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-schedule+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-user-service-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbox": {
        source: "iana",
        extensions: ["mbox"]
      },
      "application/media-policy-dataset+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpf"]
      },
      "application/media_control+xml": {
        source: "iana",
        compressible: true
      },
      "application/mediaservercontrol+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mscml"]
      },
      "application/merge-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/metalink+xml": {
        source: "apache",
        compressible: true,
        extensions: ["metalink"]
      },
      "application/metalink4+xml": {
        source: "iana",
        compressible: true,
        extensions: ["meta4"]
      },
      "application/mets+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mets"]
      },
      "application/mf4": {
        source: "iana"
      },
      "application/mikey": {
        source: "iana"
      },
      "application/mipc": {
        source: "iana"
      },
      "application/missing-blocks+cbor-seq": {
        source: "iana"
      },
      "application/mmt-aei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["maei"]
      },
      "application/mmt-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musd"]
      },
      "application/mods+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mods"]
      },
      "application/moss-keys": {
        source: "iana"
      },
      "application/moss-signature": {
        source: "iana"
      },
      "application/mosskey-data": {
        source: "iana"
      },
      "application/mosskey-request": {
        source: "iana"
      },
      "application/mp21": {
        source: "iana",
        extensions: ["m21", "mp21"]
      },
      "application/mp4": {
        source: "iana",
        extensions: ["mp4s", "m4p"]
      },
      "application/mpeg4-generic": {
        source: "iana"
      },
      "application/mpeg4-iod": {
        source: "iana"
      },
      "application/mpeg4-iod-xmt": {
        source: "iana"
      },
      "application/mrb-consumer+xml": {
        source: "iana",
        compressible: true
      },
      "application/mrb-publish+xml": {
        source: "iana",
        compressible: true
      },
      "application/msc-ivr+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msc-mixer+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msword": {
        source: "iana",
        compressible: false,
        extensions: ["doc", "dot"]
      },
      "application/mud+json": {
        source: "iana",
        compressible: true
      },
      "application/multipart-core": {
        source: "iana"
      },
      "application/mxf": {
        source: "iana",
        extensions: ["mxf"]
      },
      "application/n-quads": {
        source: "iana",
        extensions: ["nq"]
      },
      "application/n-triples": {
        source: "iana",
        extensions: ["nt"]
      },
      "application/nasdata": {
        source: "iana"
      },
      "application/news-checkgroups": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-groupinfo": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-transmission": {
        source: "iana"
      },
      "application/nlsml+xml": {
        source: "iana",
        compressible: true
      },
      "application/node": {
        source: "iana",
        extensions: ["cjs"]
      },
      "application/nss": {
        source: "iana"
      },
      "application/oauth-authz-req+jwt": {
        source: "iana"
      },
      "application/oblivious-dns-message": {
        source: "iana"
      },
      "application/ocsp-request": {
        source: "iana"
      },
      "application/ocsp-response": {
        source: "iana"
      },
      "application/octet-stream": {
        source: "iana",
        compressible: false,
        extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
      },
      "application/oda": {
        source: "iana",
        extensions: ["oda"]
      },
      "application/odm+xml": {
        source: "iana",
        compressible: true
      },
      "application/odx": {
        source: "iana"
      },
      "application/oebps-package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["opf"]
      },
      "application/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogx"]
      },
      "application/omdoc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["omdoc"]
      },
      "application/onenote": {
        source: "apache",
        extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
      },
      "application/opc-nodeset+xml": {
        source: "iana",
        compressible: true
      },
      "application/oscore": {
        source: "iana"
      },
      "application/oxps": {
        source: "iana",
        extensions: ["oxps"]
      },
      "application/p21": {
        source: "iana"
      },
      "application/p21+zip": {
        source: "iana",
        compressible: false
      },
      "application/p2p-overlay+xml": {
        source: "iana",
        compressible: true,
        extensions: ["relo"]
      },
      "application/parityfec": {
        source: "iana"
      },
      "application/passport": {
        source: "iana"
      },
      "application/patch-ops-error+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xer"]
      },
      "application/pdf": {
        source: "iana",
        compressible: false,
        extensions: ["pdf"]
      },
      "application/pdx": {
        source: "iana"
      },
      "application/pem-certificate-chain": {
        source: "iana"
      },
      "application/pgp-encrypted": {
        source: "iana",
        compressible: false,
        extensions: ["pgp"]
      },
      "application/pgp-keys": {
        source: "iana",
        extensions: ["asc"]
      },
      "application/pgp-signature": {
        source: "iana",
        extensions: ["asc", "sig"]
      },
      "application/pics-rules": {
        source: "apache",
        extensions: ["prf"]
      },
      "application/pidf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pidf-diff+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pkcs10": {
        source: "iana",
        extensions: ["p10"]
      },
      "application/pkcs12": {
        source: "iana"
      },
      "application/pkcs7-mime": {
        source: "iana",
        extensions: ["p7m", "p7c"]
      },
      "application/pkcs7-signature": {
        source: "iana",
        extensions: ["p7s"]
      },
      "application/pkcs8": {
        source: "iana",
        extensions: ["p8"]
      },
      "application/pkcs8-encrypted": {
        source: "iana"
      },
      "application/pkix-attr-cert": {
        source: "iana",
        extensions: ["ac"]
      },
      "application/pkix-cert": {
        source: "iana",
        extensions: ["cer"]
      },
      "application/pkix-crl": {
        source: "iana",
        extensions: ["crl"]
      },
      "application/pkix-pkipath": {
        source: "iana",
        extensions: ["pkipath"]
      },
      "application/pkixcmp": {
        source: "iana",
        extensions: ["pki"]
      },
      "application/pls+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pls"]
      },
      "application/poc-settings+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/postscript": {
        source: "iana",
        compressible: true,
        extensions: ["ai", "eps", "ps"]
      },
      "application/ppsp-tracker+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+xml": {
        source: "iana",
        compressible: true
      },
      "application/provenance+xml": {
        source: "iana",
        compressible: true,
        extensions: ["provx"]
      },
      "application/prs.alvestrand.titrax-sheet": {
        source: "iana"
      },
      "application/prs.cww": {
        source: "iana",
        extensions: ["cww"]
      },
      "application/prs.cyn": {
        source: "iana",
        charset: "7-BIT"
      },
      "application/prs.hpub+zip": {
        source: "iana",
        compressible: false
      },
      "application/prs.nprend": {
        source: "iana"
      },
      "application/prs.plucker": {
        source: "iana"
      },
      "application/prs.rdf-xml-crypt": {
        source: "iana"
      },
      "application/prs.xsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/pskc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pskcxml"]
      },
      "application/pvd+json": {
        source: "iana",
        compressible: true
      },
      "application/qsig": {
        source: "iana"
      },
      "application/raml+yaml": {
        compressible: true,
        extensions: ["raml"]
      },
      "application/raptorfec": {
        source: "iana"
      },
      "application/rdap+json": {
        source: "iana",
        compressible: true
      },
      "application/rdf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rdf", "owl"]
      },
      "application/reginfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rif"]
      },
      "application/relax-ng-compact-syntax": {
        source: "iana",
        extensions: ["rnc"]
      },
      "application/remote-printing": {
        source: "iana"
      },
      "application/reputon+json": {
        source: "iana",
        compressible: true
      },
      "application/resource-lists+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rl"]
      },
      "application/resource-lists-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rld"]
      },
      "application/rfc+xml": {
        source: "iana",
        compressible: true
      },
      "application/riscos": {
        source: "iana"
      },
      "application/rlmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/rls-services+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rs"]
      },
      "application/route-apd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rapd"]
      },
      "application/route-s-tsid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sls"]
      },
      "application/route-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rusd"]
      },
      "application/rpki-ghostbusters": {
        source: "iana",
        extensions: ["gbr"]
      },
      "application/rpki-manifest": {
        source: "iana",
        extensions: ["mft"]
      },
      "application/rpki-publication": {
        source: "iana"
      },
      "application/rpki-roa": {
        source: "iana",
        extensions: ["roa"]
      },
      "application/rpki-updown": {
        source: "iana"
      },
      "application/rsd+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rsd"]
      },
      "application/rss+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rss"]
      },
      "application/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "application/rtploopback": {
        source: "iana"
      },
      "application/rtx": {
        source: "iana"
      },
      "application/samlassertion+xml": {
        source: "iana",
        compressible: true
      },
      "application/samlmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/sarif+json": {
        source: "iana",
        compressible: true
      },
      "application/sarif-external-properties+json": {
        source: "iana",
        compressible: true
      },
      "application/sbe": {
        source: "iana"
      },
      "application/sbml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sbml"]
      },
      "application/scaip+xml": {
        source: "iana",
        compressible: true
      },
      "application/scim+json": {
        source: "iana",
        compressible: true
      },
      "application/scvp-cv-request": {
        source: "iana",
        extensions: ["scq"]
      },
      "application/scvp-cv-response": {
        source: "iana",
        extensions: ["scs"]
      },
      "application/scvp-vp-request": {
        source: "iana",
        extensions: ["spq"]
      },
      "application/scvp-vp-response": {
        source: "iana",
        extensions: ["spp"]
      },
      "application/sdp": {
        source: "iana",
        extensions: ["sdp"]
      },
      "application/secevent+jwt": {
        source: "iana"
      },
      "application/senml+cbor": {
        source: "iana"
      },
      "application/senml+json": {
        source: "iana",
        compressible: true
      },
      "application/senml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["senmlx"]
      },
      "application/senml-etch+cbor": {
        source: "iana"
      },
      "application/senml-etch+json": {
        source: "iana",
        compressible: true
      },
      "application/senml-exi": {
        source: "iana"
      },
      "application/sensml+cbor": {
        source: "iana"
      },
      "application/sensml+json": {
        source: "iana",
        compressible: true
      },
      "application/sensml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sensmlx"]
      },
      "application/sensml-exi": {
        source: "iana"
      },
      "application/sep+xml": {
        source: "iana",
        compressible: true
      },
      "application/sep-exi": {
        source: "iana"
      },
      "application/session-info": {
        source: "iana"
      },
      "application/set-payment": {
        source: "iana"
      },
      "application/set-payment-initiation": {
        source: "iana",
        extensions: ["setpay"]
      },
      "application/set-registration": {
        source: "iana"
      },
      "application/set-registration-initiation": {
        source: "iana",
        extensions: ["setreg"]
      },
      "application/sgml": {
        source: "iana"
      },
      "application/sgml-open-catalog": {
        source: "iana"
      },
      "application/shf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["shf"]
      },
      "application/sieve": {
        source: "iana",
        extensions: ["siv", "sieve"]
      },
      "application/simple-filter+xml": {
        source: "iana",
        compressible: true
      },
      "application/simple-message-summary": {
        source: "iana"
      },
      "application/simplesymbolcontainer": {
        source: "iana"
      },
      "application/sipc": {
        source: "iana"
      },
      "application/slate": {
        source: "iana"
      },
      "application/smil": {
        source: "iana"
      },
      "application/smil+xml": {
        source: "iana",
        compressible: true,
        extensions: ["smi", "smil"]
      },
      "application/smpte336m": {
        source: "iana"
      },
      "application/soap+fastinfoset": {
        source: "iana"
      },
      "application/soap+xml": {
        source: "iana",
        compressible: true
      },
      "application/sparql-query": {
        source: "iana",
        extensions: ["rq"]
      },
      "application/sparql-results+xml": {
        source: "iana",
        compressible: true,
        extensions: ["srx"]
      },
      "application/spdx+json": {
        source: "iana",
        compressible: true
      },
      "application/spirits-event+xml": {
        source: "iana",
        compressible: true
      },
      "application/sql": {
        source: "iana"
      },
      "application/srgs": {
        source: "iana",
        extensions: ["gram"]
      },
      "application/srgs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["grxml"]
      },
      "application/sru+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sru"]
      },
      "application/ssdl+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ssdl"]
      },
      "application/ssml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ssml"]
      },
      "application/stix+json": {
        source: "iana",
        compressible: true
      },
      "application/swid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["swidtag"]
      },
      "application/tamp-apex-update": {
        source: "iana"
      },
      "application/tamp-apex-update-confirm": {
        source: "iana"
      },
      "application/tamp-community-update": {
        source: "iana"
      },
      "application/tamp-community-update-confirm": {
        source: "iana"
      },
      "application/tamp-error": {
        source: "iana"
      },
      "application/tamp-sequence-adjust": {
        source: "iana"
      },
      "application/tamp-sequence-adjust-confirm": {
        source: "iana"
      },
      "application/tamp-status-query": {
        source: "iana"
      },
      "application/tamp-status-response": {
        source: "iana"
      },
      "application/tamp-update": {
        source: "iana"
      },
      "application/tamp-update-confirm": {
        source: "iana"
      },
      "application/tar": {
        compressible: true
      },
      "application/taxii+json": {
        source: "iana",
        compressible: true
      },
      "application/td+json": {
        source: "iana",
        compressible: true
      },
      "application/tei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tei", "teicorpus"]
      },
      "application/tetra_isi": {
        source: "iana"
      },
      "application/thraud+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tfi"]
      },
      "application/timestamp-query": {
        source: "iana"
      },
      "application/timestamp-reply": {
        source: "iana"
      },
      "application/timestamped-data": {
        source: "iana",
        extensions: ["tsd"]
      },
      "application/tlsrpt+gzip": {
        source: "iana"
      },
      "application/tlsrpt+json": {
        source: "iana",
        compressible: true
      },
      "application/tnauthlist": {
        source: "iana"
      },
      "application/token-introspection+jwt": {
        source: "iana"
      },
      "application/toml": {
        compressible: true,
        extensions: ["toml"]
      },
      "application/trickle-ice-sdpfrag": {
        source: "iana"
      },
      "application/trig": {
        source: "iana",
        extensions: ["trig"]
      },
      "application/ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ttml"]
      },
      "application/tve-trigger": {
        source: "iana"
      },
      "application/tzif": {
        source: "iana"
      },
      "application/tzif-leap": {
        source: "iana"
      },
      "application/ubjson": {
        compressible: false,
        extensions: ["ubj"]
      },
      "application/ulpfec": {
        source: "iana"
      },
      "application/urc-grpsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/urc-ressheet+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsheet"]
      },
      "application/urc-targetdesc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["td"]
      },
      "application/urc-uisocketdesc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vcard+json": {
        source: "iana",
        compressible: true
      },
      "application/vcard+xml": {
        source: "iana",
        compressible: true
      },
      "application/vemmi": {
        source: "iana"
      },
      "application/vividence.scriptfile": {
        source: "apache"
      },
      "application/vnd.1000minds.decision-model+xml": {
        source: "iana",
        compressible: true,
        extensions: ["1km"]
      },
      "application/vnd.3gpp-prose+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-prose-pc3ch+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-v2x-local-service-information": {
        source: "iana"
      },
      "application/vnd.3gpp.5gnas": {
        source: "iana"
      },
      "application/vnd.3gpp.access-transfer-events+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.bsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gmop+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gtpc": {
        source: "iana"
      },
      "application/vnd.3gpp.interworking-data": {
        source: "iana"
      },
      "application/vnd.3gpp.lpp": {
        source: "iana"
      },
      "application/vnd.3gpp.mc-signalling-ear": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-payload": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-signalling": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-floor-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-signed+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-init-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-transmission-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mid-call+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ngap": {
        source: "iana"
      },
      "application/vnd.3gpp.pfcp": {
        source: "iana"
      },
      "application/vnd.3gpp.pic-bw-large": {
        source: "iana",
        extensions: ["plb"]
      },
      "application/vnd.3gpp.pic-bw-small": {
        source: "iana",
        extensions: ["psb"]
      },
      "application/vnd.3gpp.pic-bw-var": {
        source: "iana",
        extensions: ["pvb"]
      },
      "application/vnd.3gpp.s1ap": {
        source: "iana"
      },
      "application/vnd.3gpp.sms": {
        source: "iana"
      },
      "application/vnd.3gpp.sms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-ext+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.state-and-event-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ussd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.bcmcsinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.sms": {
        source: "iana"
      },
      "application/vnd.3gpp2.tcap": {
        source: "iana",
        extensions: ["tcap"]
      },
      "application/vnd.3lightssoftware.imagescal": {
        source: "iana"
      },
      "application/vnd.3m.post-it-notes": {
        source: "iana",
        extensions: ["pwn"]
      },
      "application/vnd.accpac.simply.aso": {
        source: "iana",
        extensions: ["aso"]
      },
      "application/vnd.accpac.simply.imp": {
        source: "iana",
        extensions: ["imp"]
      },
      "application/vnd.acucobol": {
        source: "iana",
        extensions: ["acu"]
      },
      "application/vnd.acucorp": {
        source: "iana",
        extensions: ["atc", "acutc"]
      },
      "application/vnd.adobe.air-application-installer-package+zip": {
        source: "apache",
        compressible: false,
        extensions: ["air"]
      },
      "application/vnd.adobe.flash.movie": {
        source: "iana"
      },
      "application/vnd.adobe.formscentral.fcdt": {
        source: "iana",
        extensions: ["fcdt"]
      },
      "application/vnd.adobe.fxp": {
        source: "iana",
        extensions: ["fxp", "fxpl"]
      },
      "application/vnd.adobe.partial-upload": {
        source: "iana"
      },
      "application/vnd.adobe.xdp+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdp"]
      },
      "application/vnd.adobe.xfdf": {
        source: "iana",
        extensions: ["xfdf"]
      },
      "application/vnd.aether.imp": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata-pagedef": {
        source: "iana"
      },
      "application/vnd.afpc.cmoca-cmresource": {
        source: "iana"
      },
      "application/vnd.afpc.foca-charset": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codedfont": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codepage": {
        source: "iana"
      },
      "application/vnd.afpc.modca": {
        source: "iana"
      },
      "application/vnd.afpc.modca-cmtable": {
        source: "iana"
      },
      "application/vnd.afpc.modca-formdef": {
        source: "iana"
      },
      "application/vnd.afpc.modca-mediummap": {
        source: "iana"
      },
      "application/vnd.afpc.modca-objectcontainer": {
        source: "iana"
      },
      "application/vnd.afpc.modca-overlay": {
        source: "iana"
      },
      "application/vnd.afpc.modca-pagesegment": {
        source: "iana"
      },
      "application/vnd.age": {
        source: "iana",
        extensions: ["age"]
      },
      "application/vnd.ah-barcode": {
        source: "iana"
      },
      "application/vnd.ahead.space": {
        source: "iana",
        extensions: ["ahead"]
      },
      "application/vnd.airzip.filesecure.azf": {
        source: "iana",
        extensions: ["azf"]
      },
      "application/vnd.airzip.filesecure.azs": {
        source: "iana",
        extensions: ["azs"]
      },
      "application/vnd.amadeus+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.amazon.ebook": {
        source: "apache",
        extensions: ["azw"]
      },
      "application/vnd.amazon.mobi8-ebook": {
        source: "iana"
      },
      "application/vnd.americandynamics.acc": {
        source: "iana",
        extensions: ["acc"]
      },
      "application/vnd.amiga.ami": {
        source: "iana",
        extensions: ["ami"]
      },
      "application/vnd.amundsen.maze+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.android.ota": {
        source: "iana"
      },
      "application/vnd.android.package-archive": {
        source: "apache",
        compressible: false,
        extensions: ["apk"]
      },
      "application/vnd.anki": {
        source: "iana"
      },
      "application/vnd.anser-web-certificate-issue-initiation": {
        source: "iana",
        extensions: ["cii"]
      },
      "application/vnd.anser-web-funds-transfer-initiation": {
        source: "apache",
        extensions: ["fti"]
      },
      "application/vnd.antix.game-component": {
        source: "iana",
        extensions: ["atx"]
      },
      "application/vnd.apache.arrow.file": {
        source: "iana"
      },
      "application/vnd.apache.arrow.stream": {
        source: "iana"
      },
      "application/vnd.apache.thrift.binary": {
        source: "iana"
      },
      "application/vnd.apache.thrift.compact": {
        source: "iana"
      },
      "application/vnd.apache.thrift.json": {
        source: "iana"
      },
      "application/vnd.api+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.aplextor.warrp+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apothekende.reservation+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apple.installer+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpkg"]
      },
      "application/vnd.apple.keynote": {
        source: "iana",
        extensions: ["key"]
      },
      "application/vnd.apple.mpegurl": {
        source: "iana",
        extensions: ["m3u8"]
      },
      "application/vnd.apple.numbers": {
        source: "iana",
        extensions: ["numbers"]
      },
      "application/vnd.apple.pages": {
        source: "iana",
        extensions: ["pages"]
      },
      "application/vnd.apple.pkpass": {
        compressible: false,
        extensions: ["pkpass"]
      },
      "application/vnd.arastra.swi": {
        source: "iana"
      },
      "application/vnd.aristanetworks.swi": {
        source: "iana",
        extensions: ["swi"]
      },
      "application/vnd.artisan+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.artsquare": {
        source: "iana"
      },
      "application/vnd.astraea-software.iota": {
        source: "iana",
        extensions: ["iota"]
      },
      "application/vnd.audiograph": {
        source: "iana",
        extensions: ["aep"]
      },
      "application/vnd.autopackage": {
        source: "iana"
      },
      "application/vnd.avalon+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.avistar+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.balsamiq.bmml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["bmml"]
      },
      "application/vnd.balsamiq.bmpr": {
        source: "iana"
      },
      "application/vnd.banana-accounting": {
        source: "iana"
      },
      "application/vnd.bbf.usp.error": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bekitzur-stech+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bint.med-content": {
        source: "iana"
      },
      "application/vnd.biopax.rdf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.blink-idb-value-wrapper": {
        source: "iana"
      },
      "application/vnd.blueice.multipass": {
        source: "iana",
        extensions: ["mpm"]
      },
      "application/vnd.bluetooth.ep.oob": {
        source: "iana"
      },
      "application/vnd.bluetooth.le.oob": {
        source: "iana"
      },
      "application/vnd.bmi": {
        source: "iana",
        extensions: ["bmi"]
      },
      "application/vnd.bpf": {
        source: "iana"
      },
      "application/vnd.bpf3": {
        source: "iana"
      },
      "application/vnd.businessobjects": {
        source: "iana",
        extensions: ["rep"]
      },
      "application/vnd.byu.uapi+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cab-jscript": {
        source: "iana"
      },
      "application/vnd.canon-cpdl": {
        source: "iana"
      },
      "application/vnd.canon-lips": {
        source: "iana"
      },
      "application/vnd.capasystems-pg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cendio.thinlinc.clientconf": {
        source: "iana"
      },
      "application/vnd.century-systems.tcp_stream": {
        source: "iana"
      },
      "application/vnd.chemdraw+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdxml"]
      },
      "application/vnd.chess-pgn": {
        source: "iana"
      },
      "application/vnd.chipnuts.karaoke-mmd": {
        source: "iana",
        extensions: ["mmd"]
      },
      "application/vnd.ciedi": {
        source: "iana"
      },
      "application/vnd.cinderella": {
        source: "iana",
        extensions: ["cdy"]
      },
      "application/vnd.cirpack.isdn-ext": {
        source: "iana"
      },
      "application/vnd.citationstyles.style+xml": {
        source: "iana",
        compressible: true,
        extensions: ["csl"]
      },
      "application/vnd.claymore": {
        source: "iana",
        extensions: ["cla"]
      },
      "application/vnd.cloanto.rp9": {
        source: "iana",
        extensions: ["rp9"]
      },
      "application/vnd.clonk.c4group": {
        source: "iana",
        extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
      },
      "application/vnd.cluetrust.cartomobile-config": {
        source: "iana",
        extensions: ["c11amc"]
      },
      "application/vnd.cluetrust.cartomobile-config-pkg": {
        source: "iana",
        extensions: ["c11amz"]
      },
      "application/vnd.coffeescript": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet-template": {
        source: "iana"
      },
      "application/vnd.collection+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.doc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.next+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.comicbook+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.comicbook-rar": {
        source: "iana"
      },
      "application/vnd.commerce-battelle": {
        source: "iana"
      },
      "application/vnd.commonspace": {
        source: "iana",
        extensions: ["csp"]
      },
      "application/vnd.contact.cmsg": {
        source: "iana",
        extensions: ["cdbcmsg"]
      },
      "application/vnd.coreos.ignition+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cosmocaller": {
        source: "iana",
        extensions: ["cmc"]
      },
      "application/vnd.crick.clicker": {
        source: "iana",
        extensions: ["clkx"]
      },
      "application/vnd.crick.clicker.keyboard": {
        source: "iana",
        extensions: ["clkk"]
      },
      "application/vnd.crick.clicker.palette": {
        source: "iana",
        extensions: ["clkp"]
      },
      "application/vnd.crick.clicker.template": {
        source: "iana",
        extensions: ["clkt"]
      },
      "application/vnd.crick.clicker.wordbank": {
        source: "iana",
        extensions: ["clkw"]
      },
      "application/vnd.criticaltools.wbs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wbs"]
      },
      "application/vnd.cryptii.pipe+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.crypto-shade-file": {
        source: "iana"
      },
      "application/vnd.cryptomator.encrypted": {
        source: "iana"
      },
      "application/vnd.cryptomator.vault": {
        source: "iana"
      },
      "application/vnd.ctc-posml": {
        source: "iana",
        extensions: ["pml"]
      },
      "application/vnd.ctct.ws+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cups-pdf": {
        source: "iana"
      },
      "application/vnd.cups-postscript": {
        source: "iana"
      },
      "application/vnd.cups-ppd": {
        source: "iana",
        extensions: ["ppd"]
      },
      "application/vnd.cups-raster": {
        source: "iana"
      },
      "application/vnd.cups-raw": {
        source: "iana"
      },
      "application/vnd.curl": {
        source: "iana"
      },
      "application/vnd.curl.car": {
        source: "apache",
        extensions: ["car"]
      },
      "application/vnd.curl.pcurl": {
        source: "apache",
        extensions: ["pcurl"]
      },
      "application/vnd.cyan.dean.root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cybank": {
        source: "iana"
      },
      "application/vnd.cyclonedx+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cyclonedx+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.d2l.coursepackage1p0+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.d3m-dataset": {
        source: "iana"
      },
      "application/vnd.d3m-problem": {
        source: "iana"
      },
      "application/vnd.dart": {
        source: "iana",
        compressible: true,
        extensions: ["dart"]
      },
      "application/vnd.data-vision.rdz": {
        source: "iana",
        extensions: ["rdz"]
      },
      "application/vnd.datapackage+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dataresource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dbf": {
        source: "iana",
        extensions: ["dbf"]
      },
      "application/vnd.debian.binary-package": {
        source: "iana"
      },
      "application/vnd.dece.data": {
        source: "iana",
        extensions: ["uvf", "uvvf", "uvd", "uvvd"]
      },
      "application/vnd.dece.ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uvt", "uvvt"]
      },
      "application/vnd.dece.unspecified": {
        source: "iana",
        extensions: ["uvx", "uvvx"]
      },
      "application/vnd.dece.zip": {
        source: "iana",
        extensions: ["uvz", "uvvz"]
      },
      "application/vnd.denovo.fcselayout-link": {
        source: "iana",
        extensions: ["fe_launch"]
      },
      "application/vnd.desmume.movie": {
        source: "iana"
      },
      "application/vnd.dir-bi.plate-dl-nosuffix": {
        source: "iana"
      },
      "application/vnd.dm.delegation+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dna": {
        source: "iana",
        extensions: ["dna"]
      },
      "application/vnd.document+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dolby.mlp": {
        source: "apache",
        extensions: ["mlp"]
      },
      "application/vnd.dolby.mobile.1": {
        source: "iana"
      },
      "application/vnd.dolby.mobile.2": {
        source: "iana"
      },
      "application/vnd.doremir.scorecloud-binary-document": {
        source: "iana"
      },
      "application/vnd.dpgraph": {
        source: "iana",
        extensions: ["dpg"]
      },
      "application/vnd.dreamfactory": {
        source: "iana",
        extensions: ["dfac"]
      },
      "application/vnd.drive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ds-keypoint": {
        source: "apache",
        extensions: ["kpxx"]
      },
      "application/vnd.dtg.local": {
        source: "iana"
      },
      "application/vnd.dtg.local.flash": {
        source: "iana"
      },
      "application/vnd.dtg.local.html": {
        source: "iana"
      },
      "application/vnd.dvb.ait": {
        source: "iana",
        extensions: ["ait"]
      },
      "application/vnd.dvb.dvbisl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.dvbj": {
        source: "iana"
      },
      "application/vnd.dvb.esgcontainer": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcdftnotifaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess2": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgpdd": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcroaming": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-base": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-enhancement": {
        source: "iana"
      },
      "application/vnd.dvb.notif-aggregate-root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-container+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-generic+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-msglist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-init+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.pfr": {
        source: "iana"
      },
      "application/vnd.dvb.service": {
        source: "iana",
        extensions: ["svc"]
      },
      "application/vnd.dxr": {
        source: "iana"
      },
      "application/vnd.dynageo": {
        source: "iana",
        extensions: ["geo"]
      },
      "application/vnd.dzr": {
        source: "iana"
      },
      "application/vnd.easykaraoke.cdgdownload": {
        source: "iana"
      },
      "application/vnd.ecdis-update": {
        source: "iana"
      },
      "application/vnd.ecip.rlp": {
        source: "iana"
      },
      "application/vnd.eclipse.ditto+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ecowin.chart": {
        source: "iana",
        extensions: ["mag"]
      },
      "application/vnd.ecowin.filerequest": {
        source: "iana"
      },
      "application/vnd.ecowin.fileupdate": {
        source: "iana"
      },
      "application/vnd.ecowin.series": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesrequest": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesupdate": {
        source: "iana"
      },
      "application/vnd.efi.img": {
        source: "iana"
      },
      "application/vnd.efi.iso": {
        source: "iana"
      },
      "application/vnd.emclient.accessrequest+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.enliven": {
        source: "iana",
        extensions: ["nml"]
      },
      "application/vnd.enphase.envoy": {
        source: "iana"
      },
      "application/vnd.eprints.data+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.epson.esf": {
        source: "iana",
        extensions: ["esf"]
      },
      "application/vnd.epson.msf": {
        source: "iana",
        extensions: ["msf"]
      },
      "application/vnd.epson.quickanime": {
        source: "iana",
        extensions: ["qam"]
      },
      "application/vnd.epson.salt": {
        source: "iana",
        extensions: ["slt"]
      },
      "application/vnd.epson.ssf": {
        source: "iana",
        extensions: ["ssf"]
      },
      "application/vnd.ericsson.quickcall": {
        source: "iana"
      },
      "application/vnd.espass-espass+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.eszigno3+xml": {
        source: "iana",
        compressible: true,
        extensions: ["es3", "et3"]
      },
      "application/vnd.etsi.aoc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.asic-e+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.asic-s+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.cug+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvcommand+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-bc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-cod+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-npvr+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvservice+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mcid+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mheg5": {
        source: "iana"
      },
      "application/vnd.etsi.overload-control-policy-dataset+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.pstn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.sci+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.simservs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.timestamp-token": {
        source: "iana"
      },
      "application/vnd.etsi.tsl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.tsl.der": {
        source: "iana"
      },
      "application/vnd.eu.kasparian.car+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.eudora.data": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.profile": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.settings": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.theme": {
        source: "iana"
      },
      "application/vnd.exstream-empower+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.exstream-package": {
        source: "iana"
      },
      "application/vnd.ezpix-album": {
        source: "iana",
        extensions: ["ez2"]
      },
      "application/vnd.ezpix-package": {
        source: "iana",
        extensions: ["ez3"]
      },
      "application/vnd.f-secure.mobile": {
        source: "iana"
      },
      "application/vnd.familysearch.gedcom+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.fastcopy-disk-image": {
        source: "iana"
      },
      "application/vnd.fdf": {
        source: "iana",
        extensions: ["fdf"]
      },
      "application/vnd.fdsn.mseed": {
        source: "iana",
        extensions: ["mseed"]
      },
      "application/vnd.fdsn.seed": {
        source: "iana",
        extensions: ["seed", "dataless"]
      },
      "application/vnd.ffsns": {
        source: "iana"
      },
      "application/vnd.ficlab.flb+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.filmit.zfc": {
        source: "iana"
      },
      "application/vnd.fints": {
        source: "iana"
      },
      "application/vnd.firemonkeys.cloudcell": {
        source: "iana"
      },
      "application/vnd.flographit": {
        source: "iana",
        extensions: ["gph"]
      },
      "application/vnd.fluxtime.clip": {
        source: "iana",
        extensions: ["ftc"]
      },
      "application/vnd.font-fontforge-sfd": {
        source: "iana"
      },
      "application/vnd.framemaker": {
        source: "iana",
        extensions: ["fm", "frame", "maker", "book"]
      },
      "application/vnd.frogans.fnc": {
        source: "iana",
        extensions: ["fnc"]
      },
      "application/vnd.frogans.ltf": {
        source: "iana",
        extensions: ["ltf"]
      },
      "application/vnd.fsc.weblaunch": {
        source: "iana",
        extensions: ["fsc"]
      },
      "application/vnd.fujifilm.fb.docuworks": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.binder": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.jfi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fujitsu.oasys": {
        source: "iana",
        extensions: ["oas"]
      },
      "application/vnd.fujitsu.oasys2": {
        source: "iana",
        extensions: ["oa2"]
      },
      "application/vnd.fujitsu.oasys3": {
        source: "iana",
        extensions: ["oa3"]
      },
      "application/vnd.fujitsu.oasysgp": {
        source: "iana",
        extensions: ["fg5"]
      },
      "application/vnd.fujitsu.oasysprs": {
        source: "iana",
        extensions: ["bh2"]
      },
      "application/vnd.fujixerox.art-ex": {
        source: "iana"
      },
      "application/vnd.fujixerox.art4": {
        source: "iana"
      },
      "application/vnd.fujixerox.ddd": {
        source: "iana",
        extensions: ["ddd"]
      },
      "application/vnd.fujixerox.docuworks": {
        source: "iana",
        extensions: ["xdw"]
      },
      "application/vnd.fujixerox.docuworks.binder": {
        source: "iana",
        extensions: ["xbd"]
      },
      "application/vnd.fujixerox.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujixerox.hbpl": {
        source: "iana"
      },
      "application/vnd.fut-misnet": {
        source: "iana"
      },
      "application/vnd.futoin+cbor": {
        source: "iana"
      },
      "application/vnd.futoin+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fuzzysheet": {
        source: "iana",
        extensions: ["fzs"]
      },
      "application/vnd.genomatix.tuxedo": {
        source: "iana",
        extensions: ["txd"]
      },
      "application/vnd.gentics.grd+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geo+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geocube+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geogebra.file": {
        source: "iana",
        extensions: ["ggb"]
      },
      "application/vnd.geogebra.slides": {
        source: "iana"
      },
      "application/vnd.geogebra.tool": {
        source: "iana",
        extensions: ["ggt"]
      },
      "application/vnd.geometry-explorer": {
        source: "iana",
        extensions: ["gex", "gre"]
      },
      "application/vnd.geonext": {
        source: "iana",
        extensions: ["gxt"]
      },
      "application/vnd.geoplan": {
        source: "iana",
        extensions: ["g2w"]
      },
      "application/vnd.geospace": {
        source: "iana",
        extensions: ["g3w"]
      },
      "application/vnd.gerber": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt-response": {
        source: "iana"
      },
      "application/vnd.gmx": {
        source: "iana",
        extensions: ["gmx"]
      },
      "application/vnd.google-apps.document": {
        compressible: false,
        extensions: ["gdoc"]
      },
      "application/vnd.google-apps.presentation": {
        compressible: false,
        extensions: ["gslides"]
      },
      "application/vnd.google-apps.spreadsheet": {
        compressible: false,
        extensions: ["gsheet"]
      },
      "application/vnd.google-earth.kml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["kml"]
      },
      "application/vnd.google-earth.kmz": {
        source: "iana",
        compressible: false,
        extensions: ["kmz"]
      },
      "application/vnd.gov.sk.e-form+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.gov.sk.e-form+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.gov.sk.xmldatacontainer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.grafeq": {
        source: "iana",
        extensions: ["gqf", "gqs"]
      },
      "application/vnd.gridmp": {
        source: "iana"
      },
      "application/vnd.groove-account": {
        source: "iana",
        extensions: ["gac"]
      },
      "application/vnd.groove-help": {
        source: "iana",
        extensions: ["ghf"]
      },
      "application/vnd.groove-identity-message": {
        source: "iana",
        extensions: ["gim"]
      },
      "application/vnd.groove-injector": {
        source: "iana",
        extensions: ["grv"]
      },
      "application/vnd.groove-tool-message": {
        source: "iana",
        extensions: ["gtm"]
      },
      "application/vnd.groove-tool-template": {
        source: "iana",
        extensions: ["tpl"]
      },
      "application/vnd.groove-vcard": {
        source: "iana",
        extensions: ["vcg"]
      },
      "application/vnd.hal+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hal+xml": {
        source: "iana",
        compressible: true,
        extensions: ["hal"]
      },
      "application/vnd.handheld-entertainment+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zmm"]
      },
      "application/vnd.hbci": {
        source: "iana",
        extensions: ["hbci"]
      },
      "application/vnd.hc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hcl-bireports": {
        source: "iana"
      },
      "application/vnd.hdt": {
        source: "iana"
      },
      "application/vnd.heroku+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hhe.lesson-player": {
        source: "iana",
        extensions: ["les"]
      },
      "application/vnd.hl7cda+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hl7v2+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hp-hpgl": {
        source: "iana",
        extensions: ["hpgl"]
      },
      "application/vnd.hp-hpid": {
        source: "iana",
        extensions: ["hpid"]
      },
      "application/vnd.hp-hps": {
        source: "iana",
        extensions: ["hps"]
      },
      "application/vnd.hp-jlyt": {
        source: "iana",
        extensions: ["jlt"]
      },
      "application/vnd.hp-pcl": {
        source: "iana",
        extensions: ["pcl"]
      },
      "application/vnd.hp-pclxl": {
        source: "iana",
        extensions: ["pclxl"]
      },
      "application/vnd.httphone": {
        source: "iana"
      },
      "application/vnd.hydrostatix.sof-data": {
        source: "iana",
        extensions: ["sfd-hdstx"]
      },
      "application/vnd.hyper+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyper-item+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyperdrive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hzn-3d-crossword": {
        source: "iana"
      },
      "application/vnd.ibm.afplinedata": {
        source: "iana"
      },
      "application/vnd.ibm.electronic-media": {
        source: "iana"
      },
      "application/vnd.ibm.minipay": {
        source: "iana",
        extensions: ["mpy"]
      },
      "application/vnd.ibm.modcap": {
        source: "iana",
        extensions: ["afp", "listafp", "list3820"]
      },
      "application/vnd.ibm.rights-management": {
        source: "iana",
        extensions: ["irm"]
      },
      "application/vnd.ibm.secure-container": {
        source: "iana",
        extensions: ["sc"]
      },
      "application/vnd.iccprofile": {
        source: "iana",
        extensions: ["icc", "icm"]
      },
      "application/vnd.ieee.1905": {
        source: "iana"
      },
      "application/vnd.igloader": {
        source: "iana",
        extensions: ["igl"]
      },
      "application/vnd.imagemeter.folder+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.imagemeter.image+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.immervision-ivp": {
        source: "iana",
        extensions: ["ivp"]
      },
      "application/vnd.immervision-ivu": {
        source: "iana",
        extensions: ["ivu"]
      },
      "application/vnd.ims.imsccv1p1": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p2": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p3": {
        source: "iana"
      },
      "application/vnd.ims.lis.v2.result+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy.id+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings.simple+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informedcontrol.rms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informix-visionary": {
        source: "iana"
      },
      "application/vnd.infotech.project": {
        source: "iana"
      },
      "application/vnd.infotech.project+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.innopath.wamp.notification": {
        source: "iana"
      },
      "application/vnd.insors.igm": {
        source: "iana",
        extensions: ["igm"]
      },
      "application/vnd.intercon.formnet": {
        source: "iana",
        extensions: ["xpw", "xpx"]
      },
      "application/vnd.intergeo": {
        source: "iana",
        extensions: ["i2g"]
      },
      "application/vnd.intertrust.digibox": {
        source: "iana"
      },
      "application/vnd.intertrust.nncp": {
        source: "iana"
      },
      "application/vnd.intu.qbo": {
        source: "iana",
        extensions: ["qbo"]
      },
      "application/vnd.intu.qfx": {
        source: "iana",
        extensions: ["qfx"]
      },
      "application/vnd.iptc.g2.catalogitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.conceptitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.knowledgeitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.packageitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.planningitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ipunplugged.rcprofile": {
        source: "iana",
        extensions: ["rcprofile"]
      },
      "application/vnd.irepository.package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["irp"]
      },
      "application/vnd.is-xpr": {
        source: "iana",
        extensions: ["xpr"]
      },
      "application/vnd.isac.fcs": {
        source: "iana",
        extensions: ["fcs"]
      },
      "application/vnd.iso11783-10+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.jam": {
        source: "iana",
        extensions: ["jam"]
      },
      "application/vnd.japannet-directory-service": {
        source: "iana"
      },
      "application/vnd.japannet-jpnstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-payment-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-registration": {
        source: "iana"
      },
      "application/vnd.japannet-registration-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-setstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-verification": {
        source: "iana"
      },
      "application/vnd.japannet-verification-wakeup": {
        source: "iana"
      },
      "application/vnd.jcp.javame.midlet-rms": {
        source: "iana",
        extensions: ["rms"]
      },
      "application/vnd.jisp": {
        source: "iana",
        extensions: ["jisp"]
      },
      "application/vnd.joost.joda-archive": {
        source: "iana",
        extensions: ["joda"]
      },
      "application/vnd.jsk.isdn-ngn": {
        source: "iana"
      },
      "application/vnd.kahootz": {
        source: "iana",
        extensions: ["ktz", "ktr"]
      },
      "application/vnd.kde.karbon": {
        source: "iana",
        extensions: ["karbon"]
      },
      "application/vnd.kde.kchart": {
        source: "iana",
        extensions: ["chrt"]
      },
      "application/vnd.kde.kformula": {
        source: "iana",
        extensions: ["kfo"]
      },
      "application/vnd.kde.kivio": {
        source: "iana",
        extensions: ["flw"]
      },
      "application/vnd.kde.kontour": {
        source: "iana",
        extensions: ["kon"]
      },
      "application/vnd.kde.kpresenter": {
        source: "iana",
        extensions: ["kpr", "kpt"]
      },
      "application/vnd.kde.kspread": {
        source: "iana",
        extensions: ["ksp"]
      },
      "application/vnd.kde.kword": {
        source: "iana",
        extensions: ["kwd", "kwt"]
      },
      "application/vnd.kenameaapp": {
        source: "iana",
        extensions: ["htke"]
      },
      "application/vnd.kidspiration": {
        source: "iana",
        extensions: ["kia"]
      },
      "application/vnd.kinar": {
        source: "iana",
        extensions: ["kne", "knp"]
      },
      "application/vnd.koan": {
        source: "iana",
        extensions: ["skp", "skd", "skt", "skm"]
      },
      "application/vnd.kodak-descriptor": {
        source: "iana",
        extensions: ["sse"]
      },
      "application/vnd.las": {
        source: "iana"
      },
      "application/vnd.las.las+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.las.las+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lasxml"]
      },
      "application/vnd.laszip": {
        source: "iana"
      },
      "application/vnd.leap+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.liberty-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.llamagraphics.life-balance.desktop": {
        source: "iana",
        extensions: ["lbd"]
      },
      "application/vnd.llamagraphics.life-balance.exchange+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lbe"]
      },
      "application/vnd.logipipe.circuit+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.loom": {
        source: "iana"
      },
      "application/vnd.lotus-1-2-3": {
        source: "iana",
        extensions: ["123"]
      },
      "application/vnd.lotus-approach": {
        source: "iana",
        extensions: ["apr"]
      },
      "application/vnd.lotus-freelance": {
        source: "iana",
        extensions: ["pre"]
      },
      "application/vnd.lotus-notes": {
        source: "iana",
        extensions: ["nsf"]
      },
      "application/vnd.lotus-organizer": {
        source: "iana",
        extensions: ["org"]
      },
      "application/vnd.lotus-screencam": {
        source: "iana",
        extensions: ["scm"]
      },
      "application/vnd.lotus-wordpro": {
        source: "iana",
        extensions: ["lwp"]
      },
      "application/vnd.macports.portpkg": {
        source: "iana",
        extensions: ["portpkg"]
      },
      "application/vnd.mapbox-vector-tile": {
        source: "iana",
        extensions: ["mvt"]
      },
      "application/vnd.marlin.drm.actiontoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.conftoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.license+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.mdcf": {
        source: "iana"
      },
      "application/vnd.mason+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.maxar.archive.3tz+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.maxmind.maxmind-db": {
        source: "iana"
      },
      "application/vnd.mcd": {
        source: "iana",
        extensions: ["mcd"]
      },
      "application/vnd.medcalcdata": {
        source: "iana",
        extensions: ["mc1"]
      },
      "application/vnd.mediastation.cdkey": {
        source: "iana",
        extensions: ["cdkey"]
      },
      "application/vnd.meridian-slingshot": {
        source: "iana"
      },
      "application/vnd.mfer": {
        source: "iana",
        extensions: ["mwf"]
      },
      "application/vnd.mfmp": {
        source: "iana",
        extensions: ["mfm"]
      },
      "application/vnd.micro+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.micrografx.flo": {
        source: "iana",
        extensions: ["flo"]
      },
      "application/vnd.micrografx.igx": {
        source: "iana",
        extensions: ["igx"]
      },
      "application/vnd.microsoft.portable-executable": {
        source: "iana"
      },
      "application/vnd.microsoft.windows.thumbnail-cache": {
        source: "iana"
      },
      "application/vnd.miele+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.mif": {
        source: "iana",
        extensions: ["mif"]
      },
      "application/vnd.minisoft-hp3000-save": {
        source: "iana"
      },
      "application/vnd.mitsubishi.misty-guard.trustweb": {
        source: "iana"
      },
      "application/vnd.mobius.daf": {
        source: "iana",
        extensions: ["daf"]
      },
      "application/vnd.mobius.dis": {
        source: "iana",
        extensions: ["dis"]
      },
      "application/vnd.mobius.mbk": {
        source: "iana",
        extensions: ["mbk"]
      },
      "application/vnd.mobius.mqy": {
        source: "iana",
        extensions: ["mqy"]
      },
      "application/vnd.mobius.msl": {
        source: "iana",
        extensions: ["msl"]
      },
      "application/vnd.mobius.plc": {
        source: "iana",
        extensions: ["plc"]
      },
      "application/vnd.mobius.txf": {
        source: "iana",
        extensions: ["txf"]
      },
      "application/vnd.mophun.application": {
        source: "iana",
        extensions: ["mpn"]
      },
      "application/vnd.mophun.certificate": {
        source: "iana",
        extensions: ["mpc"]
      },
      "application/vnd.motorola.flexsuite": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.adsi": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.fis": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.gotap": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.kmr": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.ttc": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.wem": {
        source: "iana"
      },
      "application/vnd.motorola.iprm": {
        source: "iana"
      },
      "application/vnd.mozilla.xul+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xul"]
      },
      "application/vnd.ms-3mfdocument": {
        source: "iana"
      },
      "application/vnd.ms-artgalry": {
        source: "iana",
        extensions: ["cil"]
      },
      "application/vnd.ms-asf": {
        source: "iana"
      },
      "application/vnd.ms-cab-compressed": {
        source: "iana",
        extensions: ["cab"]
      },
      "application/vnd.ms-color.iccprofile": {
        source: "apache"
      },
      "application/vnd.ms-excel": {
        source: "iana",
        compressible: false,
        extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
      },
      "application/vnd.ms-excel.addin.macroenabled.12": {
        source: "iana",
        extensions: ["xlam"]
      },
      "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
        source: "iana",
        extensions: ["xlsb"]
      },
      "application/vnd.ms-excel.sheet.macroenabled.12": {
        source: "iana",
        extensions: ["xlsm"]
      },
      "application/vnd.ms-excel.template.macroenabled.12": {
        source: "iana",
        extensions: ["xltm"]
      },
      "application/vnd.ms-fontobject": {
        source: "iana",
        compressible: true,
        extensions: ["eot"]
      },
      "application/vnd.ms-htmlhelp": {
        source: "iana",
        extensions: ["chm"]
      },
      "application/vnd.ms-ims": {
        source: "iana",
        extensions: ["ims"]
      },
      "application/vnd.ms-lrm": {
        source: "iana",
        extensions: ["lrm"]
      },
      "application/vnd.ms-office.activex+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-officetheme": {
        source: "iana",
        extensions: ["thmx"]
      },
      "application/vnd.ms-opentype": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-outlook": {
        compressible: false,
        extensions: ["msg"]
      },
      "application/vnd.ms-package.obfuscated-opentype": {
        source: "apache"
      },
      "application/vnd.ms-pki.seccat": {
        source: "apache",
        extensions: ["cat"]
      },
      "application/vnd.ms-pki.stl": {
        source: "apache",
        extensions: ["stl"]
      },
      "application/vnd.ms-playready.initiator+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-powerpoint": {
        source: "iana",
        compressible: false,
        extensions: ["ppt", "pps", "pot"]
      },
      "application/vnd.ms-powerpoint.addin.macroenabled.12": {
        source: "iana",
        extensions: ["ppam"]
      },
      "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
        source: "iana",
        extensions: ["pptm"]
      },
      "application/vnd.ms-powerpoint.slide.macroenabled.12": {
        source: "iana",
        extensions: ["sldm"]
      },
      "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
        source: "iana",
        extensions: ["ppsm"]
      },
      "application/vnd.ms-powerpoint.template.macroenabled.12": {
        source: "iana",
        extensions: ["potm"]
      },
      "application/vnd.ms-printdevicecapabilities+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-printing.printticket+xml": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-printschematicket+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-project": {
        source: "iana",
        extensions: ["mpp", "mpt"]
      },
      "application/vnd.ms-tnef": {
        source: "iana"
      },
      "application/vnd.ms-windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.nwprinting.oob": {
        source: "iana"
      },
      "application/vnd.ms-windows.printerpairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.wsd.oob": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-resp": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-resp": {
        source: "iana"
      },
      "application/vnd.ms-word.document.macroenabled.12": {
        source: "iana",
        extensions: ["docm"]
      },
      "application/vnd.ms-word.template.macroenabled.12": {
        source: "iana",
        extensions: ["dotm"]
      },
      "application/vnd.ms-works": {
        source: "iana",
        extensions: ["wps", "wks", "wcm", "wdb"]
      },
      "application/vnd.ms-wpl": {
        source: "iana",
        extensions: ["wpl"]
      },
      "application/vnd.ms-xpsdocument": {
        source: "iana",
        compressible: false,
        extensions: ["xps"]
      },
      "application/vnd.msa-disk-image": {
        source: "iana"
      },
      "application/vnd.mseq": {
        source: "iana",
        extensions: ["mseq"]
      },
      "application/vnd.msign": {
        source: "iana"
      },
      "application/vnd.multiad.creator": {
        source: "iana"
      },
      "application/vnd.multiad.creator.cif": {
        source: "iana"
      },
      "application/vnd.music-niff": {
        source: "iana"
      },
      "application/vnd.musician": {
        source: "iana",
        extensions: ["mus"]
      },
      "application/vnd.muvee.style": {
        source: "iana",
        extensions: ["msty"]
      },
      "application/vnd.mynfc": {
        source: "iana",
        extensions: ["taglet"]
      },
      "application/vnd.nacamar.ybrid+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ncd.control": {
        source: "iana"
      },
      "application/vnd.ncd.reference": {
        source: "iana"
      },
      "application/vnd.nearst.inv+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nebumind.line": {
        source: "iana"
      },
      "application/vnd.nervana": {
        source: "iana"
      },
      "application/vnd.netfpx": {
        source: "iana"
      },
      "application/vnd.neurolanguage.nlu": {
        source: "iana",
        extensions: ["nlu"]
      },
      "application/vnd.nimn": {
        source: "iana"
      },
      "application/vnd.nintendo.nitro.rom": {
        source: "iana"
      },
      "application/vnd.nintendo.snes.rom": {
        source: "iana"
      },
      "application/vnd.nitf": {
        source: "iana",
        extensions: ["ntf", "nitf"]
      },
      "application/vnd.noblenet-directory": {
        source: "iana",
        extensions: ["nnd"]
      },
      "application/vnd.noblenet-sealer": {
        source: "iana",
        extensions: ["nns"]
      },
      "application/vnd.noblenet-web": {
        source: "iana",
        extensions: ["nnw"]
      },
      "application/vnd.nokia.catalogs": {
        source: "iana"
      },
      "application/vnd.nokia.conml+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.conml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.iptv.config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.isds-radio-presets": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.landmarkcollection+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.n-gage.ac+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ac"]
      },
      "application/vnd.nokia.n-gage.data": {
        source: "iana",
        extensions: ["ngdat"]
      },
      "application/vnd.nokia.n-gage.symbian.install": {
        source: "iana",
        extensions: ["n-gage"]
      },
      "application/vnd.nokia.ncd": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.radio-preset": {
        source: "iana",
        extensions: ["rpst"]
      },
      "application/vnd.nokia.radio-presets": {
        source: "iana",
        extensions: ["rpss"]
      },
      "application/vnd.novadigm.edm": {
        source: "iana",
        extensions: ["edm"]
      },
      "application/vnd.novadigm.edx": {
        source: "iana",
        extensions: ["edx"]
      },
      "application/vnd.novadigm.ext": {
        source: "iana",
        extensions: ["ext"]
      },
      "application/vnd.ntt-local.content-share": {
        source: "iana"
      },
      "application/vnd.ntt-local.file-transfer": {
        source: "iana"
      },
      "application/vnd.ntt-local.ogw_remote-access": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_remote": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_tcp_stream": {
        source: "iana"
      },
      "application/vnd.oasis.opendocument.chart": {
        source: "iana",
        extensions: ["odc"]
      },
      "application/vnd.oasis.opendocument.chart-template": {
        source: "iana",
        extensions: ["otc"]
      },
      "application/vnd.oasis.opendocument.database": {
        source: "iana",
        extensions: ["odb"]
      },
      "application/vnd.oasis.opendocument.formula": {
        source: "iana",
        extensions: ["odf"]
      },
      "application/vnd.oasis.opendocument.formula-template": {
        source: "iana",
        extensions: ["odft"]
      },
      "application/vnd.oasis.opendocument.graphics": {
        source: "iana",
        compressible: false,
        extensions: ["odg"]
      },
      "application/vnd.oasis.opendocument.graphics-template": {
        source: "iana",
        extensions: ["otg"]
      },
      "application/vnd.oasis.opendocument.image": {
        source: "iana",
        extensions: ["odi"]
      },
      "application/vnd.oasis.opendocument.image-template": {
        source: "iana",
        extensions: ["oti"]
      },
      "application/vnd.oasis.opendocument.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["odp"]
      },
      "application/vnd.oasis.opendocument.presentation-template": {
        source: "iana",
        extensions: ["otp"]
      },
      "application/vnd.oasis.opendocument.spreadsheet": {
        source: "iana",
        compressible: false,
        extensions: ["ods"]
      },
      "application/vnd.oasis.opendocument.spreadsheet-template": {
        source: "iana",
        extensions: ["ots"]
      },
      "application/vnd.oasis.opendocument.text": {
        source: "iana",
        compressible: false,
        extensions: ["odt"]
      },
      "application/vnd.oasis.opendocument.text-master": {
        source: "iana",
        extensions: ["odm"]
      },
      "application/vnd.oasis.opendocument.text-template": {
        source: "iana",
        extensions: ["ott"]
      },
      "application/vnd.oasis.opendocument.text-web": {
        source: "iana",
        extensions: ["oth"]
      },
      "application/vnd.obn": {
        source: "iana"
      },
      "application/vnd.ocf+cbor": {
        source: "iana"
      },
      "application/vnd.oci.image.manifest.v1+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oftn.l10n+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessdownload+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessstreaming+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.cspg-hexbinary": {
        source: "iana"
      },
      "application/vnd.oipf.dae.svg+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.dae.xhtml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.mippvcontrolmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.pae.gem": {
        source: "iana"
      },
      "application/vnd.oipf.spdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.spdlist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.ueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.userprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.olpc-sugar": {
        source: "iana",
        extensions: ["xo"]
      },
      "application/vnd.oma-scws-config": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-request": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-response": {
        source: "iana"
      },
      "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.drm-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.imd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.ltkm": {
        source: "iana"
      },
      "application/vnd.oma.bcast.notification+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.provisioningtrigger": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgboot": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgdd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sgdu": {
        source: "iana"
      },
      "application/vnd.oma.bcast.simple-symbol-container": {
        source: "iana"
      },
      "application/vnd.oma.bcast.smartcard-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sprov+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.stkm": {
        source: "iana"
      },
      "application/vnd.oma.cab-address-book+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-feature-handler+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-pcc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-subs-invite+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-user-prefs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.dcd": {
        source: "iana"
      },
      "application/vnd.oma.dcdc": {
        source: "iana"
      },
      "application/vnd.oma.dd2+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dd2"]
      },
      "application/vnd.oma.drm.risd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.group-usage-list+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+cbor": {
        source: "iana"
      },
      "application/vnd.oma.lwm2m+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+tlv": {
        source: "iana"
      },
      "application/vnd.oma.pal+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.detailed-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.final-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.groups+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.invocation-descriptor+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.optimized-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.push": {
        source: "iana"
      },
      "application/vnd.oma.scidm.messages+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.xcap-directory+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.omads-email+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-file+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-folder+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omaloc-supl-init": {
        source: "iana"
      },
      "application/vnd.onepager": {
        source: "iana"
      },
      "application/vnd.onepagertamp": {
        source: "iana"
      },
      "application/vnd.onepagertamx": {
        source: "iana"
      },
      "application/vnd.onepagertat": {
        source: "iana"
      },
      "application/vnd.onepagertatp": {
        source: "iana"
      },
      "application/vnd.onepagertatx": {
        source: "iana"
      },
      "application/vnd.openblox.game+xml": {
        source: "iana",
        compressible: true,
        extensions: ["obgx"]
      },
      "application/vnd.openblox.game-binary": {
        source: "iana"
      },
      "application/vnd.openeye.oeb": {
        source: "iana"
      },
      "application/vnd.openofficeorg.extension": {
        source: "apache",
        extensions: ["oxt"]
      },
      "application/vnd.openstreetmap.data+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osm"]
      },
      "application/vnd.opentimestamps.ots": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawing+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["pptx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide": {
        source: "iana",
        extensions: ["sldx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
        source: "iana",
        extensions: ["ppsx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template": {
        source: "iana",
        extensions: ["potx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
        source: "iana",
        compressible: false,
        extensions: ["xlsx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
        source: "iana",
        extensions: ["xltx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.theme+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.vmldrawing": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
        source: "iana",
        compressible: false,
        extensions: ["docx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
        source: "iana",
        extensions: ["dotx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.core-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.relationships+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oracle.resource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.orange.indata": {
        source: "iana"
      },
      "application/vnd.osa.netdeploy": {
        source: "iana"
      },
      "application/vnd.osgeo.mapguide.package": {
        source: "iana",
        extensions: ["mgp"]
      },
      "application/vnd.osgi.bundle": {
        source: "iana"
      },
      "application/vnd.osgi.dp": {
        source: "iana",
        extensions: ["dp"]
      },
      "application/vnd.osgi.subsystem": {
        source: "iana",
        extensions: ["esa"]
      },
      "application/vnd.otps.ct-kip+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oxli.countgraph": {
        source: "iana"
      },
      "application/vnd.pagerduty+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.palm": {
        source: "iana",
        extensions: ["pdb", "pqa", "oprc"]
      },
      "application/vnd.panoply": {
        source: "iana"
      },
      "application/vnd.paos.xml": {
        source: "iana"
      },
      "application/vnd.patentdive": {
        source: "iana"
      },
      "application/vnd.patientecommsdoc": {
        source: "iana"
      },
      "application/vnd.pawaafile": {
        source: "iana",
        extensions: ["paw"]
      },
      "application/vnd.pcos": {
        source: "iana"
      },
      "application/vnd.pg.format": {
        source: "iana",
        extensions: ["str"]
      },
      "application/vnd.pg.osasli": {
        source: "iana",
        extensions: ["ei6"]
      },
      "application/vnd.piaccess.application-licence": {
        source: "iana"
      },
      "application/vnd.picsel": {
        source: "iana",
        extensions: ["efif"]
      },
      "application/vnd.pmi.widget": {
        source: "iana",
        extensions: ["wg"]
      },
      "application/vnd.poc.group-advertisement+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.pocketlearn": {
        source: "iana",
        extensions: ["plf"]
      },
      "application/vnd.powerbuilder6": {
        source: "iana",
        extensions: ["pbd"]
      },
      "application/vnd.powerbuilder6-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder7": {
        source: "iana"
      },
      "application/vnd.powerbuilder7-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder75": {
        source: "iana"
      },
      "application/vnd.powerbuilder75-s": {
        source: "iana"
      },
      "application/vnd.preminet": {
        source: "iana"
      },
      "application/vnd.previewsystems.box": {
        source: "iana",
        extensions: ["box"]
      },
      "application/vnd.proteus.magazine": {
        source: "iana",
        extensions: ["mgz"]
      },
      "application/vnd.psfs": {
        source: "iana"
      },
      "application/vnd.publishare-delta-tree": {
        source: "iana",
        extensions: ["qps"]
      },
      "application/vnd.pvi.ptid1": {
        source: "iana",
        extensions: ["ptid"]
      },
      "application/vnd.pwg-multiplexed": {
        source: "iana"
      },
      "application/vnd.pwg-xhtml-print+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.qualcomm.brew-app-res": {
        source: "iana"
      },
      "application/vnd.quarantainenet": {
        source: "iana"
      },
      "application/vnd.quark.quarkxpress": {
        source: "iana",
        extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
      },
      "application/vnd.quobject-quoxdocument": {
        source: "iana"
      },
      "application/vnd.radisys.moml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-stream+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-base+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-detect+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-group+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-speech+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-transform+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rainstor.data": {
        source: "iana"
      },
      "application/vnd.rapid": {
        source: "iana"
      },
      "application/vnd.rar": {
        source: "iana",
        extensions: ["rar"]
      },
      "application/vnd.realvnc.bed": {
        source: "iana",
        extensions: ["bed"]
      },
      "application/vnd.recordare.musicxml": {
        source: "iana",
        extensions: ["mxl"]
      },
      "application/vnd.recordare.musicxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musicxml"]
      },
      "application/vnd.renlearn.rlprint": {
        source: "iana"
      },
      "application/vnd.resilient.logic": {
        source: "iana"
      },
      "application/vnd.restful+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rig.cryptonote": {
        source: "iana",
        extensions: ["cryptonote"]
      },
      "application/vnd.rim.cod": {
        source: "apache",
        extensions: ["cod"]
      },
      "application/vnd.rn-realmedia": {
        source: "apache",
        extensions: ["rm"]
      },
      "application/vnd.rn-realmedia-vbr": {
        source: "apache",
        extensions: ["rmvb"]
      },
      "application/vnd.route66.link66+xml": {
        source: "iana",
        compressible: true,
        extensions: ["link66"]
      },
      "application/vnd.rs-274x": {
        source: "iana"
      },
      "application/vnd.ruckus.download": {
        source: "iana"
      },
      "application/vnd.s3sms": {
        source: "iana"
      },
      "application/vnd.sailingtracker.track": {
        source: "iana",
        extensions: ["st"]
      },
      "application/vnd.sar": {
        source: "iana"
      },
      "application/vnd.sbm.cid": {
        source: "iana"
      },
      "application/vnd.sbm.mid2": {
        source: "iana"
      },
      "application/vnd.scribus": {
        source: "iana"
      },
      "application/vnd.sealed.3df": {
        source: "iana"
      },
      "application/vnd.sealed.csf": {
        source: "iana"
      },
      "application/vnd.sealed.doc": {
        source: "iana"
      },
      "application/vnd.sealed.eml": {
        source: "iana"
      },
      "application/vnd.sealed.mht": {
        source: "iana"
      },
      "application/vnd.sealed.net": {
        source: "iana"
      },
      "application/vnd.sealed.ppt": {
        source: "iana"
      },
      "application/vnd.sealed.tiff": {
        source: "iana"
      },
      "application/vnd.sealed.xls": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.html": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.pdf": {
        source: "iana"
      },
      "application/vnd.seemail": {
        source: "iana",
        extensions: ["see"]
      },
      "application/vnd.seis+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.sema": {
        source: "iana",
        extensions: ["sema"]
      },
      "application/vnd.semd": {
        source: "iana",
        extensions: ["semd"]
      },
      "application/vnd.semf": {
        source: "iana",
        extensions: ["semf"]
      },
      "application/vnd.shade-save-file": {
        source: "iana"
      },
      "application/vnd.shana.informed.formdata": {
        source: "iana",
        extensions: ["ifm"]
      },
      "application/vnd.shana.informed.formtemplate": {
        source: "iana",
        extensions: ["itp"]
      },
      "application/vnd.shana.informed.interchange": {
        source: "iana",
        extensions: ["iif"]
      },
      "application/vnd.shana.informed.package": {
        source: "iana",
        extensions: ["ipk"]
      },
      "application/vnd.shootproof+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shopkick+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shp": {
        source: "iana"
      },
      "application/vnd.shx": {
        source: "iana"
      },
      "application/vnd.sigrok.session": {
        source: "iana"
      },
      "application/vnd.simtech-mindmapper": {
        source: "iana",
        extensions: ["twd", "twds"]
      },
      "application/vnd.siren+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.smaf": {
        source: "iana",
        extensions: ["mmf"]
      },
      "application/vnd.smart.notebook": {
        source: "iana"
      },
      "application/vnd.smart.teacher": {
        source: "iana",
        extensions: ["teacher"]
      },
      "application/vnd.snesdev-page-table": {
        source: "iana"
      },
      "application/vnd.software602.filler.form+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fo"]
      },
      "application/vnd.software602.filler.form-xml-zip": {
        source: "iana"
      },
      "application/vnd.solent.sdkm+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sdkm", "sdkd"]
      },
      "application/vnd.spotfire.dxp": {
        source: "iana",
        extensions: ["dxp"]
      },
      "application/vnd.spotfire.sfs": {
        source: "iana",
        extensions: ["sfs"]
      },
      "application/vnd.sqlite3": {
        source: "iana"
      },
      "application/vnd.sss-cod": {
        source: "iana"
      },
      "application/vnd.sss-dtf": {
        source: "iana"
      },
      "application/vnd.sss-ntf": {
        source: "iana"
      },
      "application/vnd.stardivision.calc": {
        source: "apache",
        extensions: ["sdc"]
      },
      "application/vnd.stardivision.draw": {
        source: "apache",
        extensions: ["sda"]
      },
      "application/vnd.stardivision.impress": {
        source: "apache",
        extensions: ["sdd"]
      },
      "application/vnd.stardivision.math": {
        source: "apache",
        extensions: ["smf"]
      },
      "application/vnd.stardivision.writer": {
        source: "apache",
        extensions: ["sdw", "vor"]
      },
      "application/vnd.stardivision.writer-global": {
        source: "apache",
        extensions: ["sgl"]
      },
      "application/vnd.stepmania.package": {
        source: "iana",
        extensions: ["smzip"]
      },
      "application/vnd.stepmania.stepchart": {
        source: "iana",
        extensions: ["sm"]
      },
      "application/vnd.street-stream": {
        source: "iana"
      },
      "application/vnd.sun.wadl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wadl"]
      },
      "application/vnd.sun.xml.calc": {
        source: "apache",
        extensions: ["sxc"]
      },
      "application/vnd.sun.xml.calc.template": {
        source: "apache",
        extensions: ["stc"]
      },
      "application/vnd.sun.xml.draw": {
        source: "apache",
        extensions: ["sxd"]
      },
      "application/vnd.sun.xml.draw.template": {
        source: "apache",
        extensions: ["std"]
      },
      "application/vnd.sun.xml.impress": {
        source: "apache",
        extensions: ["sxi"]
      },
      "application/vnd.sun.xml.impress.template": {
        source: "apache",
        extensions: ["sti"]
      },
      "application/vnd.sun.xml.math": {
        source: "apache",
        extensions: ["sxm"]
      },
      "application/vnd.sun.xml.writer": {
        source: "apache",
        extensions: ["sxw"]
      },
      "application/vnd.sun.xml.writer.global": {
        source: "apache",
        extensions: ["sxg"]
      },
      "application/vnd.sun.xml.writer.template": {
        source: "apache",
        extensions: ["stw"]
      },
      "application/vnd.sus-calendar": {
        source: "iana",
        extensions: ["sus", "susp"]
      },
      "application/vnd.svd": {
        source: "iana",
        extensions: ["svd"]
      },
      "application/vnd.swiftview-ics": {
        source: "iana"
      },
      "application/vnd.sycle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.syft+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.symbian.install": {
        source: "apache",
        extensions: ["sis", "sisx"]
      },
      "application/vnd.syncml+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xsm"]
      },
      "application/vnd.syncml.dm+wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["bdm"]
      },
      "application/vnd.syncml.dm+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xdm"]
      },
      "application/vnd.syncml.dm.notification": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["ddf"]
      },
      "application/vnd.syncml.dmtnds+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmtnds+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.syncml.ds.notification": {
        source: "iana"
      },
      "application/vnd.tableschema+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tao.intent-module-archive": {
        source: "iana",
        extensions: ["tao"]
      },
      "application/vnd.tcpdump.pcap": {
        source: "iana",
        extensions: ["pcap", "cap", "dmp"]
      },
      "application/vnd.think-cell.ppttc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tmd.mediaflex.api+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tml": {
        source: "iana"
      },
      "application/vnd.tmobile-livetv": {
        source: "iana",
        extensions: ["tmo"]
      },
      "application/vnd.tri.onesource": {
        source: "iana"
      },
      "application/vnd.trid.tpt": {
        source: "iana",
        extensions: ["tpt"]
      },
      "application/vnd.triscape.mxs": {
        source: "iana",
        extensions: ["mxs"]
      },
      "application/vnd.trueapp": {
        source: "iana",
        extensions: ["tra"]
      },
      "application/vnd.truedoc": {
        source: "iana"
      },
      "application/vnd.ubisoft.webplayer": {
        source: "iana"
      },
      "application/vnd.ufdl": {
        source: "iana",
        extensions: ["ufd", "ufdl"]
      },
      "application/vnd.uiq.theme": {
        source: "iana",
        extensions: ["utz"]
      },
      "application/vnd.umajin": {
        source: "iana",
        extensions: ["umj"]
      },
      "application/vnd.unity": {
        source: "iana",
        extensions: ["unityweb"]
      },
      "application/vnd.uoml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uoml"]
      },
      "application/vnd.uplanet.alert": {
        source: "iana"
      },
      "application/vnd.uplanet.alert-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.channel": {
        source: "iana"
      },
      "application/vnd.uplanet.channel-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.list": {
        source: "iana"
      },
      "application/vnd.uplanet.list-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.signal": {
        source: "iana"
      },
      "application/vnd.uri-map": {
        source: "iana"
      },
      "application/vnd.valve.source.material": {
        source: "iana"
      },
      "application/vnd.vcx": {
        source: "iana",
        extensions: ["vcx"]
      },
      "application/vnd.vd-study": {
        source: "iana"
      },
      "application/vnd.vectorworks": {
        source: "iana"
      },
      "application/vnd.vel+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.verimatrix.vcas": {
        source: "iana"
      },
      "application/vnd.veritone.aion+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.veryant.thin": {
        source: "iana"
      },
      "application/vnd.ves.encrypted": {
        source: "iana"
      },
      "application/vnd.vidsoft.vidconference": {
        source: "iana"
      },
      "application/vnd.visio": {
        source: "iana",
        extensions: ["vsd", "vst", "vss", "vsw"]
      },
      "application/vnd.visionary": {
        source: "iana",
        extensions: ["vis"]
      },
      "application/vnd.vividence.scriptfile": {
        source: "iana"
      },
      "application/vnd.vsf": {
        source: "iana",
        extensions: ["vsf"]
      },
      "application/vnd.wap.sic": {
        source: "iana"
      },
      "application/vnd.wap.slc": {
        source: "iana"
      },
      "application/vnd.wap.wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["wbxml"]
      },
      "application/vnd.wap.wmlc": {
        source: "iana",
        extensions: ["wmlc"]
      },
      "application/vnd.wap.wmlscriptc": {
        source: "iana",
        extensions: ["wmlsc"]
      },
      "application/vnd.webturbo": {
        source: "iana",
        extensions: ["wtb"]
      },
      "application/vnd.wfa.dpp": {
        source: "iana"
      },
      "application/vnd.wfa.p2p": {
        source: "iana"
      },
      "application/vnd.wfa.wsc": {
        source: "iana"
      },
      "application/vnd.windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.wmc": {
        source: "iana"
      },
      "application/vnd.wmf.bootstrap": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica.package": {
        source: "iana"
      },
      "application/vnd.wolfram.player": {
        source: "iana",
        extensions: ["nbp"]
      },
      "application/vnd.wordperfect": {
        source: "iana",
        extensions: ["wpd"]
      },
      "application/vnd.wqd": {
        source: "iana",
        extensions: ["wqd"]
      },
      "application/vnd.wrq-hp3000-labelled": {
        source: "iana"
      },
      "application/vnd.wt.stf": {
        source: "iana",
        extensions: ["stf"]
      },
      "application/vnd.wv.csp+wbxml": {
        source: "iana"
      },
      "application/vnd.wv.csp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.wv.ssp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xacml+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xara": {
        source: "iana",
        extensions: ["xar"]
      },
      "application/vnd.xfdl": {
        source: "iana",
        extensions: ["xfdl"]
      },
      "application/vnd.xfdl.webform": {
        source: "iana"
      },
      "application/vnd.xmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xmpie.cpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.dpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.plan": {
        source: "iana"
      },
      "application/vnd.xmpie.ppkg": {
        source: "iana"
      },
      "application/vnd.xmpie.xlim": {
        source: "iana"
      },
      "application/vnd.yamaha.hv-dic": {
        source: "iana",
        extensions: ["hvd"]
      },
      "application/vnd.yamaha.hv-script": {
        source: "iana",
        extensions: ["hvs"]
      },
      "application/vnd.yamaha.hv-voice": {
        source: "iana",
        extensions: ["hvp"]
      },
      "application/vnd.yamaha.openscoreformat": {
        source: "iana",
        extensions: ["osf"]
      },
      "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osfpvg"]
      },
      "application/vnd.yamaha.remote-setup": {
        source: "iana"
      },
      "application/vnd.yamaha.smaf-audio": {
        source: "iana",
        extensions: ["saf"]
      },
      "application/vnd.yamaha.smaf-phrase": {
        source: "iana",
        extensions: ["spf"]
      },
      "application/vnd.yamaha.through-ngn": {
        source: "iana"
      },
      "application/vnd.yamaha.tunnel-udpencap": {
        source: "iana"
      },
      "application/vnd.yaoweme": {
        source: "iana"
      },
      "application/vnd.yellowriver-custom-menu": {
        source: "iana",
        extensions: ["cmp"]
      },
      "application/vnd.youtube.yt": {
        source: "iana"
      },
      "application/vnd.zul": {
        source: "iana",
        extensions: ["zir", "zirz"]
      },
      "application/vnd.zzazz.deck+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zaz"]
      },
      "application/voicexml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["vxml"]
      },
      "application/voucher-cms+json": {
        source: "iana",
        compressible: true
      },
      "application/vq-rtcpxr": {
        source: "iana"
      },
      "application/wasm": {
        source: "iana",
        compressible: true,
        extensions: ["wasm"]
      },
      "application/watcherinfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wif"]
      },
      "application/webpush-options+json": {
        source: "iana",
        compressible: true
      },
      "application/whoispp-query": {
        source: "iana"
      },
      "application/whoispp-response": {
        source: "iana"
      },
      "application/widget": {
        source: "iana",
        extensions: ["wgt"]
      },
      "application/winhlp": {
        source: "apache",
        extensions: ["hlp"]
      },
      "application/wita": {
        source: "iana"
      },
      "application/wordperfect5.1": {
        source: "iana"
      },
      "application/wsdl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wsdl"]
      },
      "application/wspolicy+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wspolicy"]
      },
      "application/x-7z-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["7z"]
      },
      "application/x-abiword": {
        source: "apache",
        extensions: ["abw"]
      },
      "application/x-ace-compressed": {
        source: "apache",
        extensions: ["ace"]
      },
      "application/x-amf": {
        source: "apache"
      },
      "application/x-apple-diskimage": {
        source: "apache",
        extensions: ["dmg"]
      },
      "application/x-arj": {
        compressible: false,
        extensions: ["arj"]
      },
      "application/x-authorware-bin": {
        source: "apache",
        extensions: ["aab", "x32", "u32", "vox"]
      },
      "application/x-authorware-map": {
        source: "apache",
        extensions: ["aam"]
      },
      "application/x-authorware-seg": {
        source: "apache",
        extensions: ["aas"]
      },
      "application/x-bcpio": {
        source: "apache",
        extensions: ["bcpio"]
      },
      "application/x-bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/x-bittorrent": {
        source: "apache",
        extensions: ["torrent"]
      },
      "application/x-blorb": {
        source: "apache",
        extensions: ["blb", "blorb"]
      },
      "application/x-bzip": {
        source: "apache",
        compressible: false,
        extensions: ["bz"]
      },
      "application/x-bzip2": {
        source: "apache",
        compressible: false,
        extensions: ["bz2", "boz"]
      },
      "application/x-cbr": {
        source: "apache",
        extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
      },
      "application/x-cdlink": {
        source: "apache",
        extensions: ["vcd"]
      },
      "application/x-cfs-compressed": {
        source: "apache",
        extensions: ["cfs"]
      },
      "application/x-chat": {
        source: "apache",
        extensions: ["chat"]
      },
      "application/x-chess-pgn": {
        source: "apache",
        extensions: ["pgn"]
      },
      "application/x-chrome-extension": {
        extensions: ["crx"]
      },
      "application/x-cocoa": {
        source: "nginx",
        extensions: ["cco"]
      },
      "application/x-compress": {
        source: "apache"
      },
      "application/x-conference": {
        source: "apache",
        extensions: ["nsc"]
      },
      "application/x-cpio": {
        source: "apache",
        extensions: ["cpio"]
      },
      "application/x-csh": {
        source: "apache",
        extensions: ["csh"]
      },
      "application/x-deb": {
        compressible: false
      },
      "application/x-debian-package": {
        source: "apache",
        extensions: ["deb", "udeb"]
      },
      "application/x-dgc-compressed": {
        source: "apache",
        extensions: ["dgc"]
      },
      "application/x-director": {
        source: "apache",
        extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
      },
      "application/x-doom": {
        source: "apache",
        extensions: ["wad"]
      },
      "application/x-dtbncx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ncx"]
      },
      "application/x-dtbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dtb"]
      },
      "application/x-dtbresource+xml": {
        source: "apache",
        compressible: true,
        extensions: ["res"]
      },
      "application/x-dvi": {
        source: "apache",
        compressible: false,
        extensions: ["dvi"]
      },
      "application/x-envoy": {
        source: "apache",
        extensions: ["evy"]
      },
      "application/x-eva": {
        source: "apache",
        extensions: ["eva"]
      },
      "application/x-font-bdf": {
        source: "apache",
        extensions: ["bdf"]
      },
      "application/x-font-dos": {
        source: "apache"
      },
      "application/x-font-framemaker": {
        source: "apache"
      },
      "application/x-font-ghostscript": {
        source: "apache",
        extensions: ["gsf"]
      },
      "application/x-font-libgrx": {
        source: "apache"
      },
      "application/x-font-linux-psf": {
        source: "apache",
        extensions: ["psf"]
      },
      "application/x-font-pcf": {
        source: "apache",
        extensions: ["pcf"]
      },
      "application/x-font-snf": {
        source: "apache",
        extensions: ["snf"]
      },
      "application/x-font-speedo": {
        source: "apache"
      },
      "application/x-font-sunos-news": {
        source: "apache"
      },
      "application/x-font-type1": {
        source: "apache",
        extensions: ["pfa", "pfb", "pfm", "afm"]
      },
      "application/x-font-vfont": {
        source: "apache"
      },
      "application/x-freearc": {
        source: "apache",
        extensions: ["arc"]
      },
      "application/x-futuresplash": {
        source: "apache",
        extensions: ["spl"]
      },
      "application/x-gca-compressed": {
        source: "apache",
        extensions: ["gca"]
      },
      "application/x-glulx": {
        source: "apache",
        extensions: ["ulx"]
      },
      "application/x-gnumeric": {
        source: "apache",
        extensions: ["gnumeric"]
      },
      "application/x-gramps-xml": {
        source: "apache",
        extensions: ["gramps"]
      },
      "application/x-gtar": {
        source: "apache",
        extensions: ["gtar"]
      },
      "application/x-gzip": {
        source: "apache"
      },
      "application/x-hdf": {
        source: "apache",
        extensions: ["hdf"]
      },
      "application/x-httpd-php": {
        compressible: true,
        extensions: ["php"]
      },
      "application/x-install-instructions": {
        source: "apache",
        extensions: ["install"]
      },
      "application/x-iso9660-image": {
        source: "apache",
        extensions: ["iso"]
      },
      "application/x-iwork-keynote-sffkey": {
        extensions: ["key"]
      },
      "application/x-iwork-numbers-sffnumbers": {
        extensions: ["numbers"]
      },
      "application/x-iwork-pages-sffpages": {
        extensions: ["pages"]
      },
      "application/x-java-archive-diff": {
        source: "nginx",
        extensions: ["jardiff"]
      },
      "application/x-java-jnlp-file": {
        source: "apache",
        compressible: false,
        extensions: ["jnlp"]
      },
      "application/x-javascript": {
        compressible: true
      },
      "application/x-keepass2": {
        extensions: ["kdbx"]
      },
      "application/x-latex": {
        source: "apache",
        compressible: false,
        extensions: ["latex"]
      },
      "application/x-lua-bytecode": {
        extensions: ["luac"]
      },
      "application/x-lzh-compressed": {
        source: "apache",
        extensions: ["lzh", "lha"]
      },
      "application/x-makeself": {
        source: "nginx",
        extensions: ["run"]
      },
      "application/x-mie": {
        source: "apache",
        extensions: ["mie"]
      },
      "application/x-mobipocket-ebook": {
        source: "apache",
        extensions: ["prc", "mobi"]
      },
      "application/x-mpegurl": {
        compressible: false
      },
      "application/x-ms-application": {
        source: "apache",
        extensions: ["application"]
      },
      "application/x-ms-shortcut": {
        source: "apache",
        extensions: ["lnk"]
      },
      "application/x-ms-wmd": {
        source: "apache",
        extensions: ["wmd"]
      },
      "application/x-ms-wmz": {
        source: "apache",
        extensions: ["wmz"]
      },
      "application/x-ms-xbap": {
        source: "apache",
        extensions: ["xbap"]
      },
      "application/x-msaccess": {
        source: "apache",
        extensions: ["mdb"]
      },
      "application/x-msbinder": {
        source: "apache",
        extensions: ["obd"]
      },
      "application/x-mscardfile": {
        source: "apache",
        extensions: ["crd"]
      },
      "application/x-msclip": {
        source: "apache",
        extensions: ["clp"]
      },
      "application/x-msdos-program": {
        extensions: ["exe"]
      },
      "application/x-msdownload": {
        source: "apache",
        extensions: ["exe", "dll", "com", "bat", "msi"]
      },
      "application/x-msmediaview": {
        source: "apache",
        extensions: ["mvb", "m13", "m14"]
      },
      "application/x-msmetafile": {
        source: "apache",
        extensions: ["wmf", "wmz", "emf", "emz"]
      },
      "application/x-msmoney": {
        source: "apache",
        extensions: ["mny"]
      },
      "application/x-mspublisher": {
        source: "apache",
        extensions: ["pub"]
      },
      "application/x-msschedule": {
        source: "apache",
        extensions: ["scd"]
      },
      "application/x-msterminal": {
        source: "apache",
        extensions: ["trm"]
      },
      "application/x-mswrite": {
        source: "apache",
        extensions: ["wri"]
      },
      "application/x-netcdf": {
        source: "apache",
        extensions: ["nc", "cdf"]
      },
      "application/x-ns-proxy-autoconfig": {
        compressible: true,
        extensions: ["pac"]
      },
      "application/x-nzb": {
        source: "apache",
        extensions: ["nzb"]
      },
      "application/x-perl": {
        source: "nginx",
        extensions: ["pl", "pm"]
      },
      "application/x-pilot": {
        source: "nginx",
        extensions: ["prc", "pdb"]
      },
      "application/x-pkcs12": {
        source: "apache",
        compressible: false,
        extensions: ["p12", "pfx"]
      },
      "application/x-pkcs7-certificates": {
        source: "apache",
        extensions: ["p7b", "spc"]
      },
      "application/x-pkcs7-certreqresp": {
        source: "apache",
        extensions: ["p7r"]
      },
      "application/x-pki-message": {
        source: "iana"
      },
      "application/x-rar-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["rar"]
      },
      "application/x-redhat-package-manager": {
        source: "nginx",
        extensions: ["rpm"]
      },
      "application/x-research-info-systems": {
        source: "apache",
        extensions: ["ris"]
      },
      "application/x-sea": {
        source: "nginx",
        extensions: ["sea"]
      },
      "application/x-sh": {
        source: "apache",
        compressible: true,
        extensions: ["sh"]
      },
      "application/x-shar": {
        source: "apache",
        extensions: ["shar"]
      },
      "application/x-shockwave-flash": {
        source: "apache",
        compressible: false,
        extensions: ["swf"]
      },
      "application/x-silverlight-app": {
        source: "apache",
        extensions: ["xap"]
      },
      "application/x-sql": {
        source: "apache",
        extensions: ["sql"]
      },
      "application/x-stuffit": {
        source: "apache",
        compressible: false,
        extensions: ["sit"]
      },
      "application/x-stuffitx": {
        source: "apache",
        extensions: ["sitx"]
      },
      "application/x-subrip": {
        source: "apache",
        extensions: ["srt"]
      },
      "application/x-sv4cpio": {
        source: "apache",
        extensions: ["sv4cpio"]
      },
      "application/x-sv4crc": {
        source: "apache",
        extensions: ["sv4crc"]
      },
      "application/x-t3vm-image": {
        source: "apache",
        extensions: ["t3"]
      },
      "application/x-tads": {
        source: "apache",
        extensions: ["gam"]
      },
      "application/x-tar": {
        source: "apache",
        compressible: true,
        extensions: ["tar"]
      },
      "application/x-tcl": {
        source: "apache",
        extensions: ["tcl", "tk"]
      },
      "application/x-tex": {
        source: "apache",
        extensions: ["tex"]
      },
      "application/x-tex-tfm": {
        source: "apache",
        extensions: ["tfm"]
      },
      "application/x-texinfo": {
        source: "apache",
        extensions: ["texinfo", "texi"]
      },
      "application/x-tgif": {
        source: "apache",
        extensions: ["obj"]
      },
      "application/x-ustar": {
        source: "apache",
        extensions: ["ustar"]
      },
      "application/x-virtualbox-hdd": {
        compressible: true,
        extensions: ["hdd"]
      },
      "application/x-virtualbox-ova": {
        compressible: true,
        extensions: ["ova"]
      },
      "application/x-virtualbox-ovf": {
        compressible: true,
        extensions: ["ovf"]
      },
      "application/x-virtualbox-vbox": {
        compressible: true,
        extensions: ["vbox"]
      },
      "application/x-virtualbox-vbox-extpack": {
        compressible: false,
        extensions: ["vbox-extpack"]
      },
      "application/x-virtualbox-vdi": {
        compressible: true,
        extensions: ["vdi"]
      },
      "application/x-virtualbox-vhd": {
        compressible: true,
        extensions: ["vhd"]
      },
      "application/x-virtualbox-vmdk": {
        compressible: true,
        extensions: ["vmdk"]
      },
      "application/x-wais-source": {
        source: "apache",
        extensions: ["src"]
      },
      "application/x-web-app-manifest+json": {
        compressible: true,
        extensions: ["webapp"]
      },
      "application/x-www-form-urlencoded": {
        source: "iana",
        compressible: true
      },
      "application/x-x509-ca-cert": {
        source: "iana",
        extensions: ["der", "crt", "pem"]
      },
      "application/x-x509-ca-ra-cert": {
        source: "iana"
      },
      "application/x-x509-next-ca-cert": {
        source: "iana"
      },
      "application/x-xfig": {
        source: "apache",
        extensions: ["fig"]
      },
      "application/x-xliff+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/x-xpinstall": {
        source: "apache",
        compressible: false,
        extensions: ["xpi"]
      },
      "application/x-xz": {
        source: "apache",
        extensions: ["xz"]
      },
      "application/x-zmachine": {
        source: "apache",
        extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
      },
      "application/x400-bp": {
        source: "iana"
      },
      "application/xacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/xaml+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xaml"]
      },
      "application/xcap-att+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xav"]
      },
      "application/xcap-caps+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xca"]
      },
      "application/xcap-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdf"]
      },
      "application/xcap-el+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xel"]
      },
      "application/xcap-error+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcap-ns+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xns"]
      },
      "application/xcon-conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcon-conference-info-diff+xml": {
        source: "iana",
        compressible: true
      },
      "application/xenc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xenc"]
      },
      "application/xhtml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xhtml", "xht"]
      },
      "application/xhtml-voice+xml": {
        source: "apache",
        compressible: true
      },
      "application/xliff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml", "xsl", "xsd", "rng"]
      },
      "application/xml-dtd": {
        source: "iana",
        compressible: true,
        extensions: ["dtd"]
      },
      "application/xml-external-parsed-entity": {
        source: "iana"
      },
      "application/xml-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/xmpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/xop+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xop"]
      },
      "application/xproc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xpl"]
      },
      "application/xslt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xsl", "xslt"]
      },
      "application/xspf+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xspf"]
      },
      "application/xv+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mxml", "xhvml", "xvml", "xvm"]
      },
      "application/yang": {
        source: "iana",
        extensions: ["yang"]
      },
      "application/yang-data+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-data+xml": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/yin+xml": {
        source: "iana",
        compressible: true,
        extensions: ["yin"]
      },
      "application/zip": {
        source: "iana",
        compressible: false,
        extensions: ["zip"]
      },
      "application/zlib": {
        source: "iana"
      },
      "application/zstd": {
        source: "iana"
      },
      "audio/1d-interleaved-parityfec": {
        source: "iana"
      },
      "audio/32kadpcm": {
        source: "iana"
      },
      "audio/3gpp": {
        source: "iana",
        compressible: false,
        extensions: ["3gpp"]
      },
      "audio/3gpp2": {
        source: "iana"
      },
      "audio/aac": {
        source: "iana"
      },
      "audio/ac3": {
        source: "iana"
      },
      "audio/adpcm": {
        source: "apache",
        extensions: ["adp"]
      },
      "audio/amr": {
        source: "iana",
        extensions: ["amr"]
      },
      "audio/amr-wb": {
        source: "iana"
      },
      "audio/amr-wb+": {
        source: "iana"
      },
      "audio/aptx": {
        source: "iana"
      },
      "audio/asc": {
        source: "iana"
      },
      "audio/atrac-advanced-lossless": {
        source: "iana"
      },
      "audio/atrac-x": {
        source: "iana"
      },
      "audio/atrac3": {
        source: "iana"
      },
      "audio/basic": {
        source: "iana",
        compressible: false,
        extensions: ["au", "snd"]
      },
      "audio/bv16": {
        source: "iana"
      },
      "audio/bv32": {
        source: "iana"
      },
      "audio/clearmode": {
        source: "iana"
      },
      "audio/cn": {
        source: "iana"
      },
      "audio/dat12": {
        source: "iana"
      },
      "audio/dls": {
        source: "iana"
      },
      "audio/dsr-es201108": {
        source: "iana"
      },
      "audio/dsr-es202050": {
        source: "iana"
      },
      "audio/dsr-es202211": {
        source: "iana"
      },
      "audio/dsr-es202212": {
        source: "iana"
      },
      "audio/dv": {
        source: "iana"
      },
      "audio/dvi4": {
        source: "iana"
      },
      "audio/eac3": {
        source: "iana"
      },
      "audio/encaprtp": {
        source: "iana"
      },
      "audio/evrc": {
        source: "iana"
      },
      "audio/evrc-qcp": {
        source: "iana"
      },
      "audio/evrc0": {
        source: "iana"
      },
      "audio/evrc1": {
        source: "iana"
      },
      "audio/evrcb": {
        source: "iana"
      },
      "audio/evrcb0": {
        source: "iana"
      },
      "audio/evrcb1": {
        source: "iana"
      },
      "audio/evrcnw": {
        source: "iana"
      },
      "audio/evrcnw0": {
        source: "iana"
      },
      "audio/evrcnw1": {
        source: "iana"
      },
      "audio/evrcwb": {
        source: "iana"
      },
      "audio/evrcwb0": {
        source: "iana"
      },
      "audio/evrcwb1": {
        source: "iana"
      },
      "audio/evs": {
        source: "iana"
      },
      "audio/flexfec": {
        source: "iana"
      },
      "audio/fwdred": {
        source: "iana"
      },
      "audio/g711-0": {
        source: "iana"
      },
      "audio/g719": {
        source: "iana"
      },
      "audio/g722": {
        source: "iana"
      },
      "audio/g7221": {
        source: "iana"
      },
      "audio/g723": {
        source: "iana"
      },
      "audio/g726-16": {
        source: "iana"
      },
      "audio/g726-24": {
        source: "iana"
      },
      "audio/g726-32": {
        source: "iana"
      },
      "audio/g726-40": {
        source: "iana"
      },
      "audio/g728": {
        source: "iana"
      },
      "audio/g729": {
        source: "iana"
      },
      "audio/g7291": {
        source: "iana"
      },
      "audio/g729d": {
        source: "iana"
      },
      "audio/g729e": {
        source: "iana"
      },
      "audio/gsm": {
        source: "iana"
      },
      "audio/gsm-efr": {
        source: "iana"
      },
      "audio/gsm-hr-08": {
        source: "iana"
      },
      "audio/ilbc": {
        source: "iana"
      },
      "audio/ip-mr_v2.5": {
        source: "iana"
      },
      "audio/isac": {
        source: "apache"
      },
      "audio/l16": {
        source: "iana"
      },
      "audio/l20": {
        source: "iana"
      },
      "audio/l24": {
        source: "iana",
        compressible: false
      },
      "audio/l8": {
        source: "iana"
      },
      "audio/lpc": {
        source: "iana"
      },
      "audio/melp": {
        source: "iana"
      },
      "audio/melp1200": {
        source: "iana"
      },
      "audio/melp2400": {
        source: "iana"
      },
      "audio/melp600": {
        source: "iana"
      },
      "audio/mhas": {
        source: "iana"
      },
      "audio/midi": {
        source: "apache",
        extensions: ["mid", "midi", "kar", "rmi"]
      },
      "audio/mobile-xmf": {
        source: "iana",
        extensions: ["mxmf"]
      },
      "audio/mp3": {
        compressible: false,
        extensions: ["mp3"]
      },
      "audio/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["m4a", "mp4a"]
      },
      "audio/mp4a-latm": {
        source: "iana"
      },
      "audio/mpa": {
        source: "iana"
      },
      "audio/mpa-robust": {
        source: "iana"
      },
      "audio/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
      },
      "audio/mpeg4-generic": {
        source: "iana"
      },
      "audio/musepack": {
        source: "apache"
      },
      "audio/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["oga", "ogg", "spx", "opus"]
      },
      "audio/opus": {
        source: "iana"
      },
      "audio/parityfec": {
        source: "iana"
      },
      "audio/pcma": {
        source: "iana"
      },
      "audio/pcma-wb": {
        source: "iana"
      },
      "audio/pcmu": {
        source: "iana"
      },
      "audio/pcmu-wb": {
        source: "iana"
      },
      "audio/prs.sid": {
        source: "iana"
      },
      "audio/qcelp": {
        source: "iana"
      },
      "audio/raptorfec": {
        source: "iana"
      },
      "audio/red": {
        source: "iana"
      },
      "audio/rtp-enc-aescm128": {
        source: "iana"
      },
      "audio/rtp-midi": {
        source: "iana"
      },
      "audio/rtploopback": {
        source: "iana"
      },
      "audio/rtx": {
        source: "iana"
      },
      "audio/s3m": {
        source: "apache",
        extensions: ["s3m"]
      },
      "audio/scip": {
        source: "iana"
      },
      "audio/silk": {
        source: "apache",
        extensions: ["sil"]
      },
      "audio/smv": {
        source: "iana"
      },
      "audio/smv-qcp": {
        source: "iana"
      },
      "audio/smv0": {
        source: "iana"
      },
      "audio/sofa": {
        source: "iana"
      },
      "audio/sp-midi": {
        source: "iana"
      },
      "audio/speex": {
        source: "iana"
      },
      "audio/t140c": {
        source: "iana"
      },
      "audio/t38": {
        source: "iana"
      },
      "audio/telephone-event": {
        source: "iana"
      },
      "audio/tetra_acelp": {
        source: "iana"
      },
      "audio/tetra_acelp_bb": {
        source: "iana"
      },
      "audio/tone": {
        source: "iana"
      },
      "audio/tsvcis": {
        source: "iana"
      },
      "audio/uemclip": {
        source: "iana"
      },
      "audio/ulpfec": {
        source: "iana"
      },
      "audio/usac": {
        source: "iana"
      },
      "audio/vdvi": {
        source: "iana"
      },
      "audio/vmr-wb": {
        source: "iana"
      },
      "audio/vnd.3gpp.iufp": {
        source: "iana"
      },
      "audio/vnd.4sb": {
        source: "iana"
      },
      "audio/vnd.audiokoz": {
        source: "iana"
      },
      "audio/vnd.celp": {
        source: "iana"
      },
      "audio/vnd.cisco.nse": {
        source: "iana"
      },
      "audio/vnd.cmles.radio-events": {
        source: "iana"
      },
      "audio/vnd.cns.anp1": {
        source: "iana"
      },
      "audio/vnd.cns.inf1": {
        source: "iana"
      },
      "audio/vnd.dece.audio": {
        source: "iana",
        extensions: ["uva", "uvva"]
      },
      "audio/vnd.digital-winds": {
        source: "iana",
        extensions: ["eol"]
      },
      "audio/vnd.dlna.adts": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.1": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.2": {
        source: "iana"
      },
      "audio/vnd.dolby.mlp": {
        source: "iana"
      },
      "audio/vnd.dolby.mps": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2x": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2z": {
        source: "iana"
      },
      "audio/vnd.dolby.pulse.1": {
        source: "iana"
      },
      "audio/vnd.dra": {
        source: "iana",
        extensions: ["dra"]
      },
      "audio/vnd.dts": {
        source: "iana",
        extensions: ["dts"]
      },
      "audio/vnd.dts.hd": {
        source: "iana",
        extensions: ["dtshd"]
      },
      "audio/vnd.dts.uhd": {
        source: "iana"
      },
      "audio/vnd.dvb.file": {
        source: "iana"
      },
      "audio/vnd.everad.plj": {
        source: "iana"
      },
      "audio/vnd.hns.audio": {
        source: "iana"
      },
      "audio/vnd.lucent.voice": {
        source: "iana",
        extensions: ["lvp"]
      },
      "audio/vnd.ms-playready.media.pya": {
        source: "iana",
        extensions: ["pya"]
      },
      "audio/vnd.nokia.mobile-xmf": {
        source: "iana"
      },
      "audio/vnd.nortel.vbk": {
        source: "iana"
      },
      "audio/vnd.nuera.ecelp4800": {
        source: "iana",
        extensions: ["ecelp4800"]
      },
      "audio/vnd.nuera.ecelp7470": {
        source: "iana",
        extensions: ["ecelp7470"]
      },
      "audio/vnd.nuera.ecelp9600": {
        source: "iana",
        extensions: ["ecelp9600"]
      },
      "audio/vnd.octel.sbc": {
        source: "iana"
      },
      "audio/vnd.presonus.multitrack": {
        source: "iana"
      },
      "audio/vnd.qcelp": {
        source: "iana"
      },
      "audio/vnd.rhetorex.32kadpcm": {
        source: "iana"
      },
      "audio/vnd.rip": {
        source: "iana",
        extensions: ["rip"]
      },
      "audio/vnd.rn-realaudio": {
        compressible: false
      },
      "audio/vnd.sealedmedia.softseal.mpeg": {
        source: "iana"
      },
      "audio/vnd.vmx.cvsd": {
        source: "iana"
      },
      "audio/vnd.wave": {
        compressible: false
      },
      "audio/vorbis": {
        source: "iana",
        compressible: false
      },
      "audio/vorbis-config": {
        source: "iana"
      },
      "audio/wav": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/wave": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/webm": {
        source: "apache",
        compressible: false,
        extensions: ["weba"]
      },
      "audio/x-aac": {
        source: "apache",
        compressible: false,
        extensions: ["aac"]
      },
      "audio/x-aiff": {
        source: "apache",
        extensions: ["aif", "aiff", "aifc"]
      },
      "audio/x-caf": {
        source: "apache",
        compressible: false,
        extensions: ["caf"]
      },
      "audio/x-flac": {
        source: "apache",
        extensions: ["flac"]
      },
      "audio/x-m4a": {
        source: "nginx",
        extensions: ["m4a"]
      },
      "audio/x-matroska": {
        source: "apache",
        extensions: ["mka"]
      },
      "audio/x-mpegurl": {
        source: "apache",
        extensions: ["m3u"]
      },
      "audio/x-ms-wax": {
        source: "apache",
        extensions: ["wax"]
      },
      "audio/x-ms-wma": {
        source: "apache",
        extensions: ["wma"]
      },
      "audio/x-pn-realaudio": {
        source: "apache",
        extensions: ["ram", "ra"]
      },
      "audio/x-pn-realaudio-plugin": {
        source: "apache",
        extensions: ["rmp"]
      },
      "audio/x-realaudio": {
        source: "nginx",
        extensions: ["ra"]
      },
      "audio/x-tta": {
        source: "apache"
      },
      "audio/x-wav": {
        source: "apache",
        extensions: ["wav"]
      },
      "audio/xm": {
        source: "apache",
        extensions: ["xm"]
      },
      "chemical/x-cdx": {
        source: "apache",
        extensions: ["cdx"]
      },
      "chemical/x-cif": {
        source: "apache",
        extensions: ["cif"]
      },
      "chemical/x-cmdf": {
        source: "apache",
        extensions: ["cmdf"]
      },
      "chemical/x-cml": {
        source: "apache",
        extensions: ["cml"]
      },
      "chemical/x-csml": {
        source: "apache",
        extensions: ["csml"]
      },
      "chemical/x-pdb": {
        source: "apache"
      },
      "chemical/x-xyz": {
        source: "apache",
        extensions: ["xyz"]
      },
      "font/collection": {
        source: "iana",
        extensions: ["ttc"]
      },
      "font/otf": {
        source: "iana",
        compressible: true,
        extensions: ["otf"]
      },
      "font/sfnt": {
        source: "iana"
      },
      "font/ttf": {
        source: "iana",
        compressible: true,
        extensions: ["ttf"]
      },
      "font/woff": {
        source: "iana",
        extensions: ["woff"]
      },
      "font/woff2": {
        source: "iana",
        extensions: ["woff2"]
      },
      "image/aces": {
        source: "iana",
        extensions: ["exr"]
      },
      "image/apng": {
        compressible: false,
        extensions: ["apng"]
      },
      "image/avci": {
        source: "iana",
        extensions: ["avci"]
      },
      "image/avcs": {
        source: "iana",
        extensions: ["avcs"]
      },
      "image/avif": {
        source: "iana",
        compressible: false,
        extensions: ["avif"]
      },
      "image/bmp": {
        source: "iana",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/cgm": {
        source: "iana",
        extensions: ["cgm"]
      },
      "image/dicom-rle": {
        source: "iana",
        extensions: ["drle"]
      },
      "image/emf": {
        source: "iana",
        extensions: ["emf"]
      },
      "image/fits": {
        source: "iana",
        extensions: ["fits"]
      },
      "image/g3fax": {
        source: "iana",
        extensions: ["g3"]
      },
      "image/gif": {
        source: "iana",
        compressible: false,
        extensions: ["gif"]
      },
      "image/heic": {
        source: "iana",
        extensions: ["heic"]
      },
      "image/heic-sequence": {
        source: "iana",
        extensions: ["heics"]
      },
      "image/heif": {
        source: "iana",
        extensions: ["heif"]
      },
      "image/heif-sequence": {
        source: "iana",
        extensions: ["heifs"]
      },
      "image/hej2k": {
        source: "iana",
        extensions: ["hej2"]
      },
      "image/hsj2": {
        source: "iana",
        extensions: ["hsj2"]
      },
      "image/ief": {
        source: "iana",
        extensions: ["ief"]
      },
      "image/jls": {
        source: "iana",
        extensions: ["jls"]
      },
      "image/jp2": {
        source: "iana",
        compressible: false,
        extensions: ["jp2", "jpg2"]
      },
      "image/jpeg": {
        source: "iana",
        compressible: false,
        extensions: ["jpeg", "jpg", "jpe"]
      },
      "image/jph": {
        source: "iana",
        extensions: ["jph"]
      },
      "image/jphc": {
        source: "iana",
        extensions: ["jhc"]
      },
      "image/jpm": {
        source: "iana",
        compressible: false,
        extensions: ["jpm"]
      },
      "image/jpx": {
        source: "iana",
        compressible: false,
        extensions: ["jpx", "jpf"]
      },
      "image/jxr": {
        source: "iana",
        extensions: ["jxr"]
      },
      "image/jxra": {
        source: "iana",
        extensions: ["jxra"]
      },
      "image/jxrs": {
        source: "iana",
        extensions: ["jxrs"]
      },
      "image/jxs": {
        source: "iana",
        extensions: ["jxs"]
      },
      "image/jxsc": {
        source: "iana",
        extensions: ["jxsc"]
      },
      "image/jxsi": {
        source: "iana",
        extensions: ["jxsi"]
      },
      "image/jxss": {
        source: "iana",
        extensions: ["jxss"]
      },
      "image/ktx": {
        source: "iana",
        extensions: ["ktx"]
      },
      "image/ktx2": {
        source: "iana",
        extensions: ["ktx2"]
      },
      "image/naplps": {
        source: "iana"
      },
      "image/pjpeg": {
        compressible: false
      },
      "image/png": {
        source: "iana",
        compressible: false,
        extensions: ["png"]
      },
      "image/prs.btif": {
        source: "iana",
        extensions: ["btif"]
      },
      "image/prs.pti": {
        source: "iana",
        extensions: ["pti"]
      },
      "image/pwg-raster": {
        source: "iana"
      },
      "image/sgi": {
        source: "apache",
        extensions: ["sgi"]
      },
      "image/svg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["svg", "svgz"]
      },
      "image/t38": {
        source: "iana",
        extensions: ["t38"]
      },
      "image/tiff": {
        source: "iana",
        compressible: false,
        extensions: ["tif", "tiff"]
      },
      "image/tiff-fx": {
        source: "iana",
        extensions: ["tfx"]
      },
      "image/vnd.adobe.photoshop": {
        source: "iana",
        compressible: true,
        extensions: ["psd"]
      },
      "image/vnd.airzip.accelerator.azv": {
        source: "iana",
        extensions: ["azv"]
      },
      "image/vnd.cns.inf2": {
        source: "iana"
      },
      "image/vnd.dece.graphic": {
        source: "iana",
        extensions: ["uvi", "uvvi", "uvg", "uvvg"]
      },
      "image/vnd.djvu": {
        source: "iana",
        extensions: ["djvu", "djv"]
      },
      "image/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "image/vnd.dwg": {
        source: "iana",
        extensions: ["dwg"]
      },
      "image/vnd.dxf": {
        source: "iana",
        extensions: ["dxf"]
      },
      "image/vnd.fastbidsheet": {
        source: "iana",
        extensions: ["fbs"]
      },
      "image/vnd.fpx": {
        source: "iana",
        extensions: ["fpx"]
      },
      "image/vnd.fst": {
        source: "iana",
        extensions: ["fst"]
      },
      "image/vnd.fujixerox.edmics-mmr": {
        source: "iana",
        extensions: ["mmr"]
      },
      "image/vnd.fujixerox.edmics-rlc": {
        source: "iana",
        extensions: ["rlc"]
      },
      "image/vnd.globalgraphics.pgb": {
        source: "iana"
      },
      "image/vnd.microsoft.icon": {
        source: "iana",
        compressible: true,
        extensions: ["ico"]
      },
      "image/vnd.mix": {
        source: "iana"
      },
      "image/vnd.mozilla.apng": {
        source: "iana"
      },
      "image/vnd.ms-dds": {
        compressible: true,
        extensions: ["dds"]
      },
      "image/vnd.ms-modi": {
        source: "iana",
        extensions: ["mdi"]
      },
      "image/vnd.ms-photo": {
        source: "apache",
        extensions: ["wdp"]
      },
      "image/vnd.net-fpx": {
        source: "iana",
        extensions: ["npx"]
      },
      "image/vnd.pco.b16": {
        source: "iana",
        extensions: ["b16"]
      },
      "image/vnd.radiance": {
        source: "iana"
      },
      "image/vnd.sealed.png": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.gif": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.jpg": {
        source: "iana"
      },
      "image/vnd.svf": {
        source: "iana"
      },
      "image/vnd.tencent.tap": {
        source: "iana",
        extensions: ["tap"]
      },
      "image/vnd.valve.source.texture": {
        source: "iana",
        extensions: ["vtf"]
      },
      "image/vnd.wap.wbmp": {
        source: "iana",
        extensions: ["wbmp"]
      },
      "image/vnd.xiff": {
        source: "iana",
        extensions: ["xif"]
      },
      "image/vnd.zbrush.pcx": {
        source: "iana",
        extensions: ["pcx"]
      },
      "image/webp": {
        source: "apache",
        extensions: ["webp"]
      },
      "image/wmf": {
        source: "iana",
        extensions: ["wmf"]
      },
      "image/x-3ds": {
        source: "apache",
        extensions: ["3ds"]
      },
      "image/x-cmu-raster": {
        source: "apache",
        extensions: ["ras"]
      },
      "image/x-cmx": {
        source: "apache",
        extensions: ["cmx"]
      },
      "image/x-freehand": {
        source: "apache",
        extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
      },
      "image/x-icon": {
        source: "apache",
        compressible: true,
        extensions: ["ico"]
      },
      "image/x-jng": {
        source: "nginx",
        extensions: ["jng"]
      },
      "image/x-mrsid-image": {
        source: "apache",
        extensions: ["sid"]
      },
      "image/x-ms-bmp": {
        source: "nginx",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/x-pcx": {
        source: "apache",
        extensions: ["pcx"]
      },
      "image/x-pict": {
        source: "apache",
        extensions: ["pic", "pct"]
      },
      "image/x-portable-anymap": {
        source: "apache",
        extensions: ["pnm"]
      },
      "image/x-portable-bitmap": {
        source: "apache",
        extensions: ["pbm"]
      },
      "image/x-portable-graymap": {
        source: "apache",
        extensions: ["pgm"]
      },
      "image/x-portable-pixmap": {
        source: "apache",
        extensions: ["ppm"]
      },
      "image/x-rgb": {
        source: "apache",
        extensions: ["rgb"]
      },
      "image/x-tga": {
        source: "apache",
        extensions: ["tga"]
      },
      "image/x-xbitmap": {
        source: "apache",
        extensions: ["xbm"]
      },
      "image/x-xcf": {
        compressible: false
      },
      "image/x-xpixmap": {
        source: "apache",
        extensions: ["xpm"]
      },
      "image/x-xwindowdump": {
        source: "apache",
        extensions: ["xwd"]
      },
      "message/cpim": {
        source: "iana"
      },
      "message/delivery-status": {
        source: "iana"
      },
      "message/disposition-notification": {
        source: "iana",
        extensions: [
          "disposition-notification"
        ]
      },
      "message/external-body": {
        source: "iana"
      },
      "message/feedback-report": {
        source: "iana"
      },
      "message/global": {
        source: "iana",
        extensions: ["u8msg"]
      },
      "message/global-delivery-status": {
        source: "iana",
        extensions: ["u8dsn"]
      },
      "message/global-disposition-notification": {
        source: "iana",
        extensions: ["u8mdn"]
      },
      "message/global-headers": {
        source: "iana",
        extensions: ["u8hdr"]
      },
      "message/http": {
        source: "iana",
        compressible: false
      },
      "message/imdn+xml": {
        source: "iana",
        compressible: true
      },
      "message/news": {
        source: "iana"
      },
      "message/partial": {
        source: "iana",
        compressible: false
      },
      "message/rfc822": {
        source: "iana",
        compressible: true,
        extensions: ["eml", "mime"]
      },
      "message/s-http": {
        source: "iana"
      },
      "message/sip": {
        source: "iana"
      },
      "message/sipfrag": {
        source: "iana"
      },
      "message/tracking-status": {
        source: "iana"
      },
      "message/vnd.si.simp": {
        source: "iana"
      },
      "message/vnd.wfa.wsc": {
        source: "iana",
        extensions: ["wsc"]
      },
      "model/3mf": {
        source: "iana",
        extensions: ["3mf"]
      },
      "model/e57": {
        source: "iana"
      },
      "model/gltf+json": {
        source: "iana",
        compressible: true,
        extensions: ["gltf"]
      },
      "model/gltf-binary": {
        source: "iana",
        compressible: true,
        extensions: ["glb"]
      },
      "model/iges": {
        source: "iana",
        compressible: false,
        extensions: ["igs", "iges"]
      },
      "model/mesh": {
        source: "iana",
        compressible: false,
        extensions: ["msh", "mesh", "silo"]
      },
      "model/mtl": {
        source: "iana",
        extensions: ["mtl"]
      },
      "model/obj": {
        source: "iana",
        extensions: ["obj"]
      },
      "model/step": {
        source: "iana"
      },
      "model/step+xml": {
        source: "iana",
        compressible: true,
        extensions: ["stpx"]
      },
      "model/step+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpz"]
      },
      "model/step-xml+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpxz"]
      },
      "model/stl": {
        source: "iana",
        extensions: ["stl"]
      },
      "model/vnd.collada+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dae"]
      },
      "model/vnd.dwf": {
        source: "iana",
        extensions: ["dwf"]
      },
      "model/vnd.flatland.3dml": {
        source: "iana"
      },
      "model/vnd.gdl": {
        source: "iana",
        extensions: ["gdl"]
      },
      "model/vnd.gs-gdl": {
        source: "apache"
      },
      "model/vnd.gs.gdl": {
        source: "iana"
      },
      "model/vnd.gtw": {
        source: "iana",
        extensions: ["gtw"]
      },
      "model/vnd.moml+xml": {
        source: "iana",
        compressible: true
      },
      "model/vnd.mts": {
        source: "iana",
        extensions: ["mts"]
      },
      "model/vnd.opengex": {
        source: "iana",
        extensions: ["ogex"]
      },
      "model/vnd.parasolid.transmit.binary": {
        source: "iana",
        extensions: ["x_b"]
      },
      "model/vnd.parasolid.transmit.text": {
        source: "iana",
        extensions: ["x_t"]
      },
      "model/vnd.pytha.pyox": {
        source: "iana"
      },
      "model/vnd.rosette.annotated-data-model": {
        source: "iana"
      },
      "model/vnd.sap.vds": {
        source: "iana",
        extensions: ["vds"]
      },
      "model/vnd.usdz+zip": {
        source: "iana",
        compressible: false,
        extensions: ["usdz"]
      },
      "model/vnd.valve.source.compiled-map": {
        source: "iana",
        extensions: ["bsp"]
      },
      "model/vnd.vtu": {
        source: "iana",
        extensions: ["vtu"]
      },
      "model/vrml": {
        source: "iana",
        compressible: false,
        extensions: ["wrl", "vrml"]
      },
      "model/x3d+binary": {
        source: "apache",
        compressible: false,
        extensions: ["x3db", "x3dbz"]
      },
      "model/x3d+fastinfoset": {
        source: "iana",
        extensions: ["x3db"]
      },
      "model/x3d+vrml": {
        source: "apache",
        compressible: false,
        extensions: ["x3dv", "x3dvz"]
      },
      "model/x3d+xml": {
        source: "iana",
        compressible: true,
        extensions: ["x3d", "x3dz"]
      },
      "model/x3d-vrml": {
        source: "iana",
        extensions: ["x3dv"]
      },
      "multipart/alternative": {
        source: "iana",
        compressible: false
      },
      "multipart/appledouble": {
        source: "iana"
      },
      "multipart/byteranges": {
        source: "iana"
      },
      "multipart/digest": {
        source: "iana"
      },
      "multipart/encrypted": {
        source: "iana",
        compressible: false
      },
      "multipart/form-data": {
        source: "iana",
        compressible: false
      },
      "multipart/header-set": {
        source: "iana"
      },
      "multipart/mixed": {
        source: "iana"
      },
      "multipart/multilingual": {
        source: "iana"
      },
      "multipart/parallel": {
        source: "iana"
      },
      "multipart/related": {
        source: "iana",
        compressible: false
      },
      "multipart/report": {
        source: "iana"
      },
      "multipart/signed": {
        source: "iana",
        compressible: false
      },
      "multipart/vnd.bint.med-plus": {
        source: "iana"
      },
      "multipart/voice-message": {
        source: "iana"
      },
      "multipart/x-mixed-replace": {
        source: "iana"
      },
      "text/1d-interleaved-parityfec": {
        source: "iana"
      },
      "text/cache-manifest": {
        source: "iana",
        compressible: true,
        extensions: ["appcache", "manifest"]
      },
      "text/calendar": {
        source: "iana",
        extensions: ["ics", "ifb"]
      },
      "text/calender": {
        compressible: true
      },
      "text/cmd": {
        compressible: true
      },
      "text/coffeescript": {
        extensions: ["coffee", "litcoffee"]
      },
      "text/cql": {
        source: "iana"
      },
      "text/cql-expression": {
        source: "iana"
      },
      "text/cql-identifier": {
        source: "iana"
      },
      "text/css": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["css"]
      },
      "text/csv": {
        source: "iana",
        compressible: true,
        extensions: ["csv"]
      },
      "text/csv-schema": {
        source: "iana"
      },
      "text/directory": {
        source: "iana"
      },
      "text/dns": {
        source: "iana"
      },
      "text/ecmascript": {
        source: "iana"
      },
      "text/encaprtp": {
        source: "iana"
      },
      "text/enriched": {
        source: "iana"
      },
      "text/fhirpath": {
        source: "iana"
      },
      "text/flexfec": {
        source: "iana"
      },
      "text/fwdred": {
        source: "iana"
      },
      "text/gff3": {
        source: "iana"
      },
      "text/grammar-ref-list": {
        source: "iana"
      },
      "text/html": {
        source: "iana",
        compressible: true,
        extensions: ["html", "htm", "shtml"]
      },
      "text/jade": {
        extensions: ["jade"]
      },
      "text/javascript": {
        source: "iana",
        compressible: true
      },
      "text/jcr-cnd": {
        source: "iana"
      },
      "text/jsx": {
        compressible: true,
        extensions: ["jsx"]
      },
      "text/less": {
        compressible: true,
        extensions: ["less"]
      },
      "text/markdown": {
        source: "iana",
        compressible: true,
        extensions: ["markdown", "md"]
      },
      "text/mathml": {
        source: "nginx",
        extensions: ["mml"]
      },
      "text/mdx": {
        compressible: true,
        extensions: ["mdx"]
      },
      "text/mizar": {
        source: "iana"
      },
      "text/n3": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["n3"]
      },
      "text/parameters": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/parityfec": {
        source: "iana"
      },
      "text/plain": {
        source: "iana",
        compressible: true,
        extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
      },
      "text/provenance-notation": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/prs.fallenstein.rst": {
        source: "iana"
      },
      "text/prs.lines.tag": {
        source: "iana",
        extensions: ["dsc"]
      },
      "text/prs.prop.logic": {
        source: "iana"
      },
      "text/raptorfec": {
        source: "iana"
      },
      "text/red": {
        source: "iana"
      },
      "text/rfc822-headers": {
        source: "iana"
      },
      "text/richtext": {
        source: "iana",
        compressible: true,
        extensions: ["rtx"]
      },
      "text/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "text/rtp-enc-aescm128": {
        source: "iana"
      },
      "text/rtploopback": {
        source: "iana"
      },
      "text/rtx": {
        source: "iana"
      },
      "text/sgml": {
        source: "iana",
        extensions: ["sgml", "sgm"]
      },
      "text/shaclc": {
        source: "iana"
      },
      "text/shex": {
        source: "iana",
        extensions: ["shex"]
      },
      "text/slim": {
        extensions: ["slim", "slm"]
      },
      "text/spdx": {
        source: "iana",
        extensions: ["spdx"]
      },
      "text/strings": {
        source: "iana"
      },
      "text/stylus": {
        extensions: ["stylus", "styl"]
      },
      "text/t140": {
        source: "iana"
      },
      "text/tab-separated-values": {
        source: "iana",
        compressible: true,
        extensions: ["tsv"]
      },
      "text/troff": {
        source: "iana",
        extensions: ["t", "tr", "roff", "man", "me", "ms"]
      },
      "text/turtle": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["ttl"]
      },
      "text/ulpfec": {
        source: "iana"
      },
      "text/uri-list": {
        source: "iana",
        compressible: true,
        extensions: ["uri", "uris", "urls"]
      },
      "text/vcard": {
        source: "iana",
        compressible: true,
        extensions: ["vcard"]
      },
      "text/vnd.a": {
        source: "iana"
      },
      "text/vnd.abc": {
        source: "iana"
      },
      "text/vnd.ascii-art": {
        source: "iana"
      },
      "text/vnd.curl": {
        source: "iana",
        extensions: ["curl"]
      },
      "text/vnd.curl.dcurl": {
        source: "apache",
        extensions: ["dcurl"]
      },
      "text/vnd.curl.mcurl": {
        source: "apache",
        extensions: ["mcurl"]
      },
      "text/vnd.curl.scurl": {
        source: "apache",
        extensions: ["scurl"]
      },
      "text/vnd.debian.copyright": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.dmclientscript": {
        source: "iana"
      },
      "text/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "text/vnd.esmertec.theme-descriptor": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.familysearch.gedcom": {
        source: "iana",
        extensions: ["ged"]
      },
      "text/vnd.ficlab.flt": {
        source: "iana"
      },
      "text/vnd.fly": {
        source: "iana",
        extensions: ["fly"]
      },
      "text/vnd.fmi.flexstor": {
        source: "iana",
        extensions: ["flx"]
      },
      "text/vnd.gml": {
        source: "iana"
      },
      "text/vnd.graphviz": {
        source: "iana",
        extensions: ["gv"]
      },
      "text/vnd.hans": {
        source: "iana"
      },
      "text/vnd.hgl": {
        source: "iana"
      },
      "text/vnd.in3d.3dml": {
        source: "iana",
        extensions: ["3dml"]
      },
      "text/vnd.in3d.spot": {
        source: "iana",
        extensions: ["spot"]
      },
      "text/vnd.iptc.newsml": {
        source: "iana"
      },
      "text/vnd.iptc.nitf": {
        source: "iana"
      },
      "text/vnd.latex-z": {
        source: "iana"
      },
      "text/vnd.motorola.reflex": {
        source: "iana"
      },
      "text/vnd.ms-mediapackage": {
        source: "iana"
      },
      "text/vnd.net2phone.commcenter.command": {
        source: "iana"
      },
      "text/vnd.radisys.msml-basic-layout": {
        source: "iana"
      },
      "text/vnd.senx.warpscript": {
        source: "iana"
      },
      "text/vnd.si.uricatalogue": {
        source: "iana"
      },
      "text/vnd.sosi": {
        source: "iana"
      },
      "text/vnd.sun.j2me.app-descriptor": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["jad"]
      },
      "text/vnd.trolltech.linguist": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.wap.si": {
        source: "iana"
      },
      "text/vnd.wap.sl": {
        source: "iana"
      },
      "text/vnd.wap.wml": {
        source: "iana",
        extensions: ["wml"]
      },
      "text/vnd.wap.wmlscript": {
        source: "iana",
        extensions: ["wmls"]
      },
      "text/vtt": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["vtt"]
      },
      "text/x-asm": {
        source: "apache",
        extensions: ["s", "asm"]
      },
      "text/x-c": {
        source: "apache",
        extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
      },
      "text/x-component": {
        source: "nginx",
        extensions: ["htc"]
      },
      "text/x-fortran": {
        source: "apache",
        extensions: ["f", "for", "f77", "f90"]
      },
      "text/x-gwt-rpc": {
        compressible: true
      },
      "text/x-handlebars-template": {
        extensions: ["hbs"]
      },
      "text/x-java-source": {
        source: "apache",
        extensions: ["java"]
      },
      "text/x-jquery-tmpl": {
        compressible: true
      },
      "text/x-lua": {
        extensions: ["lua"]
      },
      "text/x-markdown": {
        compressible: true,
        extensions: ["mkd"]
      },
      "text/x-nfo": {
        source: "apache",
        extensions: ["nfo"]
      },
      "text/x-opml": {
        source: "apache",
        extensions: ["opml"]
      },
      "text/x-org": {
        compressible: true,
        extensions: ["org"]
      },
      "text/x-pascal": {
        source: "apache",
        extensions: ["p", "pas"]
      },
      "text/x-processing": {
        compressible: true,
        extensions: ["pde"]
      },
      "text/x-sass": {
        extensions: ["sass"]
      },
      "text/x-scss": {
        extensions: ["scss"]
      },
      "text/x-setext": {
        source: "apache",
        extensions: ["etx"]
      },
      "text/x-sfv": {
        source: "apache",
        extensions: ["sfv"]
      },
      "text/x-suse-ymp": {
        compressible: true,
        extensions: ["ymp"]
      },
      "text/x-uuencode": {
        source: "apache",
        extensions: ["uu"]
      },
      "text/x-vcalendar": {
        source: "apache",
        extensions: ["vcs"]
      },
      "text/x-vcard": {
        source: "apache",
        extensions: ["vcf"]
      },
      "text/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml"]
      },
      "text/xml-external-parsed-entity": {
        source: "iana"
      },
      "text/yaml": {
        compressible: true,
        extensions: ["yaml", "yml"]
      },
      "video/1d-interleaved-parityfec": {
        source: "iana"
      },
      "video/3gpp": {
        source: "iana",
        extensions: ["3gp", "3gpp"]
      },
      "video/3gpp-tt": {
        source: "iana"
      },
      "video/3gpp2": {
        source: "iana",
        extensions: ["3g2"]
      },
      "video/av1": {
        source: "iana"
      },
      "video/bmpeg": {
        source: "iana"
      },
      "video/bt656": {
        source: "iana"
      },
      "video/celb": {
        source: "iana"
      },
      "video/dv": {
        source: "iana"
      },
      "video/encaprtp": {
        source: "iana"
      },
      "video/ffv1": {
        source: "iana"
      },
      "video/flexfec": {
        source: "iana"
      },
      "video/h261": {
        source: "iana",
        extensions: ["h261"]
      },
      "video/h263": {
        source: "iana",
        extensions: ["h263"]
      },
      "video/h263-1998": {
        source: "iana"
      },
      "video/h263-2000": {
        source: "iana"
      },
      "video/h264": {
        source: "iana",
        extensions: ["h264"]
      },
      "video/h264-rcdo": {
        source: "iana"
      },
      "video/h264-svc": {
        source: "iana"
      },
      "video/h265": {
        source: "iana"
      },
      "video/iso.segment": {
        source: "iana",
        extensions: ["m4s"]
      },
      "video/jpeg": {
        source: "iana",
        extensions: ["jpgv"]
      },
      "video/jpeg2000": {
        source: "iana"
      },
      "video/jpm": {
        source: "apache",
        extensions: ["jpm", "jpgm"]
      },
      "video/jxsv": {
        source: "iana"
      },
      "video/mj2": {
        source: "iana",
        extensions: ["mj2", "mjp2"]
      },
      "video/mp1s": {
        source: "iana"
      },
      "video/mp2p": {
        source: "iana"
      },
      "video/mp2t": {
        source: "iana",
        extensions: ["ts"]
      },
      "video/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["mp4", "mp4v", "mpg4"]
      },
      "video/mp4v-es": {
        source: "iana"
      },
      "video/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
      },
      "video/mpeg4-generic": {
        source: "iana"
      },
      "video/mpv": {
        source: "iana"
      },
      "video/nv": {
        source: "iana"
      },
      "video/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogv"]
      },
      "video/parityfec": {
        source: "iana"
      },
      "video/pointer": {
        source: "iana"
      },
      "video/quicktime": {
        source: "iana",
        compressible: false,
        extensions: ["qt", "mov"]
      },
      "video/raptorfec": {
        source: "iana"
      },
      "video/raw": {
        source: "iana"
      },
      "video/rtp-enc-aescm128": {
        source: "iana"
      },
      "video/rtploopback": {
        source: "iana"
      },
      "video/rtx": {
        source: "iana"
      },
      "video/scip": {
        source: "iana"
      },
      "video/smpte291": {
        source: "iana"
      },
      "video/smpte292m": {
        source: "iana"
      },
      "video/ulpfec": {
        source: "iana"
      },
      "video/vc1": {
        source: "iana"
      },
      "video/vc2": {
        source: "iana"
      },
      "video/vnd.cctv": {
        source: "iana"
      },
      "video/vnd.dece.hd": {
        source: "iana",
        extensions: ["uvh", "uvvh"]
      },
      "video/vnd.dece.mobile": {
        source: "iana",
        extensions: ["uvm", "uvvm"]
      },
      "video/vnd.dece.mp4": {
        source: "iana"
      },
      "video/vnd.dece.pd": {
        source: "iana",
        extensions: ["uvp", "uvvp"]
      },
      "video/vnd.dece.sd": {
        source: "iana",
        extensions: ["uvs", "uvvs"]
      },
      "video/vnd.dece.video": {
        source: "iana",
        extensions: ["uvv", "uvvv"]
      },
      "video/vnd.directv.mpeg": {
        source: "iana"
      },
      "video/vnd.directv.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dlna.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dvb.file": {
        source: "iana",
        extensions: ["dvb"]
      },
      "video/vnd.fvt": {
        source: "iana",
        extensions: ["fvt"]
      },
      "video/vnd.hns.video": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsavc": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsmpeg2": {
        source: "iana"
      },
      "video/vnd.motorola.video": {
        source: "iana"
      },
      "video/vnd.motorola.videop": {
        source: "iana"
      },
      "video/vnd.mpegurl": {
        source: "iana",
        extensions: ["mxu", "m4u"]
      },
      "video/vnd.ms-playready.media.pyv": {
        source: "iana",
        extensions: ["pyv"]
      },
      "video/vnd.nokia.interleaved-multimedia": {
        source: "iana"
      },
      "video/vnd.nokia.mp4vr": {
        source: "iana"
      },
      "video/vnd.nokia.videovoip": {
        source: "iana"
      },
      "video/vnd.objectvideo": {
        source: "iana"
      },
      "video/vnd.radgamettools.bink": {
        source: "iana"
      },
      "video/vnd.radgamettools.smacker": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg1": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg4": {
        source: "iana"
      },
      "video/vnd.sealed.swf": {
        source: "iana"
      },
      "video/vnd.sealedmedia.softseal.mov": {
        source: "iana"
      },
      "video/vnd.uvvu.mp4": {
        source: "iana",
        extensions: ["uvu", "uvvu"]
      },
      "video/vnd.vivo": {
        source: "iana",
        extensions: ["viv"]
      },
      "video/vnd.youtube.yt": {
        source: "iana"
      },
      "video/vp8": {
        source: "iana"
      },
      "video/vp9": {
        source: "iana"
      },
      "video/webm": {
        source: "apache",
        compressible: false,
        extensions: ["webm"]
      },
      "video/x-f4v": {
        source: "apache",
        extensions: ["f4v"]
      },
      "video/x-fli": {
        source: "apache",
        extensions: ["fli"]
      },
      "video/x-flv": {
        source: "apache",
        compressible: false,
        extensions: ["flv"]
      },
      "video/x-m4v": {
        source: "apache",
        extensions: ["m4v"]
      },
      "video/x-matroska": {
        source: "apache",
        compressible: false,
        extensions: ["mkv", "mk3d", "mks"]
      },
      "video/x-mng": {
        source: "apache",
        extensions: ["mng"]
      },
      "video/x-ms-asf": {
        source: "apache",
        extensions: ["asf", "asx"]
      },
      "video/x-ms-vob": {
        source: "apache",
        extensions: ["vob"]
      },
      "video/x-ms-wm": {
        source: "apache",
        extensions: ["wm"]
      },
      "video/x-ms-wmv": {
        source: "apache",
        compressible: false,
        extensions: ["wmv"]
      },
      "video/x-ms-wmx": {
        source: "apache",
        extensions: ["wmx"]
      },
      "video/x-ms-wvx": {
        source: "apache",
        extensions: ["wvx"]
      },
      "video/x-msvideo": {
        source: "apache",
        extensions: ["avi"]
      },
      "video/x-sgi-movie": {
        source: "apache",
        extensions: ["movie"]
      },
      "video/x-smv": {
        source: "apache",
        extensions: ["smv"]
      },
      "x-conference/x-cooltalk": {
        source: "apache",
        extensions: ["ice"]
      },
      "x-shader/x-fragment": {
        compressible: true
      },
      "x-shader/x-vertex": {
        compressible: true
      }
    };
  }
});

// ../../node_modules/mime-db/index.js
var require_mime_db = __commonJS({
  "../../node_modules/mime-db/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_db();
  }
});

// ../../node_modules/mime-types/index.js
var require_mime_types = __commonJS({
  "../../node_modules/mime-types/index.js"(exports2) {
    "use strict";
    var db = require_mime_db();
    var extname = require("path").extname;
    var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
    var TEXT_TYPE_REGEXP = /^text\//i;
    exports2.charset = charset;
    exports2.charsets = { lookup: charset };
    exports2.contentType = contentType;
    exports2.extension = extension;
    exports2.extensions = /* @__PURE__ */ Object.create(null);
    exports2.lookup = lookup;
    exports2.types = /* @__PURE__ */ Object.create(null);
    populateMaps(exports2.extensions, exports2.types);
    function charset(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var mime = match && db[match[1].toLowerCase()];
      if (mime && mime.charset) {
        return mime.charset;
      }
      if (match && TEXT_TYPE_REGEXP.test(match[1])) {
        return "UTF-8";
      }
      return false;
    }
    function contentType(str) {
      if (!str || typeof str !== "string") {
        return false;
      }
      var mime = str.indexOf("/") === -1 ? exports2.lookup(str) : str;
      if (!mime) {
        return false;
      }
      if (mime.indexOf("charset") === -1) {
        var charset2 = exports2.charset(mime);
        if (charset2) mime += "; charset=" + charset2.toLowerCase();
      }
      return mime;
    }
    function extension(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var exts = match && exports2.extensions[match[1].toLowerCase()];
      if (!exts || !exts.length) {
        return false;
      }
      return exts[0];
    }
    function lookup(path11) {
      if (!path11 || typeof path11 !== "string") {
        return false;
      }
      var extension2 = extname("x." + path11).toLowerCase().substr(1);
      if (!extension2) {
        return false;
      }
      return exports2.types[extension2] || false;
    }
    function populateMaps(extensions, types) {
      var preference = ["nginx", "apache", void 0, "iana"];
      Object.keys(db).forEach(function forEachMimeType(type) {
        var mime = db[type];
        var exts = mime.extensions;
        if (!exts || !exts.length) {
          return;
        }
        extensions[type] = exts;
        for (var i = 0; i < exts.length; i++) {
          var extension2 = exts[i];
          if (types[extension2]) {
            var from = preference.indexOf(db[types[extension2]].source);
            var to = preference.indexOf(mime.source);
            if (types[extension2] !== "application/octet-stream" && (from > to || from === to && types[extension2].substr(0, 12) === "application/")) {
              continue;
            }
          }
          types[extension2] = type;
        }
      });
    }
  }
});

// ../../node_modules/asynckit/lib/defer.js
var require_defer = __commonJS({
  "../../node_modules/asynckit/lib/defer.js"(exports2, module2) {
    "use strict";
    module2.exports = defer;
    function defer(fn) {
      var nextTick = typeof setImmediate == "function" ? setImmediate : typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : null;
      if (nextTick) {
        nextTick(fn);
      } else {
        setTimeout(fn, 0);
      }
    }
  }
});

// ../../node_modules/asynckit/lib/async.js
var require_async = __commonJS({
  "../../node_modules/asynckit/lib/async.js"(exports2, module2) {
    "use strict";
    var defer = require_defer();
    module2.exports = async;
    function async(callback2) {
      var isAsync2 = false;
      defer(function() {
        isAsync2 = true;
      });
      return function async_callback(err, result) {
        if (isAsync2) {
          callback2(err, result);
        } else {
          defer(function nextTick_callback() {
            callback2(err, result);
          });
        }
      };
    }
  }
});

// ../../node_modules/asynckit/lib/abort.js
var require_abort = __commonJS({
  "../../node_modules/asynckit/lib/abort.js"(exports2, module2) {
    "use strict";
    module2.exports = abort;
    function abort(state) {
      Object.keys(state.jobs).forEach(clean.bind(state));
      state.jobs = {};
    }
    function clean(key) {
      if (typeof this.jobs[key] == "function") {
        this.jobs[key]();
      }
    }
  }
});

// ../../node_modules/asynckit/lib/iterate.js
var require_iterate = __commonJS({
  "../../node_modules/asynckit/lib/iterate.js"(exports2, module2) {
    "use strict";
    var async = require_async();
    var abort = require_abort();
    module2.exports = iterate;
    function iterate(list, iterator, state, callback2) {
      var key = state["keyedList"] ? state["keyedList"][state.index] : state.index;
      state.jobs[key] = runJob(iterator, key, list[key], function(error, output) {
        if (!(key in state.jobs)) {
          return;
        }
        delete state.jobs[key];
        if (error) {
          abort(state);
        } else {
          state.results[key] = output;
        }
        callback2(error, state.results);
      });
    }
    function runJob(iterator, key, item, callback2) {
      var aborter;
      if (iterator.length == 2) {
        aborter = iterator(item, async(callback2));
      } else {
        aborter = iterator(item, key, async(callback2));
      }
      return aborter;
    }
  }
});

// ../../node_modules/asynckit/lib/state.js
var require_state = __commonJS({
  "../../node_modules/asynckit/lib/state.js"(exports2, module2) {
    "use strict";
    module2.exports = state;
    function state(list, sortMethod) {
      var isNamedList = !Array.isArray(list), initState = {
        index: 0,
        keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
        jobs: {},
        results: isNamedList ? {} : [],
        size: isNamedList ? Object.keys(list).length : list.length
      };
      if (sortMethod) {
        initState.keyedList.sort(isNamedList ? sortMethod : function(a, b) {
          return sortMethod(list[a], list[b]);
        });
      }
      return initState;
    }
  }
});

// ../../node_modules/asynckit/lib/terminator.js
var require_terminator = __commonJS({
  "../../node_modules/asynckit/lib/terminator.js"(exports2, module2) {
    "use strict";
    var abort = require_abort();
    var async = require_async();
    module2.exports = terminator;
    function terminator(callback2) {
      if (!Object.keys(this.jobs).length) {
        return;
      }
      this.index = this.size;
      abort(this);
      async(callback2)(null, this.results);
    }
  }
});

// ../../node_modules/asynckit/parallel.js
var require_parallel = __commonJS({
  "../../node_modules/asynckit/parallel.js"(exports2, module2) {
    "use strict";
    var iterate = require_iterate();
    var initState = require_state();
    var terminator = require_terminator();
    module2.exports = parallel;
    function parallel(list, iterator, callback2) {
      var state = initState(list);
      while (state.index < (state["keyedList"] || list).length) {
        iterate(list, iterator, state, function(error, result) {
          if (error) {
            callback2(error, result);
            return;
          }
          if (Object.keys(state.jobs).length === 0) {
            callback2(null, state.results);
            return;
          }
        });
        state.index++;
      }
      return terminator.bind(state, callback2);
    }
  }
});

// ../../node_modules/asynckit/serialOrdered.js
var require_serialOrdered = __commonJS({
  "../../node_modules/asynckit/serialOrdered.js"(exports2, module2) {
    "use strict";
    var iterate = require_iterate();
    var initState = require_state();
    var terminator = require_terminator();
    module2.exports = serialOrdered;
    module2.exports.ascending = ascending;
    module2.exports.descending = descending;
    function serialOrdered(list, iterator, sortMethod, callback2) {
      var state = initState(list, sortMethod);
      iterate(list, iterator, state, function iteratorHandler(error, result) {
        if (error) {
          callback2(error, result);
          return;
        }
        state.index++;
        if (state.index < (state["keyedList"] || list).length) {
          iterate(list, iterator, state, iteratorHandler);
          return;
        }
        callback2(null, state.results);
      });
      return terminator.bind(state, callback2);
    }
    function ascending(a, b) {
      return a < b ? -1 : a > b ? 1 : 0;
    }
    function descending(a, b) {
      return -1 * ascending(a, b);
    }
  }
});

// ../../node_modules/asynckit/serial.js
var require_serial = __commonJS({
  "../../node_modules/asynckit/serial.js"(exports2, module2) {
    "use strict";
    var serialOrdered = require_serialOrdered();
    module2.exports = serial;
    function serial(list, iterator, callback2) {
      return serialOrdered(list, iterator, null, callback2);
    }
  }
});

// ../../node_modules/asynckit/index.js
var require_asynckit = __commonJS({
  "../../node_modules/asynckit/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      parallel: require_parallel(),
      serial: require_serial(),
      serialOrdered: require_serialOrdered()
    };
  }
});

// ../../node_modules/es-object-atoms/index.js
var require_es_object_atoms = __commonJS({
  "../../node_modules/es-object-atoms/index.js"(exports2, module2) {
    "use strict";
    module2.exports = Object;
  }
});

// ../../node_modules/es-errors/index.js
var require_es_errors = __commonJS({
  "../../node_modules/es-errors/index.js"(exports2, module2) {
    "use strict";
    module2.exports = Error;
  }
});

// ../../node_modules/es-errors/eval.js
var require_eval = __commonJS({
  "../../node_modules/es-errors/eval.js"(exports2, module2) {
    "use strict";
    module2.exports = EvalError;
  }
});

// ../../node_modules/es-errors/range.js
var require_range = __commonJS({
  "../../node_modules/es-errors/range.js"(exports2, module2) {
    "use strict";
    module2.exports = RangeError;
  }
});

// ../../node_modules/es-errors/ref.js
var require_ref = __commonJS({
  "../../node_modules/es-errors/ref.js"(exports2, module2) {
    "use strict";
    module2.exports = ReferenceError;
  }
});

// ../../node_modules/es-errors/syntax.js
var require_syntax = __commonJS({
  "../../node_modules/es-errors/syntax.js"(exports2, module2) {
    "use strict";
    module2.exports = SyntaxError;
  }
});

// ../../node_modules/es-errors/type.js
var require_type = __commonJS({
  "../../node_modules/es-errors/type.js"(exports2, module2) {
    "use strict";
    module2.exports = TypeError;
  }
});

// ../../node_modules/es-errors/uri.js
var require_uri = __commonJS({
  "../../node_modules/es-errors/uri.js"(exports2, module2) {
    "use strict";
    module2.exports = URIError;
  }
});

// ../../node_modules/math-intrinsics/abs.js
var require_abs = __commonJS({
  "../../node_modules/math-intrinsics/abs.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.abs;
  }
});

// ../../node_modules/math-intrinsics/floor.js
var require_floor = __commonJS({
  "../../node_modules/math-intrinsics/floor.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.floor;
  }
});

// ../../node_modules/math-intrinsics/max.js
var require_max = __commonJS({
  "../../node_modules/math-intrinsics/max.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.max;
  }
});

// ../../node_modules/math-intrinsics/min.js
var require_min = __commonJS({
  "../../node_modules/math-intrinsics/min.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.min;
  }
});

// ../../node_modules/math-intrinsics/pow.js
var require_pow = __commonJS({
  "../../node_modules/math-intrinsics/pow.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.pow;
  }
});

// ../../node_modules/math-intrinsics/round.js
var require_round = __commonJS({
  "../../node_modules/math-intrinsics/round.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.round;
  }
});

// ../../node_modules/math-intrinsics/isNaN.js
var require_isNaN = __commonJS({
  "../../node_modules/math-intrinsics/isNaN.js"(exports2, module2) {
    "use strict";
    module2.exports = Number.isNaN || function isNaN2(a) {
      return a !== a;
    };
  }
});

// ../../node_modules/math-intrinsics/sign.js
var require_sign = __commonJS({
  "../../node_modules/math-intrinsics/sign.js"(exports2, module2) {
    "use strict";
    var $isNaN = require_isNaN();
    module2.exports = function sign(number) {
      if ($isNaN(number) || number === 0) {
        return number;
      }
      return number < 0 ? -1 : 1;
    };
  }
});

// ../../node_modules/gopd/gOPD.js
var require_gOPD = __commonJS({
  "../../node_modules/gopd/gOPD.js"(exports2, module2) {
    "use strict";
    module2.exports = Object.getOwnPropertyDescriptor;
  }
});

// ../../node_modules/gopd/index.js
var require_gopd = __commonJS({
  "../../node_modules/gopd/index.js"(exports2, module2) {
    "use strict";
    var $gOPD = require_gOPD();
    if ($gOPD) {
      try {
        $gOPD([], "length");
      } catch (e) {
        $gOPD = null;
      }
    }
    module2.exports = $gOPD;
  }
});

// ../../node_modules/es-define-property/index.js
var require_es_define_property = __commonJS({
  "../../node_modules/es-define-property/index.js"(exports2, module2) {
    "use strict";
    var $defineProperty = Object.defineProperty || false;
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e) {
        $defineProperty = false;
      }
    }
    module2.exports = $defineProperty;
  }
});

// ../../node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  "../../node_modules/has-symbols/shams.js"(exports2, module2) {
    "use strict";
    module2.exports = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = /* @__PURE__ */ Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (var _ in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = (
          /** @type {PropertyDescriptor} */
          Object.getOwnPropertyDescriptor(obj, sym)
        );
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  }
});

// ../../node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  "../../node_modules/has-symbols/index.js"(exports2, module2) {
    "use strict";
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module2.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof /* @__PURE__ */ Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
  }
});

// ../../node_modules/get-proto/Reflect.getPrototypeOf.js
var require_Reflect_getPrototypeOf = __commonJS({
  "../../node_modules/get-proto/Reflect.getPrototypeOf.js"(exports2, module2) {
    "use strict";
    module2.exports = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
  }
});

// ../../node_modules/get-proto/Object.getPrototypeOf.js
var require_Object_getPrototypeOf = __commonJS({
  "../../node_modules/get-proto/Object.getPrototypeOf.js"(exports2, module2) {
    "use strict";
    var $Object = require_es_object_atoms();
    module2.exports = $Object.getPrototypeOf || null;
  }
});

// ../../node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "../../node_modules/function-bind/implementation.js"(exports2, module2) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var toStr = Object.prototype.toString;
    var max = Math.max;
    var funcType = "[object Function]";
    var concatty = function concatty2(a, b) {
      var arr = [];
      for (var i = 0; i < a.length; i += 1) {
        arr[i] = a[i];
      }
      for (var j = 0; j < b.length; j += 1) {
        arr[j + a.length] = b[j];
      }
      return arr;
    };
    var slicy = function slicy2(arrLike, offset) {
      var arr = [];
      for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr[j] = arrLike[i];
      }
      return arr;
    };
    var joiny = function(arr, joiner) {
      var str = "";
      for (var i = 0; i < arr.length; i += 1) {
        str += arr[i];
        if (i + 1 < arr.length) {
          str += joiner;
        }
      }
      return str;
    };
    module2.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slicy(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            concatty(args, arguments)
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        }
        return target.apply(
          that,
          concatty(args, arguments)
        );
      };
      var boundLength = max(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = "$" + i;
      }
      bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// ../../node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "../../node_modules/function-bind/index.js"(exports2, module2) {
    "use strict";
    var implementation = require_implementation();
    module2.exports = Function.prototype.bind || implementation;
  }
});

// ../../node_modules/call-bind-apply-helpers/functionCall.js
var require_functionCall = __commonJS({
  "../../node_modules/call-bind-apply-helpers/functionCall.js"(exports2, module2) {
    "use strict";
    module2.exports = Function.prototype.call;
  }
});

// ../../node_modules/call-bind-apply-helpers/functionApply.js
var require_functionApply = __commonJS({
  "../../node_modules/call-bind-apply-helpers/functionApply.js"(exports2, module2) {
    "use strict";
    module2.exports = Function.prototype.apply;
  }
});

// ../../node_modules/call-bind-apply-helpers/reflectApply.js
var require_reflectApply = __commonJS({
  "../../node_modules/call-bind-apply-helpers/reflectApply.js"(exports2, module2) {
    "use strict";
    module2.exports = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
  }
});

// ../../node_modules/call-bind-apply-helpers/actualApply.js
var require_actualApply = __commonJS({
  "../../node_modules/call-bind-apply-helpers/actualApply.js"(exports2, module2) {
    "use strict";
    var bind = require_function_bind();
    var $apply = require_functionApply();
    var $call = require_functionCall();
    var $reflectApply = require_reflectApply();
    module2.exports = $reflectApply || bind.call($call, $apply);
  }
});

// ../../node_modules/call-bind-apply-helpers/index.js
var require_call_bind_apply_helpers = __commonJS({
  "../../node_modules/call-bind-apply-helpers/index.js"(exports2, module2) {
    "use strict";
    var bind = require_function_bind();
    var $TypeError = require_type();
    var $call = require_functionCall();
    var $actualApply = require_actualApply();
    module2.exports = function callBindBasic(args) {
      if (args.length < 1 || typeof args[0] !== "function") {
        throw new $TypeError("a function is required");
      }
      return $actualApply(bind, $call, args);
    };
  }
});

// ../../node_modules/dunder-proto/get.js
var require_get = __commonJS({
  "../../node_modules/dunder-proto/get.js"(exports2, module2) {
    "use strict";
    var callBind = require_call_bind_apply_helpers();
    var gOPD = require_gopd();
    var hasProtoAccessor;
    try {
      hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */
      [].__proto__ === Array.prototype;
    } catch (e) {
      if (!e || typeof e !== "object" || !("code" in e) || e.code !== "ERR_PROTO_ACCESS") {
        throw e;
      }
    }
    var desc = !!hasProtoAccessor && gOPD && gOPD(
      Object.prototype,
      /** @type {keyof typeof Object.prototype} */
      "__proto__"
    );
    var $Object = Object;
    var $getPrototypeOf = $Object.getPrototypeOf;
    module2.exports = desc && typeof desc.get === "function" ? callBind([desc.get]) : typeof $getPrototypeOf === "function" ? (
      /** @type {import('./get')} */
      function getDunder(value) {
        return $getPrototypeOf(value == null ? value : $Object(value));
      }
    ) : false;
  }
});

// ../../node_modules/get-proto/index.js
var require_get_proto = __commonJS({
  "../../node_modules/get-proto/index.js"(exports2, module2) {
    "use strict";
    var reflectGetProto = require_Reflect_getPrototypeOf();
    var originalGetProto = require_Object_getPrototypeOf();
    var getDunderProto = require_get();
    module2.exports = reflectGetProto ? function getProto(O) {
      return reflectGetProto(O);
    } : originalGetProto ? function getProto(O) {
      if (!O || typeof O !== "object" && typeof O !== "function") {
        throw new TypeError("getProto: not an object");
      }
      return originalGetProto(O);
    } : getDunderProto ? function getProto(O) {
      return getDunderProto(O);
    } : null;
  }
});

// ../../node_modules/hasown/index.js
var require_hasown = __commonJS({
  "../../node_modules/hasown/index.js"(exports2, module2) {
    "use strict";
    var call = Function.prototype.call;
    var $hasOwn = Object.prototype.hasOwnProperty;
    var bind = require_function_bind();
    module2.exports = bind.call(call, $hasOwn);
  }
});

// ../../node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  "../../node_modules/get-intrinsic/index.js"(exports2, module2) {
    "use strict";
    var undefined2;
    var $Object = require_es_object_atoms();
    var $Error = require_es_errors();
    var $EvalError = require_eval();
    var $RangeError = require_range();
    var $ReferenceError = require_ref();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var $URIError = require_uri();
    var abs = require_abs();
    var floor = require_floor();
    var max = require_max();
    var min = require_min();
    var pow = require_pow();
    var round = require_round();
    var sign = require_sign();
    var $Function = Function;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e) {
      }
    };
    var $gOPD = require_gopd();
    var $defineProperty = require_es_define_property();
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? (function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    })() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var getProto = require_get_proto();
    var $ObjectGPO = require_Object_getPrototypeOf();
    var $ReflectGPO = require_Reflect_getPrototypeOf();
    var $apply = require_functionApply();
    var $call = require_functionCall();
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      __proto__: null,
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": $Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": $EvalError,
      "%Float16Array%": typeof Float16Array === "undefined" ? undefined2 : Float16Array,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": $Object,
      "%Object.getOwnPropertyDescriptor%": $gOPD,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": $RangeError,
      "%ReferenceError%": $ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": $URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet,
      "%Function.prototype.call%": $call,
      "%Function.prototype.apply%": $apply,
      "%Object.defineProperty%": $defineProperty,
      "%Object.getPrototypeOf%": $ObjectGPO,
      "%Math.abs%": abs,
      "%Math.floor%": floor,
      "%Math.max%": max,
      "%Math.min%": min,
      "%Math.pow%": pow,
      "%Math.round%": round,
      "%Math.sign%": sign,
      "%Reflect.getPrototypeOf%": $ReflectGPO
    };
    if (getProto) {
      try {
        null.error;
      } catch (e) {
        errorProto = getProto(getProto(e));
        INTRINSICS["%Error.prototype%"] = errorProto;
      }
    }
    var errorProto;
    var doEval = function doEval2(name) {
      var value;
      if (name === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen && getProto) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      __proto__: null,
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = require_function_bind();
    var hasOwn = require_hasown();
    var $concat = bind.call($call, Array.prototype.concat);
    var $spliceApply = bind.call($apply, Array.prototype.splice);
    var $replace = bind.call($call, String.prototype.replace);
    var $strSlice = bind.call($call, String.prototype.slice);
    var $exec = bind.call($call, RegExp.prototype.exec);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string) {
      var first2 = $strSlice(string, 0, 1);
      var last2 = $strSlice(string, -1);
      if (first2 === "%" && last2 !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last2 === "%" && first2 !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
      var intrinsicName = name;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name + " does not exist!");
    };
    module2.exports = function GetIntrinsic(name, allowMissing) {
      if (typeof name !== "string" || name.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath(name);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i = 1, isOwn = true; i < parts.length; i += 1) {
        var part = parts[i];
        var first2 = $strSlice(part, 0, 1);
        var last2 = $strSlice(part, -1);
        if ((first2 === '"' || first2 === "'" || first2 === "`" || (last2 === '"' || last2 === "'" || last2 === "`")) && first2 !== last2) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
            }
            return void undefined2;
          }
          if ($gOPD && i + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
  }
});

// ../../node_modules/has-tostringtag/shams.js
var require_shams2 = __commonJS({
  "../../node_modules/has-tostringtag/shams.js"(exports2, module2) {
    "use strict";
    var hasSymbols = require_shams();
    module2.exports = function hasToStringTagShams() {
      return hasSymbols() && !!Symbol.toStringTag;
    };
  }
});

// ../../node_modules/es-set-tostringtag/index.js
var require_es_set_tostringtag = __commonJS({
  "../../node_modules/es-set-tostringtag/index.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
    var hasToStringTag = require_shams2()();
    var hasOwn = require_hasown();
    var $TypeError = require_type();
    var toStringTag = hasToStringTag ? Symbol.toStringTag : null;
    module2.exports = function setToStringTag(object, value) {
      var overrideIfSet = arguments.length > 2 && !!arguments[2] && arguments[2].force;
      var nonConfigurable = arguments.length > 2 && !!arguments[2] && arguments[2].nonConfigurable;
      if (typeof overrideIfSet !== "undefined" && typeof overrideIfSet !== "boolean" || typeof nonConfigurable !== "undefined" && typeof nonConfigurable !== "boolean") {
        throw new $TypeError("if provided, the `overrideIfSet` and `nonConfigurable` options must be booleans");
      }
      if (toStringTag && (overrideIfSet || !hasOwn(object, toStringTag))) {
        if ($defineProperty) {
          $defineProperty(object, toStringTag, {
            configurable: !nonConfigurable,
            enumerable: false,
            value,
            writable: false
          });
        } else {
          object[toStringTag] = value;
        }
      }
    };
  }
});

// ../../node_modules/form-data/lib/populate.js
var require_populate = __commonJS({
  "../../node_modules/form-data/lib/populate.js"(exports2, module2) {
    "use strict";
    module2.exports = function(dst, src) {
      Object.keys(src).forEach(function(prop) {
        dst[prop] = dst[prop] || src[prop];
      });
      return dst;
    };
  }
});

// ../../node_modules/form-data/lib/form_data.js
var require_form_data = __commonJS({
  "../../node_modules/form-data/lib/form_data.js"(exports2, module2) {
    "use strict";
    var CombinedStream = require_combined_stream();
    var util2 = require("util");
    var path11 = require("path");
    var http = require("http");
    var https = require("https");
    var parseUrl = require("url").parse;
    var fs10 = require("fs");
    var Stream = require("stream").Stream;
    var crypto2 = require("crypto");
    var mime = require_mime_types();
    var asynckit = require_asynckit();
    var setToStringTag = require_es_set_tostringtag();
    var hasOwn = require_hasown();
    var populate = require_populate();
    function FormData2(options) {
      if (!(this instanceof FormData2)) {
        return new FormData2(options);
      }
      this._overheadLength = 0;
      this._valueLength = 0;
      this._valuesToMeasure = [];
      CombinedStream.call(this);
      options = options || {};
      for (var option in options) {
        this[option] = options[option];
      }
    }
    util2.inherits(FormData2, CombinedStream);
    FormData2.LINE_BREAK = "\r\n";
    FormData2.DEFAULT_CONTENT_TYPE = "application/octet-stream";
    FormData2.prototype.append = function(field, value, options) {
      options = options || {};
      if (typeof options === "string") {
        options = { filename: options };
      }
      var append2 = CombinedStream.prototype.append.bind(this);
      if (typeof value === "number" || value == null) {
        value = String(value);
      }
      if (Array.isArray(value)) {
        this._error(new Error("Arrays are not supported."));
        return;
      }
      var header = this._multiPartHeader(field, value, options);
      var footer = this._multiPartFooter();
      append2(header);
      append2(value);
      append2(footer);
      this._trackLength(header, value, options);
    };
    FormData2.prototype._trackLength = function(header, value, options) {
      var valueLength = 0;
      if (options.knownLength != null) {
        valueLength += Number(options.knownLength);
      } else if (Buffer.isBuffer(value)) {
        valueLength = value.length;
      } else if (typeof value === "string") {
        valueLength = Buffer.byteLength(value);
      }
      this._valueLength += valueLength;
      this._overheadLength += Buffer.byteLength(header) + FormData2.LINE_BREAK.length;
      if (!value || !value.path && !(value.readable && hasOwn(value, "httpVersion")) && !(value instanceof Stream)) {
        return;
      }
      if (!options.knownLength) {
        this._valuesToMeasure.push(value);
      }
    };
    FormData2.prototype._lengthRetriever = function(value, callback2) {
      if (hasOwn(value, "fd")) {
        if (value.end != void 0 && value.end != Infinity && value.start != void 0) {
          callback2(null, value.end + 1 - (value.start ? value.start : 0));
        } else {
          fs10.stat(value.path, function(err, stat3) {
            if (err) {
              callback2(err);
              return;
            }
            var fileSize = stat3.size - (value.start ? value.start : 0);
            callback2(null, fileSize);
          });
        }
      } else if (hasOwn(value, "httpVersion")) {
        callback2(null, Number(value.headers["content-length"]));
      } else if (hasOwn(value, "httpModule")) {
        value.on("response", function(response) {
          value.pause();
          callback2(null, Number(response.headers["content-length"]));
        });
        value.resume();
      } else {
        callback2("Unknown stream");
      }
    };
    FormData2.prototype._multiPartHeader = function(field, value, options) {
      if (typeof options.header === "string") {
        return options.header;
      }
      var contentDisposition = this._getContentDisposition(value, options);
      var contentType = this._getContentType(value, options);
      var contents = "";
      var headers = {
        // add custom disposition as third element or keep it two elements if not
        "Content-Disposition": ["form-data", 'name="' + field + '"'].concat(contentDisposition || []),
        // if no content type. allow it to be empty array
        "Content-Type": [].concat(contentType || [])
      };
      if (typeof options.header === "object") {
        populate(headers, options.header);
      }
      var header;
      for (var prop in headers) {
        if (hasOwn(headers, prop)) {
          header = headers[prop];
          if (header == null) {
            continue;
          }
          if (!Array.isArray(header)) {
            header = [header];
          }
          if (header.length) {
            contents += prop + ": " + header.join("; ") + FormData2.LINE_BREAK;
          }
        }
      }
      return "--" + this.getBoundary() + FormData2.LINE_BREAK + contents + FormData2.LINE_BREAK;
    };
    FormData2.prototype._getContentDisposition = function(value, options) {
      var filename;
      if (typeof options.filepath === "string") {
        filename = path11.normalize(options.filepath).replace(/\\/g, "/");
      } else if (options.filename || value && (value.name || value.path)) {
        filename = path11.basename(options.filename || value && (value.name || value.path));
      } else if (value && value.readable && hasOwn(value, "httpVersion")) {
        filename = path11.basename(value.client._httpMessage.path || "");
      }
      if (filename) {
        return 'filename="' + filename + '"';
      }
    };
    FormData2.prototype._getContentType = function(value, options) {
      var contentType = options.contentType;
      if (!contentType && value && value.name) {
        contentType = mime.lookup(value.name);
      }
      if (!contentType && value && value.path) {
        contentType = mime.lookup(value.path);
      }
      if (!contentType && value && value.readable && hasOwn(value, "httpVersion")) {
        contentType = value.headers["content-type"];
      }
      if (!contentType && (options.filepath || options.filename)) {
        contentType = mime.lookup(options.filepath || options.filename);
      }
      if (!contentType && value && typeof value === "object") {
        contentType = FormData2.DEFAULT_CONTENT_TYPE;
      }
      return contentType;
    };
    FormData2.prototype._multiPartFooter = function() {
      return function(next) {
        var footer = FormData2.LINE_BREAK;
        var lastPart = this._streams.length === 0;
        if (lastPart) {
          footer += this._lastBoundary();
        }
        next(footer);
      }.bind(this);
    };
    FormData2.prototype._lastBoundary = function() {
      return "--" + this.getBoundary() + "--" + FormData2.LINE_BREAK;
    };
    FormData2.prototype.getHeaders = function(userHeaders) {
      var header;
      var formHeaders = {
        "content-type": "multipart/form-data; boundary=" + this.getBoundary()
      };
      for (header in userHeaders) {
        if (hasOwn(userHeaders, header)) {
          formHeaders[header.toLowerCase()] = userHeaders[header];
        }
      }
      return formHeaders;
    };
    FormData2.prototype.setBoundary = function(boundary) {
      if (typeof boundary !== "string") {
        throw new TypeError("FormData boundary must be a string");
      }
      this._boundary = boundary;
    };
    FormData2.prototype.getBoundary = function() {
      if (!this._boundary) {
        this._generateBoundary();
      }
      return this._boundary;
    };
    FormData2.prototype.getBuffer = function() {
      var dataBuffer = new Buffer.alloc(0);
      var boundary = this.getBoundary();
      for (var i = 0, len = this._streams.length; i < len; i++) {
        if (typeof this._streams[i] !== "function") {
          if (Buffer.isBuffer(this._streams[i])) {
            dataBuffer = Buffer.concat([dataBuffer, this._streams[i]]);
          } else {
            dataBuffer = Buffer.concat([dataBuffer, Buffer.from(this._streams[i])]);
          }
          if (typeof this._streams[i] !== "string" || this._streams[i].substring(2, boundary.length + 2) !== boundary) {
            dataBuffer = Buffer.concat([dataBuffer, Buffer.from(FormData2.LINE_BREAK)]);
          }
        }
      }
      return Buffer.concat([dataBuffer, Buffer.from(this._lastBoundary())]);
    };
    FormData2.prototype._generateBoundary = function() {
      this._boundary = "--------------------------" + crypto2.randomBytes(12).toString("hex");
    };
    FormData2.prototype.getLengthSync = function() {
      var knownLength = this._overheadLength + this._valueLength;
      if (this._streams.length) {
        knownLength += this._lastBoundary().length;
      }
      if (!this.hasKnownLength()) {
        this._error(new Error("Cannot calculate proper length in synchronous way."));
      }
      return knownLength;
    };
    FormData2.prototype.hasKnownLength = function() {
      var hasKnownLength = true;
      if (this._valuesToMeasure.length) {
        hasKnownLength = false;
      }
      return hasKnownLength;
    };
    FormData2.prototype.getLength = function(cb) {
      var knownLength = this._overheadLength + this._valueLength;
      if (this._streams.length) {
        knownLength += this._lastBoundary().length;
      }
      if (!this._valuesToMeasure.length) {
        process.nextTick(cb.bind(this, null, knownLength));
        return;
      }
      asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
        if (err) {
          cb(err);
          return;
        }
        values.forEach(function(length) {
          knownLength += length;
        });
        cb(null, knownLength);
      });
    };
    FormData2.prototype.submit = function(params, cb) {
      var request;
      var options;
      var defaults = { method: "post" };
      if (typeof params === "string") {
        params = parseUrl(params);
        options = populate({
          port: params.port,
          path: params.pathname,
          host: params.hostname,
          protocol: params.protocol
        }, defaults);
      } else {
        options = populate(params, defaults);
        if (!options.port) {
          options.port = options.protocol === "https:" ? 443 : 80;
        }
      }
      options.headers = this.getHeaders(params.headers);
      if (options.protocol === "https:") {
        request = https.request(options);
      } else {
        request = http.request(options);
      }
      this.getLength(function(err, length) {
        if (err && err !== "Unknown stream") {
          this._error(err);
          return;
        }
        if (length) {
          request.setHeader("Content-Length", length);
        }
        this.pipe(request);
        if (cb) {
          var onResponse;
          var callback2 = function(error, responce) {
            request.removeListener("error", callback2);
            request.removeListener("response", onResponse);
            return cb.call(this, error, responce);
          };
          onResponse = callback2.bind(this, null);
          request.on("error", callback2);
          request.on("response", onResponse);
        }
      }.bind(this));
      return request;
    };
    FormData2.prototype._error = function(err) {
      if (!this.error) {
        this.error = err;
        this.pause();
        this.emit("error", err);
      }
    };
    FormData2.prototype.toString = function() {
      return "[object FormData]";
    };
    setToStringTag(FormData2.prototype, "FormData");
    module2.exports = FormData2;
  }
});

// ../../node_modules/proxy-from-env/index.js
var require_proxy_from_env = __commonJS({
  "../../node_modules/proxy-from-env/index.js"(exports2) {
    "use strict";
    var parseUrl = require("url").parse;
    var DEFAULT_PORTS = {
      ftp: 21,
      gopher: 70,
      http: 80,
      https: 443,
      ws: 80,
      wss: 443
    };
    var stringEndsWith = String.prototype.endsWith || function(s) {
      return s.length <= this.length && this.indexOf(s, this.length - s.length) !== -1;
    };
    function getProxyForUrl(url) {
      var parsedUrl = typeof url === "string" ? parseUrl(url) : url || {};
      var proto = parsedUrl.protocol;
      var hostname = parsedUrl.host;
      var port = parsedUrl.port;
      if (typeof hostname !== "string" || !hostname || typeof proto !== "string") {
        return "";
      }
      proto = proto.split(":", 1)[0];
      hostname = hostname.replace(/:\d*$/, "");
      port = parseInt(port) || DEFAULT_PORTS[proto] || 0;
      if (!shouldProxy(hostname, port)) {
        return "";
      }
      var proxy = getEnv("npm_config_" + proto + "_proxy") || getEnv(proto + "_proxy") || getEnv("npm_config_proxy") || getEnv("all_proxy");
      if (proxy && proxy.indexOf("://") === -1) {
        proxy = proto + "://" + proxy;
      }
      return proxy;
    }
    function shouldProxy(hostname, port) {
      var NO_PROXY = (getEnv("npm_config_no_proxy") || getEnv("no_proxy")).toLowerCase();
      if (!NO_PROXY) {
        return true;
      }
      if (NO_PROXY === "*") {
        return false;
      }
      return NO_PROXY.split(/[,\s]/).every(function(proxy) {
        if (!proxy) {
          return true;
        }
        var parsedProxy = proxy.match(/^(.+):(\d+)$/);
        var parsedProxyHostname = parsedProxy ? parsedProxy[1] : proxy;
        var parsedProxyPort = parsedProxy ? parseInt(parsedProxy[2]) : 0;
        if (parsedProxyPort && parsedProxyPort !== port) {
          return true;
        }
        if (!/^[.*]/.test(parsedProxyHostname)) {
          return hostname !== parsedProxyHostname;
        }
        if (parsedProxyHostname.charAt(0) === "*") {
          parsedProxyHostname = parsedProxyHostname.slice(1);
        }
        return !stringEndsWith.call(hostname, parsedProxyHostname);
      });
    }
    function getEnv(key) {
      return process.env[key.toLowerCase()] || process.env[key.toUpperCase()] || "";
    }
    exports2.getProxyForUrl = getProxyForUrl;
  }
});

// ../../node_modules/ms/index.js
var require_ms = __commonJS({
  "../../node_modules/ms/index.js"(exports2, module2) {
    "use strict";
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse2(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse2(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// ../../node_modules/debug/src/common.js
var require_common = __commonJS({
  "../../node_modules/debug/src/common.js"(exports2, module2) {
    "use strict";
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce2;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug2(...args) {
          if (!debug2.enabled) {
            return;
          }
          const self2 = debug2;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug2.namespace = namespace;
        debug2.useColors = createDebug.useColors();
        debug2.color = createDebug.selectColor(namespace);
        debug2.extend = extend;
        debug2.destroy = createDebug.destroy;
        Object.defineProperty(debug2, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug2);
        }
        return debug2;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
        for (const ns of split) {
          if (ns[0] === "-") {
            createDebug.skips.push(ns.slice(1));
          } else {
            createDebug.names.push(ns);
          }
        }
      }
      function matchesTemplate(search, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while (searchIndex < search.length) {
          if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
            if (template[templateIndex] === "*") {
              starIndex = templateIndex;
              matchIndex = searchIndex;
              templateIndex++;
            } else {
              searchIndex++;
              templateIndex++;
            }
          } else if (starIndex !== -1) {
            templateIndex = starIndex + 1;
            matchIndex++;
            searchIndex = matchIndex;
          } else {
            return false;
          }
        }
        while (templateIndex < template.length && template[templateIndex] === "*") {
          templateIndex++;
        }
        return templateIndex === template.length;
      }
      function disable() {
        const namespaces = [
          ...createDebug.names,
          ...createDebug.skips.map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        for (const skip of createDebug.skips) {
          if (matchesTemplate(name, skip)) {
            return false;
          }
        }
        for (const ns of createDebug.names) {
          if (matchesTemplate(name, ns)) {
            return true;
          }
        }
        return false;
      }
      function coerce2(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// ../../node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "../../node_modules/debug/src/browser.js"(exports2, module2) {
    "use strict";
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports2.storage.getItem("debug") || exports2.storage.getItem("DEBUG");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// ../../node_modules/debug/src/node.js
var require_node = __commonJS({
  "../../node_modules/debug/src/node.js"(exports2, module2) {
    "use strict";
    var tty = require("tty");
    var util2 = require("util");
    exports2.init = init;
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.destroy = util2.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports2.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require("supports-color");
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util2.formatWithOptions(exports2.inspectOpts, ...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug2) {
      debug2.inspectOpts = {};
      const keys = Object.keys(exports2.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug2.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts);
    };
  }
});

// ../../node_modules/debug/src/index.js
var require_src = __commonJS({
  "../../node_modules/debug/src/index.js"(exports2, module2) {
    "use strict";
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node();
    }
  }
});

// ../../node_modules/follow-redirects/debug.js
var require_debug = __commonJS({
  "../../node_modules/follow-redirects/debug.js"(exports2, module2) {
    "use strict";
    var debug2;
    module2.exports = function() {
      if (!debug2) {
        try {
          debug2 = require_src()("follow-redirects");
        } catch (error) {
        }
        if (typeof debug2 !== "function") {
          debug2 = function() {
          };
        }
      }
      debug2.apply(null, arguments);
    };
  }
});

// ../../node_modules/follow-redirects/index.js
var require_follow_redirects = __commonJS({
  "../../node_modules/follow-redirects/index.js"(exports2, module2) {
    "use strict";
    var url = require("url");
    var URL2 = url.URL;
    var http = require("http");
    var https = require("https");
    var Writable = require("stream").Writable;
    var assert = require("assert");
    var debug2 = require_debug();
    (function detectUnsupportedEnvironment() {
      var looksLikeNode = typeof process !== "undefined";
      var looksLikeBrowser = typeof window !== "undefined" && typeof document !== "undefined";
      var looksLikeV8 = isFunction(Error.captureStackTrace);
      if (!looksLikeNode && (looksLikeBrowser || !looksLikeV8)) {
        console.warn("The follow-redirects package should be excluded from browser builds.");
      }
    })();
    var useNativeURL = false;
    try {
      assert(new URL2(""));
    } catch (error) {
      useNativeURL = error.code === "ERR_INVALID_URL";
    }
    var preservedUrlFields = [
      "auth",
      "host",
      "hostname",
      "href",
      "path",
      "pathname",
      "port",
      "protocol",
      "query",
      "search",
      "hash"
    ];
    var events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
    var eventHandlers = /* @__PURE__ */ Object.create(null);
    events.forEach(function(event) {
      eventHandlers[event] = function(arg1, arg2, arg3) {
        this._redirectable.emit(event, arg1, arg2, arg3);
      };
    });
    var InvalidUrlError = createErrorType(
      "ERR_INVALID_URL",
      "Invalid URL",
      TypeError
    );
    var RedirectionError = createErrorType(
      "ERR_FR_REDIRECTION_FAILURE",
      "Redirected request failed"
    );
    var TooManyRedirectsError = createErrorType(
      "ERR_FR_TOO_MANY_REDIRECTS",
      "Maximum number of redirects exceeded",
      RedirectionError
    );
    var MaxBodyLengthExceededError = createErrorType(
      "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
      "Request body larger than maxBodyLength limit"
    );
    var WriteAfterEndError = createErrorType(
      "ERR_STREAM_WRITE_AFTER_END",
      "write after end"
    );
    var destroy = Writable.prototype.destroy || noop;
    function RedirectableRequest(options, responseCallback) {
      Writable.call(this);
      this._sanitizeOptions(options);
      this._options = options;
      this._ended = false;
      this._ending = false;
      this._redirectCount = 0;
      this._redirects = [];
      this._requestBodyLength = 0;
      this._requestBodyBuffers = [];
      if (responseCallback) {
        this.on("response", responseCallback);
      }
      var self2 = this;
      this._onNativeResponse = function(response) {
        try {
          self2._processResponse(response);
        } catch (cause) {
          self2.emit("error", cause instanceof RedirectionError ? cause : new RedirectionError({ cause }));
        }
      };
      this._performRequest();
    }
    RedirectableRequest.prototype = Object.create(Writable.prototype);
    RedirectableRequest.prototype.abort = function() {
      destroyRequest(this._currentRequest);
      this._currentRequest.abort();
      this.emit("abort");
    };
    RedirectableRequest.prototype.destroy = function(error) {
      destroyRequest(this._currentRequest, error);
      destroy.call(this, error);
      return this;
    };
    RedirectableRequest.prototype.write = function(data, encoding, callback2) {
      if (this._ending) {
        throw new WriteAfterEndError();
      }
      if (!isString(data) && !isBuffer(data)) {
        throw new TypeError("data should be a string, Buffer or Uint8Array");
      }
      if (isFunction(encoding)) {
        callback2 = encoding;
        encoding = null;
      }
      if (data.length === 0) {
        if (callback2) {
          callback2();
        }
        return;
      }
      if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
        this._requestBodyLength += data.length;
        this._requestBodyBuffers.push({ data, encoding });
        this._currentRequest.write(data, encoding, callback2);
      } else {
        this.emit("error", new MaxBodyLengthExceededError());
        this.abort();
      }
    };
    RedirectableRequest.prototype.end = function(data, encoding, callback2) {
      if (isFunction(data)) {
        callback2 = data;
        data = encoding = null;
      } else if (isFunction(encoding)) {
        callback2 = encoding;
        encoding = null;
      }
      if (!data) {
        this._ended = this._ending = true;
        this._currentRequest.end(null, null, callback2);
      } else {
        var self2 = this;
        var currentRequest = this._currentRequest;
        this.write(data, encoding, function() {
          self2._ended = true;
          currentRequest.end(null, null, callback2);
        });
        this._ending = true;
      }
    };
    RedirectableRequest.prototype.setHeader = function(name, value) {
      this._options.headers[name] = value;
      this._currentRequest.setHeader(name, value);
    };
    RedirectableRequest.prototype.removeHeader = function(name) {
      delete this._options.headers[name];
      this._currentRequest.removeHeader(name);
    };
    RedirectableRequest.prototype.setTimeout = function(msecs, callback2) {
      var self2 = this;
      function destroyOnTimeout(socket) {
        socket.setTimeout(msecs);
        socket.removeListener("timeout", socket.destroy);
        socket.addListener("timeout", socket.destroy);
      }
      function startTimer(socket) {
        if (self2._timeout) {
          clearTimeout(self2._timeout);
        }
        self2._timeout = setTimeout(function() {
          self2.emit("timeout");
          clearTimer();
        }, msecs);
        destroyOnTimeout(socket);
      }
      function clearTimer() {
        if (self2._timeout) {
          clearTimeout(self2._timeout);
          self2._timeout = null;
        }
        self2.removeListener("abort", clearTimer);
        self2.removeListener("error", clearTimer);
        self2.removeListener("response", clearTimer);
        self2.removeListener("close", clearTimer);
        if (callback2) {
          self2.removeListener("timeout", callback2);
        }
        if (!self2.socket) {
          self2._currentRequest.removeListener("socket", startTimer);
        }
      }
      if (callback2) {
        this.on("timeout", callback2);
      }
      if (this.socket) {
        startTimer(this.socket);
      } else {
        this._currentRequest.once("socket", startTimer);
      }
      this.on("socket", destroyOnTimeout);
      this.on("abort", clearTimer);
      this.on("error", clearTimer);
      this.on("response", clearTimer);
      this.on("close", clearTimer);
      return this;
    };
    [
      "flushHeaders",
      "getHeader",
      "setNoDelay",
      "setSocketKeepAlive"
    ].forEach(function(method) {
      RedirectableRequest.prototype[method] = function(a, b) {
        return this._currentRequest[method](a, b);
      };
    });
    ["aborted", "connection", "socket"].forEach(function(property) {
      Object.defineProperty(RedirectableRequest.prototype, property, {
        get: function() {
          return this._currentRequest[property];
        }
      });
    });
    RedirectableRequest.prototype._sanitizeOptions = function(options) {
      if (!options.headers) {
        options.headers = {};
      }
      if (options.host) {
        if (!options.hostname) {
          options.hostname = options.host;
        }
        delete options.host;
      }
      if (!options.pathname && options.path) {
        var searchPos = options.path.indexOf("?");
        if (searchPos < 0) {
          options.pathname = options.path;
        } else {
          options.pathname = options.path.substring(0, searchPos);
          options.search = options.path.substring(searchPos);
        }
      }
    };
    RedirectableRequest.prototype._performRequest = function() {
      var protocol = this._options.protocol;
      var nativeProtocol = this._options.nativeProtocols[protocol];
      if (!nativeProtocol) {
        throw new TypeError("Unsupported protocol " + protocol);
      }
      if (this._options.agents) {
        var scheme = protocol.slice(0, -1);
        this._options.agent = this._options.agents[scheme];
      }
      var request = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
      request._redirectable = this;
      for (var event of events) {
        request.on(event, eventHandlers[event]);
      }
      this._currentUrl = /^\//.test(this._options.path) ? url.format(this._options) : (
        // When making a request to a proxy, []
        // a client MUST send the target URI in absolute-form [].
        this._options.path
      );
      if (this._isRedirect) {
        var i = 0;
        var self2 = this;
        var buffers = this._requestBodyBuffers;
        (function writeNext(error) {
          if (request === self2._currentRequest) {
            if (error) {
              self2.emit("error", error);
            } else if (i < buffers.length) {
              var buffer = buffers[i++];
              if (!request.finished) {
                request.write(buffer.data, buffer.encoding, writeNext);
              }
            } else if (self2._ended) {
              request.end();
            }
          }
        })();
      }
    };
    RedirectableRequest.prototype._processResponse = function(response) {
      var statusCode = response.statusCode;
      if (this._options.trackRedirects) {
        this._redirects.push({
          url: this._currentUrl,
          headers: response.headers,
          statusCode
        });
      }
      var location = response.headers.location;
      if (!location || this._options.followRedirects === false || statusCode < 300 || statusCode >= 400) {
        response.responseUrl = this._currentUrl;
        response.redirects = this._redirects;
        this.emit("response", response);
        this._requestBodyBuffers = [];
        return;
      }
      destroyRequest(this._currentRequest);
      response.destroy();
      if (++this._redirectCount > this._options.maxRedirects) {
        throw new TooManyRedirectsError();
      }
      var requestHeaders;
      var beforeRedirect = this._options.beforeRedirect;
      if (beforeRedirect) {
        requestHeaders = Object.assign({
          // The Host header was set by nativeProtocol.request
          Host: response.req.getHeader("host")
        }, this._options.headers);
      }
      var method = this._options.method;
      if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || // RFC72316.4.4: The 303 (See Other) status code indicates that
      // the server is redirecting the user agent to a different resource []
      // A user agent can perform a retrieval request targeting that URI
      // (a GET or HEAD request if using HTTP) []
      statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
        this._options.method = "GET";
        this._requestBodyBuffers = [];
        removeMatchingHeaders(/^content-/i, this._options.headers);
      }
      var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);
      var currentUrlParts = parseUrl(this._currentUrl);
      var currentHost = currentHostHeader || currentUrlParts.host;
      var currentUrl = /^\w+:/.test(location) ? this._currentUrl : url.format(Object.assign(currentUrlParts, { host: currentHost }));
      var redirectUrl = resolveUrl(location, currentUrl);
      debug2("redirecting to", redirectUrl.href);
      this._isRedirect = true;
      spreadUrlObject(redirectUrl, this._options);
      if (redirectUrl.protocol !== currentUrlParts.protocol && redirectUrl.protocol !== "https:" || redirectUrl.host !== currentHost && !isSubdomain(redirectUrl.host, currentHost)) {
        removeMatchingHeaders(/^(?:(?:proxy-)?authorization|cookie)$/i, this._options.headers);
      }
      if (isFunction(beforeRedirect)) {
        var responseDetails = {
          headers: response.headers,
          statusCode
        };
        var requestDetails = {
          url: currentUrl,
          method,
          headers: requestHeaders
        };
        beforeRedirect(this._options, responseDetails, requestDetails);
        this._sanitizeOptions(this._options);
      }
      this._performRequest();
    };
    function wrap(protocols) {
      var exports3 = {
        maxRedirects: 21,
        maxBodyLength: 10 * 1024 * 1024
      };
      var nativeProtocols = {};
      Object.keys(protocols).forEach(function(scheme) {
        var protocol = scheme + ":";
        var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
        var wrappedProtocol = exports3[scheme] = Object.create(nativeProtocol);
        function request(input, options, callback2) {
          if (isURL(input)) {
            input = spreadUrlObject(input);
          } else if (isString(input)) {
            input = spreadUrlObject(parseUrl(input));
          } else {
            callback2 = options;
            options = validateUrl(input);
            input = { protocol };
          }
          if (isFunction(options)) {
            callback2 = options;
            options = null;
          }
          options = Object.assign({
            maxRedirects: exports3.maxRedirects,
            maxBodyLength: exports3.maxBodyLength
          }, input, options);
          options.nativeProtocols = nativeProtocols;
          if (!isString(options.host) && !isString(options.hostname)) {
            options.hostname = "::1";
          }
          assert.equal(options.protocol, protocol, "protocol mismatch");
          debug2("options", options);
          return new RedirectableRequest(options, callback2);
        }
        function get(input, options, callback2) {
          var wrappedRequest = wrappedProtocol.request(input, options, callback2);
          wrappedRequest.end();
          return wrappedRequest;
        }
        Object.defineProperties(wrappedProtocol, {
          request: { value: request, configurable: true, enumerable: true, writable: true },
          get: { value: get, configurable: true, enumerable: true, writable: true }
        });
      });
      return exports3;
    }
    function noop() {
    }
    function parseUrl(input) {
      var parsed;
      if (useNativeURL) {
        parsed = new URL2(input);
      } else {
        parsed = validateUrl(url.parse(input));
        if (!isString(parsed.protocol)) {
          throw new InvalidUrlError({ input });
        }
      }
      return parsed;
    }
    function resolveUrl(relative6, base) {
      return useNativeURL ? new URL2(relative6, base) : parseUrl(url.resolve(base, relative6));
    }
    function validateUrl(input) {
      if (/^\[/.test(input.hostname) && !/^\[[:0-9a-f]+\]$/i.test(input.hostname)) {
        throw new InvalidUrlError({ input: input.href || input });
      }
      if (/^\[/.test(input.host) && !/^\[[:0-9a-f]+\](:\d+)?$/i.test(input.host)) {
        throw new InvalidUrlError({ input: input.href || input });
      }
      return input;
    }
    function spreadUrlObject(urlObject, target) {
      var spread = target || {};
      for (var key of preservedUrlFields) {
        spread[key] = urlObject[key];
      }
      if (spread.hostname.startsWith("[")) {
        spread.hostname = spread.hostname.slice(1, -1);
      }
      if (spread.port !== "") {
        spread.port = Number(spread.port);
      }
      spread.path = spread.search ? spread.pathname + spread.search : spread.pathname;
      return spread;
    }
    function removeMatchingHeaders(regex, headers) {
      var lastValue;
      for (var header in headers) {
        if (regex.test(header)) {
          lastValue = headers[header];
          delete headers[header];
        }
      }
      return lastValue === null || typeof lastValue === "undefined" ? void 0 : String(lastValue).trim();
    }
    function createErrorType(code, message, baseClass) {
      function CustomError(properties) {
        if (isFunction(Error.captureStackTrace)) {
          Error.captureStackTrace(this, this.constructor);
        }
        Object.assign(this, properties || {});
        this.code = code;
        this.message = this.cause ? message + ": " + this.cause.message : message;
      }
      CustomError.prototype = new (baseClass || Error)();
      Object.defineProperties(CustomError.prototype, {
        constructor: {
          value: CustomError,
          enumerable: false
        },
        name: {
          value: "Error [" + code + "]",
          enumerable: false
        }
      });
      return CustomError;
    }
    function destroyRequest(request, error) {
      for (var event of events) {
        request.removeListener(event, eventHandlers[event]);
      }
      request.on("error", noop);
      request.destroy(error);
    }
    function isSubdomain(subdomain, domain) {
      assert(isString(subdomain) && isString(domain));
      var dot = subdomain.length - domain.length - 1;
      return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
    }
    function isString(value) {
      return typeof value === "string" || value instanceof String;
    }
    function isFunction(value) {
      return typeof value === "function";
    }
    function isBuffer(value) {
      return typeof value === "object" && "length" in value;
    }
    function isURL(value) {
      return URL2 && value instanceof URL2;
    }
    module2.exports = wrap({ http, https });
    module2.exports.wrap = wrap;
  }
});

// ../../node_modules/axios/dist/node/axios.cjs
var require_axios = __commonJS({
  "../../node_modules/axios/dist/node/axios.cjs"(exports2, module2) {
    "use strict";
    var FormData$1 = require_form_data();
    var crypto2 = require("crypto");
    var url = require("url");
    var proxyFromEnv = require_proxy_from_env();
    var http = require("http");
    var https = require("https");
    var http2 = require("http2");
    var util2 = require("util");
    var followRedirects = require_follow_redirects();
    var zlib = require("zlib");
    var stream = require("stream");
    var events = require("events");
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var FormData__default = /* @__PURE__ */ _interopDefaultLegacy(FormData$1);
    var crypto__default = /* @__PURE__ */ _interopDefaultLegacy(crypto2);
    var url__default = /* @__PURE__ */ _interopDefaultLegacy(url);
    var proxyFromEnv__default = /* @__PURE__ */ _interopDefaultLegacy(proxyFromEnv);
    var http__default = /* @__PURE__ */ _interopDefaultLegacy(http);
    var https__default = /* @__PURE__ */ _interopDefaultLegacy(https);
    var http2__default = /* @__PURE__ */ _interopDefaultLegacy(http2);
    var util__default = /* @__PURE__ */ _interopDefaultLegacy(util2);
    var followRedirects__default = /* @__PURE__ */ _interopDefaultLegacy(followRedirects);
    var zlib__default = /* @__PURE__ */ _interopDefaultLegacy(zlib);
    var stream__default = /* @__PURE__ */ _interopDefaultLegacy(stream);
    function bind(fn, thisArg) {
      return function wrap() {
        return fn.apply(thisArg, arguments);
      };
    }
    var { toString } = Object.prototype;
    var { getPrototypeOf } = Object;
    var { iterator, toStringTag } = Symbol;
    var kindOf = /* @__PURE__ */ ((cache2) => (thing) => {
      const str = toString.call(thing);
      return cache2[str] || (cache2[str] = str.slice(8, -1).toLowerCase());
    })(/* @__PURE__ */ Object.create(null));
    var kindOfTest = (type) => {
      type = type.toLowerCase();
      return (thing) => kindOf(thing) === type;
    };
    var typeOfTest = (type) => (thing) => typeof thing === type;
    var { isArray } = Array;
    var isUndefined = typeOfTest("undefined");
    function isBuffer(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction$1(val.constructor.isBuffer) && val.constructor.isBuffer(val);
    }
    var isArrayBuffer = kindOfTest("ArrayBuffer");
    function isArrayBufferView(val) {
      let result;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
      } else {
        result = val && val.buffer && isArrayBuffer(val.buffer);
      }
      return result;
    }
    var isString = typeOfTest("string");
    var isFunction$1 = typeOfTest("function");
    var isNumber = typeOfTest("number");
    var isObject = (thing) => thing !== null && typeof thing === "object";
    var isBoolean = (thing) => thing === true || thing === false;
    var isPlainObject = (val) => {
      if (kindOf(val) !== "object") {
        return false;
      }
      const prototype2 = getPrototypeOf(val);
      return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(toStringTag in val) && !(iterator in val);
    };
    var isEmptyObject = (val) => {
      if (!isObject(val) || isBuffer(val)) {
        return false;
      }
      try {
        return Object.keys(val).length === 0 && Object.getPrototypeOf(val) === Object.prototype;
      } catch (e) {
        return false;
      }
    };
    var isDate = kindOfTest("Date");
    var isFile = kindOfTest("File");
    var isBlob = kindOfTest("Blob");
    var isFileList = kindOfTest("FileList");
    var isStream = (val) => isObject(val) && isFunction$1(val.pipe);
    var isFormData = (thing) => {
      let kind;
      return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction$1(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
      kind === "object" && isFunction$1(thing.toString) && thing.toString() === "[object FormData]"));
    };
    var isURLSearchParams = kindOfTest("URLSearchParams");
    var [isReadableStream, isRequest2, isResponse2, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
    var trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
    function forEach2(obj, fn, { allOwnKeys = false } = {}) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      let i;
      let l;
      if (typeof obj !== "object") {
        obj = [obj];
      }
      if (isArray(obj)) {
        for (i = 0, l = obj.length; i < l; i++) {
          fn.call(null, obj[i], i, obj);
        }
      } else {
        if (isBuffer(obj)) {
          return;
        }
        const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
        const len = keys.length;
        let key;
        for (i = 0; i < len; i++) {
          key = keys[i];
          fn.call(null, obj[key], key, obj);
        }
      }
    }
    function findKey(obj, key) {
      if (isBuffer(obj)) {
        return null;
      }
      key = key.toLowerCase();
      const keys = Object.keys(obj);
      let i = keys.length;
      let _key;
      while (i-- > 0) {
        _key = keys[i];
        if (key === _key.toLowerCase()) {
          return _key;
        }
      }
      return null;
    }
    var _global = (() => {
      if (typeof globalThis !== "undefined") return globalThis;
      return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
    })();
    var isContextDefined = (context) => !isUndefined(context) && context !== _global;
    function merge() {
      const { caseless, skipUndefined } = isContextDefined(this) && this || {};
      const result = {};
      const assignValue = (val, key) => {
        const targetKey = caseless && findKey(result, key) || key;
        if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
          result[targetKey] = merge(result[targetKey], val);
        } else if (isPlainObject(val)) {
          result[targetKey] = merge({}, val);
        } else if (isArray(val)) {
          result[targetKey] = val.slice();
        } else if (!skipUndefined || !isUndefined(val)) {
          result[targetKey] = val;
        }
      };
      for (let i = 0, l = arguments.length; i < l; i++) {
        arguments[i] && forEach2(arguments[i], assignValue);
      }
      return result;
    }
    var extend = (a, b, thisArg, { allOwnKeys } = {}) => {
      forEach2(b, (val, key) => {
        if (thisArg && isFunction$1(val)) {
          a[key] = bind(val, thisArg);
        } else {
          a[key] = val;
        }
      }, { allOwnKeys });
      return a;
    };
    var stripBOM = (content) => {
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    };
    var inherits = (constructor, superConstructor, props, descriptors2) => {
      constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
      constructor.prototype.constructor = constructor;
      Object.defineProperty(constructor, "super", {
        value: superConstructor.prototype
      });
      props && Object.assign(constructor.prototype, props);
    };
    var toFlatObject = (sourceObj, destObj, filter, propFilter) => {
      let props;
      let i;
      let prop;
      const merged = {};
      destObj = destObj || {};
      if (sourceObj == null) return destObj;
      do {
        props = Object.getOwnPropertyNames(sourceObj);
        i = props.length;
        while (i-- > 0) {
          prop = props[i];
          if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
            destObj[prop] = sourceObj[prop];
            merged[prop] = true;
          }
        }
        sourceObj = filter !== false && getPrototypeOf(sourceObj);
      } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
      return destObj;
    };
    var endsWith = (str, searchString, position) => {
      str = String(str);
      if (position === void 0 || position > str.length) {
        position = str.length;
      }
      position -= searchString.length;
      const lastIndex = str.indexOf(searchString, position);
      return lastIndex !== -1 && lastIndex === position;
    };
    var toArray = (thing) => {
      if (!thing) return null;
      if (isArray(thing)) return thing;
      let i = thing.length;
      if (!isNumber(i)) return null;
      const arr = new Array(i);
      while (i-- > 0) {
        arr[i] = thing[i];
      }
      return arr;
    };
    var isTypedArray = /* @__PURE__ */ ((TypedArray) => {
      return (thing) => {
        return TypedArray && thing instanceof TypedArray;
      };
    })(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
    var forEachEntry = (obj, fn) => {
      const generator = obj && obj[iterator];
      const _iterator = generator.call(obj);
      let result;
      while ((result = _iterator.next()) && !result.done) {
        const pair = result.value;
        fn.call(obj, pair[0], pair[1]);
      }
    };
    var matchAll = (regExp, str) => {
      let matches;
      const arr = [];
      while ((matches = regExp.exec(str)) !== null) {
        arr.push(matches);
      }
      return arr;
    };
    var isHTMLForm = kindOfTest("HTMLFormElement");
    var toCamelCase = (str) => {
      return str.toLowerCase().replace(
        /[-_\s]([a-z\d])(\w*)/g,
        function replacer(m, p1, p2) {
          return p1.toUpperCase() + p2;
        }
      );
    };
    var hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
    var isRegExp = kindOfTest("RegExp");
    var reduceDescriptors = (obj, reducer) => {
      const descriptors2 = Object.getOwnPropertyDescriptors(obj);
      const reducedDescriptors = {};
      forEach2(descriptors2, (descriptor, name) => {
        let ret;
        if ((ret = reducer(descriptor, name, obj)) !== false) {
          reducedDescriptors[name] = ret || descriptor;
        }
      });
      Object.defineProperties(obj, reducedDescriptors);
    };
    var freezeMethods = (obj) => {
      reduceDescriptors(obj, (descriptor, name) => {
        if (isFunction$1(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
          return false;
        }
        const value = obj[name];
        if (!isFunction$1(value)) return;
        descriptor.enumerable = false;
        if ("writable" in descriptor) {
          descriptor.writable = false;
          return;
        }
        if (!descriptor.set) {
          descriptor.set = () => {
            throw Error("Can not rewrite read-only method '" + name + "'");
          };
        }
      });
    };
    var toObjectSet = (arrayOrString, delimiter) => {
      const obj = {};
      const define = (arr) => {
        arr.forEach((value) => {
          obj[value] = true;
        });
      };
      isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
      return obj;
    };
    var noop = () => {
    };
    var toFiniteNumber = (value, defaultValue) => {
      return value != null && Number.isFinite(value = +value) ? value : defaultValue;
    };
    function isSpecCompliantForm(thing) {
      return !!(thing && isFunction$1(thing.append) && thing[toStringTag] === "FormData" && thing[iterator]);
    }
    var toJSONObject = (obj) => {
      const stack = new Array(10);
      const visit = (source, i) => {
        if (isObject(source)) {
          if (stack.indexOf(source) >= 0) {
            return;
          }
          if (isBuffer(source)) {
            return source;
          }
          if (!("toJSON" in source)) {
            stack[i] = source;
            const target = isArray(source) ? [] : {};
            forEach2(source, (value, key) => {
              const reducedValue = visit(value, i + 1);
              !isUndefined(reducedValue) && (target[key] = reducedValue);
            });
            stack[i] = void 0;
            return target;
          }
        }
        return source;
      };
      return visit(obj, 0);
    };
    var isAsyncFn = kindOfTest("AsyncFunction");
    var isThenable = (thing) => thing && (isObject(thing) || isFunction$1(thing)) && isFunction$1(thing.then) && isFunction$1(thing.catch);
    var _setImmediate = ((setImmediateSupported, postMessageSupported) => {
      if (setImmediateSupported) {
        return setImmediate;
      }
      return postMessageSupported ? ((token, callbacks) => {
        _global.addEventListener("message", ({ source, data }) => {
          if (source === _global && data === token) {
            callbacks.length && callbacks.shift()();
          }
        }, false);
        return (cb) => {
          callbacks.push(cb);
          _global.postMessage(token, "*");
        };
      })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
    })(
      typeof setImmediate === "function",
      isFunction$1(_global.postMessage)
    );
    var asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
    var isIterable = (thing) => thing != null && isFunction$1(thing[iterator]);
    var utils$1 = {
      isArray,
      isArrayBuffer,
      isBuffer,
      isFormData,
      isArrayBufferView,
      isString,
      isNumber,
      isBoolean,
      isObject,
      isPlainObject,
      isEmptyObject,
      isReadableStream,
      isRequest: isRequest2,
      isResponse: isResponse2,
      isHeaders,
      isUndefined,
      isDate,
      isFile,
      isBlob,
      isRegExp,
      isFunction: isFunction$1,
      isStream,
      isURLSearchParams,
      isTypedArray,
      isFileList,
      forEach: forEach2,
      merge,
      extend,
      trim,
      stripBOM,
      inherits,
      toFlatObject,
      kindOf,
      kindOfTest,
      endsWith,
      toArray,
      forEachEntry,
      matchAll,
      isHTMLForm,
      hasOwnProperty,
      hasOwnProp: hasOwnProperty,
      // an alias to avoid ESLint no-prototype-builtins detection
      reduceDescriptors,
      freezeMethods,
      toObjectSet,
      toCamelCase,
      noop,
      toFiniteNumber,
      findKey,
      global: _global,
      isContextDefined,
      isSpecCompliantForm,
      toJSONObject,
      isAsyncFn,
      isThenable,
      setImmediate: _setImmediate,
      asap,
      isIterable
    };
    function AxiosError(message, code, config, request, response) {
      Error.call(this);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      } else {
        this.stack = new Error().stack;
      }
      this.message = message;
      this.name = "AxiosError";
      code && (this.code = code);
      config && (this.config = config);
      request && (this.request = request);
      if (response) {
        this.response = response;
        this.status = response.status ? response.status : null;
      }
    }
    utils$1.inherits(AxiosError, Error, {
      toJSON: function toJSON() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: utils$1.toJSONObject(this.config),
          code: this.code,
          status: this.status
        };
      }
    });
    var prototype$1 = AxiosError.prototype;
    var descriptors = {};
    [
      "ERR_BAD_OPTION_VALUE",
      "ERR_BAD_OPTION",
      "ECONNABORTED",
      "ETIMEDOUT",
      "ERR_NETWORK",
      "ERR_FR_TOO_MANY_REDIRECTS",
      "ERR_DEPRECATED",
      "ERR_BAD_RESPONSE",
      "ERR_BAD_REQUEST",
      "ERR_CANCELED",
      "ERR_NOT_SUPPORT",
      "ERR_INVALID_URL"
      // eslint-disable-next-line func-names
    ].forEach((code) => {
      descriptors[code] = { value: code };
    });
    Object.defineProperties(AxiosError, descriptors);
    Object.defineProperty(prototype$1, "isAxiosError", { value: true });
    AxiosError.from = (error, code, config, request, response, customProps) => {
      const axiosError = Object.create(prototype$1);
      utils$1.toFlatObject(error, axiosError, function filter(obj) {
        return obj !== Error.prototype;
      }, (prop) => {
        return prop !== "isAxiosError";
      });
      const msg = error && error.message ? error.message : "Error";
      const errCode = code == null && error ? error.code : code;
      AxiosError.call(axiosError, msg, errCode, config, request, response);
      if (error && axiosError.cause == null) {
        Object.defineProperty(axiosError, "cause", { value: error, configurable: true });
      }
      axiosError.name = error && error.name || "Error";
      customProps && Object.assign(axiosError, customProps);
      return axiosError;
    };
    function isVisitable(thing) {
      return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
    }
    function removeBrackets(key) {
      return utils$1.endsWith(key, "[]") ? key.slice(0, -2) : key;
    }
    function renderKey(path11, key, dots) {
      if (!path11) return key;
      return path11.concat(key).map(function each(token, i) {
        token = removeBrackets(token);
        return !dots && i ? "[" + token + "]" : token;
      }).join(dots ? "." : "");
    }
    function isFlatArray(arr) {
      return utils$1.isArray(arr) && !arr.some(isVisitable);
    }
    var predicates = utils$1.toFlatObject(utils$1, {}, null, function filter(prop) {
      return /^is[A-Z]/.test(prop);
    });
    function toFormData(obj, formData, options) {
      if (!utils$1.isObject(obj)) {
        throw new TypeError("target must be an object");
      }
      formData = formData || new (FormData__default["default"] || FormData)();
      options = utils$1.toFlatObject(options, {
        metaTokens: true,
        dots: false,
        indexes: false
      }, false, function defined(option, source) {
        return !utils$1.isUndefined(source[option]);
      });
      const metaTokens = options.metaTokens;
      const visitor = options.visitor || defaultVisitor;
      const dots = options.dots;
      const indexes = options.indexes;
      const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
      const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);
      if (!utils$1.isFunction(visitor)) {
        throw new TypeError("visitor must be a function");
      }
      function convertValue(value) {
        if (value === null) return "";
        if (utils$1.isDate(value)) {
          return value.toISOString();
        }
        if (utils$1.isBoolean(value)) {
          return value.toString();
        }
        if (!useBlob && utils$1.isBlob(value)) {
          throw new AxiosError("Blob is not supported. Use a Buffer instead.");
        }
        if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {
          return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
        }
        return value;
      }
      function defaultVisitor(value, key, path11) {
        let arr = value;
        if (value && !path11 && typeof value === "object") {
          if (utils$1.endsWith(key, "{}")) {
            key = metaTokens ? key : key.slice(0, -2);
            value = JSON.stringify(value);
          } else if (utils$1.isArray(value) && isFlatArray(value) || (utils$1.isFileList(value) || utils$1.endsWith(key, "[]")) && (arr = utils$1.toArray(value))) {
            key = removeBrackets(key);
            arr.forEach(function each(el, index) {
              !(utils$1.isUndefined(el) || el === null) && formData.append(
                // eslint-disable-next-line no-nested-ternary
                indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
                convertValue(el)
              );
            });
            return false;
          }
        }
        if (isVisitable(value)) {
          return true;
        }
        formData.append(renderKey(path11, key, dots), convertValue(value));
        return false;
      }
      const stack = [];
      const exposedHelpers = Object.assign(predicates, {
        defaultVisitor,
        convertValue,
        isVisitable
      });
      function build2(value, path11) {
        if (utils$1.isUndefined(value)) return;
        if (stack.indexOf(value) !== -1) {
          throw Error("Circular reference detected in " + path11.join("."));
        }
        stack.push(value);
        utils$1.forEach(value, function each(el, key) {
          const result = !(utils$1.isUndefined(el) || el === null) && visitor.call(
            formData,
            el,
            utils$1.isString(key) ? key.trim() : key,
            path11,
            exposedHelpers
          );
          if (result === true) {
            build2(el, path11 ? path11.concat(key) : [key]);
          }
        });
        stack.pop();
      }
      if (!utils$1.isObject(obj)) {
        throw new TypeError("data must be an object");
      }
      build2(obj);
      return formData;
    }
    function encode$1(str) {
      const charMap = {
        "!": "%21",
        "'": "%27",
        "(": "%28",
        ")": "%29",
        "~": "%7E",
        "%20": "+",
        "%00": "\0"
      };
      return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
        return charMap[match];
      });
    }
    function AxiosURLSearchParams(params, options) {
      this._pairs = [];
      params && toFormData(params, this, options);
    }
    var prototype = AxiosURLSearchParams.prototype;
    prototype.append = function append2(name, value) {
      this._pairs.push([name, value]);
    };
    prototype.toString = function toString2(encoder) {
      const _encode = encoder ? function(value) {
        return encoder.call(this, value, encode$1);
      } : encode$1;
      return this._pairs.map(function each(pair) {
        return _encode(pair[0]) + "=" + _encode(pair[1]);
      }, "").join("&");
    };
    function encode(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+");
    }
    function buildURL(url2, params, options) {
      if (!params) {
        return url2;
      }
      const _encode = options && options.encode || encode;
      if (utils$1.isFunction(options)) {
        options = {
          serialize: options
        };
      }
      const serializeFn = options && options.serialize;
      let serializedParams;
      if (serializeFn) {
        serializedParams = serializeFn(params, options);
      } else {
        serializedParams = utils$1.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
      }
      if (serializedParams) {
        const hashmarkIndex = url2.indexOf("#");
        if (hashmarkIndex !== -1) {
          url2 = url2.slice(0, hashmarkIndex);
        }
        url2 += (url2.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url2;
    }
    var InterceptorManager = class {
      constructor() {
        this.handlers = [];
      }
      /**
       * Add a new interceptor to the stack
       *
       * @param {Function} fulfilled The function to handle `then` for a `Promise`
       * @param {Function} rejected The function to handle `reject` for a `Promise`
       *
       * @return {Number} An ID used to remove interceptor later
       */
      use(fulfilled, rejected, options) {
        this.handlers.push({
          fulfilled,
          rejected,
          synchronous: options ? options.synchronous : false,
          runWhen: options ? options.runWhen : null
        });
        return this.handlers.length - 1;
      }
      /**
       * Remove an interceptor from the stack
       *
       * @param {Number} id The ID that was returned by `use`
       *
       * @returns {void}
       */
      eject(id) {
        if (this.handlers[id]) {
          this.handlers[id] = null;
        }
      }
      /**
       * Clear all interceptors from the stack
       *
       * @returns {void}
       */
      clear() {
        if (this.handlers) {
          this.handlers = [];
        }
      }
      /**
       * Iterate over all the registered interceptors
       *
       * This method is particularly useful for skipping over any
       * interceptors that may have become `null` calling `eject`.
       *
       * @param {Function} fn The function to call for each interceptor
       *
       * @returns {void}
       */
      forEach(fn) {
        utils$1.forEach(this.handlers, function forEachHandler(h) {
          if (h !== null) {
            fn(h);
          }
        });
      }
    };
    var InterceptorManager$1 = InterceptorManager;
    var transitionalDefaults = {
      silentJSONParsing: true,
      forcedJSONParsing: true,
      clarifyTimeoutError: false
    };
    var URLSearchParams = url__default["default"].URLSearchParams;
    var ALPHA = "abcdefghijklmnopqrstuvwxyz";
    var DIGIT = "0123456789";
    var ALPHABET = {
      DIGIT,
      ALPHA,
      ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
    };
    var generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
      let str = "";
      const { length } = alphabet;
      const randomValues = new Uint32Array(size);
      crypto__default["default"].randomFillSync(randomValues);
      for (let i = 0; i < size; i++) {
        str += alphabet[randomValues[i] % length];
      }
      return str;
    };
    var platform$1 = {
      isNode: true,
      classes: {
        URLSearchParams,
        FormData: FormData__default["default"],
        Blob: typeof Blob !== "undefined" && Blob || null
      },
      ALPHABET,
      generateString,
      protocols: ["http", "https", "file", "data"]
    };
    var hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
    var _navigator = typeof navigator === "object" && navigator || void 0;
    var hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0);
    var hasStandardBrowserWebWorkerEnv = (() => {
      return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
      self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
    })();
    var origin = hasBrowserEnv && window.location.href || "http://localhost";
    var utils = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      hasBrowserEnv,
      hasStandardBrowserWebWorkerEnv,
      hasStandardBrowserEnv,
      navigator: _navigator,
      origin
    });
    var platform = {
      ...utils,
      ...platform$1
    };
    function toURLEncodedForm(data, options) {
      return toFormData(data, new platform.classes.URLSearchParams(), {
        visitor: function(value, key, path11, helpers) {
          if (platform.isNode && utils$1.isBuffer(value)) {
            this.append(key, value.toString("base64"));
            return false;
          }
          return helpers.defaultVisitor.apply(this, arguments);
        },
        ...options
      });
    }
    function parsePropPath(name) {
      return utils$1.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
        return match[0] === "[]" ? "" : match[1] || match[0];
      });
    }
    function arrayToObject(arr) {
      const obj = {};
      const keys = Object.keys(arr);
      let i;
      const len = keys.length;
      let key;
      for (i = 0; i < len; i++) {
        key = keys[i];
        obj[key] = arr[key];
      }
      return obj;
    }
    function formDataToJSON(formData) {
      function buildPath(path11, value, target, index) {
        let name = path11[index++];
        if (name === "__proto__") return true;
        const isNumericKey = Number.isFinite(+name);
        const isLast = index >= path11.length;
        name = !name && utils$1.isArray(target) ? target.length : name;
        if (isLast) {
          if (utils$1.hasOwnProp(target, name)) {
            target[name] = [target[name], value];
          } else {
            target[name] = value;
          }
          return !isNumericKey;
        }
        if (!target[name] || !utils$1.isObject(target[name])) {
          target[name] = [];
        }
        const result = buildPath(path11, value, target[name], index);
        if (result && utils$1.isArray(target[name])) {
          target[name] = arrayToObject(target[name]);
        }
        return !isNumericKey;
      }
      if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
        const obj = {};
        utils$1.forEachEntry(formData, (name, value) => {
          buildPath(parsePropPath(name), value, obj, 0);
        });
        return obj;
      }
      return null;
    }
    function stringifySafely(rawValue, parser4, encoder) {
      if (utils$1.isString(rawValue)) {
        try {
          (parser4 || JSON.parse)(rawValue);
          return utils$1.trim(rawValue);
        } catch (e) {
          if (e.name !== "SyntaxError") {
            throw e;
          }
        }
      }
      return (encoder || JSON.stringify)(rawValue);
    }
    var defaults = {
      transitional: transitionalDefaults,
      adapter: ["xhr", "http", "fetch"],
      transformRequest: [function transformRequest(data, headers) {
        const contentType = headers.getContentType() || "";
        const hasJSONContentType = contentType.indexOf("application/json") > -1;
        const isObjectPayload = utils$1.isObject(data);
        if (isObjectPayload && utils$1.isHTMLForm(data)) {
          data = new FormData(data);
        }
        const isFormData2 = utils$1.isFormData(data);
        if (isFormData2) {
          return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
        }
        if (utils$1.isArrayBuffer(data) || utils$1.isBuffer(data) || utils$1.isStream(data) || utils$1.isFile(data) || utils$1.isBlob(data) || utils$1.isReadableStream(data)) {
          return data;
        }
        if (utils$1.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils$1.isURLSearchParams(data)) {
          headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
          return data.toString();
        }
        let isFileList2;
        if (isObjectPayload) {
          if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
            return toURLEncodedForm(data, this.formSerializer).toString();
          }
          if ((isFileList2 = utils$1.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
            const _FormData = this.env && this.env.FormData;
            return toFormData(
              isFileList2 ? { "files[]": data } : data,
              _FormData && new _FormData(),
              this.formSerializer
            );
          }
        }
        if (isObjectPayload || hasJSONContentType) {
          headers.setContentType("application/json", false);
          return stringifySafely(data);
        }
        return data;
      }],
      transformResponse: [function transformResponse(data) {
        const transitional = this.transitional || defaults.transitional;
        const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
        const JSONRequested = this.responseType === "json";
        if (utils$1.isResponse(data) || utils$1.isReadableStream(data)) {
          return data;
        }
        if (data && utils$1.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
          const silentJSONParsing = transitional && transitional.silentJSONParsing;
          const strictJSONParsing = !silentJSONParsing && JSONRequested;
          try {
            return JSON.parse(data, this.parseReviver);
          } catch (e) {
            if (strictJSONParsing) {
              if (e.name === "SyntaxError") {
                throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
              }
              throw e;
            }
          }
        }
        return data;
      }],
      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      env: {
        FormData: platform.classes.FormData,
        Blob: platform.classes.Blob
      },
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      },
      headers: {
        common: {
          "Accept": "application/json, text/plain, */*",
          "Content-Type": void 0
        }
      }
    };
    utils$1.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
      defaults.headers[method] = {};
    });
    var defaults$1 = defaults;
    var ignoreDuplicateOf = utils$1.toObjectSet([
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ]);
    var parseHeaders = (rawHeaders) => {
      const parsed = {};
      let key;
      let val;
      let i;
      rawHeaders && rawHeaders.split("\n").forEach(function parser4(line) {
        i = line.indexOf(":");
        key = line.substring(0, i).trim().toLowerCase();
        val = line.substring(i + 1).trim();
        if (!key || parsed[key] && ignoreDuplicateOf[key]) {
          return;
        }
        if (key === "set-cookie") {
          if (parsed[key]) {
            parsed[key].push(val);
          } else {
            parsed[key] = [val];
          }
        } else {
          parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
        }
      });
      return parsed;
    };
    var $internals = /* @__PURE__ */ Symbol("internals");
    function normalizeHeader(header) {
      return header && String(header).trim().toLowerCase();
    }
    function normalizeValue(value) {
      if (value === false || value == null) {
        return value;
      }
      return utils$1.isArray(value) ? value.map(normalizeValue) : String(value);
    }
    function parseTokens(str) {
      const tokens = /* @__PURE__ */ Object.create(null);
      const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
      let match;
      while (match = tokensRE.exec(str)) {
        tokens[match[1]] = match[2];
      }
      return tokens;
    }
    var isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
    function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
      if (utils$1.isFunction(filter)) {
        return filter.call(this, value, header);
      }
      if (isHeaderNameFilter) {
        value = header;
      }
      if (!utils$1.isString(value)) return;
      if (utils$1.isString(filter)) {
        return value.indexOf(filter) !== -1;
      }
      if (utils$1.isRegExp(filter)) {
        return filter.test(value);
      }
    }
    function formatHeader(header) {
      return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
        return char.toUpperCase() + str;
      });
    }
    function buildAccessors(obj, header) {
      const accessorName = utils$1.toCamelCase(" " + header);
      ["get", "set", "has"].forEach((methodName) => {
        Object.defineProperty(obj, methodName + accessorName, {
          value: function(arg1, arg2, arg3) {
            return this[methodName].call(this, header, arg1, arg2, arg3);
          },
          configurable: true
        });
      });
    }
    var AxiosHeaders = class {
      constructor(headers) {
        headers && this.set(headers);
      }
      set(header, valueOrRewrite, rewrite) {
        const self2 = this;
        function setHeader(_value, _header, _rewrite) {
          const lHeader = normalizeHeader(_header);
          if (!lHeader) {
            throw new Error("header name must be a non-empty string");
          }
          const key = utils$1.findKey(self2, lHeader);
          if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
            self2[key || _header] = normalizeValue(_value);
          }
        }
        const setHeaders = (headers, _rewrite) => utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
        if (utils$1.isPlainObject(header) || header instanceof this.constructor) {
          setHeaders(header, valueOrRewrite);
        } else if (utils$1.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
          setHeaders(parseHeaders(header), valueOrRewrite);
        } else if (utils$1.isObject(header) && utils$1.isIterable(header)) {
          let obj = {}, dest, key;
          for (const entry of header) {
            if (!utils$1.isArray(entry)) {
              throw TypeError("Object iterator must return a key-value pair");
            }
            obj[key = entry[0]] = (dest = obj[key]) ? utils$1.isArray(dest) ? [...dest, entry[1]] : [dest, entry[1]] : entry[1];
          }
          setHeaders(obj, valueOrRewrite);
        } else {
          header != null && setHeader(valueOrRewrite, header, rewrite);
        }
        return this;
      }
      get(header, parser4) {
        header = normalizeHeader(header);
        if (header) {
          const key = utils$1.findKey(this, header);
          if (key) {
            const value = this[key];
            if (!parser4) {
              return value;
            }
            if (parser4 === true) {
              return parseTokens(value);
            }
            if (utils$1.isFunction(parser4)) {
              return parser4.call(this, value, key);
            }
            if (utils$1.isRegExp(parser4)) {
              return parser4.exec(value);
            }
            throw new TypeError("parser must be boolean|regexp|function");
          }
        }
      }
      has(header, matcher) {
        header = normalizeHeader(header);
        if (header) {
          const key = utils$1.findKey(this, header);
          return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
        }
        return false;
      }
      delete(header, matcher) {
        const self2 = this;
        let deleted = false;
        function deleteHeader(_header) {
          _header = normalizeHeader(_header);
          if (_header) {
            const key = utils$1.findKey(self2, _header);
            if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
              delete self2[key];
              deleted = true;
            }
          }
        }
        if (utils$1.isArray(header)) {
          header.forEach(deleteHeader);
        } else {
          deleteHeader(header);
        }
        return deleted;
      }
      clear(matcher) {
        const keys = Object.keys(this);
        let i = keys.length;
        let deleted = false;
        while (i--) {
          const key = keys[i];
          if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
            delete this[key];
            deleted = true;
          }
        }
        return deleted;
      }
      normalize(format) {
        const self2 = this;
        const headers = {};
        utils$1.forEach(this, (value, header) => {
          const key = utils$1.findKey(headers, header);
          if (key) {
            self2[key] = normalizeValue(value);
            delete self2[header];
            return;
          }
          const normalized = format ? formatHeader(header) : String(header).trim();
          if (normalized !== header) {
            delete self2[header];
          }
          self2[normalized] = normalizeValue(value);
          headers[normalized] = true;
        });
        return this;
      }
      concat(...targets) {
        return this.constructor.concat(this, ...targets);
      }
      toJSON(asStrings) {
        const obj = /* @__PURE__ */ Object.create(null);
        utils$1.forEach(this, (value, header) => {
          value != null && value !== false && (obj[header] = asStrings && utils$1.isArray(value) ? value.join(", ") : value);
        });
        return obj;
      }
      [Symbol.iterator]() {
        return Object.entries(this.toJSON())[Symbol.iterator]();
      }
      toString() {
        return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
      }
      getSetCookie() {
        return this.get("set-cookie") || [];
      }
      get [Symbol.toStringTag]() {
        return "AxiosHeaders";
      }
      static from(thing) {
        return thing instanceof this ? thing : new this(thing);
      }
      static concat(first2, ...targets) {
        const computed = new this(first2);
        targets.forEach((target) => computed.set(target));
        return computed;
      }
      static accessor(header) {
        const internals = this[$internals] = this[$internals] = {
          accessors: {}
        };
        const accessors = internals.accessors;
        const prototype2 = this.prototype;
        function defineAccessor(_header) {
          const lHeader = normalizeHeader(_header);
          if (!accessors[lHeader]) {
            buildAccessors(prototype2, _header);
            accessors[lHeader] = true;
          }
        }
        utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
        return this;
      }
    };
    AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
    utils$1.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
      let mapped = key[0].toUpperCase() + key.slice(1);
      return {
        get: () => value,
        set(headerValue) {
          this[mapped] = headerValue;
        }
      };
    });
    utils$1.freezeMethods(AxiosHeaders);
    var AxiosHeaders$1 = AxiosHeaders;
    function transformData(fns, response) {
      const config = this || defaults$1;
      const context = response || config;
      const headers = AxiosHeaders$1.from(context.headers);
      let data = context.data;
      utils$1.forEach(fns, function transform(fn) {
        data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
      });
      headers.normalize();
      return data;
    }
    function isCancel(value) {
      return !!(value && value.__CANCEL__);
    }
    function CanceledError(message, config, request) {
      AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED, config, request);
      this.name = "CanceledError";
    }
    utils$1.inherits(CanceledError, AxiosError, {
      __CANCEL__: true
    });
    function settle(resolve8, reject, response) {
      const validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve8(response);
      } else {
        reject(new AxiosError(
          "Request failed with status code " + response.status,
          [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
          response.config,
          response.request,
          response
        ));
      }
    }
    function isAbsoluteURL(url2) {
      return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url2);
    }
    function combineURLs(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    }
    function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
      let isRelativeUrl = !isAbsoluteURL(requestedURL);
      if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    }
    var VERSION = "1.13.2";
    function parseProtocol(url2) {
      const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url2);
      return match && match[1] || "";
    }
    var DATA_URL_PATTERN = /^(?:([^;]+);)?(?:[^;]+;)?(base64|),([\s\S]*)$/;
    function fromDataURI(uri, asBlob, options) {
      const _Blob = options && options.Blob || platform.classes.Blob;
      const protocol = parseProtocol(uri);
      if (asBlob === void 0 && _Blob) {
        asBlob = true;
      }
      if (protocol === "data") {
        uri = protocol.length ? uri.slice(protocol.length + 1) : uri;
        const match = DATA_URL_PATTERN.exec(uri);
        if (!match) {
          throw new AxiosError("Invalid URL", AxiosError.ERR_INVALID_URL);
        }
        const mime = match[1];
        const isBase64 = match[2];
        const body = match[3];
        const buffer = Buffer.from(decodeURIComponent(body), isBase64 ? "base64" : "utf8");
        if (asBlob) {
          if (!_Blob) {
            throw new AxiosError("Blob is not supported", AxiosError.ERR_NOT_SUPPORT);
          }
          return new _Blob([buffer], { type: mime });
        }
        return buffer;
      }
      throw new AxiosError("Unsupported protocol " + protocol, AxiosError.ERR_NOT_SUPPORT);
    }
    var kInternals = /* @__PURE__ */ Symbol("internals");
    var AxiosTransformStream = class extends stream__default["default"].Transform {
      constructor(options) {
        options = utils$1.toFlatObject(options, {
          maxRate: 0,
          chunkSize: 64 * 1024,
          minChunkSize: 100,
          timeWindow: 500,
          ticksRate: 2,
          samplesCount: 15
        }, null, (prop, source) => {
          return !utils$1.isUndefined(source[prop]);
        });
        super({
          readableHighWaterMark: options.chunkSize
        });
        const internals = this[kInternals] = {
          timeWindow: options.timeWindow,
          chunkSize: options.chunkSize,
          maxRate: options.maxRate,
          minChunkSize: options.minChunkSize,
          bytesSeen: 0,
          isCaptured: false,
          notifiedBytesLoaded: 0,
          ts: Date.now(),
          bytes: 0,
          onReadCallback: null
        };
        this.on("newListener", (event) => {
          if (event === "progress") {
            if (!internals.isCaptured) {
              internals.isCaptured = true;
            }
          }
        });
      }
      _read(size) {
        const internals = this[kInternals];
        if (internals.onReadCallback) {
          internals.onReadCallback();
        }
        return super._read(size);
      }
      _transform(chunk, encoding, callback2) {
        const internals = this[kInternals];
        const maxRate = internals.maxRate;
        const readableHighWaterMark = this.readableHighWaterMark;
        const timeWindow = internals.timeWindow;
        const divider = 1e3 / timeWindow;
        const bytesThreshold = maxRate / divider;
        const minChunkSize = internals.minChunkSize !== false ? Math.max(internals.minChunkSize, bytesThreshold * 0.01) : 0;
        const pushChunk = (_chunk, _callback) => {
          const bytes = Buffer.byteLength(_chunk);
          internals.bytesSeen += bytes;
          internals.bytes += bytes;
          internals.isCaptured && this.emit("progress", internals.bytesSeen);
          if (this.push(_chunk)) {
            process.nextTick(_callback);
          } else {
            internals.onReadCallback = () => {
              internals.onReadCallback = null;
              process.nextTick(_callback);
            };
          }
        };
        const transformChunk = (_chunk, _callback) => {
          const chunkSize = Buffer.byteLength(_chunk);
          let chunkRemainder = null;
          let maxChunkSize = readableHighWaterMark;
          let bytesLeft;
          let passed = 0;
          if (maxRate) {
            const now = Date.now();
            if (!internals.ts || (passed = now - internals.ts) >= timeWindow) {
              internals.ts = now;
              bytesLeft = bytesThreshold - internals.bytes;
              internals.bytes = bytesLeft < 0 ? -bytesLeft : 0;
              passed = 0;
            }
            bytesLeft = bytesThreshold - internals.bytes;
          }
          if (maxRate) {
            if (bytesLeft <= 0) {
              return setTimeout(() => {
                _callback(null, _chunk);
              }, timeWindow - passed);
            }
            if (bytesLeft < maxChunkSize) {
              maxChunkSize = bytesLeft;
            }
          }
          if (maxChunkSize && chunkSize > maxChunkSize && chunkSize - maxChunkSize > minChunkSize) {
            chunkRemainder = _chunk.subarray(maxChunkSize);
            _chunk = _chunk.subarray(0, maxChunkSize);
          }
          pushChunk(_chunk, chunkRemainder ? () => {
            process.nextTick(_callback, null, chunkRemainder);
          } : _callback);
        };
        transformChunk(chunk, function transformNextChunk(err, _chunk) {
          if (err) {
            return callback2(err);
          }
          if (_chunk) {
            transformChunk(_chunk, transformNextChunk);
          } else {
            callback2(null);
          }
        });
      }
    };
    var AxiosTransformStream$1 = AxiosTransformStream;
    var { asyncIterator } = Symbol;
    var readBlob = async function* (blob) {
      if (blob.stream) {
        yield* blob.stream();
      } else if (blob.arrayBuffer) {
        yield await blob.arrayBuffer();
      } else if (blob[asyncIterator]) {
        yield* blob[asyncIterator]();
      } else {
        yield blob;
      }
    };
    var readBlob$1 = readBlob;
    var BOUNDARY_ALPHABET = platform.ALPHABET.ALPHA_DIGIT + "-_";
    var textEncoder = typeof TextEncoder === "function" ? new TextEncoder() : new util__default["default"].TextEncoder();
    var CRLF = "\r\n";
    var CRLF_BYTES = textEncoder.encode(CRLF);
    var CRLF_BYTES_COUNT = 2;
    var FormDataPart = class {
      constructor(name, value) {
        const { escapeName } = this.constructor;
        const isStringValue = utils$1.isString(value);
        let headers = `Content-Disposition: form-data; name="${escapeName(name)}"${!isStringValue && value.name ? `; filename="${escapeName(value.name)}"` : ""}${CRLF}`;
        if (isStringValue) {
          value = textEncoder.encode(String(value).replace(/\r?\n|\r\n?/g, CRLF));
        } else {
          headers += `Content-Type: ${value.type || "application/octet-stream"}${CRLF}`;
        }
        this.headers = textEncoder.encode(headers + CRLF);
        this.contentLength = isStringValue ? value.byteLength : value.size;
        this.size = this.headers.byteLength + this.contentLength + CRLF_BYTES_COUNT;
        this.name = name;
        this.value = value;
      }
      async *encode() {
        yield this.headers;
        const { value } = this;
        if (utils$1.isTypedArray(value)) {
          yield value;
        } else {
          yield* readBlob$1(value);
        }
        yield CRLF_BYTES;
      }
      static escapeName(name) {
        return String(name).replace(/[\r\n"]/g, (match) => ({
          "\r": "%0D",
          "\n": "%0A",
          '"': "%22"
        })[match]);
      }
    };
    var formDataToStream = (form, headersHandler, options) => {
      const {
        tag = "form-data-boundary",
        size = 25,
        boundary = tag + "-" + platform.generateString(size, BOUNDARY_ALPHABET)
      } = options || {};
      if (!utils$1.isFormData(form)) {
        throw TypeError("FormData instance required");
      }
      if (boundary.length < 1 || boundary.length > 70) {
        throw Error("boundary must be 10-70 characters long");
      }
      const boundaryBytes = textEncoder.encode("--" + boundary + CRLF);
      const footerBytes = textEncoder.encode("--" + boundary + "--" + CRLF);
      let contentLength = footerBytes.byteLength;
      const parts = Array.from(form.entries()).map(([name, value]) => {
        const part = new FormDataPart(name, value);
        contentLength += part.size;
        return part;
      });
      contentLength += boundaryBytes.byteLength * parts.length;
      contentLength = utils$1.toFiniteNumber(contentLength);
      const computedHeaders = {
        "Content-Type": `multipart/form-data; boundary=${boundary}`
      };
      if (Number.isFinite(contentLength)) {
        computedHeaders["Content-Length"] = contentLength;
      }
      headersHandler && headersHandler(computedHeaders);
      return stream.Readable.from((async function* () {
        for (const part of parts) {
          yield boundaryBytes;
          yield* part.encode();
        }
        yield footerBytes;
      })());
    };
    var formDataToStream$1 = formDataToStream;
    var ZlibHeaderTransformStream = class extends stream__default["default"].Transform {
      __transform(chunk, encoding, callback2) {
        this.push(chunk);
        callback2();
      }
      _transform(chunk, encoding, callback2) {
        if (chunk.length !== 0) {
          this._transform = this.__transform;
          if (chunk[0] !== 120) {
            const header = Buffer.alloc(2);
            header[0] = 120;
            header[1] = 156;
            this.push(header, encoding);
          }
        }
        this.__transform(chunk, encoding, callback2);
      }
    };
    var ZlibHeaderTransformStream$1 = ZlibHeaderTransformStream;
    var callbackify = (fn, reducer) => {
      return utils$1.isAsyncFn(fn) ? function(...args) {
        const cb = args.pop();
        fn.apply(this, args).then((value) => {
          try {
            reducer ? cb(null, ...reducer(value)) : cb(null, value);
          } catch (err) {
            cb(err);
          }
        }, cb);
      } : fn;
    };
    var callbackify$1 = callbackify;
    function speedometer(samplesCount, min) {
      samplesCount = samplesCount || 10;
      const bytes = new Array(samplesCount);
      const timestamps = new Array(samplesCount);
      let head = 0;
      let tail = 0;
      let firstSampleTS;
      min = min !== void 0 ? min : 1e3;
      return function push(chunkLength) {
        const now = Date.now();
        const startedAt = timestamps[tail];
        if (!firstSampleTS) {
          firstSampleTS = now;
        }
        bytes[head] = chunkLength;
        timestamps[head] = now;
        let i = tail;
        let bytesCount = 0;
        while (i !== head) {
          bytesCount += bytes[i++];
          i = i % samplesCount;
        }
        head = (head + 1) % samplesCount;
        if (head === tail) {
          tail = (tail + 1) % samplesCount;
        }
        if (now - firstSampleTS < min) {
          return;
        }
        const passed = startedAt && now - startedAt;
        return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
      };
    }
    function throttle(fn, freq) {
      let timestamp = 0;
      let threshold = 1e3 / freq;
      let lastArgs;
      let timer;
      const invoke = (args, now = Date.now()) => {
        timestamp = now;
        lastArgs = null;
        if (timer) {
          clearTimeout(timer);
          timer = null;
        }
        fn(...args);
      };
      const throttled = (...args) => {
        const now = Date.now();
        const passed = now - timestamp;
        if (passed >= threshold) {
          invoke(args, now);
        } else {
          lastArgs = args;
          if (!timer) {
            timer = setTimeout(() => {
              timer = null;
              invoke(lastArgs);
            }, threshold - passed);
          }
        }
      };
      const flush = () => lastArgs && invoke(lastArgs);
      return [throttled, flush];
    }
    var progressEventReducer = (listener, isDownloadStream, freq = 3) => {
      let bytesNotified = 0;
      const _speedometer = speedometer(50, 250);
      return throttle((e) => {
        const loaded = e.loaded;
        const total = e.lengthComputable ? e.total : void 0;
        const progressBytes = loaded - bytesNotified;
        const rate = _speedometer(progressBytes);
        const inRange = loaded <= total;
        bytesNotified = loaded;
        const data = {
          loaded,
          total,
          progress: total ? loaded / total : void 0,
          bytes: progressBytes,
          rate: rate ? rate : void 0,
          estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
          event: e,
          lengthComputable: total != null,
          [isDownloadStream ? "download" : "upload"]: true
        };
        listener(data);
      }, freq);
    };
    var progressEventDecorator = (total, throttled) => {
      const lengthComputable = total != null;
      return [(loaded) => throttled[0]({
        lengthComputable,
        total,
        loaded
      }), throttled[1]];
    };
    var asyncDecorator = (fn) => (...args) => utils$1.asap(() => fn(...args));
    function estimateDataURLDecodedBytes(url2) {
      if (!url2 || typeof url2 !== "string") return 0;
      if (!url2.startsWith("data:")) return 0;
      const comma = url2.indexOf(",");
      if (comma < 0) return 0;
      const meta = url2.slice(5, comma);
      const body = url2.slice(comma + 1);
      const isBase64 = /;base64/i.test(meta);
      if (isBase64) {
        let effectiveLen = body.length;
        const len = body.length;
        for (let i = 0; i < len; i++) {
          if (body.charCodeAt(i) === 37 && i + 2 < len) {
            const a = body.charCodeAt(i + 1);
            const b = body.charCodeAt(i + 2);
            const isHex = (a >= 48 && a <= 57 || a >= 65 && a <= 70 || a >= 97 && a <= 102) && (b >= 48 && b <= 57 || b >= 65 && b <= 70 || b >= 97 && b <= 102);
            if (isHex) {
              effectiveLen -= 2;
              i += 2;
            }
          }
        }
        let pad = 0;
        let idx = len - 1;
        const tailIsPct3D = (j) => j >= 2 && body.charCodeAt(j - 2) === 37 && // '%'
        body.charCodeAt(j - 1) === 51 && // '3'
        (body.charCodeAt(j) === 68 || body.charCodeAt(j) === 100);
        if (idx >= 0) {
          if (body.charCodeAt(idx) === 61) {
            pad++;
            idx--;
          } else if (tailIsPct3D(idx)) {
            pad++;
            idx -= 3;
          }
        }
        if (pad === 1 && idx >= 0) {
          if (body.charCodeAt(idx) === 61) {
            pad++;
          } else if (tailIsPct3D(idx)) {
            pad++;
          }
        }
        const groups = Math.floor(effectiveLen / 4);
        const bytes = groups * 3 - (pad || 0);
        return bytes > 0 ? bytes : 0;
      }
      return Buffer.byteLength(body, "utf8");
    }
    var zlibOptions = {
      flush: zlib__default["default"].constants.Z_SYNC_FLUSH,
      finishFlush: zlib__default["default"].constants.Z_SYNC_FLUSH
    };
    var brotliOptions = {
      flush: zlib__default["default"].constants.BROTLI_OPERATION_FLUSH,
      finishFlush: zlib__default["default"].constants.BROTLI_OPERATION_FLUSH
    };
    var isBrotliSupported = utils$1.isFunction(zlib__default["default"].createBrotliDecompress);
    var { http: httpFollow, https: httpsFollow } = followRedirects__default["default"];
    var isHttps = /https:?/;
    var supportedProtocols = platform.protocols.map((protocol) => {
      return protocol + ":";
    });
    var flushOnFinish = (stream2, [throttled, flush]) => {
      stream2.on("end", flush).on("error", flush);
      return throttled;
    };
    var Http2Sessions = class {
      constructor() {
        this.sessions = /* @__PURE__ */ Object.create(null);
      }
      getSession(authority, options) {
        options = Object.assign({
          sessionTimeout: 1e3
        }, options);
        let authoritySessions = this.sessions[authority];
        if (authoritySessions) {
          let len = authoritySessions.length;
          for (let i = 0; i < len; i++) {
            const [sessionHandle, sessionOptions] = authoritySessions[i];
            if (!sessionHandle.destroyed && !sessionHandle.closed && util__default["default"].isDeepStrictEqual(sessionOptions, options)) {
              return sessionHandle;
            }
          }
        }
        const session = http2__default["default"].connect(authority, options);
        let removed;
        const removeSession = () => {
          if (removed) {
            return;
          }
          removed = true;
          let entries = authoritySessions, len = entries.length, i = len;
          while (i--) {
            if (entries[i][0] === session) {
              if (len === 1) {
                delete this.sessions[authority];
              } else {
                entries.splice(i, 1);
              }
              return;
            }
          }
        };
        const originalRequestFn = session.request;
        const { sessionTimeout } = options;
        if (sessionTimeout != null) {
          let timer;
          let streamsCount = 0;
          session.request = function() {
            const stream2 = originalRequestFn.apply(this, arguments);
            streamsCount++;
            if (timer) {
              clearTimeout(timer);
              timer = null;
            }
            stream2.once("close", () => {
              if (!--streamsCount) {
                timer = setTimeout(() => {
                  timer = null;
                  removeSession();
                }, sessionTimeout);
              }
            });
            return stream2;
          };
        }
        session.once("close", removeSession);
        let entry = [
          session,
          options
        ];
        authoritySessions ? authoritySessions.push(entry) : authoritySessions = this.sessions[authority] = [entry];
        return session;
      }
    };
    var http2Sessions = new Http2Sessions();
    function dispatchBeforeRedirect(options, responseDetails) {
      if (options.beforeRedirects.proxy) {
        options.beforeRedirects.proxy(options);
      }
      if (options.beforeRedirects.config) {
        options.beforeRedirects.config(options, responseDetails);
      }
    }
    function setProxy(options, configProxy, location) {
      let proxy = configProxy;
      if (!proxy && proxy !== false) {
        const proxyUrl = proxyFromEnv__default["default"].getProxyForUrl(location);
        if (proxyUrl) {
          proxy = new URL(proxyUrl);
        }
      }
      if (proxy) {
        if (proxy.username) {
          proxy.auth = (proxy.username || "") + ":" + (proxy.password || "");
        }
        if (proxy.auth) {
          if (proxy.auth.username || proxy.auth.password) {
            proxy.auth = (proxy.auth.username || "") + ":" + (proxy.auth.password || "");
          }
          const base64 = Buffer.from(proxy.auth, "utf8").toString("base64");
          options.headers["Proxy-Authorization"] = "Basic " + base64;
        }
        options.headers.host = options.hostname + (options.port ? ":" + options.port : "");
        const proxyHost = proxy.hostname || proxy.host;
        options.hostname = proxyHost;
        options.host = proxyHost;
        options.port = proxy.port;
        options.path = location;
        if (proxy.protocol) {
          options.protocol = proxy.protocol.includes(":") ? proxy.protocol : `${proxy.protocol}:`;
        }
      }
      options.beforeRedirects.proxy = function beforeRedirect(redirectOptions) {
        setProxy(redirectOptions, configProxy, redirectOptions.href);
      };
    }
    var isHttpAdapterSupported = typeof process !== "undefined" && utils$1.kindOf(process) === "process";
    var wrapAsync = (asyncExecutor) => {
      return new Promise((resolve8, reject) => {
        let onDone;
        let isDone;
        const done = (value, isRejected) => {
          if (isDone) return;
          isDone = true;
          onDone && onDone(value, isRejected);
        };
        const _resolve = (value) => {
          done(value);
          resolve8(value);
        };
        const _reject = (reason) => {
          done(reason, true);
          reject(reason);
        };
        asyncExecutor(_resolve, _reject, (onDoneHandler) => onDone = onDoneHandler).catch(_reject);
      });
    };
    var resolveFamily = ({ address, family }) => {
      if (!utils$1.isString(address)) {
        throw TypeError("address must be a string");
      }
      return {
        address,
        family: family || (address.indexOf(".") < 0 ? 6 : 4)
      };
    };
    var buildAddressEntry = (address, family) => resolveFamily(utils$1.isObject(address) ? address : { address, family });
    var http2Transport = {
      request(options, cb) {
        const authority = options.protocol + "//" + options.hostname + ":" + (options.port || 80);
        const { http2Options, headers } = options;
        const session = http2Sessions.getSession(authority, http2Options);
        const {
          HTTP2_HEADER_SCHEME,
          HTTP2_HEADER_METHOD,
          HTTP2_HEADER_PATH,
          HTTP2_HEADER_STATUS
        } = http2__default["default"].constants;
        const http2Headers = {
          [HTTP2_HEADER_SCHEME]: options.protocol.replace(":", ""),
          [HTTP2_HEADER_METHOD]: options.method,
          [HTTP2_HEADER_PATH]: options.path
        };
        utils$1.forEach(headers, (header, name) => {
          name.charAt(0) !== ":" && (http2Headers[name] = header);
        });
        const req = session.request(http2Headers);
        req.once("response", (responseHeaders) => {
          const response = req;
          responseHeaders = Object.assign({}, responseHeaders);
          const status = responseHeaders[HTTP2_HEADER_STATUS];
          delete responseHeaders[HTTP2_HEADER_STATUS];
          response.headers = responseHeaders;
          response.statusCode = +status;
          cb(response);
        });
        return req;
      }
    };
    var httpAdapter = isHttpAdapterSupported && function httpAdapter2(config) {
      return wrapAsync(async function dispatchHttpRequest(resolve8, reject, onDone) {
        let { data, lookup, family, httpVersion = 1, http2Options } = config;
        const { responseType, responseEncoding } = config;
        const method = config.method.toUpperCase();
        let isDone;
        let rejected = false;
        let req;
        httpVersion = +httpVersion;
        if (Number.isNaN(httpVersion)) {
          throw TypeError(`Invalid protocol version: '${config.httpVersion}' is not a number`);
        }
        if (httpVersion !== 1 && httpVersion !== 2) {
          throw TypeError(`Unsupported protocol version '${httpVersion}'`);
        }
        const isHttp2 = httpVersion === 2;
        if (lookup) {
          const _lookup = callbackify$1(lookup, (value) => utils$1.isArray(value) ? value : [value]);
          lookup = (hostname, opt, cb) => {
            _lookup(hostname, opt, (err, arg0, arg1) => {
              if (err) {
                return cb(err);
              }
              const addresses = utils$1.isArray(arg0) ? arg0.map((addr) => buildAddressEntry(addr)) : [buildAddressEntry(arg0, arg1)];
              opt.all ? cb(err, addresses) : cb(err, addresses[0].address, addresses[0].family);
            });
          };
        }
        const abortEmitter = new events.EventEmitter();
        function abort(reason) {
          try {
            abortEmitter.emit("abort", !reason || reason.type ? new CanceledError(null, config, req) : reason);
          } catch (err) {
            console.warn("emit error", err);
          }
        }
        abortEmitter.once("abort", reject);
        const onFinished = () => {
          if (config.cancelToken) {
            config.cancelToken.unsubscribe(abort);
          }
          if (config.signal) {
            config.signal.removeEventListener("abort", abort);
          }
          abortEmitter.removeAllListeners();
        };
        if (config.cancelToken || config.signal) {
          config.cancelToken && config.cancelToken.subscribe(abort);
          if (config.signal) {
            config.signal.aborted ? abort() : config.signal.addEventListener("abort", abort);
          }
        }
        onDone((response, isRejected) => {
          isDone = true;
          if (isRejected) {
            rejected = true;
            onFinished();
            return;
          }
          const { data: data2 } = response;
          if (data2 instanceof stream__default["default"].Readable || data2 instanceof stream__default["default"].Duplex) {
            const offListeners = stream__default["default"].finished(data2, () => {
              offListeners();
              onFinished();
            });
          } else {
            onFinished();
          }
        });
        const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);
        const parsed = new URL(fullPath, platform.hasBrowserEnv ? platform.origin : void 0);
        const protocol = parsed.protocol || supportedProtocols[0];
        if (protocol === "data:") {
          if (config.maxContentLength > -1) {
            const dataUrl = String(config.url || fullPath || "");
            const estimated = estimateDataURLDecodedBytes(dataUrl);
            if (estimated > config.maxContentLength) {
              return reject(new AxiosError(
                "maxContentLength size of " + config.maxContentLength + " exceeded",
                AxiosError.ERR_BAD_RESPONSE,
                config
              ));
            }
          }
          let convertedData;
          if (method !== "GET") {
            return settle(resolve8, reject, {
              status: 405,
              statusText: "method not allowed",
              headers: {},
              config
            });
          }
          try {
            convertedData = fromDataURI(config.url, responseType === "blob", {
              Blob: config.env && config.env.Blob
            });
          } catch (err) {
            throw AxiosError.from(err, AxiosError.ERR_BAD_REQUEST, config);
          }
          if (responseType === "text") {
            convertedData = convertedData.toString(responseEncoding);
            if (!responseEncoding || responseEncoding === "utf8") {
              convertedData = utils$1.stripBOM(convertedData);
            }
          } else if (responseType === "stream") {
            convertedData = stream__default["default"].Readable.from(convertedData);
          }
          return settle(resolve8, reject, {
            data: convertedData,
            status: 200,
            statusText: "OK",
            headers: new AxiosHeaders$1(),
            config
          });
        }
        if (supportedProtocols.indexOf(protocol) === -1) {
          return reject(new AxiosError(
            "Unsupported protocol " + protocol,
            AxiosError.ERR_BAD_REQUEST,
            config
          ));
        }
        const headers = AxiosHeaders$1.from(config.headers).normalize();
        headers.set("User-Agent", "axios/" + VERSION, false);
        const { onUploadProgress, onDownloadProgress } = config;
        const maxRate = config.maxRate;
        let maxUploadRate = void 0;
        let maxDownloadRate = void 0;
        if (utils$1.isSpecCompliantForm(data)) {
          const userBoundary = headers.getContentType(/boundary=([-_\w\d]{10,70})/i);
          data = formDataToStream$1(data, (formHeaders) => {
            headers.set(formHeaders);
          }, {
            tag: `axios-${VERSION}-boundary`,
            boundary: userBoundary && userBoundary[1] || void 0
          });
        } else if (utils$1.isFormData(data) && utils$1.isFunction(data.getHeaders)) {
          headers.set(data.getHeaders());
          if (!headers.hasContentLength()) {
            try {
              const knownLength = await util__default["default"].promisify(data.getLength).call(data);
              Number.isFinite(knownLength) && knownLength >= 0 && headers.setContentLength(knownLength);
            } catch (e) {
            }
          }
        } else if (utils$1.isBlob(data) || utils$1.isFile(data)) {
          data.size && headers.setContentType(data.type || "application/octet-stream");
          headers.setContentLength(data.size || 0);
          data = stream__default["default"].Readable.from(readBlob$1(data));
        } else if (data && !utils$1.isStream(data)) {
          if (Buffer.isBuffer(data)) ;
          else if (utils$1.isArrayBuffer(data)) {
            data = Buffer.from(new Uint8Array(data));
          } else if (utils$1.isString(data)) {
            data = Buffer.from(data, "utf-8");
          } else {
            return reject(new AxiosError(
              "Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream",
              AxiosError.ERR_BAD_REQUEST,
              config
            ));
          }
          headers.setContentLength(data.length, false);
          if (config.maxBodyLength > -1 && data.length > config.maxBodyLength) {
            return reject(new AxiosError(
              "Request body larger than maxBodyLength limit",
              AxiosError.ERR_BAD_REQUEST,
              config
            ));
          }
        }
        const contentLength = utils$1.toFiniteNumber(headers.getContentLength());
        if (utils$1.isArray(maxRate)) {
          maxUploadRate = maxRate[0];
          maxDownloadRate = maxRate[1];
        } else {
          maxUploadRate = maxDownloadRate = maxRate;
        }
        if (data && (onUploadProgress || maxUploadRate)) {
          if (!utils$1.isStream(data)) {
            data = stream__default["default"].Readable.from(data, { objectMode: false });
          }
          data = stream__default["default"].pipeline([data, new AxiosTransformStream$1({
            maxRate: utils$1.toFiniteNumber(maxUploadRate)
          })], utils$1.noop);
          onUploadProgress && data.on("progress", flushOnFinish(
            data,
            progressEventDecorator(
              contentLength,
              progressEventReducer(asyncDecorator(onUploadProgress), false, 3)
            )
          ));
        }
        let auth = void 0;
        if (config.auth) {
          const username = config.auth.username || "";
          const password = config.auth.password || "";
          auth = username + ":" + password;
        }
        if (!auth && parsed.username) {
          const urlUsername = parsed.username;
          const urlPassword = parsed.password;
          auth = urlUsername + ":" + urlPassword;
        }
        auth && headers.delete("authorization");
        let path11;
        try {
          path11 = buildURL(
            parsed.pathname + parsed.search,
            config.params,
            config.paramsSerializer
          ).replace(/^\?/, "");
        } catch (err) {
          const customErr = new Error(err.message);
          customErr.config = config;
          customErr.url = config.url;
          customErr.exists = true;
          return reject(customErr);
        }
        headers.set(
          "Accept-Encoding",
          "gzip, compress, deflate" + (isBrotliSupported ? ", br" : ""),
          false
        );
        const options = {
          path: path11,
          method,
          headers: headers.toJSON(),
          agents: { http: config.httpAgent, https: config.httpsAgent },
          auth,
          protocol,
          family,
          beforeRedirect: dispatchBeforeRedirect,
          beforeRedirects: {},
          http2Options
        };
        !utils$1.isUndefined(lookup) && (options.lookup = lookup);
        if (config.socketPath) {
          options.socketPath = config.socketPath;
        } else {
          options.hostname = parsed.hostname.startsWith("[") ? parsed.hostname.slice(1, -1) : parsed.hostname;
          options.port = parsed.port;
          setProxy(options, config.proxy, protocol + "//" + parsed.hostname + (parsed.port ? ":" + parsed.port : "") + options.path);
        }
        let transport;
        const isHttpsRequest = isHttps.test(options.protocol);
        options.agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;
        if (isHttp2) {
          transport = http2Transport;
        } else {
          if (config.transport) {
            transport = config.transport;
          } else if (config.maxRedirects === 0) {
            transport = isHttpsRequest ? https__default["default"] : http__default["default"];
          } else {
            if (config.maxRedirects) {
              options.maxRedirects = config.maxRedirects;
            }
            if (config.beforeRedirect) {
              options.beforeRedirects.config = config.beforeRedirect;
            }
            transport = isHttpsRequest ? httpsFollow : httpFollow;
          }
        }
        if (config.maxBodyLength > -1) {
          options.maxBodyLength = config.maxBodyLength;
        } else {
          options.maxBodyLength = Infinity;
        }
        if (config.insecureHTTPParser) {
          options.insecureHTTPParser = config.insecureHTTPParser;
        }
        req = transport.request(options, function handleResponse(res) {
          if (req.destroyed) return;
          const streams = [res];
          const responseLength = utils$1.toFiniteNumber(res.headers["content-length"]);
          if (onDownloadProgress || maxDownloadRate) {
            const transformStream = new AxiosTransformStream$1({
              maxRate: utils$1.toFiniteNumber(maxDownloadRate)
            });
            onDownloadProgress && transformStream.on("progress", flushOnFinish(
              transformStream,
              progressEventDecorator(
                responseLength,
                progressEventReducer(asyncDecorator(onDownloadProgress), true, 3)
              )
            ));
            streams.push(transformStream);
          }
          let responseStream = res;
          const lastRequest = res.req || req;
          if (config.decompress !== false && res.headers["content-encoding"]) {
            if (method === "HEAD" || res.statusCode === 204) {
              delete res.headers["content-encoding"];
            }
            switch ((res.headers["content-encoding"] || "").toLowerCase()) {
              /*eslint default-case:0*/
              case "gzip":
              case "x-gzip":
              case "compress":
              case "x-compress":
                streams.push(zlib__default["default"].createUnzip(zlibOptions));
                delete res.headers["content-encoding"];
                break;
              case "deflate":
                streams.push(new ZlibHeaderTransformStream$1());
                streams.push(zlib__default["default"].createUnzip(zlibOptions));
                delete res.headers["content-encoding"];
                break;
              case "br":
                if (isBrotliSupported) {
                  streams.push(zlib__default["default"].createBrotliDecompress(brotliOptions));
                  delete res.headers["content-encoding"];
                }
            }
          }
          responseStream = streams.length > 1 ? stream__default["default"].pipeline(streams, utils$1.noop) : streams[0];
          const response = {
            status: res.statusCode,
            statusText: res.statusMessage,
            headers: new AxiosHeaders$1(res.headers),
            config,
            request: lastRequest
          };
          if (responseType === "stream") {
            response.data = responseStream;
            settle(resolve8, reject, response);
          } else {
            const responseBuffer = [];
            let totalResponseBytes = 0;
            responseStream.on("data", function handleStreamData(chunk) {
              responseBuffer.push(chunk);
              totalResponseBytes += chunk.length;
              if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {
                rejected = true;
                responseStream.destroy();
                abort(new AxiosError(
                  "maxContentLength size of " + config.maxContentLength + " exceeded",
                  AxiosError.ERR_BAD_RESPONSE,
                  config,
                  lastRequest
                ));
              }
            });
            responseStream.on("aborted", function handlerStreamAborted() {
              if (rejected) {
                return;
              }
              const err = new AxiosError(
                "stream has been aborted",
                AxiosError.ERR_BAD_RESPONSE,
                config,
                lastRequest
              );
              responseStream.destroy(err);
              reject(err);
            });
            responseStream.on("error", function handleStreamError(err) {
              if (req.destroyed) return;
              reject(AxiosError.from(err, null, config, lastRequest));
            });
            responseStream.on("end", function handleStreamEnd() {
              try {
                let responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);
                if (responseType !== "arraybuffer") {
                  responseData = responseData.toString(responseEncoding);
                  if (!responseEncoding || responseEncoding === "utf8") {
                    responseData = utils$1.stripBOM(responseData);
                  }
                }
                response.data = responseData;
              } catch (err) {
                return reject(AxiosError.from(err, null, config, response.request, response));
              }
              settle(resolve8, reject, response);
            });
          }
          abortEmitter.once("abort", (err) => {
            if (!responseStream.destroyed) {
              responseStream.emit("error", err);
              responseStream.destroy();
            }
          });
        });
        abortEmitter.once("abort", (err) => {
          if (req.close) {
            req.close();
          } else {
            req.destroy(err);
          }
        });
        req.on("error", function handleRequestError(err) {
          reject(AxiosError.from(err, null, config, req));
        });
        req.on("socket", function handleRequestSocket(socket) {
          socket.setKeepAlive(true, 1e3 * 60);
        });
        if (config.timeout) {
          const timeout = parseInt(config.timeout, 10);
          if (Number.isNaN(timeout)) {
            abort(new AxiosError(
              "error trying to parse `config.timeout` to int",
              AxiosError.ERR_BAD_OPTION_VALUE,
              config,
              req
            ));
            return;
          }
          req.setTimeout(timeout, function handleRequestTimeout() {
            if (isDone) return;
            let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
            const transitional = config.transitional || transitionalDefaults;
            if (config.timeoutErrorMessage) {
              timeoutErrorMessage = config.timeoutErrorMessage;
            }
            abort(new AxiosError(
              timeoutErrorMessage,
              transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
              config,
              req
            ));
          });
        } else {
          req.setTimeout(0);
        }
        if (utils$1.isStream(data)) {
          let ended = false;
          let errored = false;
          data.on("end", () => {
            ended = true;
          });
          data.once("error", (err) => {
            errored = true;
            req.destroy(err);
          });
          data.on("close", () => {
            if (!ended && !errored) {
              abort(new CanceledError("Request stream has been aborted", config, req));
            }
          });
          data.pipe(req);
        } else {
          data && req.write(data);
          req.end();
        }
      });
    };
    var isURLSameOrigin = platform.hasStandardBrowserEnv ? /* @__PURE__ */ ((origin2, isMSIE) => (url2) => {
      url2 = new URL(url2, platform.origin);
      return origin2.protocol === url2.protocol && origin2.host === url2.host && (isMSIE || origin2.port === url2.port);
    })(
      new URL(platform.origin),
      platform.navigator && /(msie|trident)/i.test(platform.navigator.userAgent)
    ) : () => true;
    var cookies = platform.hasStandardBrowserEnv ? (
      // Standard browser envs support document.cookie
      {
        write(name, value, expires, path11, domain, secure, sameSite) {
          if (typeof document === "undefined") return;
          const cookie = [`${name}=${encodeURIComponent(value)}`];
          if (utils$1.isNumber(expires)) {
            cookie.push(`expires=${new Date(expires).toUTCString()}`);
          }
          if (utils$1.isString(path11)) {
            cookie.push(`path=${path11}`);
          }
          if (utils$1.isString(domain)) {
            cookie.push(`domain=${domain}`);
          }
          if (secure === true) {
            cookie.push("secure");
          }
          if (utils$1.isString(sameSite)) {
            cookie.push(`SameSite=${sameSite}`);
          }
          document.cookie = cookie.join("; ");
        },
        read(name) {
          if (typeof document === "undefined") return null;
          const match = document.cookie.match(new RegExp("(?:^|; )" + name + "=([^;]*)"));
          return match ? decodeURIComponent(match[1]) : null;
        },
        remove(name) {
          this.write(name, "", Date.now() - 864e5, "/");
        }
      }
    ) : (
      // Non-standard browser env (web workers, react-native) lack needed support.
      {
        write() {
        },
        read() {
          return null;
        },
        remove() {
        }
      }
    );
    var headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? { ...thing } : thing;
    function mergeConfig(config1, config2) {
      config2 = config2 || {};
      const config = {};
      function getMergedValue(target, source, prop, caseless) {
        if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {
          return utils$1.merge.call({ caseless }, target, source);
        } else if (utils$1.isPlainObject(source)) {
          return utils$1.merge({}, source);
        } else if (utils$1.isArray(source)) {
          return source.slice();
        }
        return source;
      }
      function mergeDeepProperties(a, b, prop, caseless) {
        if (!utils$1.isUndefined(b)) {
          return getMergedValue(a, b, prop, caseless);
        } else if (!utils$1.isUndefined(a)) {
          return getMergedValue(void 0, a, prop, caseless);
        }
      }
      function valueFromConfig2(a, b) {
        if (!utils$1.isUndefined(b)) {
          return getMergedValue(void 0, b);
        }
      }
      function defaultToConfig2(a, b) {
        if (!utils$1.isUndefined(b)) {
          return getMergedValue(void 0, b);
        } else if (!utils$1.isUndefined(a)) {
          return getMergedValue(void 0, a);
        }
      }
      function mergeDirectKeys(a, b, prop) {
        if (prop in config2) {
          return getMergedValue(a, b);
        } else if (prop in config1) {
          return getMergedValue(void 0, a);
        }
      }
      const mergeMap = {
        url: valueFromConfig2,
        method: valueFromConfig2,
        data: valueFromConfig2,
        baseURL: defaultToConfig2,
        transformRequest: defaultToConfig2,
        transformResponse: defaultToConfig2,
        paramsSerializer: defaultToConfig2,
        timeout: defaultToConfig2,
        timeoutMessage: defaultToConfig2,
        withCredentials: defaultToConfig2,
        withXSRFToken: defaultToConfig2,
        adapter: defaultToConfig2,
        responseType: defaultToConfig2,
        xsrfCookieName: defaultToConfig2,
        xsrfHeaderName: defaultToConfig2,
        onUploadProgress: defaultToConfig2,
        onDownloadProgress: defaultToConfig2,
        decompress: defaultToConfig2,
        maxContentLength: defaultToConfig2,
        maxBodyLength: defaultToConfig2,
        beforeRedirect: defaultToConfig2,
        transport: defaultToConfig2,
        httpAgent: defaultToConfig2,
        httpsAgent: defaultToConfig2,
        cancelToken: defaultToConfig2,
        socketPath: defaultToConfig2,
        responseEncoding: defaultToConfig2,
        validateStatus: mergeDirectKeys,
        headers: (a, b, prop) => mergeDeepProperties(headersToObject(a), headersToObject(b), prop, true)
      };
      utils$1.forEach(Object.keys({ ...config1, ...config2 }), function computeConfigValue(prop) {
        const merge2 = mergeMap[prop] || mergeDeepProperties;
        const configValue = merge2(config1[prop], config2[prop], prop);
        utils$1.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
      });
      return config;
    }
    var resolveConfig = (config) => {
      const newConfig = mergeConfig({}, config);
      let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
      newConfig.headers = headers = AxiosHeaders$1.from(headers);
      newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config.params, config.paramsSerializer);
      if (auth) {
        headers.set(
          "Authorization",
          "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
        );
      }
      if (utils$1.isFormData(data)) {
        if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
          headers.setContentType(void 0);
        } else if (utils$1.isFunction(data.getHeaders)) {
          const formHeaders = data.getHeaders();
          const allowedHeaders = ["content-type", "content-length"];
          Object.entries(formHeaders).forEach(([key, val]) => {
            if (allowedHeaders.includes(key.toLowerCase())) {
              headers.set(key, val);
            }
          });
        }
      }
      if (platform.hasStandardBrowserEnv) {
        withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
        if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(newConfig.url)) {
          const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);
          if (xsrfValue) {
            headers.set(xsrfHeaderName, xsrfValue);
          }
        }
      }
      return newConfig;
    };
    var isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
    var xhrAdapter = isXHRAdapterSupported && function(config) {
      return new Promise(function dispatchXhrRequest(resolve8, reject) {
        const _config = resolveConfig(config);
        let requestData = _config.data;
        const requestHeaders = AxiosHeaders$1.from(_config.headers).normalize();
        let { responseType, onUploadProgress, onDownloadProgress } = _config;
        let onCanceled;
        let uploadThrottled, downloadThrottled;
        let flushUpload, flushDownload;
        function done() {
          flushUpload && flushUpload();
          flushDownload && flushDownload();
          _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
          _config.signal && _config.signal.removeEventListener("abort", onCanceled);
        }
        let request = new XMLHttpRequest();
        request.open(_config.method.toUpperCase(), _config.url, true);
        request.timeout = _config.timeout;
        function onloadend() {
          if (!request) {
            return;
          }
          const responseHeaders = AxiosHeaders$1.from(
            "getAllResponseHeaders" in request && request.getAllResponseHeaders()
          );
          const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
          const response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config,
            request
          };
          settle(function _resolve(value) {
            resolve8(value);
            done();
          }, function _reject(err) {
            reject(err);
            done();
          }, response);
          request = null;
        }
        if ("onloadend" in request) {
          request.onloadend = onloadend;
        } else {
          request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
              return;
            }
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
              return;
            }
            setTimeout(onloadend);
          };
        }
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }
          reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config, request));
          request = null;
        };
        request.onerror = function handleError(event) {
          const msg = event && event.message ? event.message : "Network Error";
          const err = new AxiosError(msg, AxiosError.ERR_NETWORK, config, request);
          err.event = event || null;
          reject(err);
          request = null;
        };
        request.ontimeout = function handleTimeout() {
          let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
          const transitional = _config.transitional || transitionalDefaults;
          if (_config.timeoutErrorMessage) {
            timeoutErrorMessage = _config.timeoutErrorMessage;
          }
          reject(new AxiosError(
            timeoutErrorMessage,
            transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
            config,
            request
          ));
          request = null;
        };
        requestData === void 0 && requestHeaders.setContentType(null);
        if ("setRequestHeader" in request) {
          utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
            request.setRequestHeader(key, val);
          });
        }
        if (!utils$1.isUndefined(_config.withCredentials)) {
          request.withCredentials = !!_config.withCredentials;
        }
        if (responseType && responseType !== "json") {
          request.responseType = _config.responseType;
        }
        if (onDownloadProgress) {
          [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
          request.addEventListener("progress", downloadThrottled);
        }
        if (onUploadProgress && request.upload) {
          [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
          request.upload.addEventListener("progress", uploadThrottled);
          request.upload.addEventListener("loadend", flushUpload);
        }
        if (_config.cancelToken || _config.signal) {
          onCanceled = (cancel) => {
            if (!request) {
              return;
            }
            reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);
            request.abort();
            request = null;
          };
          _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
          if (_config.signal) {
            _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
          }
        }
        const protocol = parseProtocol(_config.url);
        if (protocol && platform.protocols.indexOf(protocol) === -1) {
          reject(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config));
          return;
        }
        request.send(requestData || null);
      });
    };
    var composeSignals = (signals, timeout) => {
      const { length } = signals = signals ? signals.filter(Boolean) : [];
      if (timeout || length) {
        let controller = new AbortController();
        let aborted;
        const onabort = function(reason) {
          if (!aborted) {
            aborted = true;
            unsubscribe();
            const err = reason instanceof Error ? reason : this.reason;
            controller.abort(err instanceof AxiosError ? err : new CanceledError(err instanceof Error ? err.message : err));
          }
        };
        let timer = timeout && setTimeout(() => {
          timer = null;
          onabort(new AxiosError(`timeout ${timeout} of ms exceeded`, AxiosError.ETIMEDOUT));
        }, timeout);
        const unsubscribe = () => {
          if (signals) {
            timer && clearTimeout(timer);
            timer = null;
            signals.forEach((signal2) => {
              signal2.unsubscribe ? signal2.unsubscribe(onabort) : signal2.removeEventListener("abort", onabort);
            });
            signals = null;
          }
        };
        signals.forEach((signal2) => signal2.addEventListener("abort", onabort));
        const { signal } = controller;
        signal.unsubscribe = () => utils$1.asap(unsubscribe);
        return signal;
      }
    };
    var composeSignals$1 = composeSignals;
    var streamChunk = function* (chunk, chunkSize) {
      let len = chunk.byteLength;
      if (!chunkSize || len < chunkSize) {
        yield chunk;
        return;
      }
      let pos = 0;
      let end;
      while (pos < len) {
        end = pos + chunkSize;
        yield chunk.slice(pos, end);
        pos = end;
      }
    };
    var readBytes = async function* (iterable, chunkSize) {
      for await (const chunk of readStream(iterable)) {
        yield* streamChunk(chunk, chunkSize);
      }
    };
    var readStream = async function* (stream2) {
      if (stream2[Symbol.asyncIterator]) {
        yield* stream2;
        return;
      }
      const reader = stream2.getReader();
      try {
        for (; ; ) {
          const { done, value } = await reader.read();
          if (done) {
            break;
          }
          yield value;
        }
      } finally {
        await reader.cancel();
      }
    };
    var trackStream = (stream2, chunkSize, onProgress, onFinish) => {
      const iterator2 = readBytes(stream2, chunkSize);
      let bytes = 0;
      let done;
      let _onFinish = (e) => {
        if (!done) {
          done = true;
          onFinish && onFinish(e);
        }
      };
      return new ReadableStream({
        async pull(controller) {
          try {
            const { done: done2, value } = await iterator2.next();
            if (done2) {
              _onFinish();
              controller.close();
              return;
            }
            let len = value.byteLength;
            if (onProgress) {
              let loadedBytes = bytes += len;
              onProgress(loadedBytes);
            }
            controller.enqueue(new Uint8Array(value));
          } catch (err) {
            _onFinish(err);
            throw err;
          }
        },
        cancel(reason) {
          _onFinish(reason);
          return iterator2.return();
        }
      }, {
        highWaterMark: 2
      });
    };
    var DEFAULT_CHUNK_SIZE = 64 * 1024;
    var { isFunction } = utils$1;
    var globalFetchAPI = (({ Request, Response }) => ({
      Request,
      Response
    }))(utils$1.global);
    var {
      ReadableStream: ReadableStream$1,
      TextEncoder: TextEncoder$1
    } = utils$1.global;
    var test = (fn, ...args) => {
      try {
        return !!fn(...args);
      } catch (e) {
        return false;
      }
    };
    var factory = (env) => {
      env = utils$1.merge.call({
        skipUndefined: true
      }, globalFetchAPI, env);
      const { fetch: envFetch, Request, Response } = env;
      const isFetchSupported = envFetch ? isFunction(envFetch) : typeof fetch === "function";
      const isRequestSupported = isFunction(Request);
      const isResponseSupported = isFunction(Response);
      if (!isFetchSupported) {
        return false;
      }
      const isReadableStreamSupported = isFetchSupported && isFunction(ReadableStream$1);
      const encodeText = isFetchSupported && (typeof TextEncoder$1 === "function" ? /* @__PURE__ */ ((encoder) => (str) => encoder.encode(str))(new TextEncoder$1()) : async (str) => new Uint8Array(await new Request(str).arrayBuffer()));
      const supportsRequestStream = isRequestSupported && isReadableStreamSupported && test(() => {
        let duplexAccessed = false;
        const hasContentType = new Request(platform.origin, {
          body: new ReadableStream$1(),
          method: "POST",
          get duplex() {
            duplexAccessed = true;
            return "half";
          }
        }).headers.has("Content-Type");
        return duplexAccessed && !hasContentType;
      });
      const supportsResponseStream = isResponseSupported && isReadableStreamSupported && test(() => utils$1.isReadableStream(new Response("").body));
      const resolvers = {
        stream: supportsResponseStream && ((res) => res.body)
      };
      isFetchSupported && (() => {
        ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type) => {
          !resolvers[type] && (resolvers[type] = (res, config) => {
            let method = res && res[type];
            if (method) {
              return method.call(res);
            }
            throw new AxiosError(`Response type '${type}' is not supported`, AxiosError.ERR_NOT_SUPPORT, config);
          });
        });
      })();
      const getBodyLength = async (body) => {
        if (body == null) {
          return 0;
        }
        if (utils$1.isBlob(body)) {
          return body.size;
        }
        if (utils$1.isSpecCompliantForm(body)) {
          const _request = new Request(platform.origin, {
            method: "POST",
            body
          });
          return (await _request.arrayBuffer()).byteLength;
        }
        if (utils$1.isArrayBufferView(body) || utils$1.isArrayBuffer(body)) {
          return body.byteLength;
        }
        if (utils$1.isURLSearchParams(body)) {
          body = body + "";
        }
        if (utils$1.isString(body)) {
          return (await encodeText(body)).byteLength;
        }
      };
      const resolveBodyLength = async (headers, body) => {
        const length = utils$1.toFiniteNumber(headers.getContentLength());
        return length == null ? getBodyLength(body) : length;
      };
      return async (config) => {
        let {
          url: url2,
          method,
          data,
          signal,
          cancelToken,
          timeout,
          onDownloadProgress,
          onUploadProgress,
          responseType,
          headers,
          withCredentials = "same-origin",
          fetchOptions
        } = resolveConfig(config);
        let _fetch = envFetch || fetch;
        responseType = responseType ? (responseType + "").toLowerCase() : "text";
        let composedSignal = composeSignals$1([signal, cancelToken && cancelToken.toAbortSignal()], timeout);
        let request = null;
        const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
          composedSignal.unsubscribe();
        });
        let requestContentLength;
        try {
          if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
            let _request = new Request(url2, {
              method: "POST",
              body: data,
              duplex: "half"
            });
            let contentTypeHeader;
            if (utils$1.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
              headers.setContentType(contentTypeHeader);
            }
            if (_request.body) {
              const [onProgress, flush] = progressEventDecorator(
                requestContentLength,
                progressEventReducer(asyncDecorator(onUploadProgress))
              );
              data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
            }
          }
          if (!utils$1.isString(withCredentials)) {
            withCredentials = withCredentials ? "include" : "omit";
          }
          const isCredentialsSupported = isRequestSupported && "credentials" in Request.prototype;
          const resolvedOptions = {
            ...fetchOptions,
            signal: composedSignal,
            method: method.toUpperCase(),
            headers: headers.normalize().toJSON(),
            body: data,
            duplex: "half",
            credentials: isCredentialsSupported ? withCredentials : void 0
          };
          request = isRequestSupported && new Request(url2, resolvedOptions);
          let response = await (isRequestSupported ? _fetch(request, fetchOptions) : _fetch(url2, resolvedOptions));
          const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
          if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
            const options = {};
            ["status", "statusText", "headers"].forEach((prop) => {
              options[prop] = response[prop];
            });
            const responseContentLength = utils$1.toFiniteNumber(response.headers.get("content-length"));
            const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
              responseContentLength,
              progressEventReducer(asyncDecorator(onDownloadProgress), true)
            ) || [];
            response = new Response(
              trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
                flush && flush();
                unsubscribe && unsubscribe();
              }),
              options
            );
          }
          responseType = responseType || "text";
          let responseData = await resolvers[utils$1.findKey(resolvers, responseType) || "text"](response, config);
          !isStreamResponse && unsubscribe && unsubscribe();
          return await new Promise((resolve8, reject) => {
            settle(resolve8, reject, {
              data: responseData,
              headers: AxiosHeaders$1.from(response.headers),
              status: response.status,
              statusText: response.statusText,
              config,
              request
            });
          });
        } catch (err) {
          unsubscribe && unsubscribe();
          if (err && err.name === "TypeError" && /Load failed|fetch/i.test(err.message)) {
            throw Object.assign(
              new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request),
              {
                cause: err.cause || err
              }
            );
          }
          throw AxiosError.from(err, err && err.code, config, request);
        }
      };
    };
    var seedCache = /* @__PURE__ */ new Map();
    var getFetch = (config) => {
      let env = config && config.env || {};
      const { fetch: fetch2, Request, Response } = env;
      const seeds = [
        Request,
        Response,
        fetch2
      ];
      let len = seeds.length, i = len, seed, target, map = seedCache;
      while (i--) {
        seed = seeds[i];
        target = map.get(seed);
        target === void 0 && map.set(seed, target = i ? /* @__PURE__ */ new Map() : factory(env));
        map = target;
      }
      return target;
    };
    getFetch();
    var knownAdapters = {
      http: httpAdapter,
      xhr: xhrAdapter,
      fetch: {
        get: getFetch
      }
    };
    utils$1.forEach(knownAdapters, (fn, value) => {
      if (fn) {
        try {
          Object.defineProperty(fn, "name", { value });
        } catch (e) {
        }
        Object.defineProperty(fn, "adapterName", { value });
      }
    });
    var renderReason = (reason) => `- ${reason}`;
    var isResolvedHandle = (adapter) => utils$1.isFunction(adapter) || adapter === null || adapter === false;
    function getAdapter(adapters2, config) {
      adapters2 = utils$1.isArray(adapters2) ? adapters2 : [adapters2];
      const { length } = adapters2;
      let nameOrAdapter;
      let adapter;
      const rejectedReasons = {};
      for (let i = 0; i < length; i++) {
        nameOrAdapter = adapters2[i];
        let id;
        adapter = nameOrAdapter;
        if (!isResolvedHandle(nameOrAdapter)) {
          adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
          if (adapter === void 0) {
            throw new AxiosError(`Unknown adapter '${id}'`);
          }
        }
        if (adapter && (utils$1.isFunction(adapter) || (adapter = adapter.get(config)))) {
          break;
        }
        rejectedReasons[id || "#" + i] = adapter;
      }
      if (!adapter) {
        const reasons = Object.entries(rejectedReasons).map(
          ([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
        );
        let s = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
        throw new AxiosError(
          `There is no suitable adapter to dispatch the request ` + s,
          "ERR_NOT_SUPPORT"
        );
      }
      return adapter;
    }
    var adapters = {
      /**
       * Resolve an adapter from a list of adapter names or functions.
       * @type {Function}
       */
      getAdapter,
      /**
       * Exposes all known adapters
       * @type {Object<string, Function|Object>}
       */
      adapters: knownAdapters
    };
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }
      if (config.signal && config.signal.aborted) {
        throw new CanceledError(null, config);
      }
    }
    function dispatchRequest(config) {
      throwIfCancellationRequested(config);
      config.headers = AxiosHeaders$1.from(config.headers);
      config.data = transformData.call(
        config,
        config.transformRequest
      );
      if (["post", "put", "patch"].indexOf(config.method) !== -1) {
        config.headers.setContentType("application/x-www-form-urlencoded", false);
      }
      const adapter = adapters.getAdapter(config.adapter || defaults$1.adapter, config);
      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);
        response.data = transformData.call(
          config,
          config.transformResponse,
          response
        );
        response.headers = AxiosHeaders$1.from(response.headers);
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config);
          if (reason && reason.response) {
            reason.response.data = transformData.call(
              config,
              config.transformResponse,
              reason.response
            );
            reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
          }
        }
        return Promise.reject(reason);
      });
    }
    var validators$1 = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
      validators$1[type] = function validator2(thing) {
        return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
      };
    });
    var deprecatedWarnings = {};
    validators$1.transitional = function transitional(validator2, version, message) {
      function formatMessage(opt, desc) {
        return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
      }
      return (value, opt, opts) => {
        if (validator2 === false) {
          throw new AxiosError(
            formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
            AxiosError.ERR_DEPRECATED
          );
        }
        if (version && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          console.warn(
            formatMessage(
              opt,
              " has been deprecated since v" + version + " and will be removed in the near future"
            )
          );
        }
        return validator2 ? validator2(value, opt, opts) : true;
      };
    };
    validators$1.spelling = function spelling(correctSpelling) {
      return (value, opt) => {
        console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
        return true;
      };
    };
    function assertOptions(options, schema, allowUnknown) {
      if (typeof options !== "object") {
        throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
      }
      const keys = Object.keys(options);
      let i = keys.length;
      while (i-- > 0) {
        const opt = keys[i];
        const validator2 = schema[opt];
        if (validator2) {
          const value = options[opt];
          const result = value === void 0 || validator2(value, opt, options);
          if (result !== true) {
            throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
        }
      }
    }
    var validator = {
      assertOptions,
      validators: validators$1
    };
    var validators = validator.validators;
    var Axios = class {
      constructor(instanceConfig) {
        this.defaults = instanceConfig || {};
        this.interceptors = {
          request: new InterceptorManager$1(),
          response: new InterceptorManager$1()
        };
      }
      /**
       * Dispatch a request
       *
       * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
       * @param {?Object} config
       *
       * @returns {Promise} The Promise to be fulfilled
       */
      async request(configOrUrl, config) {
        try {
          return await this._request(configOrUrl, config);
        } catch (err) {
          if (err instanceof Error) {
            let dummy = {};
            Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = new Error();
            const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
            try {
              if (!err.stack) {
                err.stack = stack;
              } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
                err.stack += "\n" + stack;
              }
            } catch (e) {
            }
          }
          throw err;
        }
      }
      _request(configOrUrl, config) {
        if (typeof configOrUrl === "string") {
          config = config || {};
          config.url = configOrUrl;
        } else {
          config = configOrUrl || {};
        }
        config = mergeConfig(this.defaults, config);
        const { transitional, paramsSerializer, headers } = config;
        if (transitional !== void 0) {
          validator.assertOptions(transitional, {
            silentJSONParsing: validators.transitional(validators.boolean),
            forcedJSONParsing: validators.transitional(validators.boolean),
            clarifyTimeoutError: validators.transitional(validators.boolean)
          }, false);
        }
        if (paramsSerializer != null) {
          if (utils$1.isFunction(paramsSerializer)) {
            config.paramsSerializer = {
              serialize: paramsSerializer
            };
          } else {
            validator.assertOptions(paramsSerializer, {
              encode: validators.function,
              serialize: validators.function
            }, true);
          }
        }
        if (config.allowAbsoluteUrls !== void 0) ;
        else if (this.defaults.allowAbsoluteUrls !== void 0) {
          config.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
        } else {
          config.allowAbsoluteUrls = true;
        }
        validator.assertOptions(config, {
          baseUrl: validators.spelling("baseURL"),
          withXsrfToken: validators.spelling("withXSRFToken")
        }, true);
        config.method = (config.method || this.defaults.method || "get").toLowerCase();
        let contextHeaders = headers && utils$1.merge(
          headers.common,
          headers[config.method]
        );
        headers && utils$1.forEach(
          ["delete", "get", "head", "post", "put", "patch", "common"],
          (method) => {
            delete headers[method];
          }
        );
        config.headers = AxiosHeaders$1.concat(contextHeaders, headers);
        const requestInterceptorChain = [];
        let synchronousRequestInterceptors = true;
        this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
          if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
            return;
          }
          synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
          requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
        });
        const responseInterceptorChain = [];
        this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
          responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
        });
        let promise2;
        let i = 0;
        let len;
        if (!synchronousRequestInterceptors) {
          const chain = [dispatchRequest.bind(this), void 0];
          chain.unshift(...requestInterceptorChain);
          chain.push(...responseInterceptorChain);
          len = chain.length;
          promise2 = Promise.resolve(config);
          while (i < len) {
            promise2 = promise2.then(chain[i++], chain[i++]);
          }
          return promise2;
        }
        len = requestInterceptorChain.length;
        let newConfig = config;
        while (i < len) {
          const onFulfilled = requestInterceptorChain[i++];
          const onRejected = requestInterceptorChain[i++];
          try {
            newConfig = onFulfilled(newConfig);
          } catch (error) {
            onRejected.call(this, error);
            break;
          }
        }
        try {
          promise2 = dispatchRequest.call(this, newConfig);
        } catch (error) {
          return Promise.reject(error);
        }
        i = 0;
        len = responseInterceptorChain.length;
        while (i < len) {
          promise2 = promise2.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
        }
        return promise2;
      }
      getUri(config) {
        config = mergeConfig(this.defaults, config);
        const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);
        return buildURL(fullPath, config.params, config.paramsSerializer);
      }
    };
    utils$1.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
      Axios.prototype[method] = function(url2, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          url: url2,
          data: (config || {}).data
        }));
      };
    });
    utils$1.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      function generateHTTPMethod(isForm) {
        return function httpMethod(url2, data, config) {
          return this.request(mergeConfig(config || {}, {
            method,
            headers: isForm ? {
              "Content-Type": "multipart/form-data"
            } : {},
            url: url2,
            data
          }));
        };
      }
      Axios.prototype[method] = generateHTTPMethod();
      Axios.prototype[method + "Form"] = generateHTTPMethod(true);
    });
    var Axios$1 = Axios;
    var CancelToken = class _CancelToken {
      constructor(executor) {
        if (typeof executor !== "function") {
          throw new TypeError("executor must be a function.");
        }
        let resolvePromise;
        this.promise = new Promise(function promiseExecutor(resolve8) {
          resolvePromise = resolve8;
        });
        const token = this;
        this.promise.then((cancel) => {
          if (!token._listeners) return;
          let i = token._listeners.length;
          while (i-- > 0) {
            token._listeners[i](cancel);
          }
          token._listeners = null;
        });
        this.promise.then = (onfulfilled) => {
          let _resolve;
          const promise2 = new Promise((resolve8) => {
            token.subscribe(resolve8);
            _resolve = resolve8;
          }).then(onfulfilled);
          promise2.cancel = function reject() {
            token.unsubscribe(_resolve);
          };
          return promise2;
        };
        executor(function cancel(message, config, request) {
          if (token.reason) {
            return;
          }
          token.reason = new CanceledError(message, config, request);
          resolvePromise(token.reason);
        });
      }
      /**
       * Throws a `CanceledError` if cancellation has been requested.
       */
      throwIfRequested() {
        if (this.reason) {
          throw this.reason;
        }
      }
      /**
       * Subscribe to the cancel signal
       */
      subscribe(listener) {
        if (this.reason) {
          listener(this.reason);
          return;
        }
        if (this._listeners) {
          this._listeners.push(listener);
        } else {
          this._listeners = [listener];
        }
      }
      /**
       * Unsubscribe from the cancel signal
       */
      unsubscribe(listener) {
        if (!this._listeners) {
          return;
        }
        const index = this._listeners.indexOf(listener);
        if (index !== -1) {
          this._listeners.splice(index, 1);
        }
      }
      toAbortSignal() {
        const controller = new AbortController();
        const abort = (err) => {
          controller.abort(err);
        };
        this.subscribe(abort);
        controller.signal.unsubscribe = () => this.unsubscribe(abort);
        return controller.signal;
      }
      /**
       * Returns an object that contains a new `CancelToken` and a function that, when called,
       * cancels the `CancelToken`.
       */
      static source() {
        let cancel;
        const token = new _CancelToken(function executor(c) {
          cancel = c;
        });
        return {
          token,
          cancel
        };
      }
    };
    var CancelToken$1 = CancelToken;
    function spread(callback2) {
      return function wrap(arr) {
        return callback2.apply(null, arr);
      };
    }
    function isAxiosError(payload) {
      return utils$1.isObject(payload) && payload.isAxiosError === true;
    }
    var HttpStatusCode = {
      Continue: 100,
      SwitchingProtocols: 101,
      Processing: 102,
      EarlyHints: 103,
      Ok: 200,
      Created: 201,
      Accepted: 202,
      NonAuthoritativeInformation: 203,
      NoContent: 204,
      ResetContent: 205,
      PartialContent: 206,
      MultiStatus: 207,
      AlreadyReported: 208,
      ImUsed: 226,
      MultipleChoices: 300,
      MovedPermanently: 301,
      Found: 302,
      SeeOther: 303,
      NotModified: 304,
      UseProxy: 305,
      Unused: 306,
      TemporaryRedirect: 307,
      PermanentRedirect: 308,
      BadRequest: 400,
      Unauthorized: 401,
      PaymentRequired: 402,
      Forbidden: 403,
      NotFound: 404,
      MethodNotAllowed: 405,
      NotAcceptable: 406,
      ProxyAuthenticationRequired: 407,
      RequestTimeout: 408,
      Conflict: 409,
      Gone: 410,
      LengthRequired: 411,
      PreconditionFailed: 412,
      PayloadTooLarge: 413,
      UriTooLong: 414,
      UnsupportedMediaType: 415,
      RangeNotSatisfiable: 416,
      ExpectationFailed: 417,
      ImATeapot: 418,
      MisdirectedRequest: 421,
      UnprocessableEntity: 422,
      Locked: 423,
      FailedDependency: 424,
      TooEarly: 425,
      UpgradeRequired: 426,
      PreconditionRequired: 428,
      TooManyRequests: 429,
      RequestHeaderFieldsTooLarge: 431,
      UnavailableForLegalReasons: 451,
      InternalServerError: 500,
      NotImplemented: 501,
      BadGateway: 502,
      ServiceUnavailable: 503,
      GatewayTimeout: 504,
      HttpVersionNotSupported: 505,
      VariantAlsoNegotiates: 506,
      InsufficientStorage: 507,
      LoopDetected: 508,
      NotExtended: 510,
      NetworkAuthenticationRequired: 511,
      WebServerIsDown: 521,
      ConnectionTimedOut: 522,
      OriginIsUnreachable: 523,
      TimeoutOccurred: 524,
      SslHandshakeFailed: 525,
      InvalidSslCertificate: 526
    };
    Object.entries(HttpStatusCode).forEach(([key, value]) => {
      HttpStatusCode[value] = key;
    });
    var HttpStatusCode$1 = HttpStatusCode;
    function createInstance(defaultConfig) {
      const context = new Axios$1(defaultConfig);
      const instance = bind(Axios$1.prototype.request, context);
      utils$1.extend(instance, Axios$1.prototype, context, { allOwnKeys: true });
      utils$1.extend(instance, context, null, { allOwnKeys: true });
      instance.create = function create(instanceConfig) {
        return createInstance(mergeConfig(defaultConfig, instanceConfig));
      };
      return instance;
    }
    var axios = createInstance(defaults$1);
    axios.Axios = Axios$1;
    axios.CanceledError = CanceledError;
    axios.CancelToken = CancelToken$1;
    axios.isCancel = isCancel;
    axios.VERSION = VERSION;
    axios.toFormData = toFormData;
    axios.AxiosError = AxiosError;
    axios.Cancel = axios.CanceledError;
    axios.all = function all(promises2) {
      return Promise.all(promises2);
    };
    axios.spread = spread;
    axios.isAxiosError = isAxiosError;
    axios.mergeConfig = mergeConfig;
    axios.AxiosHeaders = AxiosHeaders$1;
    axios.formToJSON = (thing) => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);
    axios.getAdapter = adapters.getAdapter;
    axios.HttpStatusCode = HttpStatusCode$1;
    axios.default = axios;
    module2.exports = axios;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-management/tunnelPlanTokenProperties.js
var require_tunnelPlanTokenProperties = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-management/tunnelPlanTokenProperties.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TunnelPlanTokenProperties = void 0;
    var TunnelPlanTokenProperties = class _TunnelPlanTokenProperties {
      constructor(clusterId, issuer, expiration, userEmail, tunnelPlanId, subscriptionId, scopes) {
        this.clusterId = clusterId;
        this.issuer = issuer;
        this.expiration = expiration;
        this.userEmail = userEmail;
        this.tunnelPlanId = tunnelPlanId;
        this.subscriptionId = subscriptionId;
        this.scopes = scopes;
      }
      /**
       * Checks if the tunnel access token expiration claim is in the past.
       * Note: uses client's system time for the validation.
       * (Does not throw if the token is an invalid format.)
       */
      static validateTokenExpiration(token) {
        const t = _TunnelPlanTokenProperties.tryParse(token);
        if (t === null || t === void 0 ? void 0 : t.expiration) {
          if (t.expiration < /* @__PURE__ */ new Date()) {
            throw new Error("The access token is expired: " + t);
          }
        }
      }
      /**
       * Attempts to parse a tunnel access token (JWT). This does NOT validate the token
       * signature or any claims.
       */
      static tryParse(token) {
        if (typeof token !== "string")
          throw new TypeError("Token string expected.");
        const tokenParts = token.split(".");
        if (tokenParts.length !== 3) {
          return null;
        }
        const tokenBodyJson = _TunnelPlanTokenProperties.base64UrlDecode(tokenParts[1]);
        if (!tokenBodyJson) {
          return null;
        }
        try {
          const tokenJson = JSON.parse(tokenBodyJson);
          const clusterId = tokenJson.clusterId;
          const subscriptionId = tokenJson.subscriptionId;
          const tunnelPlanId = tokenJson.tunnelPlanId;
          const userEmail = tokenJson.userEmail;
          const scp = tokenJson.scp;
          const iss = tokenJson.iss;
          const exp = tokenJson.exp;
          return new _TunnelPlanTokenProperties(clusterId, iss, typeof exp === "number" ? new Date(exp * 1e3) : void 0, userEmail, tunnelPlanId, subscriptionId, scp === null || scp === void 0 ? void 0 : scp.split(" "));
        } catch (_a2) {
          return null;
        }
      }
      /**
       * Gets the tunnal access token trace string.
       * 'none' if null or undefined, parsed token info if can be parsed, or 'token' if cannot be parsed.
       */
      static getTokenTrace(token) {
        var _a2, _b;
        return !token ? "none" : (_b = (_a2 = _TunnelPlanTokenProperties.tryParse(token)) === null || _a2 === void 0 ? void 0 : _a2.toString()) !== null && _b !== void 0 ? _b : "token";
      }
      static base64UrlDecode(encodedString) {
        encodedString = encodedString.replace("-", "+");
        while (encodedString.length % 4 !== 0) {
          encodedString += "=";
        }
        try {
          const result = atob(encodedString);
          return result;
        } catch (_a2) {
          return null;
        }
      }
    };
    exports2.TunnelPlanTokenProperties = TunnelPlanTokenProperties;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-management/idGeneration.js
var require_idGeneration = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-management/idGeneration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IdGeneration = void 0;
    var dev_tunnels_contracts_1 = require_dev_tunnels_contracts();
    var IdGeneration = class {
      static generateTunnelId() {
        let tunnelId = "";
        tunnelId += this.adjectives[Math.floor(Math.random() * this.adjectives.length)] + "-";
        tunnelId += this.nouns[Math.floor(Math.random() * this.nouns.length)] + "-";
        for (let i = 0; i < 7; i++) {
          tunnelId += dev_tunnels_contracts_1.TunnelConstraints.oldTunnelIdChars[Math.floor(Math.random() * dev_tunnels_contracts_1.TunnelConstraints.oldTunnelIdChars.length)];
        }
        return tunnelId;
      }
    };
    exports2.IdGeneration = IdGeneration;
    IdGeneration.nouns = ["pond", "hill", "mountain", "field", "fog", "ant", "dog", "cat", "shoe", "plane", "chair", "book", "ocean", "lake", "river", "horse"];
    IdGeneration.adjectives = ["fun", "happy", "interesting", "neat", "peaceful", "puzzled", "kind", "joyful", "new", "giant", "sneaky", "quick", "majestic", "jolly", "fancy", "tidy", "swift", "silent", "amusing", "spiffy"];
  }
});

// ../../node_modules/@microsoft/dev-tunnels-management/tunnelManagementHttpClient.js
var require_tunnelManagementHttpClient = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-management/tunnelManagementHttpClient.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TunnelManagementHttpClient = exports2.ManagementApiVersions = void 0;
    var vscode_jsonrpc_1 = require_main();
    var dev_tunnels_ssh_1 = require_dev_tunnels_ssh();
    var dev_tunnels_contracts_1 = require_dev_tunnels_contracts();
    var tunnelManagementClient_1 = require_tunnelManagementClient();
    var tunnelAccessTokenProperties_1 = require_tunnelAccessTokenProperties();
    var version_1 = require_version();
    var axios_1 = require_axios();
    var tunnelPlanTokenProperties_1 = require_tunnelPlanTokenProperties();
    var idGeneration_1 = require_idGeneration();
    var tunnelsApiPath = "/tunnels";
    var limitsApiPath = "/userlimits";
    var endpointsApiSubPath = "/endpoints";
    var portsApiSubPath = "/ports";
    var eventsApiSubPath = "/events";
    var clustersApiPath = "/clusters";
    var tunnelAuthentication = "Authorization";
    var checkAvailablePath = ":checkNameAvailability";
    var createNameRetries = 3;
    var ManagementApiVersions3;
    (function(ManagementApiVersions4) {
      ManagementApiVersions4["Version20230927preview"] = "2023-09-27-preview";
    })(ManagementApiVersions3 = exports2.ManagementApiVersions || (exports2.ManagementApiVersions = {}));
    function comparePorts(a, b) {
      var _a2, _b;
      return ((_a2 = a.portNumber) !== null && _a2 !== void 0 ? _a2 : Number.MAX_SAFE_INTEGER) - ((_b = b.portNumber) !== null && _b !== void 0 ? _b : Number.MAX_SAFE_INTEGER);
    }
    function parseDate(value) {
      return typeof value === "string" ? new Date(Date.parse(value)) : value;
    }
    function parseTunnelDates(tunnel) {
      if (!tunnel)
        return;
      tunnel.created = parseDate(tunnel.created);
      if (tunnel.status) {
        tunnel.status.lastHostConnectionTime = parseDate(tunnel.status.lastHostConnectionTime);
        tunnel.status.lastClientConnectionTime = parseDate(tunnel.status.lastClientConnectionTime);
      }
    }
    function parseTunnelPortDates(port) {
      if (!port)
        return;
      if (port.status) {
        port.status.lastClientConnectionTime = parseDate(port.status.lastClientConnectionTime);
      }
    }
    function preserveAccessTokens(requestObject, resultObject) {
      var _a2;
      if (requestObject.accessTokens && resultObject) {
        (_a2 = resultObject.accessTokens) !== null && _a2 !== void 0 ? _a2 : resultObject.accessTokens = {};
        for (const scopeAndToken of Object.entries(requestObject.accessTokens)) {
          if (!resultObject.accessTokens[scopeAndToken[0]]) {
            resultObject.accessTokens[scopeAndToken[0]] = scopeAndToken[1];
          }
        }
      }
    }
    var manageAccessTokenScope = [dev_tunnels_contracts_1.TunnelAccessScopes.Manage];
    var hostAccessTokenScope = [dev_tunnels_contracts_1.TunnelAccessScopes.Host];
    var managePortsAccessTokenScopes = [
      dev_tunnels_contracts_1.TunnelAccessScopes.Manage,
      dev_tunnels_contracts_1.TunnelAccessScopes.ManagePorts,
      dev_tunnels_contracts_1.TunnelAccessScopes.Host
    ];
    var readAccessTokenScopes = [
      dev_tunnels_contracts_1.TunnelAccessScopes.Manage,
      dev_tunnels_contracts_1.TunnelAccessScopes.ManagePorts,
      dev_tunnels_contracts_1.TunnelAccessScopes.Host,
      dev_tunnels_contracts_1.TunnelAccessScopes.Connect
    ];
    var apiVersions = ["2023-09-27-preview"];
    var defaultRequestTimeoutMS = 2e4;
    var TunnelManagementHttpClient3 = class _TunnelManagementHttpClient {
      /**
       * Initializes a new instance of the `TunnelManagementHttpClient` class
       * with a client authentication callback, service URI, and HTTP handler.
       *
       * @param userAgent { name, version } object or a comment string to use as the User-Agent header.
       * @param apiVersion ApiVersion to be used for requests, value should be one of ManagementApiVersions enum.
       * @param userTokenCallback Optional async callback for retrieving a client authentication
       * header value with access token, for AAD or GitHub user authentication. This may be omitted
       * for anonymous tunnel clients, or if tunnel access tokens will be specified via
       * `TunnelRequestOptions.accessToken`.
       * @param tunnelServiceUri Optional tunnel service URI (not including any path). Defaults to
       * the global tunnel service URI.
       * @param httpsAgent Optional agent that will be invoked for HTTPS requests to the tunnel
       * service.
       * @param adapter Optional axios adapter to use for HTTP requests.
       */
      constructor(userAgents, apiVersion, userTokenCallback, tunnelServiceUri, httpsAgent, adapter) {
        var _a2;
        this.httpsAgent = httpsAgent;
        this.adapter = adapter;
        this.reportProgressEmitter = new vscode_jsonrpc_1.Emitter();
        this.onReportProgress = this.reportProgressEmitter.event;
        this.trace = (msg) => {
        };
        this.enableEventsReporting = false;
        this.eventsQueue = [];
        this.eventsPromise = null;
        this.isDisposed = false;
        this.eventsAvailableCompletion = new dev_tunnels_ssh_1.PromiseCompletionSource();
        if (apiVersions.indexOf(apiVersion) === -1) {
          throw new TypeError(`Invalid API version: ${apiVersion}, must be one of ${apiVersions}`);
        }
        this.apiVersion = apiVersion;
        if (!userAgents) {
          throw new TypeError("User agent must be provided.");
        }
        if (Array.isArray(userAgents)) {
          if (userAgents.length === 0) {
            throw new TypeError("User agents cannot be empty.");
          }
          let combinedUserAgents = "";
          userAgents.forEach((userAgent) => {
            var _a3;
            if (typeof userAgent !== "string") {
              if (!userAgent.name) {
                throw new TypeError("Invalid user agent. The name must be provided.");
              }
              if (typeof userAgent.name !== "string") {
                throw new TypeError("Invalid user agent. The name must be a string.");
              }
              if (userAgent.version && typeof userAgent.version !== "string") {
                throw new TypeError("Invalid user agent. The version must be a string.");
              }
              combinedUserAgents = `${combinedUserAgents}${userAgent.name}/${(_a3 = userAgent.version) !== null && _a3 !== void 0 ? _a3 : "unknown"} `;
            } else {
              combinedUserAgents = `${combinedUserAgents}${userAgent} `;
            }
          });
          this.userAgents = combinedUserAgents.trim();
        } else if (typeof userAgents !== "string") {
          if (!userAgents.name) {
            throw new TypeError("Invalid user agent. The name must be provided.");
          }
          if (typeof userAgents.name !== "string") {
            throw new TypeError("Invalid user agent. The name must be a string.");
          }
          if (userAgents.version && typeof userAgents.version !== "string") {
            throw new TypeError("Invalid user agent. The version must be a string.");
          }
          this.userAgents = `${userAgents.name}/${(_a2 = userAgents.version) !== null && _a2 !== void 0 ? _a2 : "unknown"}`;
        } else {
          this.userAgents = userAgents;
        }
        this.userTokenCallback = userTokenCallback !== null && userTokenCallback !== void 0 ? userTokenCallback : (() => Promise.resolve(null));
        if (!tunnelServiceUri) {
          tunnelServiceUri = dev_tunnels_contracts_1.TunnelServiceProperties.production.serviceUri;
        }
        const parsedUri = new URL(tunnelServiceUri);
        if (!parsedUri || parsedUri.pathname !== "/") {
          throw new TypeError(`Invalid tunnel service URI: ${tunnelServiceUri}`);
        }
        this.baseAddress = tunnelServiceUri;
      }
      async listTunnels(clusterId, domain, options, cancellation) {
        const queryParams = [clusterId ? null : "global=true", domain ? `domain=${domain}` : null];
        const query = queryParams.filter((p) => !!p).join("&");
        const results = await this.sendRequest("GET", clusterId, tunnelsApiPath, query, options, void 0, void 0, cancellation);
        let tunnels = new Array();
        if (results.value) {
          for (const region of results.value) {
            if (region.value) {
              tunnels = tunnels.concat(region.value);
            }
          }
        }
        tunnels.forEach(parseTunnelDates);
        return tunnels;
      }
      async getTunnel(tunnel, options, cancellation) {
        const result = await this.sendTunnelRequest("GET", tunnel, readAccessTokenScopes, void 0, void 0, options, void 0, void 0, cancellation);
        preserveAccessTokens(tunnel, result);
        parseTunnelDates(result);
        return result;
      }
      async createTunnel(tunnel, options, cancellation) {
        const tunnelId = tunnel.tunnelId;
        const idGenerated = tunnelId === void 0 || tunnelId === null || tunnelId === "";
        options = options || {};
        options.additionalHeaders = options.additionalHeaders || {};
        options.additionalHeaders["If-Not-Match"] = "*";
        if (idGenerated) {
          tunnel.tunnelId = idGeneration_1.IdGeneration.generateTunnelId();
        }
        for (let i = 0; i <= createNameRetries; i++) {
          try {
            const result = await this.sendTunnelRequest("PUT", tunnel, manageAccessTokenScope, void 0, void 0, options, this.convertTunnelForRequest(tunnel), void 0, cancellation, true);
            preserveAccessTokens(tunnel, result);
            parseTunnelDates(result);
            return result;
          } catch (error) {
            if (idGenerated) {
              tunnel.tunnelId = idGeneration_1.IdGeneration.generateTunnelId();
            } else {
              throw error;
            }
          }
        }
        const result2 = await this.sendTunnelRequest("PUT", tunnel, manageAccessTokenScope, void 0, void 0, options, this.convertTunnelForRequest(tunnel), void 0, cancellation, true);
        preserveAccessTokens(tunnel, result2);
        parseTunnelDates(result2);
        return result2;
      }
      async createOrUpdateTunnel(tunnel, options, cancellation) {
        const tunnelId = tunnel.tunnelId;
        const idGenerated = tunnelId === void 0 || tunnelId === null || tunnelId === "";
        if (idGenerated) {
          tunnel.tunnelId = idGeneration_1.IdGeneration.generateTunnelId();
        }
        for (let i = 0; i <= createNameRetries; i++) {
          try {
            const result = await this.sendTunnelRequest("PUT", tunnel, manageAccessTokenScope, void 0, void 0, options, this.convertTunnelForRequest(tunnel), void 0, cancellation, true);
            preserveAccessTokens(tunnel, result);
            parseTunnelDates(result);
            return result;
          } catch (error) {
            if (idGenerated) {
              tunnel.tunnelId = idGeneration_1.IdGeneration.generateTunnelId();
            } else {
              throw error;
            }
          }
        }
        const result2 = await this.sendTunnelRequest("PUT", tunnel, manageAccessTokenScope, void 0, "forceCreate=true", options, this.convertTunnelForRequest(tunnel), void 0, cancellation, true);
        preserveAccessTokens(tunnel, result2);
        parseTunnelDates(result2);
        return result2;
      }
      async updateTunnel(tunnel, options, cancellation) {
        options = options || {};
        options.additionalHeaders = options.additionalHeaders || {};
        options.additionalHeaders["If-Match"] = "*";
        const result = await this.sendTunnelRequest("PUT", tunnel, manageAccessTokenScope, void 0, void 0, options, this.convertTunnelForRequest(tunnel), void 0, cancellation);
        preserveAccessTokens(tunnel, result);
        parseTunnelDates(result);
        return result;
      }
      async deleteTunnel(tunnel, options, cancellation) {
        return await this.sendTunnelRequest("DELETE", tunnel, manageAccessTokenScope, void 0, void 0, options, void 0, true, cancellation);
      }
      async updateTunnelEndpoint(tunnel, endpoint, options, cancellation) {
        if (endpoint.id == null) {
          throw new Error("Endpoint ID must be specified when updating an endpoint.");
        }
        const path11 = `${endpointsApiSubPath}/${endpoint.id}`;
        const result = await this.sendTunnelRequest("PUT", tunnel, hostAccessTokenScope, path11, "connectionMode=" + endpoint.connectionMode, options, endpoint, void 0, cancellation);
        if (tunnel.endpoints) {
          tunnel.endpoints = tunnel.endpoints.filter((e) => e.hostId !== endpoint.hostId || e.connectionMode !== endpoint.connectionMode).concat(result);
        }
        return result;
      }
      async deleteTunnelEndpoints(tunnel, id, options, cancellation) {
        const path11 = `${endpointsApiSubPath}/${id}`;
        const result = await this.sendTunnelRequest("DELETE", tunnel, hostAccessTokenScope, path11, void 0, options, void 0, true, cancellation);
        if (result && tunnel.endpoints) {
          tunnel.endpoints = tunnel.endpoints.filter((e) => e.id !== id);
        }
        return result;
      }
      async listUserLimits(cancellation) {
        const results = await this.sendRequest("GET", void 0, limitsApiPath, void 0, void 0, void 0, void 0, cancellation);
        return results || [];
      }
      async listTunnelPorts(tunnel, options, cancellation) {
        const results = await this.sendTunnelRequest("GET", tunnel, readAccessTokenScopes, portsApiSubPath, void 0, options, void 0, void 0, cancellation);
        if (results.value) {
          results.value.forEach(parseTunnelPortDates);
        }
        return results.value;
      }
      async getTunnelPort(tunnel, portNumber, options, cancellation) {
        this.raiseReportProgress(dev_tunnels_contracts_1.TunnelProgress.StartingGetTunnelPort);
        const path11 = `${portsApiSubPath}/${portNumber}`;
        const result = await this.sendTunnelRequest("GET", tunnel, readAccessTokenScopes, path11, void 0, options, void 0, void 0, cancellation);
        parseTunnelPortDates(result);
        this.raiseReportProgress(dev_tunnels_contracts_1.TunnelProgress.CompletedGetTunnelPort);
        return result;
      }
      async createTunnelPort(tunnel, tunnelPort, options, cancellation) {
        this.raiseReportProgress(dev_tunnels_contracts_1.TunnelProgress.StartingCreateTunnelPort);
        tunnelPort = this.convertTunnelPortForRequest(tunnel, tunnelPort);
        const path11 = `${portsApiSubPath}/${tunnelPort.portNumber}`;
        options = options || {};
        options.additionalHeaders = options.additionalHeaders || {};
        options.additionalHeaders["If-Not-Match"] = "*";
        const result = await this.sendTunnelRequest("PUT", tunnel, managePortsAccessTokenScopes, path11, void 0, options, tunnelPort, void 0, cancellation);
        tunnel.ports = tunnel.ports || [];
        tunnel.ports = tunnel.ports.filter((p) => p.portNumber !== tunnelPort.portNumber).concat(result).sort(comparePorts);
        parseTunnelPortDates(result);
        this.raiseReportProgress(dev_tunnels_contracts_1.TunnelProgress.CompletedCreateTunnelPort);
        return result;
      }
      async updateTunnelPort(tunnel, tunnelPort, options, cancellation) {
        if (tunnelPort.clusterId && tunnel.clusterId && tunnelPort.clusterId !== tunnel.clusterId) {
          throw new Error("Tunnel port cluster ID is not consistent.");
        }
        options = options || {};
        options.additionalHeaders = options.additionalHeaders || {};
        options.additionalHeaders["If-Match"] = "*";
        const portNumber = tunnelPort.portNumber;
        const path11 = `${portsApiSubPath}/${portNumber}`;
        tunnelPort = this.convertTunnelPortForRequest(tunnel, tunnelPort);
        const result = await this.sendTunnelRequest("PUT", tunnel, managePortsAccessTokenScopes, path11, void 0, options, tunnelPort, void 0, cancellation);
        preserveAccessTokens(tunnelPort, result);
        parseTunnelPortDates(result);
        tunnel.ports = tunnel.ports || [];
        tunnel.ports = tunnel.ports.filter((p) => p.portNumber !== tunnelPort.portNumber).concat(result).sort(comparePorts);
        return result;
      }
      async createOrUpdateTunnelPort(tunnel, tunnelPort, options, cancellation) {
        tunnelPort = this.convertTunnelPortForRequest(tunnel, tunnelPort);
        const path11 = `${portsApiSubPath}/${tunnelPort.portNumber}`;
        const result = await this.sendTunnelRequest("PUT", tunnel, managePortsAccessTokenScopes, path11, void 0, options, tunnelPort, void 0, cancellation);
        tunnel.ports = tunnel.ports || [];
        tunnel.ports = tunnel.ports.filter((p) => p.portNumber !== tunnelPort.portNumber).concat(result).sort(comparePorts);
        parseTunnelPortDates(result);
        return result;
      }
      async deleteTunnelPort(tunnel, portNumber, options, cancellation) {
        const path11 = `${portsApiSubPath}/${portNumber}`;
        const result = await this.sendTunnelRequest("DELETE", tunnel, managePortsAccessTokenScopes, path11, void 0, options, void 0, true, cancellation);
        if (result && tunnel.ports) {
          tunnel.ports = tunnel.ports.filter((p) => p.portNumber !== portNumber).sort(comparePorts);
        }
        return result;
      }
      async listClusters(cancellation) {
        return await this.sendRequest("GET", void 0, clustersApiPath, void 0, void 0, void 0, false, cancellation);
      }
      /**
       * Sends an HTTP request to the tunnel management API, targeting a specific tunnel.
       * This protected method enables subclasses to support additional tunnel management APIs.
       * @param method HTTP request method.
       * @param tunnel Tunnel that the request is targeting.
       * @param accessTokenScopes Required array of access scopes for tokens in `tunnel.accessTokens`
       * that could be used to authorize the request.
       * @param path Optional request sub-path relative to the tunnel.
       * @param query Optional query string to append to the request.
       * @param options Request options.
       * @param body Optional request body object.
       * @param allowNotFound If true, a 404 response is returned as a null or false result
       * instead of an error.
       * @param cancellationToken Optional cancellation token for the request.
       * @param isCreate Set to true if this is a tunnel create request, default is false.
       * @returns Result of the request.
       */
      async sendTunnelRequest(method, tunnel, accessTokenScopes, path11, query, options, body, allowNotFound, cancellation, isCreate = false) {
        this.raiseReportProgress(dev_tunnels_contracts_1.TunnelProgress.StartingRequestUri);
        const uri = await this.buildUriForTunnel(tunnel, path11, query, options, isCreate);
        this.raiseReportProgress(dev_tunnels_contracts_1.TunnelProgress.StartingRequestConfig);
        const config = await this.getAxiosRequestConfig(tunnel, options, accessTokenScopes);
        this.raiseReportProgress(dev_tunnels_contracts_1.TunnelProgress.StartingSendTunnelRequest);
        try {
          const result = await this.request(method, uri, body, config, allowNotFound, cancellation);
          this.raiseReportProgress(dev_tunnels_contracts_1.TunnelProgress.CompletedSendTunnelRequest);
          return result;
        } catch (error) {
          if (/certificate/i.test(error.message)) {
            const originalErrorMessage = error.message;
            throw new Error("Tunnel service HTTPS certificate is invalid. This may be caused by the use of a self-signed certificate or a firewall intercepting the connection. " + originalErrorMessage + ". ");
          }
          throw error;
        }
      }
      /**
       * Sends an HTTP request to the tunnel management API.
       * This protected method enables subclasses to support additional tunnel management APIs.
       * @param method HTTP request method.
       * @param clusterId Optional tunnel service cluster ID to direct the request to. If unspecified,
       * the request will use the global traffic-manager to find the nearest cluster.
       * @param path Required request path.
       * @param query Optional query string to append to the request.
       * @param options Request options.
       * @param body Optional request body object.
       * @param allowNotFound If true, a 404 response is returned as a null or false result
       * instead of an error.
       * @param cancellationToken Optional cancellation token for the request.
       * @returns Result of the request.
       */
      async sendRequest(method, clusterId, path11, query, options, body, allowNotFound, cancellation) {
        this.raiseReportProgress(dev_tunnels_contracts_1.TunnelProgress.StartingSendTunnelRequest);
        const uri = await this.buildUri(clusterId, path11, query, options);
        const config = await this.getAxiosRequestConfig(void 0, options);
        try {
          const result = await this.request(method, uri, body, config, allowNotFound, cancellation);
          this.raiseReportProgress(dev_tunnels_contracts_1.TunnelProgress.CompletedSendTunnelRequest);
          return result;
        } catch (error) {
          if (/certificate/i.test(error.message)) {
            throw new Error("Tunnel service HTTPS certificate is invalid. This may be caused by the use of a self signed certificate or a firewall intercepting the connection.");
          }
          throw error;
        }
      }
      async checkNameAvailablility(tunnelName, cancellation) {
        tunnelName = encodeURI(tunnelName);
        const uri = await this.buildUri(void 0, `${tunnelsApiPath}/${tunnelName}${checkAvailablePath}`);
        const config = {
          httpsAgent: this.httpsAgent,
          adapter: this.adapter
        };
        return await this.request("GET", uri, void 0, config, void 0, cancellation);
      }
      reportEvent(tunnel, tunnelEvent, options) {
        var _a2;
        if (!tunnel) {
          throw new TypeError("A tunnel is required.");
        }
        if (!tunnelEvent) {
          throw new TypeError("A tunnelEvent is required.");
        }
        if (!this.apiVersion) {
          return;
        }
        if (!this.enableEventsReporting) {
          return;
        }
        if (this.isDisposed) {
          return;
        }
        (_a2 = tunnelEvent.timestamp) !== null && _a2 !== void 0 ? _a2 : tunnelEvent.timestamp = /* @__PURE__ */ new Date();
        const wasEmpty = this.eventsQueue.length === 0;
        this.eventsQueue.push({
          tunnel,
          event: tunnelEvent,
          requestOptions: options
        });
        if (wasEmpty) {
          this.eventsAvailableCompletion.resolve();
        }
        if (this.eventsPromise === null) {
          this.eventsPromise = this.processPendingEventsAsync();
        }
      }
      async processPendingEventsAsync() {
        const eventsToSend = [];
        while (!this.isDisposed) {
          await this.eventsAvailableCompletion.promise;
          this.eventsAvailableCompletion = new dev_tunnels_ssh_1.PromiseCompletionSource();
          const nextEventInfo = this.eventsQueue.shift();
          if (!nextEventInfo) {
            break;
          }
          const tunnel = nextEventInfo.tunnel;
          const requestOptions = nextEventInfo.requestOptions;
          eventsToSend.length = 0;
          eventsToSend.push(nextEventInfo.event);
          while (this.eventsQueue.length > 0) {
            const peekEventInfo = this.eventsQueue[0];
            if (peekEventInfo.tunnel !== tunnel || peekEventInfo.requestOptions !== requestOptions) {
              break;
            }
            eventsToSend.push(this.eventsQueue.shift().event);
          }
          try {
            const uri = await this.buildUriForTunnel(tunnel, eventsApiSubPath, this.tunnelRequestOptionsToQueryString(requestOptions), requestOptions);
            const config = await this.getAxiosRequestConfig(tunnel, requestOptions, readAccessTokenScopes);
            await this.request(
              "POST",
              uri,
              [...eventsToSend],
              // Create a copy to avoid mutation issues
              config,
              void 0,
              void 0
            );
          } catch (error) {
            this.trace(`Error uploading events: ${error}`);
          }
        }
      }
      raiseReportProgress(progress) {
        const args = {
          progress
        };
        this.reportProgressEmitter.fire(args);
      }
      getResponseErrorMessage(error, signal) {
        var _a2, _b, _c, _d, _e, _f;
        let errorMessage = "";
        if (signal.aborted) {
          error.code = "ECONNABORTED";
          errorMessage = `ECONNABORTED: (signal aborted) ${error.message}`;
        } else if (error.code === "ECONNABORTED") {
          errorMessage = `ECONNABORTED: (timeout) ${error.message}`;
        }
        if ((_a2 = error.response) === null || _a2 === void 0 ? void 0 : _a2.data) {
          const problemDetails = error.response.data;
          if (problemDetails.title || problemDetails.detail) {
            errorMessage = `Tunnel service error: ${problemDetails.title}`;
            if (problemDetails.detail) {
              errorMessage += " " + problemDetails.detail;
            }
            if (problemDetails.errors) {
              errorMessage += JSON.stringify(problemDetails.errors);
            }
          }
        }
        if (!errorMessage && error.response && error.response.status && error.response.status >= 400 && error.response.status < 500 && error.response.headers) {
          const headers = error.response.headers;
          const servedBy = headers["X-Served-By"] || headers["x-served-by"];
          if (!/tunnels-/.test(servedBy)) {
            const requestDomain = new URL((_c = (_b = error.config) === null || _b === void 0 ? void 0 : _b.url) !== null && _c !== void 0 ? _c : dev_tunnels_contracts_1.TunnelServiceProperties.production.serviceUri).host;
            errorMessage = `The tunnel request resulted in ${error.response.status} status, but the request did not reach the tunnel service. This may indicate the domain '${requestDomain}' is blocked by a firewall.`;
          }
        }
        if (!errorMessage) {
          if (error.response) {
            errorMessage = `Tunnel service returned status code: ${error.response.status} ${error.response.statusText}`;
          } else {
            errorMessage = (_e = (_d = error === null || error === void 0 ? void 0 : error.message) !== null && _d !== void 0 ? _d : error) !== null && _e !== void 0 ? _e : "Unknown tunnel service request error.";
          }
        }
        const requestIdHeaderName = "VsSaaS-Request-Id";
        if (((_f = error.response) === null || _f === void 0 ? void 0 : _f.headers) && error.response.headers[requestIdHeaderName]) {
          errorMessage += `
Request ID: ${error.response.headers[requestIdHeaderName]}`;
        }
        return errorMessage;
      }
      // Helper functions
      async buildUri(clusterId, path11, query, options) {
        if (clusterId === void 0 && this.userTokenCallback) {
          let token = await this.userTokenCallback();
          if (token && token.startsWith("tunnelplan")) {
            token = token.replace("tunnelplan ", "");
            const parsedToken = tunnelPlanTokenProperties_1.TunnelPlanTokenProperties.tryParse(token);
            if (parsedToken !== null && parsedToken.clusterId) {
              clusterId = parsedToken.clusterId;
            }
          }
        }
        let baseAddress = this.baseAddress;
        if (clusterId) {
          const url = new URL(baseAddress);
          const portNumber = parseInt(url.port, 10);
          url.hostname = _TunnelManagementHttpClient.replaceTunnelServiceHostnameClusterId(url.hostname, clusterId);
          if (url.protocol === "https:" && clusterId.startsWith("localhost") && portNumber % 10 > 0) {
            const clusterNumber = parseInt(clusterId.substring("localhost".length), 10);
            if (clusterNumber > 0 && clusterNumber < 10) {
              url.port = (portNumber - portNumber % 10 + clusterNumber).toString();
            }
          }
          baseAddress = url.toString();
        }
        baseAddress = `${baseAddress.replace(/\/$/, "")}${path11}`;
        const optionsQuery = this.tunnelRequestOptionsToQueryString(options, query);
        if (optionsQuery) {
          baseAddress += `?${optionsQuery}`;
        }
        return baseAddress;
      }
      static replaceTunnelServiceHostnameClusterId(hostname, clusterId) {
        if (!clusterId || hostname === "localhost" || hostname === "tunnels.local.api.visualstudio.com") {
          return hostname;
        }
        if (hostname.startsWith("global.") || dev_tunnels_contracts_1.TunnelConstraints.clusterIdPrefixRegex.test(hostname)) {
          return clusterId + hostname.substring(hostname.indexOf("."));
        } else {
          return `${clusterId}.${hostname}`;
        }
      }
      buildUriForTunnel(tunnel, path11, query, options, isCreate = false) {
        let tunnelPath = "";
        if ((tunnel.clusterId || isCreate) && tunnel.tunnelId) {
          tunnelPath = `${tunnelsApiPath}/${tunnel.tunnelId}`;
        } else {
          throw new Error("Tunnel object must include a tunnel ID always and cluster ID for non creates.");
        }
        if (options === null || options === void 0 ? void 0 : options.additionalQueryParameters) {
          for (const [paramName, paramValue] of Object.entries(options.additionalQueryParameters)) {
            if (query) {
              query += `&${paramName}=${paramValue}`;
            } else {
              query = `${paramName}=${paramValue}`;
            }
          }
        }
        return this.buildUri(tunnel.clusterId, tunnelPath + (path11 ? path11 : ""), query, options);
      }
      async getAxiosRequestConfig(tunnel, options, accessTokenScopes) {
        const headers = {};
        if (options && options.accessToken) {
          headers[tunnelAuthentication] = `${tunnelManagementClient_1.TunnelAuthenticationSchemes.tunnel} ${options.accessToken}`;
        }
        if (!(tunnelAuthentication in headers) && this.userTokenCallback) {
          const token = await this.userTokenCallback();
          if (token) {
            headers[tunnelAuthentication] = token;
          }
        }
        if (!(tunnelAuthentication in headers)) {
          const accessToken = tunnelAccessTokenProperties_1.TunnelAccessTokenProperties.getTunnelAccessToken(tunnel, accessTokenScopes);
          if (accessToken) {
            headers[tunnelAuthentication] = `${tunnelManagementClient_1.TunnelAuthenticationSchemes.tunnel} ${accessToken}`;
          }
        }
        const copyAdditionalHeaders = (additionalHeaders) => {
          if (additionalHeaders) {
            for (const [headerName, headerValue] of Object.entries(additionalHeaders)) {
              headers[headerName] = headerValue;
            }
          }
        };
        copyAdditionalHeaders(this.additionalRequestHeaders);
        copyAdditionalHeaders(options === null || options === void 0 ? void 0 : options.additionalHeaders);
        const userAgentPrefix = headers["User-Agent"] ? headers["User-Agent"] + " " : "";
        headers["User-Agent"] = `${userAgentPrefix}${this.userAgents} ${version_1.tunnelSdkUserAgent}`;
        const config = Object.assign(Object.assign({ headers }, this.httpsAgent && { httpsAgent: this.httpsAgent }), this.adapter && { adapter: this.adapter });
        if ((options === null || options === void 0 ? void 0 : options.followRedirects) === false) {
          config.maxRedirects = 0;
        }
        return config;
      }
      convertTunnelForRequest(tunnel) {
        var _a2;
        const convertedTunnel = {
          tunnelId: tunnel.tunnelId,
          name: tunnel.name,
          domain: tunnel.domain,
          description: tunnel.description,
          labels: tunnel.labels,
          options: tunnel.options,
          customExpiration: tunnel.customExpiration,
          accessControl: !tunnel.accessControl ? void 0 : { entries: tunnel.accessControl.entries.filter((ace) => !ace.isInherited) },
          endpoints: tunnel.endpoints,
          ports: (_a2 = tunnel.ports) === null || _a2 === void 0 ? void 0 : _a2.map((p) => this.convertTunnelPortForRequest(tunnel, p))
        };
        return convertedTunnel;
      }
      convertTunnelPortForRequest(tunnel, tunnelPort) {
        if (tunnelPort.clusterId && tunnel.clusterId && tunnelPort.clusterId !== tunnel.clusterId) {
          throw new Error("Tunnel port cluster ID does not match tunnel.");
        }
        if (tunnelPort.tunnelId && tunnel.tunnelId && tunnelPort.tunnelId !== tunnel.tunnelId) {
          throw new Error("Tunnel port tunnel ID does not match tunnel.");
        }
        return {
          portNumber: tunnelPort.portNumber,
          protocol: tunnelPort.protocol,
          isDefault: tunnelPort.isDefault,
          description: tunnelPort.description,
          labels: tunnelPort.labels,
          sshUser: tunnelPort.sshUser,
          options: tunnelPort.options,
          accessControl: !tunnelPort.accessControl ? void 0 : { entries: tunnelPort.accessControl.entries.filter((ace) => !ace.isInherited) }
        };
      }
      tunnelRequestOptionsToQueryString(options, additionalQuery) {
        const queryOptions = {};
        const queryItems = [];
        if (options) {
          if (options.includePorts) {
            queryOptions.includePorts = ["true"];
          }
          if (options.includeAccessControl) {
            queryOptions.includeAccessControl = ["true"];
          }
          if (options.tokenScopes) {
            dev_tunnels_contracts_1.TunnelAccessControl.validateScopes(options.tokenScopes, void 0, true);
            queryOptions.tokenScopes = options.tokenScopes;
          }
          if (options.forceRename) {
            queryOptions.forceRename = ["true"];
          }
          if (options.labels) {
            queryOptions.labels = options.labels;
            if (options.requireAllLabels) {
              queryOptions.allLabels = ["true"];
            }
          }
          if (options.limit) {
            queryOptions.limit = [options.limit.toString()];
          }
          queryItems.push(...Object.keys(queryOptions).map((key) => {
            const value = queryOptions[key];
            return `${key}=${value.map(encodeURIComponent).join(",")}`;
          }));
        }
        if (additionalQuery) {
          queryItems.push(additionalQuery);
        }
        queryItems.push(`api-version=${this.apiVersion}`);
        const queryString = queryItems.join("&");
        return queryString;
      }
      /**
       * Axios request that can be overridden for unit tests purposes.
       * @param config axios request config
       * @param _cancellation the cancellation token for the request (used by unit tests to simulate timeouts).
       */
      async axiosRequest(config, _cancellation) {
        return await axios_1.default.request(config);
      }
      /**
       * Makes an HTTP request using Axios, while tracing request and response details.
       */
      async request(method, uri, data, config, allowNotFound, cancellation) {
        var _a2, _b;
        this.trace(`${method} ${uri}`);
        if (config.headers) {
          this.traceHeaders(config.headers);
        }
        this.traceContent(data);
        const traceResponse = (response) => {
          this.trace(`${response.status} ${response.statusText}`);
          this.traceHeaders(response.headers);
          this.traceContent(response.data);
        };
        let disposable;
        const abortController = new AbortController();
        let timeout = void 0;
        const newAbortSignal = () => {
          if (cancellation === null || cancellation === void 0 ? void 0 : cancellation.isCancellationRequested) {
            abortController.abort("Cancelled: CancellationToken cancel requested.");
          } else if (cancellation) {
            disposable = cancellation.onCancellationRequested(() => abortController.abort("Cancelled: CancellationToken cancel requested."));
          } else {
            timeout = setTimeout(() => abortController.abort("Cancelled: default request timeout reached."), defaultRequestTimeoutMS);
          }
          return abortController.signal;
        };
        try {
          config.url = uri;
          config.method = method;
          config.data = data;
          config.signal = newAbortSignal();
          config.timeout = defaultRequestTimeoutMS;
          const response = await this.axiosRequest(config, cancellation);
          traceResponse(response);
          return method === "DELETE" ? true : response.data;
        } catch (e) {
          if (!(e instanceof Error) || !e.isAxiosError)
            throw e;
          const requestError = e;
          if (requestError.response) {
            traceResponse(requestError.response);
            if (allowNotFound && requestError.response.status === 404) {
              return method === "DELETE" ? false : null;
            }
          }
          requestError.message = this.getResponseErrorMessage(requestError, abortController.signal);
          delete requestError.request;
          if (requestError.response) {
            (_a2 = requestError.config) === null || _a2 === void 0 ? true : delete _a2.httpAgent;
            (_b = requestError.config) === null || _b === void 0 ? true : delete _b.httpsAgent;
            delete requestError.response.request;
          }
          throw requestError;
        } finally {
          if (timeout) {
            clearTimeout(timeout);
          }
          disposable === null || disposable === void 0 ? void 0 : disposable.dispose();
        }
      }
      traceHeaders(headers) {
        for (const [headerName, headerValue] of Object.entries(headers)) {
          if (headerName === "Authorization") {
            this.traceAuthorizationHeader(headerName, headerValue);
            return;
          }
          this.trace(`${headerName}: ${headerValue !== null && headerValue !== void 0 ? headerValue : ""}`);
        }
      }
      traceAuthorizationHeader(key, value) {
        if (typeof value !== "string")
          return;
        const spaceIndex = value.indexOf(" ");
        if (spaceIndex < 0) {
          this.trace(`${key}: [${value.length}]`);
          return;
        }
        const scheme = value.substring(0, spaceIndex);
        const token = value.substring(spaceIndex + 1);
        if (scheme.toLowerCase() === tunnelManagementClient_1.TunnelAuthenticationSchemes.tunnel.toLowerCase()) {
          const tokenProperties = tunnelAccessTokenProperties_1.TunnelAccessTokenProperties.tryParse(token);
          if (tokenProperties) {
            this.trace(`${key}: ${scheme} <${tokenProperties}>`);
            return;
          }
        }
        this.trace(`${key}: ${scheme} <token>`);
      }
      traceContent(data) {
        if (typeof data === "object") {
          data = JSON.stringify(data, void 0, "  ");
        }
        if (typeof data === "string") {
          this.trace(_TunnelManagementHttpClient.replaceTokensInContent(data));
        }
      }
      static replaceTokensInContent(content) {
        var _a2;
        const tokenRegex = /"(eyJ[a-zA-z0-9\-_]+\.[a-zA-z0-9\-_]+\.[a-zA-z0-9\-_]+)"/;
        let match = tokenRegex.exec(content);
        while (match) {
          let token = match[1];
          const tokenProperties = tunnelAccessTokenProperties_1.TunnelAccessTokenProperties.tryParse(token);
          token = (_a2 = tokenProperties === null || tokenProperties === void 0 ? void 0 : tokenProperties.toString()) !== null && _a2 !== void 0 ? _a2 : "token";
          content = content.substring(0, match.index + 1) + "<" + token + ">" + content.substring(match.index + match[0].length - 1);
          match = tokenRegex.exec(content);
        }
        return content;
      }
      /**
       * Disposes the client and any background tasks.
       */
      async dispose() {
        this.isDisposed = true;
        this.eventsAvailableCompletion.resolve();
        if (this.eventsPromise) {
          await this.eventsPromise;
          this.eventsPromise = null;
        }
      }
    };
    exports2.TunnelManagementHttpClient = TunnelManagementHttpClient3;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-management/tunnelRequestOptions.js
var require_tunnelRequestOptions = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-management/tunnelRequestOptions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/@microsoft/dev-tunnels-management/index.js
var require_dev_tunnels_management = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-management/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_tunnelManagementHttpClient(), exports2);
    __exportStar(require_tunnelManagementClient(), exports2);
    __exportStar(require_tunnelRequestOptions(), exports2);
    __exportStar(require_tunnelAccessTokenProperties(), exports2);
  }
});

// ../../node_modules/@microsoft/dev-tunnels-connections/tunnelClient.js
var require_tunnelClient = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-connections/tunnelClient.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/@microsoft/dev-tunnels-connections/tunnelHost.js
var require_tunnelHost = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-connections/tunnelHost.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/@microsoft/dev-tunnels-connections/connectionStatus.js
var require_connectionStatus = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-connections/connectionStatus.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConnectionStatus = void 0;
    var ConnectionStatus;
    (function(ConnectionStatus2) {
      ConnectionStatus2["None"] = "none";
      ConnectionStatus2["Connecting"] = "connecting";
      ConnectionStatus2["RefreshingTunnelAccessToken"] = "refreshingTunnelAccessToken";
      ConnectionStatus2["Connected"] = "connected";
      ConnectionStatus2["Disconnected"] = "disconnected";
      ConnectionStatus2["RefreshingTunnelHostPublicKey"] = "refreshingTunnelHostPublicKey";
    })(ConnectionStatus = exports2.ConnectionStatus || (exports2.ConnectionStatus = {}));
  }
});

// ../../node_modules/@microsoft/dev-tunnels-connections/connectionStatusChangedEventArgs.js
var require_connectionStatusChangedEventArgs = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-connections/connectionStatusChangedEventArgs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConnectionStatusChangedEventArgs = void 0;
    var ConnectionStatusChangedEventArgs = class {
      /**
       * Creates a new instance of ConnectionStatusChangedEventArgs.
       */
      constructor(previousStatus, status, disconnectError) {
        this.previousStatus = previousStatus;
        this.status = status;
        this.disconnectError = disconnectError;
      }
    };
    exports2.ConnectionStatusChangedEventArgs = ConnectionStatusChangedEventArgs;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-connections/refreshingTunnelAccessTokenEventArgs.js
var require_refreshingTunnelAccessTokenEventArgs = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-connections/refreshingTunnelAccessTokenEventArgs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RefreshingTunnelAccessTokenEventArgs = void 0;
    var RefreshingTunnelAccessTokenEventArgs = class {
      /**
       * Creates a new instance of RefreshingTunnelAccessTokenEventArgs class.
       */
      constructor(tunnelAccessScope, cancellation) {
        this.tunnelAccessScope = tunnelAccessScope;
        this.cancellation = cancellation;
      }
    };
    exports2.RefreshingTunnelAccessTokenEventArgs = RefreshingTunnelAccessTokenEventArgs;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-connections/utils.js
var require_utils = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-connections/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TrackingEmitter = exports2.withCancellation = exports2.getError = exports2.getErrorMessage = exports2.delay = exports2.List = void 0;
    var dev_tunnels_ssh_1 = require_dev_tunnels_ssh();
    var vscode_jsonrpc_1 = require_main();
    var List = class {
      static groupBy(list, keyGetter) {
        const map = /* @__PURE__ */ new Map();
        list.forEach((item) => {
          const key = keyGetter(item);
          const collection = map.get(key);
          if (!collection) {
            map.set(key, [item]);
          } else {
            collection.push(item);
          }
        });
        return map;
      }
    };
    exports2.List = List;
    function delay2(milliseconds, cancellation) {
      return new Promise((resolve8, reject) => {
        let cancellationDisposable;
        let timeout = void 0;
        if (cancellation) {
          if (cancellation.isCancellationRequested) {
            reject(new dev_tunnels_ssh_1.CancellationError());
            return;
          }
          cancellationDisposable = cancellation.onCancellationRequested(() => {
            if (timeout) {
              clearTimeout(timeout);
            }
            cancellationDisposable === null || cancellationDisposable === void 0 ? void 0 : cancellationDisposable.dispose();
            reject(new dev_tunnels_ssh_1.CancellationError());
          });
        }
        timeout = setTimeout(() => {
          cancellationDisposable === null || cancellationDisposable === void 0 ? void 0 : cancellationDisposable.dispose();
          resolve8();
        }, milliseconds);
      });
    }
    exports2.delay = delay2;
    function getErrorMessage2(e) {
      var _a2;
      return String((_a2 = e === null || e === void 0 ? void 0 : e.message) !== null && _a2 !== void 0 ? _a2 : e);
    }
    exports2.getErrorMessage = getErrorMessage2;
    function getError(e, messagePrefix) {
      return e instanceof Error ? e : new Error(`${messagePrefix !== null && messagePrefix !== void 0 ? messagePrefix : ""}${e}`);
    }
    exports2.getError = getError;
    function withCancellation(promise2, cancellation) {
      if (!cancellation) {
        return promise2;
      }
      return Promise.race([
        promise2,
        new Promise((resolve8, reject) => {
          if (cancellation.isCancellationRequested) {
            reject(new dev_tunnels_ssh_1.CancellationError());
          } else {
            cancellation.onCancellationRequested(() => {
              reject(new dev_tunnels_ssh_1.CancellationError());
            });
          }
        })
      ]);
    }
    exports2.withCancellation = withCancellation;
    var TrackingEmitter = class extends vscode_jsonrpc_1.Emitter {
      constructor() {
        super({
          onFirstListenerAdd: () => this.subscribed = true,
          onLastListenerRemove: () => this.subscribed = false
        });
        this.subscribed = false;
      }
      /**
       * A value indicating whether there event handlers subscribed to the event emitter.
       */
      get isSubscribed() {
        return this.subscribed;
      }
    };
    exports2.TrackingEmitter = TrackingEmitter;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-connections/sshKeepAliveEventArgs.js
var require_sshKeepAliveEventArgs = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-connections/sshKeepAliveEventArgs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SshKeepAliveEventArgs = void 0;
    var SshKeepAliveEventArgs = class {
      constructor(count) {
        this.count = count;
      }
    };
    exports2.SshKeepAliveEventArgs = SshKeepAliveEventArgs;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-connections/tunnelConnectionBase.js
var require_tunnelConnectionBase = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-connections/tunnelConnectionBase.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TunnelConnectionBase = void 0;
    var dev_tunnels_ssh_1 = require_dev_tunnels_ssh();
    var vscode_jsonrpc_1 = require_main();
    var connectionStatus_1 = require_connectionStatus();
    var connectionStatusChangedEventArgs_1 = require_connectionStatusChangedEventArgs();
    var refreshingTunnelAccessTokenEventArgs_1 = require_refreshingTunnelAccessTokenEventArgs();
    var utils_1 = require_utils();
    var sshKeepAliveEventArgs_1 = require_sshKeepAliveEventArgs();
    var TunnelConnectionBase = class {
      constructor(tunnelAccessScope) {
        this.tunnelAccessScope = tunnelAccessScope;
        this.disposeCts = new vscode_jsonrpc_1.CancellationTokenSource();
        this.status = connectionStatus_1.ConnectionStatus.None;
        this.refreshingTunnelAccessTokenEmitter = new utils_1.TrackingEmitter();
        this.connectionStatusChangedEmitter = new vscode_jsonrpc_1.Emitter();
        this.retryingTunnelConnectionEmitter = new vscode_jsonrpc_1.Emitter();
        this.forwardedPortConnectingEmitter = new vscode_jsonrpc_1.Emitter();
        this.keepAliveFailedEmitter = new vscode_jsonrpc_1.Emitter();
        this.keepAliveSucceededEmitter = new vscode_jsonrpc_1.Emitter();
        this.refreshingTunnelAccessToken = this.refreshingTunnelAccessTokenEmitter.event;
        this.connectionStatusChanged = this.connectionStatusChangedEmitter.event;
        this.retryingTunnelConnection = this.retryingTunnelConnectionEmitter.event;
        this.forwardedPortConnecting = this.forwardedPortConnectingEmitter.event;
        this.keepAliveFailed = this.keepAliveFailedEmitter.event;
        this.keepAliveSucceeded = this.keepAliveSucceededEmitter.event;
      }
      /**
       * Gets a value indicathing that this tunnel connection session is disposed.
       */
      get isDisposed() {
        return this.disposeCts.token.isCancellationRequested;
      }
      get isRefreshingTunnelAccessTokenEventHandled() {
        return this.refreshingTunnelAccessTokenEmitter.isSubscribed;
      }
      /**
       * Gets dispose cancellation token.
       */
      get disposeToken() {
        return this.disposeCts.token;
      }
      /**
       * Gets the connection status.
       */
      get connectionStatus() {
        return this.status;
      }
      /**
       * Sets the connection status.
       * Throws CancellationError if the session is disposed and the status being set is not ConnectionStatus.Disconnected.
       */
      set connectionStatus(value) {
        if (this.isDisposed && value !== connectionStatus_1.ConnectionStatus.Disconnected) {
          this.throwIfDisposed(`ConnectionStatus: ${value}`);
        }
        if (value === connectionStatus_1.ConnectionStatus.RefreshingTunnelAccessToken && this.status !== connectionStatus_1.ConnectionStatus.Connecting) {
          throw new Error("Refreshing tunnel access token is allowed only when connecting.");
        }
        if (value !== this.status) {
          const previousStatus = this.connectionStatus;
          this.status = value;
          this.onConnectionStatusChanged(previousStatus, value);
        }
      }
      /**
       * Gets the error that caused disconnection.
       * Undefined if not yet connected or disconnection was caused by disposing of this object.
       */
      get disconnectError() {
        return this.error;
      }
      /**
       * Sets the error that caused disconnection.
       */
      set disconnectError(e) {
        this.error = e;
      }
      onForwardedPortConnecting(e) {
        this.forwardedPortConnectingEmitter.fire(e);
      }
      /**
       * Raises the keep-alive failed event.
       */
      onKeepAliveFailed(count) {
        this.keepAliveFailedEmitter.fire(new sshKeepAliveEventArgs_1.SshKeepAliveEventArgs(count));
      }
      /**
       * Raises the keep-alive succeeded event.
       */
      onKeepAliveSucceeded(count) {
        this.keepAliveSucceededEmitter.fire(new sshKeepAliveEventArgs_1.SshKeepAliveEventArgs(count));
      }
      /**
       * Closes and disposes the tunnel session.
       */
      dispose() {
        this.disposeCts.cancel();
        this.connectionStatus = connectionStatus_1.ConnectionStatus.Disconnected;
        return Promise.resolve();
      }
      /**
       *  Notifies about a connection retry, giving the relay client a chance to delay or cancel it.
       */
      onRetrying(event) {
        this.retryingTunnelConnectionEmitter.fire(event);
      }
      /**
       * Gets the fresh tunnel access token or undefined if it cannot.
       */
      async getFreshTunnelAccessToken(cancellation) {
        const event = new refreshingTunnelAccessTokenEventArgs_1.RefreshingTunnelAccessTokenEventArgs(this.tunnelAccessScope, cancellation);
        this.refreshingTunnelAccessTokenEmitter.fire(event);
        return event.tunnelAccessToken ? await event.tunnelAccessToken : void 0;
      }
      /**
       * Event fired when the connection status has changed.
       */
      onConnectionStatusChanged(previousStatus, status) {
        const disconnectError = this.connectionStatus === connectionStatus_1.ConnectionStatus.Disconnected && !this.isDisposed ? this.disconnectError : void 0;
        const event = new connectionStatusChangedEventArgs_1.ConnectionStatusChangedEventArgs(previousStatus, status, disconnectError);
        this.connectionStatusChangedEmitter.fire(event);
      }
      /**
       * Throws CancellationError if the tunnel connection is disposed.
       */
      throwIfDisposed(message, stack) {
        if (this.isDisposed) {
          const error = new dev_tunnels_ssh_1.ObjectDisposedError(`The tunnel connection is disposed. ${message}`);
          if (stack) {
            error.stack = stack;
          }
          throw error;
        }
      }
    };
    exports2.TunnelConnectionBase = TunnelConnectionBase;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-connections/multiModeTunnelClient.js
var require_multiModeTunnelClient = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-connections/multiModeTunnelClient.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MultiModeTunnelClient = void 0;
    var dev_tunnels_contracts_1 = require_dev_tunnels_contracts();
    var tunnelConnectionBase_1 = require_tunnelConnectionBase();
    var MultiModeTunnelClient = class extends tunnelConnectionBase_1.TunnelConnectionBase {
      constructor() {
        super(dev_tunnels_contracts_1.TunnelAccessScopes.Connect);
        this.clients = [];
        this.connectionModes = this.clients ? [...new Set(...this.clients.map((c) => c.connectionModes))] : [];
      }
      /**
       * A value indicating whether local connections for forwarded ports are accepted.
       * Local connections are not accepted if the host process is not NodeJS (e.g. browser).
       */
      get acceptLocalConnectionsForForwardedPorts() {
        return !!this.clients.find((c) => c.acceptLocalConnectionsForForwardedPorts);
      }
      set acceptLocalConnectionsForForwardedPorts(value) {
        this.clients.forEach((c) => c.acceptLocalConnectionsForForwardedPorts = value);
      }
      get localForwardingHostAddress() {
        var _a2;
        return (_a2 = this.clients[0]) === null || _a2 === void 0 ? void 0 : _a2.localForwardingHostAddress;
      }
      set localForwardingHostAddress(value) {
        this.clients.forEach((c) => c.localForwardingHostAddress = value);
      }
      connect(tunnel, options, cancellation) {
        if (!tunnel) {
          throw new Error("Tunnel cannot be null");
        }
        return new Promise((resolve8) => {
        });
      }
      get portForwarding() {
        throw new Error("Not supported.");
      }
      connectToForwardedPort(fowardedPort, cancellation) {
        throw new Error("Method not implemented.");
      }
      waitForForwardedPort(forwardedPort, cancellation) {
        throw new Error("Method not implemented.");
      }
      async refreshPorts() {
        throw new Error("Method not implemented.");
      }
      async dispose() {
        await super.dispose();
        await Promise.all(this.clients.map((client) => client.dispose()));
      }
    };
    exports2.MultiModeTunnelClient = MultiModeTunnelClient;
  }
});

// ../../node_modules/uuid/lib/rng.js
var require_rng = __commonJS({
  "../../node_modules/uuid/lib/rng.js"(exports2, module2) {
    "use strict";
    var crypto2 = require("crypto");
    module2.exports = function nodeRNG() {
      return crypto2.randomBytes(16);
    };
  }
});

// ../../node_modules/uuid/lib/bytesToUuid.js
var require_bytesToUuid = __commonJS({
  "../../node_modules/uuid/lib/bytesToUuid.js"(exports2, module2) {
    "use strict";
    var byteToHex = [];
    for (i = 0; i < 256; ++i) {
      byteToHex[i] = (i + 256).toString(16).substr(1);
    }
    var i;
    function bytesToUuid(buf, offset) {
      var i2 = offset || 0;
      var bth = byteToHex;
      return [
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        "-",
        bth[buf[i2++]],
        bth[buf[i2++]],
        "-",
        bth[buf[i2++]],
        bth[buf[i2++]],
        "-",
        bth[buf[i2++]],
        bth[buf[i2++]],
        "-",
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]]
      ].join("");
    }
    module2.exports = bytesToUuid;
  }
});

// ../../node_modules/uuid/v1.js
var require_v1 = __commonJS({
  "../../node_modules/uuid/v1.js"(exports2, module2) {
    "use strict";
    var rng = require_rng();
    var bytesToUuid = require_bytesToUuid();
    var _nodeId;
    var _clockseq;
    var _lastMSecs = 0;
    var _lastNSecs = 0;
    function v1(options, buf, offset) {
      var i = buf && offset || 0;
      var b = buf || [];
      options = options || {};
      var node = options.node || _nodeId;
      var clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
      if (node == null || clockseq == null) {
        var seedBytes = rng();
        if (node == null) {
          node = _nodeId = [
            seedBytes[0] | 1,
            seedBytes[1],
            seedBytes[2],
            seedBytes[3],
            seedBytes[4],
            seedBytes[5]
          ];
        }
        if (clockseq == null) {
          clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
        }
      }
      var msecs = options.msecs !== void 0 ? options.msecs : (/* @__PURE__ */ new Date()).getTime();
      var nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
      var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
      if (dt < 0 && options.clockseq === void 0) {
        clockseq = clockseq + 1 & 16383;
      }
      if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
        nsecs = 0;
      }
      if (nsecs >= 1e4) {
        throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
      }
      _lastMSecs = msecs;
      _lastNSecs = nsecs;
      _clockseq = clockseq;
      msecs += 122192928e5;
      var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
      b[i++] = tl >>> 24 & 255;
      b[i++] = tl >>> 16 & 255;
      b[i++] = tl >>> 8 & 255;
      b[i++] = tl & 255;
      var tmh = msecs / 4294967296 * 1e4 & 268435455;
      b[i++] = tmh >>> 8 & 255;
      b[i++] = tmh & 255;
      b[i++] = tmh >>> 24 & 15 | 16;
      b[i++] = tmh >>> 16 & 255;
      b[i++] = clockseq >>> 8 | 128;
      b[i++] = clockseq & 255;
      for (var n = 0; n < 6; ++n) {
        b[i + n] = node[n];
      }
      return buf ? buf : bytesToUuid(b);
    }
    module2.exports = v1;
  }
});

// ../../node_modules/uuid/v4.js
var require_v4 = __commonJS({
  "../../node_modules/uuid/v4.js"(exports2, module2) {
    "use strict";
    var rng = require_rng();
    var bytesToUuid = require_bytesToUuid();
    function v4(options, buf, offset) {
      var i = buf && offset || 0;
      if (typeof options == "string") {
        buf = options === "binary" ? new Array(16) : null;
        options = null;
      }
      options = options || {};
      var rnds = options.random || (options.rng || rng)();
      rnds[6] = rnds[6] & 15 | 64;
      rnds[8] = rnds[8] & 63 | 128;
      if (buf) {
        for (var ii = 0; ii < 16; ++ii) {
          buf[i + ii] = rnds[ii];
        }
      }
      return buf || bytesToUuid(rnds);
    }
    module2.exports = v4;
  }
});

// ../../node_modules/uuid/index.js
var require_uuid = __commonJS({
  "../../node_modules/uuid/index.js"(exports2, module2) {
    "use strict";
    var v1 = require_v1();
    var v4 = require_v4();
    var uuid = v4;
    uuid.v1 = v1;
    uuid.v4 = v4;
    module2.exports = uuid;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-connections/multiModeTunnelHost.js
var require_multiModeTunnelHost = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-connections/multiModeTunnelHost.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MultiModeTunnelHost = void 0;
    var dev_tunnels_contracts_1 = require_dev_tunnels_contracts();
    var uuid_1 = require_uuid();
    var tunnelConnectionBase_1 = require_tunnelConnectionBase();
    var MultiModeTunnelHost = class extends tunnelConnectionBase_1.TunnelConnectionBase {
      constructor() {
        super(dev_tunnels_contracts_1.TunnelAccessScopes.Host);
        this.hosts = [];
      }
      /**
       * @deprecated Use `connect()` instead.
       */
      async start(tunnel) {
        await this.connect(tunnel);
      }
      async connect(tunnel, options, cancellation) {
        const startTasks = [];
        this.hosts.forEach((host) => {
          startTasks.push(host.connect(tunnel, options, cancellation));
        });
        await Promise.all(startTasks);
      }
      async refreshPorts() {
        const refreshTasks = [];
        this.hosts.forEach((host) => {
          refreshTasks.push(host.refreshPorts());
        });
        await Promise.all(refreshTasks);
      }
      async dispose() {
        await Promise.all(this.hosts.map((host) => host.dispose()));
        await super.dispose();
      }
    };
    exports2.MultiModeTunnelHost = MultiModeTunnelHost;
    MultiModeTunnelHost.hostId = (0, uuid_1.v4)();
  }
});

// ../../node_modules/@microsoft/dev-tunnels-connections/retryTcpListenerFactory.js
var require_retryTcpListenerFactory = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-connections/retryTcpListenerFactory.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RetryTcpListenerFactory = void 0;
    var net2 = require("net");
    var RetryTcpListenerFactory = class {
      constructor(localAddress) {
        this.localAddress = localAddress;
      }
      async createTcpListener(remotePort, localIPAddress, localPort, canChangeLocalPort, cancellation) {
        if (localIPAddress.indexOf(":") >= 0) {
          if (this.localAddress === "0.0.0.0") {
            localIPAddress = "::";
          } else if (this.localAddress === "127.0.0.1") {
            localIPAddress = "::1";
          }
        } else {
          localIPAddress = this.localAddress;
        }
        const maxOffset = 10;
        const listener = net2.createServer();
        for (let offset = 0; ; offset++) {
          const localPortNumber = offset === maxOffset ? 0 : localPort + offset;
          try {
            return await new Promise((resolve8, reject) => {
              listener.listen({
                host: localIPAddress,
                port: localPortNumber,
                ipv6Only: net2.isIPv6(localIPAddress)
              });
              listener.on("listening", () => {
                if (remotePort) {
                  const { address, port } = listener.address();
                  console.log(`Forwarding from ${address}:${port} to host port ${remotePort}.`);
                }
                resolve8(listener);
              });
              listener.on("error", (err) => {
                reject(err);
              });
            });
          } catch (err) {
            if (offset < maxOffset && canChangeLocalPort) {
              console.log("Listening on port " + localPortNumber + " failed: " + err);
              console.log("Incrementing port and trying again");
              continue;
            } else {
              throw err;
            }
          }
        }
      }
    };
    exports2.RetryTcpListenerFactory = RetryTcpListenerFactory;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-connections/sessionPortKey.js
var require_sessionPortKey = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-connections/sessionPortKey.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SessionPortKey = void 0;
    var SessionPortKey = class {
      constructor(sessionId, port) {
        this.sessionId = sessionId !== null && sessionId !== void 0 ? sessionId : null;
        this.port = port;
      }
      equals(other) {
        return this.port === other.port && (!this.sessionId && !other.sessionId || this.sessionId && other.sessionId && this.sessionId === other.sessionId);
      }
      toString() {
        return this.port + (this.sessionId ? "_" + this.sessionId.toString("base64") : "");
      }
    };
    exports2.SessionPortKey = SessionPortKey;
  }
});

// ../../node_modules/websocket/node_modules/ms/index.js
var require_ms2 = __commonJS({
  "../../node_modules/websocket/node_modules/ms/index.js"(exports2, module2) {
    "use strict";
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse2(val);
      } else if (type === "number" && isNaN(val) === false) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse2(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      if (ms >= d) {
        return Math.round(ms / d) + "d";
      }
      if (ms >= h) {
        return Math.round(ms / h) + "h";
      }
      if (ms >= m) {
        return Math.round(ms / m) + "m";
      }
      if (ms >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      return plural(ms, d, "day") || plural(ms, h, "hour") || plural(ms, m, "minute") || plural(ms, s, "second") || ms + " ms";
    }
    function plural(ms, n, name) {
      if (ms < n) {
        return;
      }
      if (ms < n * 1.5) {
        return Math.floor(ms / n) + " " + name;
      }
      return Math.ceil(ms / n) + " " + name + "s";
    }
  }
});

// ../../node_modules/websocket/node_modules/debug/src/debug.js
var require_debug2 = __commonJS({
  "../../node_modules/websocket/node_modules/debug/src/debug.js"(exports2, module2) {
    "use strict";
    exports2 = module2.exports = createDebug.debug = createDebug["default"] = createDebug;
    exports2.coerce = coerce2;
    exports2.disable = disable;
    exports2.enable = enable;
    exports2.enabled = enabled;
    exports2.humanize = require_ms2();
    exports2.names = [];
    exports2.skips = [];
    exports2.formatters = {};
    var prevTime;
    function selectColor(namespace) {
      var hash = 0, i;
      for (i in namespace) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return exports2.colors[Math.abs(hash) % exports2.colors.length];
    }
    function createDebug(namespace) {
      function debug2() {
        if (!debug2.enabled) return;
        var self2 = debug2;
        var curr = +/* @__PURE__ */ new Date();
        var ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        args[0] = exports2.coerce(args[0]);
        if ("string" !== typeof args[0]) {
          args.unshift("%O");
        }
        var index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
          if (match === "%%") return match;
          index++;
          var formatter = exports2.formatters[format];
          if ("function" === typeof formatter) {
            var val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        exports2.formatArgs.call(self2, args);
        var logFn = debug2.log || exports2.log || console.log.bind(console);
        logFn.apply(self2, args);
      }
      debug2.namespace = namespace;
      debug2.enabled = exports2.enabled(namespace);
      debug2.useColors = exports2.useColors();
      debug2.color = selectColor(namespace);
      if ("function" === typeof exports2.init) {
        exports2.init(debug2);
      }
      return debug2;
    }
    function enable(namespaces) {
      exports2.save(namespaces);
      exports2.names = [];
      exports2.skips = [];
      var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      var len = split.length;
      for (var i = 0; i < len; i++) {
        if (!split[i]) continue;
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          exports2.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          exports2.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      exports2.enable("");
    }
    function enabled(name) {
      var i, len;
      for (i = 0, len = exports2.skips.length; i < len; i++) {
        if (exports2.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = exports2.names.length; i < len; i++) {
        if (exports2.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function coerce2(val) {
      if (val instanceof Error) return val.stack || val.message;
      return val;
    }
  }
});

// ../../node_modules/websocket/node_modules/debug/src/browser.js
var require_browser2 = __commonJS({
  "../../node_modules/websocket/node_modules/debug/src/browser.js"(exports2, module2) {
    "use strict";
    exports2 = module2.exports = require_debug2();
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = "undefined" != typeof chrome && "undefined" != typeof chrome.storage ? chrome.storage.local : localstorage();
    exports2.colors = [
      "lightseagreen",
      "forestgreen",
      "goldenrod",
      "dodgerblue",
      "darkorchid",
      "crimson"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
        return true;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    exports2.formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (err) {
        return "[UnexpectedJSONParseError]: " + err.message;
      }
    };
    function formatArgs(args) {
      var useColors2 = this.useColors;
      args[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args[0] + (useColors2 ? "%c " : " ") + "+" + exports2.humanize(this.diff);
      if (!useColors2) return;
      var c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      var index = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function(match) {
        if ("%%" === match) return;
        index++;
        if ("%c" === match) {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    function log() {
      return "object" === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
    }
    function save(namespaces) {
      try {
        if (null == namespaces) {
          exports2.storage.removeItem("debug");
        } else {
          exports2.storage.debug = namespaces;
        }
      } catch (e) {
      }
    }
    function load() {
      var r;
      try {
        r = exports2.storage.debug;
      } catch (e) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    exports2.enable(load());
    function localstorage() {
      try {
        return window.localStorage;
      } catch (e) {
      }
    }
  }
});

// ../../node_modules/websocket/node_modules/debug/src/node.js
var require_node2 = __commonJS({
  "../../node_modules/websocket/node_modules/debug/src/node.js"(exports2, module2) {
    "use strict";
    var tty = require("tty");
    var util2 = require("util");
    exports2 = module2.exports = require_debug2();
    exports2.init = init;
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.colors = [6, 2, 3, 4, 5, 1];
    exports2.inspectOpts = Object.keys(process.env).filter(function(key) {
      return /^debug_/i.test(key);
    }).reduce(function(obj, key) {
      var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function(_, k) {
        return k.toUpperCase();
      });
      var val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) val = true;
      else if (/^(no|off|false|disabled)$/i.test(val)) val = false;
      else if (val === "null") val = null;
      else val = Number(val);
      obj[prop] = val;
      return obj;
    }, {});
    var fd = parseInt(process.env.DEBUG_FD, 10) || 2;
    if (1 !== fd && 2 !== fd) {
      util2.deprecate(function() {
      }, "except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)")();
    }
    var stream = 1 === fd ? process.stdout : 2 === fd ? process.stderr : createWritableStdioStream(fd);
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(fd);
    }
    exports2.formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts).split("\n").map(function(str) {
        return str.trim();
      }).join(" ");
    };
    exports2.formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts);
    };
    function formatArgs(args) {
      var name = this.namespace;
      var useColors2 = this.useColors;
      if (useColors2) {
        var c = this.color;
        var prefix = "  \x1B[3" + c + ";1m" + name + " \x1B[0m";
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push("\x1B[3" + c + "m+" + exports2.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = (/* @__PURE__ */ new Date()).toUTCString() + " " + name + " " + args[0];
      }
    }
    function log() {
      return stream.write(util2.format.apply(util2, arguments) + "\n");
    }
    function save(namespaces) {
      if (null == namespaces) {
        delete process.env.DEBUG;
      } else {
        process.env.DEBUG = namespaces;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function createWritableStdioStream(fd2) {
      var stream2;
      var tty_wrap = process.binding("tty_wrap");
      switch (tty_wrap.guessHandleType(fd2)) {
        case "TTY":
          stream2 = new tty.WriteStream(fd2);
          stream2._type = "tty";
          if (stream2._handle && stream2._handle.unref) {
            stream2._handle.unref();
          }
          break;
        case "FILE":
          var fs10 = require("fs");
          stream2 = new fs10.SyncWriteStream(fd2, { autoClose: false });
          stream2._type = "fs";
          break;
        case "PIPE":
        case "TCP":
          var net2 = require("net");
          stream2 = new net2.Socket({
            fd: fd2,
            readable: false,
            writable: true
          });
          stream2.readable = false;
          stream2.read = null;
          stream2._type = "pipe";
          if (stream2._handle && stream2._handle.unref) {
            stream2._handle.unref();
          }
          break;
        default:
          throw new Error("Implement me. Unknown stream file type!");
      }
      stream2.fd = fd2;
      stream2._isStdio = true;
      return stream2;
    }
    function init(debug2) {
      debug2.inspectOpts = {};
      var keys = Object.keys(exports2.inspectOpts);
      for (var i = 0; i < keys.length; i++) {
        debug2.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    exports2.enable(load());
  }
});

// ../../node_modules/websocket/node_modules/debug/src/index.js
var require_src2 = __commonJS({
  "../../node_modules/websocket/node_modules/debug/src/index.js"(exports2, module2) {
    "use strict";
    if (typeof process !== "undefined" && process.type === "renderer") {
      module2.exports = require_browser2();
    } else {
      module2.exports = require_node2();
    }
  }
});

// ../../node_modules/websocket/lib/utils.js
var require_utils2 = __commonJS({
  "../../node_modules/websocket/lib/utils.js"(exports2) {
    "use strict";
    var noop = exports2.noop = function() {
    };
    exports2.extend = function extend(dest, source) {
      for (var prop in source) {
        dest[prop] = source[prop];
      }
    };
    exports2.eventEmitterListenerCount = require("events").EventEmitter.listenerCount || function(emitter, type) {
      return emitter.listeners(type).length;
    };
    exports2.bufferAllocUnsafe = Buffer.allocUnsafe ? Buffer.allocUnsafe : function oldBufferAllocUnsafe(size) {
      return new Buffer(size);
    };
    exports2.bufferFromString = Buffer.from ? Buffer.from : function oldBufferFromString(string, encoding) {
      return new Buffer(string, encoding);
    };
    exports2.BufferingLogger = function createBufferingLogger(identifier, uniqueID) {
      var logFunction = require_src2()(identifier);
      if (logFunction.enabled) {
        var logger = new BufferingLogger(identifier, uniqueID, logFunction);
        var debug2 = logger.log.bind(logger);
        debug2.printOutput = logger.printOutput.bind(logger);
        debug2.enabled = logFunction.enabled;
        return debug2;
      }
      logFunction.printOutput = noop;
      return logFunction;
    };
    function BufferingLogger(identifier, uniqueID, logFunction) {
      this.logFunction = logFunction;
      this.identifier = identifier;
      this.uniqueID = uniqueID;
      this.buffer = [];
    }
    BufferingLogger.prototype.log = function() {
      this.buffer.push([/* @__PURE__ */ new Date(), Array.prototype.slice.call(arguments)]);
      return this;
    };
    BufferingLogger.prototype.clear = function() {
      this.buffer = [];
      return this;
    };
    BufferingLogger.prototype.printOutput = function(logFunction) {
      if (!logFunction) {
        logFunction = this.logFunction;
      }
      var uniqueID = this.uniqueID;
      this.buffer.forEach(function(entry) {
        var date = entry[0].toLocaleString();
        var args = entry[1].slice();
        var formatString = args[0];
        if (formatString !== void 0 && formatString !== null) {
          formatString = "%s - %s - " + formatString.toString();
          args.splice(0, 1, formatString, date, uniqueID);
          logFunction.apply(global, args);
        }
      });
    };
  }
});

// ../../node_modules/node-gyp-build/node-gyp-build.js
var require_node_gyp_build = __commonJS({
  "../../node_modules/node-gyp-build/node-gyp-build.js"(exports2, module2) {
    "use strict";
    var fs10 = require("fs");
    var path11 = require("path");
    var os5 = require("os");
    var runtimeRequire = typeof __webpack_require__ === "function" ? __non_webpack_require__ : require;
    var vars = process.config && process.config.variables || {};
    var prebuildsOnly = !!process.env.PREBUILDS_ONLY;
    var abi = process.versions.modules;
    var runtime = isElectron() ? "electron" : isNwjs() ? "node-webkit" : "node";
    var arch = process.env.npm_config_arch || os5.arch();
    var platform = process.env.npm_config_platform || os5.platform();
    var libc = process.env.LIBC || (isAlpine(platform) ? "musl" : "glibc");
    var armv = process.env.ARM_VERSION || (arch === "arm64" ? "8" : vars.arm_version) || "";
    var uv = (process.versions.uv || "").split(".")[0];
    module2.exports = load;
    function load(dir) {
      return runtimeRequire(load.resolve(dir));
    }
    load.resolve = load.path = function(dir) {
      dir = path11.resolve(dir || ".");
      try {
        var name = runtimeRequire(path11.join(dir, "package.json")).name.toUpperCase().replace(/-/g, "_");
        if (process.env[name + "_PREBUILD"]) dir = process.env[name + "_PREBUILD"];
      } catch (err) {
      }
      if (!prebuildsOnly) {
        var release = getFirst(path11.join(dir, "build/Release"), matchBuild);
        if (release) return release;
        var debug2 = getFirst(path11.join(dir, "build/Debug"), matchBuild);
        if (debug2) return debug2;
      }
      var prebuild = resolve8(dir);
      if (prebuild) return prebuild;
      var nearby = resolve8(path11.dirname(process.execPath));
      if (nearby) return nearby;
      var target = [
        "platform=" + platform,
        "arch=" + arch,
        "runtime=" + runtime,
        "abi=" + abi,
        "uv=" + uv,
        armv ? "armv=" + armv : "",
        "libc=" + libc,
        "node=" + process.versions.node,
        process.versions.electron ? "electron=" + process.versions.electron : "",
        typeof __webpack_require__ === "function" ? "webpack=true" : ""
        // eslint-disable-line
      ].filter(Boolean).join(" ");
      throw new Error("No native build was found for " + target + "\n    loaded from: " + dir + "\n");
      function resolve8(dir2) {
        var tuples = readdirSync(path11.join(dir2, "prebuilds")).map(parseTuple);
        var tuple = tuples.filter(matchTuple(platform, arch)).sort(compareTuples)[0];
        if (!tuple) return;
        var prebuilds = path11.join(dir2, "prebuilds", tuple.name);
        var parsed = readdirSync(prebuilds).map(parseTags);
        var candidates = parsed.filter(matchTags(runtime, abi));
        var winner = candidates.sort(compareTags(runtime))[0];
        if (winner) return path11.join(prebuilds, winner.file);
      }
    };
    function readdirSync(dir) {
      try {
        return fs10.readdirSync(dir);
      } catch (err) {
        return [];
      }
    }
    function getFirst(dir, filter) {
      var files = readdirSync(dir).filter(filter);
      return files[0] && path11.join(dir, files[0]);
    }
    function matchBuild(name) {
      return /\.node$/.test(name);
    }
    function parseTuple(name) {
      var arr = name.split("-");
      if (arr.length !== 2) return;
      var platform2 = arr[0];
      var architectures = arr[1].split("+");
      if (!platform2) return;
      if (!architectures.length) return;
      if (!architectures.every(Boolean)) return;
      return { name, platform: platform2, architectures };
    }
    function matchTuple(platform2, arch2) {
      return function(tuple) {
        if (tuple == null) return false;
        if (tuple.platform !== platform2) return false;
        return tuple.architectures.includes(arch2);
      };
    }
    function compareTuples(a, b) {
      return a.architectures.length - b.architectures.length;
    }
    function parseTags(file) {
      var arr = file.split(".");
      var extension = arr.pop();
      var tags = { file, specificity: 0 };
      if (extension !== "node") return;
      for (var i = 0; i < arr.length; i++) {
        var tag = arr[i];
        if (tag === "node" || tag === "electron" || tag === "node-webkit") {
          tags.runtime = tag;
        } else if (tag === "napi") {
          tags.napi = true;
        } else if (tag.slice(0, 3) === "abi") {
          tags.abi = tag.slice(3);
        } else if (tag.slice(0, 2) === "uv") {
          tags.uv = tag.slice(2);
        } else if (tag.slice(0, 4) === "armv") {
          tags.armv = tag.slice(4);
        } else if (tag === "glibc" || tag === "musl") {
          tags.libc = tag;
        } else {
          continue;
        }
        tags.specificity++;
      }
      return tags;
    }
    function matchTags(runtime2, abi2) {
      return function(tags) {
        if (tags == null) return false;
        if (tags.runtime && tags.runtime !== runtime2 && !runtimeAgnostic(tags)) return false;
        if (tags.abi && tags.abi !== abi2 && !tags.napi) return false;
        if (tags.uv && tags.uv !== uv) return false;
        if (tags.armv && tags.armv !== armv) return false;
        if (tags.libc && tags.libc !== libc) return false;
        return true;
      };
    }
    function runtimeAgnostic(tags) {
      return tags.runtime === "node" && tags.napi;
    }
    function compareTags(runtime2) {
      return function(a, b) {
        if (a.runtime !== b.runtime) {
          return a.runtime === runtime2 ? -1 : 1;
        } else if (a.abi !== b.abi) {
          return a.abi ? -1 : 1;
        } else if (a.specificity !== b.specificity) {
          return a.specificity > b.specificity ? -1 : 1;
        } else {
          return 0;
        }
      };
    }
    function isNwjs() {
      return !!(process.versions && process.versions.nw);
    }
    function isElectron() {
      if (process.versions && process.versions.electron) return true;
      if (process.env.ELECTRON_RUN_AS_NODE) return true;
      return typeof window !== "undefined" && window.process && window.process.type === "renderer";
    }
    function isAlpine(platform2) {
      return platform2 === "linux" && fs10.existsSync("/etc/alpine-release");
    }
    load.parseTags = parseTags;
    load.matchTags = matchTags;
    load.compareTags = compareTags;
    load.parseTuple = parseTuple;
    load.matchTuple = matchTuple;
    load.compareTuples = compareTuples;
  }
});

// ../../node_modules/node-gyp-build/index.js
var require_node_gyp_build2 = __commonJS({
  "../../node_modules/node-gyp-build/index.js"(exports2, module2) {
    "use strict";
    var runtimeRequire = typeof __webpack_require__ === "function" ? __non_webpack_require__ : require;
    if (typeof runtimeRequire.addon === "function") {
      module2.exports = runtimeRequire.addon.bind(runtimeRequire);
    } else {
      module2.exports = require_node_gyp_build();
    }
  }
});

// ../../node_modules/bufferutil/fallback.js
var require_fallback = __commonJS({
  "../../node_modules/bufferutil/fallback.js"(exports2, module2) {
    "use strict";
    var mask = (source, mask2, output, offset, length) => {
      for (var i = 0; i < length; i++) {
        output[offset + i] = source[i] ^ mask2[i & 3];
      }
    };
    var unmask = (buffer, mask2) => {
      const length = buffer.length;
      for (var i = 0; i < length; i++) {
        buffer[i] ^= mask2[i & 3];
      }
    };
    module2.exports = { mask, unmask };
  }
});

// ../../node_modules/bufferutil/index.js
var require_bufferutil = __commonJS({
  "../../node_modules/bufferutil/index.js"(exports2, module2) {
    "use strict";
    try {
      module2.exports = require_node_gyp_build2()(__dirname);
    } catch (e) {
      module2.exports = require_fallback();
    }
  }
});

// ../../node_modules/websocket/lib/WebSocketFrame.js
var require_WebSocketFrame = __commonJS({
  "../../node_modules/websocket/lib/WebSocketFrame.js"(exports2, module2) {
    "use strict";
    var bufferUtil = require_bufferutil();
    var bufferAllocUnsafe = require_utils2().bufferAllocUnsafe;
    var DECODE_HEADER = 1;
    var WAITING_FOR_16_BIT_LENGTH = 2;
    var WAITING_FOR_64_BIT_LENGTH = 3;
    var WAITING_FOR_MASK_KEY = 4;
    var WAITING_FOR_PAYLOAD = 5;
    var COMPLETE = 6;
    function WebSocketFrame(maskBytes, frameHeader, config) {
      this.maskBytes = maskBytes;
      this.frameHeader = frameHeader;
      this.config = config;
      this.maxReceivedFrameSize = config.maxReceivedFrameSize;
      this.protocolError = false;
      this.frameTooLarge = false;
      this.invalidCloseFrameLength = false;
      this.parseState = DECODE_HEADER;
      this.closeStatus = -1;
    }
    WebSocketFrame.prototype.addData = function(bufferList) {
      if (this.parseState === DECODE_HEADER) {
        if (bufferList.length >= 2) {
          bufferList.joinInto(this.frameHeader, 0, 0, 2);
          bufferList.advance(2);
          var firstByte = this.frameHeader[0];
          var secondByte = this.frameHeader[1];
          this.fin = Boolean(firstByte & 128);
          this.rsv1 = Boolean(firstByte & 64);
          this.rsv2 = Boolean(firstByte & 32);
          this.rsv3 = Boolean(firstByte & 16);
          this.mask = Boolean(secondByte & 128);
          this.opcode = firstByte & 15;
          this.length = secondByte & 127;
          if (this.opcode >= 8) {
            if (this.length > 125) {
              this.protocolError = true;
              this.dropReason = "Illegal control frame longer than 125 bytes.";
              return true;
            }
            if (!this.fin) {
              this.protocolError = true;
              this.dropReason = "Control frames must not be fragmented.";
              return true;
            }
          }
          if (this.length === 126) {
            this.parseState = WAITING_FOR_16_BIT_LENGTH;
          } else if (this.length === 127) {
            this.parseState = WAITING_FOR_64_BIT_LENGTH;
          } else {
            this.parseState = WAITING_FOR_MASK_KEY;
          }
        }
      }
      if (this.parseState === WAITING_FOR_16_BIT_LENGTH) {
        if (bufferList.length >= 2) {
          bufferList.joinInto(this.frameHeader, 2, 0, 2);
          bufferList.advance(2);
          this.length = this.frameHeader.readUInt16BE(2);
          this.parseState = WAITING_FOR_MASK_KEY;
        }
      } else if (this.parseState === WAITING_FOR_64_BIT_LENGTH) {
        if (bufferList.length >= 8) {
          bufferList.joinInto(this.frameHeader, 2, 0, 8);
          bufferList.advance(8);
          var lengthPair = [
            this.frameHeader.readUInt32BE(2),
            this.frameHeader.readUInt32BE(2 + 4)
          ];
          if (lengthPair[0] !== 0) {
            this.protocolError = true;
            this.dropReason = "Unsupported 64-bit length frame received";
            return true;
          }
          this.length = lengthPair[1];
          this.parseState = WAITING_FOR_MASK_KEY;
        }
      }
      if (this.parseState === WAITING_FOR_MASK_KEY) {
        if (this.mask) {
          if (bufferList.length >= 4) {
            bufferList.joinInto(this.maskBytes, 0, 0, 4);
            bufferList.advance(4);
            this.parseState = WAITING_FOR_PAYLOAD;
          }
        } else {
          this.parseState = WAITING_FOR_PAYLOAD;
        }
      }
      if (this.parseState === WAITING_FOR_PAYLOAD) {
        if (this.length > this.maxReceivedFrameSize) {
          this.frameTooLarge = true;
          this.dropReason = "Frame size of " + this.length.toString(10) + " bytes exceeds maximum accepted frame size";
          return true;
        }
        if (this.length === 0) {
          this.binaryPayload = bufferAllocUnsafe(0);
          this.parseState = COMPLETE;
          return true;
        }
        if (bufferList.length >= this.length) {
          this.binaryPayload = bufferList.take(this.length);
          bufferList.advance(this.length);
          if (this.mask) {
            bufferUtil.unmask(this.binaryPayload, this.maskBytes);
          }
          if (this.opcode === 8) {
            if (this.length === 1) {
              this.binaryPayload = bufferAllocUnsafe(0);
              this.invalidCloseFrameLength = true;
            }
            if (this.length >= 2) {
              this.closeStatus = this.binaryPayload.readUInt16BE(0);
              this.binaryPayload = this.binaryPayload.slice(2);
            }
          }
          this.parseState = COMPLETE;
          return true;
        }
      }
      return false;
    };
    WebSocketFrame.prototype.throwAwayPayload = function(bufferList) {
      if (bufferList.length >= this.length) {
        bufferList.advance(this.length);
        this.parseState = COMPLETE;
        return true;
      }
      return false;
    };
    WebSocketFrame.prototype.toBuffer = function(nullMask) {
      var maskKey;
      var headerLength = 2;
      var data;
      var outputPos;
      var firstByte = 0;
      var secondByte = 0;
      if (this.fin) {
        firstByte |= 128;
      }
      if (this.rsv1) {
        firstByte |= 64;
      }
      if (this.rsv2) {
        firstByte |= 32;
      }
      if (this.rsv3) {
        firstByte |= 16;
      }
      if (this.mask) {
        secondByte |= 128;
      }
      firstByte |= this.opcode & 15;
      if (this.opcode === 8) {
        this.length = 2;
        if (this.binaryPayload) {
          this.length += this.binaryPayload.length;
        }
        data = bufferAllocUnsafe(this.length);
        data.writeUInt16BE(this.closeStatus, 0);
        if (this.length > 2) {
          this.binaryPayload.copy(data, 2);
        }
      } else if (this.binaryPayload) {
        data = this.binaryPayload;
        this.length = data.length;
      } else {
        this.length = 0;
      }
      if (this.length <= 125) {
        secondByte |= this.length & 127;
      } else if (this.length > 125 && this.length <= 65535) {
        secondByte |= 126;
        headerLength += 2;
      } else if (this.length > 65535) {
        secondByte |= 127;
        headerLength += 8;
      }
      var output = bufferAllocUnsafe(this.length + headerLength + (this.mask ? 4 : 0));
      output[0] = firstByte;
      output[1] = secondByte;
      outputPos = 2;
      if (this.length > 125 && this.length <= 65535) {
        output.writeUInt16BE(this.length, outputPos);
        outputPos += 2;
      } else if (this.length > 65535) {
        output.writeUInt32BE(0, outputPos);
        output.writeUInt32BE(this.length, outputPos + 4);
        outputPos += 8;
      }
      if (this.mask) {
        maskKey = nullMask ? 0 : Math.random() * 4294967295 >>> 0;
        this.maskBytes.writeUInt32BE(maskKey, 0);
        this.maskBytes.copy(output, outputPos);
        outputPos += 4;
        if (data) {
          bufferUtil.mask(data, this.maskBytes, output, outputPos, this.length);
        }
      } else if (data) {
        data.copy(output, outputPos);
      }
      return output;
    };
    WebSocketFrame.prototype.toString = function() {
      return "Opcode: " + this.opcode + ", fin: " + this.fin + ", length: " + this.length + ", hasPayload: " + Boolean(this.binaryPayload) + ", masked: " + this.mask;
    };
    module2.exports = WebSocketFrame;
  }
});

// ../../node_modules/websocket/vendor/FastBufferList.js
var require_FastBufferList = __commonJS({
  "../../node_modules/websocket/vendor/FastBufferList.js"(exports2, module2) {
    "use strict";
    var Buffer3 = require("buffer").Buffer;
    var EventEmitter4 = require("events").EventEmitter;
    var bufferAllocUnsafe = require_utils2().bufferAllocUnsafe;
    module2.exports = BufferList;
    module2.exports.BufferList = BufferList;
    function BufferList(opts) {
      if (!(this instanceof BufferList)) return new BufferList(opts);
      EventEmitter4.call(this);
      var self2 = this;
      if (typeof opts == "undefined") opts = {};
      self2.encoding = opts.encoding;
      var head = { next: null, buffer: null };
      var last2 = { next: null, buffer: null };
      var length = 0;
      self2.__defineGetter__("length", function() {
        return length;
      });
      var offset = 0;
      self2.write = function(buf) {
        if (!head.buffer) {
          head.buffer = buf;
          last2 = head;
        } else {
          last2.next = { next: null, buffer: buf };
          last2 = last2.next;
        }
        length += buf.length;
        self2.emit("write", buf);
        return true;
      };
      self2.end = function(buf) {
        if (Buffer3.isBuffer(buf)) self2.write(buf);
      };
      self2.push = function() {
        var args = [].concat.apply([], arguments);
        args.forEach(self2.write);
        return self2;
      };
      self2.forEach = function(fn) {
        if (!head.buffer) return bufferAllocUnsafe(0);
        if (head.buffer.length - offset <= 0) return self2;
        var firstBuf = head.buffer.slice(offset);
        var b = { buffer: firstBuf, next: head.next };
        while (b && b.buffer) {
          var r = fn(b.buffer);
          if (r) break;
          b = b.next;
        }
        return self2;
      };
      self2.join = function(start, end) {
        if (!head.buffer) return bufferAllocUnsafe(0);
        if (start == void 0) start = 0;
        if (end == void 0) end = self2.length;
        var big = bufferAllocUnsafe(end - start);
        var ix = 0;
        self2.forEach(function(buffer) {
          if (start < ix + buffer.length && ix < end) {
            buffer.copy(
              big,
              Math.max(0, ix - start),
              Math.max(0, start - ix),
              Math.min(buffer.length, end - ix)
            );
          }
          ix += buffer.length;
          if (ix > end) return true;
        });
        return big;
      };
      self2.joinInto = function(targetBuffer, targetStart, sourceStart, sourceEnd) {
        if (!head.buffer) return new bufferAllocUnsafe(0);
        if (sourceStart == void 0) sourceStart = 0;
        if (sourceEnd == void 0) sourceEnd = self2.length;
        var big = targetBuffer;
        if (big.length - targetStart < sourceEnd - sourceStart) {
          throw new Error("Insufficient space available in target Buffer.");
        }
        var ix = 0;
        self2.forEach(function(buffer) {
          if (sourceStart < ix + buffer.length && ix < sourceEnd) {
            buffer.copy(
              big,
              Math.max(targetStart, targetStart + ix - sourceStart),
              Math.max(0, sourceStart - ix),
              Math.min(buffer.length, sourceEnd - ix)
            );
          }
          ix += buffer.length;
          if (ix > sourceEnd) return true;
        });
        return big;
      };
      self2.advance = function(n) {
        offset += n;
        length -= n;
        while (head.buffer && offset >= head.buffer.length) {
          offset -= head.buffer.length;
          head = head.next ? head.next : { buffer: null, next: null };
        }
        if (head.buffer === null) last2 = { next: null, buffer: null };
        self2.emit("advance", n);
        return self2;
      };
      self2.take = function(n, encoding) {
        if (n == void 0) n = self2.length;
        else if (typeof n !== "number") {
          encoding = n;
          n = self2.length;
        }
        var b = head;
        if (!encoding) encoding = self2.encoding;
        if (encoding) {
          var acc = "";
          self2.forEach(function(buffer) {
            if (n <= 0) return true;
            acc += buffer.toString(
              encoding,
              0,
              Math.min(n, buffer.length)
            );
            n -= buffer.length;
          });
          return acc;
        } else {
          return self2.join(0, n);
        }
      };
      self2.toString = function() {
        return self2.take("binary");
      };
    }
    require("util").inherits(BufferList, EventEmitter4);
  }
});

// ../../node_modules/utf-8-validate/fallback.js
var require_fallback2 = __commonJS({
  "../../node_modules/utf-8-validate/fallback.js"(exports2, module2) {
    "use strict";
    function isValidUTF8(buf) {
      const len = buf.length;
      let i = 0;
      while (i < len) {
        if ((buf[i] & 128) === 0) {
          i++;
        } else if ((buf[i] & 224) === 192) {
          if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {
            return false;
          }
          i += 2;
        } else if ((buf[i] & 240) === 224) {
          if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || // overlong
          buf[i] === 237 && (buf[i + 1] & 224) === 160) {
            return false;
          }
          i += 3;
        } else if ((buf[i] & 248) === 240) {
          if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || // overlong
          buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) {
            return false;
          }
          i += 4;
        } else {
          return false;
        }
      }
      return true;
    }
    module2.exports = isValidUTF8;
  }
});

// ../../node_modules/utf-8-validate/index.js
var require_utf_8_validate = __commonJS({
  "../../node_modules/utf-8-validate/index.js"(exports2, module2) {
    "use strict";
    try {
      module2.exports = require_node_gyp_build2()(__dirname);
    } catch (e) {
      module2.exports = require_fallback2();
    }
  }
});

// ../../node_modules/websocket/lib/WebSocketConnection.js
var require_WebSocketConnection = __commonJS({
  "../../node_modules/websocket/lib/WebSocketConnection.js"(exports2, module2) {
    "use strict";
    var util2 = require("util");
    var utils = require_utils2();
    var EventEmitter4 = require("events").EventEmitter;
    var WebSocketFrame = require_WebSocketFrame();
    var BufferList = require_FastBufferList();
    var isValidUTF8 = require_utf_8_validate();
    var bufferAllocUnsafe = utils.bufferAllocUnsafe;
    var bufferFromString = utils.bufferFromString;
    var STATE_OPEN = "open";
    var STATE_PEER_REQUESTED_CLOSE = "peer_requested_close";
    var STATE_ENDING = "ending";
    var STATE_CLOSED = "closed";
    var setImmediateImpl = "setImmediate" in global ? global.setImmediate.bind(global) : process.nextTick.bind(process);
    var idCounter = 0;
    function WebSocketConnection(socket, extensions, protocol, maskOutgoingPackets, config) {
      this._debug = utils.BufferingLogger("websocket:connection", ++idCounter);
      this._debug("constructor");
      if (this._debug.enabled) {
        instrumentSocketForDebugging(this, socket);
      }
      EventEmitter4.call(this);
      this._pingListenerCount = 0;
      this.on("newListener", function(ev) {
        if (ev === "ping") {
          this._pingListenerCount++;
        }
      }).on("removeListener", function(ev) {
        if (ev === "ping") {
          this._pingListenerCount--;
        }
      });
      this.config = config;
      this.socket = socket;
      this.protocol = protocol;
      this.extensions = extensions;
      this.remoteAddress = socket.remoteAddress;
      this.closeReasonCode = -1;
      this.closeDescription = null;
      this.closeEventEmitted = false;
      this.maskOutgoingPackets = maskOutgoingPackets;
      this.maskBytes = bufferAllocUnsafe(4);
      this.frameHeader = bufferAllocUnsafe(10);
      this.bufferList = new BufferList();
      this.currentFrame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);
      this.fragmentationSize = 0;
      this.frameQueue = [];
      this.connected = true;
      this.state = STATE_OPEN;
      this.waitingForCloseResponse = false;
      this.receivedEnd = false;
      this.closeTimeout = this.config.closeTimeout;
      this.assembleFragments = this.config.assembleFragments;
      this.maxReceivedMessageSize = this.config.maxReceivedMessageSize;
      this.outputBufferFull = false;
      this.inputPaused = false;
      this.receivedDataHandler = this.processReceivedData.bind(this);
      this._closeTimerHandler = this.handleCloseTimer.bind(this);
      this.socket.setNoDelay(this.config.disableNagleAlgorithm);
      this.socket.setTimeout(0);
      if (this.config.keepalive && !this.config.useNativeKeepalive) {
        if (typeof this.config.keepaliveInterval !== "number") {
          throw new Error("keepaliveInterval must be specified and numeric if keepalive is true.");
        }
        this._keepaliveTimerHandler = this.handleKeepaliveTimer.bind(this);
        this.setKeepaliveTimer();
        if (this.config.dropConnectionOnKeepaliveTimeout) {
          if (typeof this.config.keepaliveGracePeriod !== "number") {
            throw new Error("keepaliveGracePeriod  must be specified and numeric if dropConnectionOnKeepaliveTimeout is true.");
          }
          this._gracePeriodTimerHandler = this.handleGracePeriodTimer.bind(this);
        }
      } else if (this.config.keepalive && this.config.useNativeKeepalive) {
        if (!("setKeepAlive" in this.socket)) {
          throw new Error("Unable to use native keepalive: unsupported by this version of Node.");
        }
        this.socket.setKeepAlive(true, this.config.keepaliveInterval);
      }
      this.socket.removeAllListeners("error");
    }
    WebSocketConnection.CLOSE_REASON_NORMAL = 1e3;
    WebSocketConnection.CLOSE_REASON_GOING_AWAY = 1001;
    WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR = 1002;
    WebSocketConnection.CLOSE_REASON_UNPROCESSABLE_INPUT = 1003;
    WebSocketConnection.CLOSE_REASON_RESERVED = 1004;
    WebSocketConnection.CLOSE_REASON_NOT_PROVIDED = 1005;
    WebSocketConnection.CLOSE_REASON_ABNORMAL = 1006;
    WebSocketConnection.CLOSE_REASON_INVALID_DATA = 1007;
    WebSocketConnection.CLOSE_REASON_POLICY_VIOLATION = 1008;
    WebSocketConnection.CLOSE_REASON_MESSAGE_TOO_BIG = 1009;
    WebSocketConnection.CLOSE_REASON_EXTENSION_REQUIRED = 1010;
    WebSocketConnection.CLOSE_REASON_INTERNAL_SERVER_ERROR = 1011;
    WebSocketConnection.CLOSE_REASON_TLS_HANDSHAKE_FAILED = 1015;
    WebSocketConnection.CLOSE_DESCRIPTIONS = {
      1e3: "Normal connection closure",
      1001: "Remote peer is going away",
      1002: "Protocol error",
      1003: "Unprocessable input",
      1004: "Reserved",
      1005: "Reason not provided",
      1006: "Abnormal closure, no further detail available",
      1007: "Invalid data received",
      1008: "Policy violation",
      1009: "Message too big",
      1010: "Extension requested by client is required",
      1011: "Internal Server Error",
      1015: "TLS Handshake Failed"
    };
    function validateCloseReason(code) {
      if (code < 1e3) {
        return false;
      }
      if (code >= 1e3 && code <= 2999) {
        return [1e3, 1001, 1002, 1003, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015].indexOf(code) !== -1;
      }
      if (code >= 3e3 && code <= 3999) {
        return true;
      }
      if (code >= 4e3 && code <= 4999) {
        return true;
      }
      if (code >= 5e3) {
        return false;
      }
    }
    util2.inherits(WebSocketConnection, EventEmitter4);
    WebSocketConnection.prototype._addSocketEventListeners = function() {
      this.socket.on("error", this.handleSocketError.bind(this));
      this.socket.on("end", this.handleSocketEnd.bind(this));
      this.socket.on("close", this.handleSocketClose.bind(this));
      this.socket.on("drain", this.handleSocketDrain.bind(this));
      this.socket.on("pause", this.handleSocketPause.bind(this));
      this.socket.on("resume", this.handleSocketResume.bind(this));
      this.socket.on("data", this.handleSocketData.bind(this));
    };
    WebSocketConnection.prototype.setKeepaliveTimer = function() {
      this._debug("setKeepaliveTimer");
      if (!this.config.keepalive || this.config.useNativeKeepalive) {
        return;
      }
      this.clearKeepaliveTimer();
      this.clearGracePeriodTimer();
      this._keepaliveTimeoutID = setTimeout(this._keepaliveTimerHandler, this.config.keepaliveInterval);
    };
    WebSocketConnection.prototype.clearKeepaliveTimer = function() {
      if (this._keepaliveTimeoutID) {
        clearTimeout(this._keepaliveTimeoutID);
      }
    };
    WebSocketConnection.prototype.handleKeepaliveTimer = function() {
      this._debug("handleKeepaliveTimer");
      this._keepaliveTimeoutID = null;
      this.ping();
      if (this.config.dropConnectionOnKeepaliveTimeout) {
        this.setGracePeriodTimer();
      } else {
        this.setKeepaliveTimer();
      }
    };
    WebSocketConnection.prototype.setGracePeriodTimer = function() {
      this._debug("setGracePeriodTimer");
      this.clearGracePeriodTimer();
      this._gracePeriodTimeoutID = setTimeout(this._gracePeriodTimerHandler, this.config.keepaliveGracePeriod);
    };
    WebSocketConnection.prototype.clearGracePeriodTimer = function() {
      if (this._gracePeriodTimeoutID) {
        clearTimeout(this._gracePeriodTimeoutID);
      }
    };
    WebSocketConnection.prototype.handleGracePeriodTimer = function() {
      this._debug("handleGracePeriodTimer");
      this._gracePeriodTimeoutID = null;
      this.drop(WebSocketConnection.CLOSE_REASON_ABNORMAL, "Peer not responding.", true);
    };
    WebSocketConnection.prototype.handleSocketData = function(data) {
      this._debug("handleSocketData");
      this.setKeepaliveTimer();
      this.bufferList.write(data);
      this.processReceivedData();
    };
    WebSocketConnection.prototype.processReceivedData = function() {
      this._debug("processReceivedData");
      if (!this.connected) {
        return;
      }
      if (this.inputPaused) {
        return;
      }
      var frame = this.currentFrame;
      if (!frame.addData(this.bufferList)) {
        this._debug("-- insufficient data for frame");
        return;
      }
      var self2 = this;
      if (frame.protocolError) {
        this._debug("-- protocol error");
        process.nextTick(function() {
          self2.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR, frame.dropReason);
        });
        return;
      } else if (frame.frameTooLarge) {
        this._debug("-- frame too large");
        process.nextTick(function() {
          self2.drop(WebSocketConnection.CLOSE_REASON_MESSAGE_TOO_BIG, frame.dropReason);
        });
        return;
      }
      if (frame.rsv1 || frame.rsv2 || frame.rsv3) {
        this._debug("-- illegal rsv flag");
        process.nextTick(function() {
          self2.drop(
            WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR,
            "Unsupported usage of rsv bits without negotiated extension."
          );
        });
        return;
      }
      if (!this.assembleFragments) {
        this._debug("-- emitting frame");
        process.nextTick(function() {
          self2.emit("frame", frame);
        });
      }
      process.nextTick(function() {
        self2.processFrame(frame);
      });
      this.currentFrame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);
      if (this.bufferList.length > 0) {
        setImmediateImpl(this.receivedDataHandler);
      }
    };
    WebSocketConnection.prototype.handleSocketError = function(error) {
      this._debug("handleSocketError: %j", error);
      if (this.state === STATE_CLOSED) {
        this._debug("  --- Socket 'error' after 'close'");
        return;
      }
      this.closeReasonCode = WebSocketConnection.CLOSE_REASON_ABNORMAL;
      this.closeDescription = "Socket Error: " + error.syscall + " " + error.code;
      this.connected = false;
      this.state = STATE_CLOSED;
      this.fragmentationSize = 0;
      if (utils.eventEmitterListenerCount(this, "error") > 0) {
        this.emit("error", error);
      }
      this.socket.destroy();
      this._debug.printOutput();
    };
    WebSocketConnection.prototype.handleSocketEnd = function() {
      this._debug("handleSocketEnd: received socket end.  state = %s", this.state);
      this.receivedEnd = true;
      if (this.state === STATE_CLOSED) {
        this._debug("  --- Socket 'end' after 'close'");
        return;
      }
      if (this.state !== STATE_PEER_REQUESTED_CLOSE && this.state !== STATE_ENDING) {
        this._debug("  --- UNEXPECTED socket end.");
        this.socket.end();
      }
    };
    WebSocketConnection.prototype.handleSocketClose = function(hadError) {
      this._debug("handleSocketClose: received socket close");
      this.socketHadError = hadError;
      this.connected = false;
      this.state = STATE_CLOSED;
      if (this.closeReasonCode === -1) {
        this.closeReasonCode = WebSocketConnection.CLOSE_REASON_ABNORMAL;
        this.closeDescription = "Connection dropped by remote peer.";
      }
      this.clearCloseTimer();
      this.clearKeepaliveTimer();
      this.clearGracePeriodTimer();
      if (!this.closeEventEmitted) {
        this.closeEventEmitted = true;
        this._debug("-- Emitting WebSocketConnection close event");
        this.emit("close", this.closeReasonCode, this.closeDescription);
      }
    };
    WebSocketConnection.prototype.handleSocketDrain = function() {
      this._debug("handleSocketDrain: socket drain event");
      this.outputBufferFull = false;
      this.emit("drain");
    };
    WebSocketConnection.prototype.handleSocketPause = function() {
      this._debug("handleSocketPause: socket pause event");
      this.inputPaused = true;
      this.emit("pause");
    };
    WebSocketConnection.prototype.handleSocketResume = function() {
      this._debug("handleSocketResume: socket resume event");
      this.inputPaused = false;
      this.emit("resume");
      this.processReceivedData();
    };
    WebSocketConnection.prototype.pause = function() {
      this._debug("pause: pause requested");
      this.socket.pause();
    };
    WebSocketConnection.prototype.resume = function() {
      this._debug("resume: resume requested");
      this.socket.resume();
    };
    WebSocketConnection.prototype.close = function(reasonCode, description) {
      if (this.connected) {
        this._debug("close: Initating clean WebSocket close sequence.");
        if ("number" !== typeof reasonCode) {
          reasonCode = WebSocketConnection.CLOSE_REASON_NORMAL;
        }
        if (!validateCloseReason(reasonCode)) {
          throw new Error("Close code " + reasonCode + " is not valid.");
        }
        if ("string" !== typeof description) {
          description = WebSocketConnection.CLOSE_DESCRIPTIONS[reasonCode];
        }
        this.closeReasonCode = reasonCode;
        this.closeDescription = description;
        this.setCloseTimer();
        this.sendCloseFrame(this.closeReasonCode, this.closeDescription);
        this.state = STATE_ENDING;
        this.connected = false;
      }
    };
    WebSocketConnection.prototype.drop = function(reasonCode, description, skipCloseFrame) {
      this._debug("drop");
      if (typeof reasonCode !== "number") {
        reasonCode = WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR;
      }
      if (typeof description !== "string") {
        description = WebSocketConnection.CLOSE_DESCRIPTIONS[reasonCode];
      }
      this._debug(
        "Forcefully dropping connection. skipCloseFrame: %s, code: %d, description: %s",
        skipCloseFrame,
        reasonCode,
        description
      );
      this.closeReasonCode = reasonCode;
      this.closeDescription = description;
      this.frameQueue = [];
      this.fragmentationSize = 0;
      if (!skipCloseFrame) {
        this.sendCloseFrame(reasonCode, description);
      }
      this.connected = false;
      this.state = STATE_CLOSED;
      this.clearCloseTimer();
      this.clearKeepaliveTimer();
      this.clearGracePeriodTimer();
      if (!this.closeEventEmitted) {
        this.closeEventEmitted = true;
        this._debug("Emitting WebSocketConnection close event");
        this.emit("close", this.closeReasonCode, this.closeDescription);
      }
      this._debug("Drop: destroying socket");
      this.socket.destroy();
    };
    WebSocketConnection.prototype.setCloseTimer = function() {
      this._debug("setCloseTimer");
      this.clearCloseTimer();
      this._debug("Setting close timer");
      this.waitingForCloseResponse = true;
      this.closeTimer = setTimeout(this._closeTimerHandler, this.closeTimeout);
    };
    WebSocketConnection.prototype.clearCloseTimer = function() {
      this._debug("clearCloseTimer");
      if (this.closeTimer) {
        this._debug("Clearing close timer");
        clearTimeout(this.closeTimer);
        this.waitingForCloseResponse = false;
        this.closeTimer = null;
      }
    };
    WebSocketConnection.prototype.handleCloseTimer = function() {
      this._debug("handleCloseTimer");
      this.closeTimer = null;
      if (this.waitingForCloseResponse) {
        this._debug("Close response not received from client.  Forcing socket end.");
        this.waitingForCloseResponse = false;
        this.state = STATE_CLOSED;
        this.socket.end();
      }
    };
    WebSocketConnection.prototype.processFrame = function(frame) {
      this._debug("processFrame");
      this._debug(" -- frame: %s", frame);
      if (this.frameQueue.length !== 0 && (frame.opcode > 0 && frame.opcode < 8)) {
        this.drop(
          WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR,
          "Illegal frame opcode 0x" + frame.opcode.toString(16) + " received in middle of fragmented message."
        );
        return;
      }
      switch (frame.opcode) {
        case 2:
          this._debug("-- Binary Frame");
          if (this.assembleFragments) {
            if (frame.fin) {
              this._debug("---- Emitting 'message' event");
              this.emit("message", {
                type: "binary",
                binaryData: frame.binaryPayload
              });
            } else {
              this.frameQueue.push(frame);
              this.fragmentationSize = frame.length;
            }
          }
          break;
        case 1:
          this._debug("-- Text Frame");
          if (this.assembleFragments) {
            if (frame.fin) {
              if (!isValidUTF8(frame.binaryPayload)) {
                this.drop(
                  WebSocketConnection.CLOSE_REASON_INVALID_DATA,
                  "Invalid UTF-8 Data Received"
                );
                return;
              }
              this._debug("---- Emitting 'message' event");
              this.emit("message", {
                type: "utf8",
                utf8Data: frame.binaryPayload.toString("utf8")
              });
            } else {
              this.frameQueue.push(frame);
              this.fragmentationSize = frame.length;
            }
          }
          break;
        case 0:
          this._debug("-- Continuation Frame");
          if (this.assembleFragments) {
            if (this.frameQueue.length === 0) {
              this.drop(
                WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR,
                "Unexpected Continuation Frame"
              );
              return;
            }
            this.fragmentationSize += frame.length;
            if (this.fragmentationSize > this.maxReceivedMessageSize) {
              this.drop(
                WebSocketConnection.CLOSE_REASON_MESSAGE_TOO_BIG,
                "Maximum message size exceeded."
              );
              return;
            }
            this.frameQueue.push(frame);
            if (frame.fin) {
              var bytesCopied = 0;
              var binaryPayload = bufferAllocUnsafe(this.fragmentationSize);
              var opcode = this.frameQueue[0].opcode;
              this.frameQueue.forEach(function(currentFrame) {
                currentFrame.binaryPayload.copy(binaryPayload, bytesCopied);
                bytesCopied += currentFrame.binaryPayload.length;
              });
              this.frameQueue = [];
              this.fragmentationSize = 0;
              switch (opcode) {
                case 2:
                  this.emit("message", {
                    type: "binary",
                    binaryData: binaryPayload
                  });
                  break;
                case 1:
                  if (!isValidUTF8(binaryPayload)) {
                    this.drop(
                      WebSocketConnection.CLOSE_REASON_INVALID_DATA,
                      "Invalid UTF-8 Data Received"
                    );
                    return;
                  }
                  this.emit("message", {
                    type: "utf8",
                    utf8Data: binaryPayload.toString("utf8")
                  });
                  break;
                default:
                  this.drop(
                    WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR,
                    "Unexpected first opcode in fragmentation sequence: 0x" + opcode.toString(16)
                  );
                  return;
              }
            }
          }
          break;
        case 9:
          this._debug("-- Ping Frame");
          if (this._pingListenerCount > 0) {
            var cancelled = false;
            var cancel = function() {
              cancelled = true;
            };
            this.emit("ping", cancel, frame.binaryPayload);
            if (!cancelled) {
              this.pong(frame.binaryPayload);
            }
          } else {
            this.pong(frame.binaryPayload);
          }
          break;
        case 10:
          this._debug("-- Pong Frame");
          this.emit("pong", frame.binaryPayload);
          break;
        case 8:
          this._debug("-- Close Frame");
          if (this.waitingForCloseResponse) {
            this._debug("---- Got close response from peer.  Completing closing handshake.");
            this.clearCloseTimer();
            this.waitingForCloseResponse = false;
            this.state = STATE_CLOSED;
            this.socket.end();
            return;
          }
          this._debug("---- Closing handshake initiated by peer.");
          this.state = STATE_PEER_REQUESTED_CLOSE;
          var respondCloseReasonCode;
          if (frame.invalidCloseFrameLength) {
            this.closeReasonCode = 1005;
            respondCloseReasonCode = WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR;
          } else if (frame.closeStatus === -1 || validateCloseReason(frame.closeStatus)) {
            this.closeReasonCode = frame.closeStatus;
            respondCloseReasonCode = WebSocketConnection.CLOSE_REASON_NORMAL;
          } else {
            this.closeReasonCode = frame.closeStatus;
            respondCloseReasonCode = WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR;
          }
          if (frame.binaryPayload.length > 1) {
            if (!isValidUTF8(frame.binaryPayload)) {
              this.drop(
                WebSocketConnection.CLOSE_REASON_INVALID_DATA,
                "Invalid UTF-8 Data Received"
              );
              return;
            }
            this.closeDescription = frame.binaryPayload.toString("utf8");
          } else {
            this.closeDescription = WebSocketConnection.CLOSE_DESCRIPTIONS[this.closeReasonCode];
          }
          this._debug(
            "------ Remote peer %s - code: %d - %s - close frame payload length: %d",
            this.remoteAddress,
            this.closeReasonCode,
            this.closeDescription,
            frame.length
          );
          this._debug("------ responding to remote peer's close request.");
          this.sendCloseFrame(respondCloseReasonCode, null);
          this.connected = false;
          break;
        default:
          this._debug("-- Unrecognized Opcode %d", frame.opcode);
          this.drop(
            WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR,
            "Unrecognized Opcode: 0x" + frame.opcode.toString(16)
          );
          break;
      }
    };
    WebSocketConnection.prototype.send = function(data, cb) {
      this._debug("send");
      if (Buffer.isBuffer(data)) {
        this.sendBytes(data, cb);
      } else if (typeof data["toString"] === "function") {
        this.sendUTF(data, cb);
      } else {
        throw new Error("Data provided must either be a Node Buffer or implement toString()");
      }
    };
    WebSocketConnection.prototype.sendUTF = function(data, cb) {
      data = bufferFromString(data.toString(), "utf8");
      this._debug("sendUTF: %d bytes", data.length);
      var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);
      frame.opcode = 1;
      frame.binaryPayload = data;
      this.fragmentAndSend(frame, cb);
    };
    WebSocketConnection.prototype.sendBytes = function(data, cb) {
      this._debug("sendBytes");
      if (!Buffer.isBuffer(data)) {
        throw new Error("You must pass a Node Buffer object to WebSocketConnection.prototype.sendBytes()");
      }
      var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);
      frame.opcode = 2;
      frame.binaryPayload = data;
      this.fragmentAndSend(frame, cb);
    };
    WebSocketConnection.prototype.ping = function(data) {
      this._debug("ping");
      var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);
      frame.opcode = 9;
      frame.fin = true;
      if (data) {
        if (!Buffer.isBuffer(data)) {
          data = bufferFromString(data.toString(), "utf8");
        }
        if (data.length > 125) {
          this._debug("WebSocket: Data for ping is longer than 125 bytes.  Truncating.");
          data = data.slice(0, 124);
        }
        frame.binaryPayload = data;
      }
      this.sendFrame(frame);
    };
    WebSocketConnection.prototype.pong = function(binaryPayload) {
      this._debug("pong");
      var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);
      frame.opcode = 10;
      if (Buffer.isBuffer(binaryPayload) && binaryPayload.length > 125) {
        this._debug("WebSocket: Data for pong is longer than 125 bytes.  Truncating.");
        binaryPayload = binaryPayload.slice(0, 124);
      }
      frame.binaryPayload = binaryPayload;
      frame.fin = true;
      this.sendFrame(frame);
    };
    WebSocketConnection.prototype.fragmentAndSend = function(frame, cb) {
      this._debug("fragmentAndSend");
      if (frame.opcode > 7) {
        throw new Error("You cannot fragment control frames.");
      }
      var threshold = this.config.fragmentationThreshold;
      var length = frame.binaryPayload.length;
      if (!this.config.fragmentOutgoingMessages || frame.binaryPayload && length <= threshold) {
        frame.fin = true;
        this.sendFrame(frame, cb);
        return;
      }
      var numFragments = Math.ceil(length / threshold);
      var sentFragments = 0;
      var sentCallback = function fragmentSentCallback(err) {
        if (err) {
          if (typeof cb === "function") {
            cb(err);
            cb = null;
          }
          return;
        }
        ++sentFragments;
        if (sentFragments === numFragments && typeof cb === "function") {
          cb();
        }
      };
      for (var i = 1; i <= numFragments; i++) {
        var currentFrame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);
        currentFrame.opcode = i === 1 ? frame.opcode : 0;
        currentFrame.fin = i === numFragments;
        var currentLength = i === numFragments ? length - threshold * (i - 1) : threshold;
        var sliceStart = threshold * (i - 1);
        currentFrame.binaryPayload = frame.binaryPayload.slice(sliceStart, sliceStart + currentLength);
        this.sendFrame(currentFrame, sentCallback);
      }
    };
    WebSocketConnection.prototype.sendCloseFrame = function(reasonCode, description, cb) {
      if (typeof reasonCode !== "number") {
        reasonCode = WebSocketConnection.CLOSE_REASON_NORMAL;
      }
      this._debug("sendCloseFrame state: %s, reasonCode: %d, description: %s", this.state, reasonCode, description);
      if (this.state !== STATE_OPEN && this.state !== STATE_PEER_REQUESTED_CLOSE) {
        return;
      }
      var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);
      frame.fin = true;
      frame.opcode = 8;
      frame.closeStatus = reasonCode;
      if (typeof description === "string") {
        frame.binaryPayload = bufferFromString(description, "utf8");
      }
      this.sendFrame(frame, cb);
      this.socket.end();
    };
    WebSocketConnection.prototype.sendFrame = function(frame, cb) {
      this._debug("sendFrame");
      frame.mask = this.maskOutgoingPackets;
      var flushed = this.socket.write(frame.toBuffer(), cb);
      this.outputBufferFull = !flushed;
      return flushed;
    };
    module2.exports = WebSocketConnection;
    function instrumentSocketForDebugging(connection, socket) {
      if (!connection._debug.enabled) {
        return;
      }
      var originalSocketEmit = socket.emit;
      socket.emit = function(event) {
        connection._debug("||| Socket Event  '%s'", event);
        originalSocketEmit.apply(this, arguments);
      };
      for (var key in socket) {
        if ("function" !== typeof socket[key]) {
          continue;
        }
        if (["emit"].indexOf(key) !== -1) {
          continue;
        }
        (function(key2) {
          var original = socket[key2];
          if (key2 === "on") {
            socket[key2] = function proxyMethod__EventEmitter__On() {
              connection._debug("||| Socket method called:  %s (%s)", key2, arguments[0]);
              return original.apply(this, arguments);
            };
            return;
          }
          socket[key2] = function proxyMethod() {
            connection._debug("||| Socket method called:  %s", key2);
            return original.apply(this, arguments);
          };
        })(key);
      }
    }
  }
});

// ../../node_modules/websocket/lib/WebSocketRequest.js
var require_WebSocketRequest = __commonJS({
  "../../node_modules/websocket/lib/WebSocketRequest.js"(exports2, module2) {
    "use strict";
    var crypto2 = require("crypto");
    var util2 = require("util");
    var url = require("url");
    var EventEmitter4 = require("events").EventEmitter;
    var WebSocketConnection = require_WebSocketConnection();
    var headerValueSplitRegExp = /,\s*/;
    var headerParamSplitRegExp = /;\s*/;
    var headerSanitizeRegExp = /[\r\n]/g;
    var xForwardedForSeparatorRegExp = /,\s*/;
    var separators = [
      "(",
      ")",
      "<",
      ">",
      "@",
      ",",
      ";",
      ":",
      "\\",
      '"',
      "/",
      "[",
      "]",
      "?",
      "=",
      "{",
      "}",
      " ",
      String.fromCharCode(9)
    ];
    var controlChars = [
      String.fromCharCode(127)
      /* DEL */
    ];
    for (i = 0; i < 31; i++) {
      controlChars.push(String.fromCharCode(i));
    }
    var i;
    var cookieNameValidateRegEx = /([\x00-\x20\x22\x28\x29\x2c\x2f\x3a-\x3f\x40\x5b-\x5e\x7b\x7d\x7f])/;
    var cookieValueValidateRegEx = /[^\x21\x23-\x2b\x2d-\x3a\x3c-\x5b\x5d-\x7e]/;
    var cookieValueDQuoteValidateRegEx = /^"[^"]*"$/;
    var controlCharsAndSemicolonRegEx = /[\x00-\x20\x3b]/g;
    var cookieSeparatorRegEx = /[;,] */;
    var httpStatusDescriptions = {
      100: "Continue",
      101: "Switching Protocols",
      200: "OK",
      201: "Created",
      203: "Non-Authoritative Information",
      204: "No Content",
      205: "Reset Content",
      206: "Partial Content",
      300: "Multiple Choices",
      301: "Moved Permanently",
      302: "Found",
      303: "See Other",
      304: "Not Modified",
      305: "Use Proxy",
      307: "Temporary Redirect",
      400: "Bad Request",
      401: "Unauthorized",
      402: "Payment Required",
      403: "Forbidden",
      404: "Not Found",
      406: "Not Acceptable",
      407: "Proxy Authorization Required",
      408: "Request Timeout",
      409: "Conflict",
      410: "Gone",
      411: "Length Required",
      412: "Precondition Failed",
      413: "Request Entity Too Long",
      414: "Request-URI Too Long",
      415: "Unsupported Media Type",
      416: "Requested Range Not Satisfiable",
      417: "Expectation Failed",
      426: "Upgrade Required",
      500: "Internal Server Error",
      501: "Not Implemented",
      502: "Bad Gateway",
      503: "Service Unavailable",
      504: "Gateway Timeout",
      505: "HTTP Version Not Supported"
    };
    function WebSocketRequest(socket, httpRequest, serverConfig) {
      EventEmitter4.call(this);
      this.socket = socket;
      this.httpRequest = httpRequest;
      this.resource = httpRequest.url;
      this.remoteAddress = socket.remoteAddress;
      this.remoteAddresses = [this.remoteAddress];
      this.serverConfig = serverConfig;
      this._socketIsClosing = false;
      this._socketCloseHandler = this._handleSocketCloseBeforeAccept.bind(this);
      this.socket.on("end", this._socketCloseHandler);
      this.socket.on("close", this._socketCloseHandler);
      this._resolved = false;
    }
    util2.inherits(WebSocketRequest, EventEmitter4);
    WebSocketRequest.prototype.readHandshake = function() {
      var self2 = this;
      var request = this.httpRequest;
      this.resourceURL = url.parse(this.resource, true);
      this.host = request.headers["host"];
      if (!this.host) {
        throw new Error("Client must provide a Host header.");
      }
      this.key = request.headers["sec-websocket-key"];
      if (!this.key) {
        throw new Error("Client must provide a value for Sec-WebSocket-Key.");
      }
      this.webSocketVersion = parseInt(request.headers["sec-websocket-version"], 10);
      if (!this.webSocketVersion || isNaN(this.webSocketVersion)) {
        throw new Error("Client must provide a value for Sec-WebSocket-Version.");
      }
      switch (this.webSocketVersion) {
        case 8:
        case 13:
          break;
        default:
          var e = new Error("Unsupported websocket client version: " + this.webSocketVersion + "Only versions 8 and 13 are supported.");
          e.httpCode = 426;
          e.headers = {
            "Sec-WebSocket-Version": "13"
          };
          throw e;
      }
      if (this.webSocketVersion === 13) {
        this.origin = request.headers["origin"];
      } else if (this.webSocketVersion === 8) {
        this.origin = request.headers["sec-websocket-origin"];
      }
      var protocolString = request.headers["sec-websocket-protocol"];
      this.protocolFullCaseMap = {};
      this.requestedProtocols = [];
      if (protocolString) {
        var requestedProtocolsFullCase = protocolString.split(headerValueSplitRegExp);
        requestedProtocolsFullCase.forEach(function(protocol) {
          var lcProtocol = protocol.toLocaleLowerCase();
          self2.requestedProtocols.push(lcProtocol);
          self2.protocolFullCaseMap[lcProtocol] = protocol;
        });
      }
      if (!this.serverConfig.ignoreXForwardedFor && request.headers["x-forwarded-for"]) {
        var immediatePeerIP = this.remoteAddress;
        this.remoteAddresses = request.headers["x-forwarded-for"].split(xForwardedForSeparatorRegExp);
        this.remoteAddresses.push(immediatePeerIP);
        this.remoteAddress = this.remoteAddresses[0];
      }
      if (this.serverConfig.parseExtensions) {
        var extensionsString = request.headers["sec-websocket-extensions"];
        this.requestedExtensions = this.parseExtensions(extensionsString);
      } else {
        this.requestedExtensions = [];
      }
      if (this.serverConfig.parseCookies) {
        var cookieString = request.headers["cookie"];
        this.cookies = this.parseCookies(cookieString);
      } else {
        this.cookies = [];
      }
    };
    WebSocketRequest.prototype.parseExtensions = function(extensionsString) {
      if (!extensionsString || extensionsString.length === 0) {
        return [];
      }
      var extensions = extensionsString.toLocaleLowerCase().split(headerValueSplitRegExp);
      extensions.forEach(function(extension, index, array) {
        var params = extension.split(headerParamSplitRegExp);
        var extensionName = params[0];
        var extensionParams = params.slice(1);
        extensionParams.forEach(function(rawParam, index2, array2) {
          var arr = rawParam.split("=");
          var obj2 = {
            name: arr[0],
            value: arr[1]
          };
          array2.splice(index2, 1, obj2);
        });
        var obj = {
          name: extensionName,
          params: extensionParams
        };
        array.splice(index, 1, obj);
      });
      return extensions;
    };
    WebSocketRequest.prototype.parseCookies = function(str) {
      if (!str || typeof str !== "string") {
        return [];
      }
      var cookies = [];
      var pairs = str.split(cookieSeparatorRegEx);
      pairs.forEach(function(pair) {
        var eq_idx = pair.indexOf("=");
        if (eq_idx === -1) {
          cookies.push({
            name: pair,
            value: null
          });
          return;
        }
        var key = pair.substr(0, eq_idx).trim();
        var val = pair.substr(++eq_idx, pair.length).trim();
        if ('"' === val[0]) {
          val = val.slice(1, -1);
        }
        cookies.push({
          name: key,
          value: decodeURIComponent(val)
        });
      });
      return cookies;
    };
    WebSocketRequest.prototype.accept = function(acceptedProtocol, allowedOrigin, cookies) {
      this._verifyResolution();
      var protocolFullCase;
      if (acceptedProtocol) {
        protocolFullCase = this.protocolFullCaseMap[acceptedProtocol.toLocaleLowerCase()];
        if (typeof protocolFullCase === "undefined") {
          protocolFullCase = acceptedProtocol;
        }
      } else {
        protocolFullCase = acceptedProtocol;
      }
      this.protocolFullCaseMap = null;
      var sha1 = crypto2.createHash("sha1");
      sha1.update(this.key + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11");
      var acceptKey = sha1.digest("base64");
      var response = "HTTP/1.1 101 Switching Protocols\r\nUpgrade: websocket\r\nConnection: Upgrade\r\nSec-WebSocket-Accept: " + acceptKey + "\r\n";
      if (protocolFullCase) {
        for (var i2 = 0; i2 < protocolFullCase.length; i2++) {
          var charCode = protocolFullCase.charCodeAt(i2);
          var character = protocolFullCase.charAt(i2);
          if (charCode < 33 || charCode > 126 || separators.indexOf(character) !== -1) {
            this.reject(500);
            throw new Error('Illegal character "' + String.fromCharCode(character) + '" in subprotocol.');
          }
        }
        if (this.requestedProtocols.indexOf(acceptedProtocol) === -1) {
          this.reject(500);
          throw new Error("Specified protocol was not requested by the client.");
        }
        protocolFullCase = protocolFullCase.replace(headerSanitizeRegExp, "");
        response += "Sec-WebSocket-Protocol: " + protocolFullCase + "\r\n";
      }
      this.requestedProtocols = null;
      if (allowedOrigin) {
        allowedOrigin = allowedOrigin.replace(headerSanitizeRegExp, "");
        if (this.webSocketVersion === 13) {
          response += "Origin: " + allowedOrigin + "\r\n";
        } else if (this.webSocketVersion === 8) {
          response += "Sec-WebSocket-Origin: " + allowedOrigin + "\r\n";
        }
      }
      if (cookies) {
        if (!Array.isArray(cookies)) {
          this.reject(500);
          throw new Error('Value supplied for "cookies" argument must be an array.');
        }
        var seenCookies = {};
        cookies.forEach(function(cookie) {
          if (!cookie.name || !cookie.value) {
            this.reject(500);
            throw new Error('Each cookie to set must at least provide a "name" and "value"');
          }
          cookie.name = cookie.name.replace(controlCharsAndSemicolonRegEx, "");
          cookie.value = cookie.value.replace(controlCharsAndSemicolonRegEx, "");
          if (seenCookies[cookie.name]) {
            this.reject(500);
            throw new Error("You may not specify the same cookie name twice.");
          }
          seenCookies[cookie.name] = true;
          var invalidChar = cookie.name.match(cookieNameValidateRegEx);
          if (invalidChar) {
            this.reject(500);
            throw new Error("Illegal character " + invalidChar[0] + " in cookie name");
          }
          if (cookie.value.match(cookieValueDQuoteValidateRegEx)) {
            invalidChar = cookie.value.slice(1, -1).match(cookieValueValidateRegEx);
          } else {
            invalidChar = cookie.value.match(cookieValueValidateRegEx);
          }
          if (invalidChar) {
            this.reject(500);
            throw new Error("Illegal character " + invalidChar[0] + " in cookie value");
          }
          var cookieParts = [cookie.name + "=" + cookie.value];
          if (cookie.path) {
            invalidChar = cookie.path.match(controlCharsAndSemicolonRegEx);
            if (invalidChar) {
              this.reject(500);
              throw new Error("Illegal character " + invalidChar[0] + " in cookie path");
            }
            cookieParts.push("Path=" + cookie.path);
          }
          if (cookie.domain) {
            if (typeof cookie.domain !== "string") {
              this.reject(500);
              throw new Error("Domain must be specified and must be a string.");
            }
            invalidChar = cookie.domain.match(controlCharsAndSemicolonRegEx);
            if (invalidChar) {
              this.reject(500);
              throw new Error("Illegal character " + invalidChar[0] + " in cookie domain");
            }
            cookieParts.push("Domain=" + cookie.domain.toLowerCase());
          }
          if (cookie.expires) {
            if (!(cookie.expires instanceof Date)) {
              this.reject(500);
              throw new Error('Value supplied for cookie "expires" must be a vaild date object');
            }
            cookieParts.push("Expires=" + cookie.expires.toGMTString());
          }
          if (cookie.maxage) {
            var maxage = cookie.maxage;
            if (typeof maxage === "string") {
              maxage = parseInt(maxage, 10);
            }
            if (isNaN(maxage) || maxage <= 0) {
              this.reject(500);
              throw new Error('Value supplied for cookie "maxage" must be a non-zero number');
            }
            maxage = Math.round(maxage);
            cookieParts.push("Max-Age=" + maxage.toString(10));
          }
          if (cookie.secure) {
            if (typeof cookie.secure !== "boolean") {
              this.reject(500);
              throw new Error('Value supplied for cookie "secure" must be of type boolean');
            }
            cookieParts.push("Secure");
          }
          if (cookie.httponly) {
            if (typeof cookie.httponly !== "boolean") {
              this.reject(500);
              throw new Error('Value supplied for cookie "httponly" must be of type boolean');
            }
            cookieParts.push("HttpOnly");
          }
          response += "Set-Cookie: " + cookieParts.join(";") + "\r\n";
        }.bind(this));
      }
      this._resolved = true;
      this.emit("requestResolved", this);
      response += "\r\n";
      var connection = new WebSocketConnection(this.socket, [], acceptedProtocol, false, this.serverConfig);
      connection.webSocketVersion = this.webSocketVersion;
      connection.remoteAddress = this.remoteAddress;
      connection.remoteAddresses = this.remoteAddresses;
      var self2 = this;
      if (this._socketIsClosing) {
        cleanupFailedConnection(connection);
      } else {
        this.socket.write(response, "ascii", function(error) {
          if (error) {
            cleanupFailedConnection(connection);
            return;
          }
          self2._removeSocketCloseListeners();
          connection._addSocketEventListeners();
        });
      }
      this.emit("requestAccepted", connection);
      return connection;
    };
    WebSocketRequest.prototype.reject = function(status, reason, extraHeaders) {
      this._verifyResolution();
      this._resolved = true;
      this.emit("requestResolved", this);
      if (typeof status !== "number") {
        status = 403;
      }
      var response = "HTTP/1.1 " + status + " " + httpStatusDescriptions[status] + "\r\nConnection: close\r\n";
      if (reason) {
        reason = reason.replace(headerSanitizeRegExp, "");
        response += "X-WebSocket-Reject-Reason: " + reason + "\r\n";
      }
      if (extraHeaders) {
        for (var key in extraHeaders) {
          var sanitizedValue = extraHeaders[key].toString().replace(headerSanitizeRegExp, "");
          var sanitizedKey = key.replace(headerSanitizeRegExp, "");
          response += sanitizedKey + ": " + sanitizedValue + "\r\n";
        }
      }
      response += "\r\n";
      this.socket.end(response, "ascii");
      this.emit("requestRejected", this);
    };
    WebSocketRequest.prototype._handleSocketCloseBeforeAccept = function() {
      this._socketIsClosing = true;
      this._removeSocketCloseListeners();
    };
    WebSocketRequest.prototype._removeSocketCloseListeners = function() {
      this.socket.removeListener("end", this._socketCloseHandler);
      this.socket.removeListener("close", this._socketCloseHandler);
    };
    WebSocketRequest.prototype._verifyResolution = function() {
      if (this._resolved) {
        throw new Error("WebSocketRequest may only be accepted or rejected one time.");
      }
    };
    function cleanupFailedConnection(connection) {
      process.nextTick(function() {
        connection.drop(1006, "TCP connection lost before handshake completed.", true);
      });
    }
    module2.exports = WebSocketRequest;
  }
});

// ../../node_modules/websocket/lib/WebSocketServer.js
var require_WebSocketServer = __commonJS({
  "../../node_modules/websocket/lib/WebSocketServer.js"(exports2, module2) {
    "use strict";
    var extend = require_utils2().extend;
    var utils = require_utils2();
    var util2 = require("util");
    var debug2 = require_src2()("websocket:server");
    var EventEmitter4 = require("events").EventEmitter;
    var WebSocketRequest = require_WebSocketRequest();
    var WebSocketServer = function WebSocketServer2(config) {
      EventEmitter4.call(this);
      this._handlers = {
        upgrade: this.handleUpgrade.bind(this),
        requestAccepted: this.handleRequestAccepted.bind(this),
        requestResolved: this.handleRequestResolved.bind(this)
      };
      this.connections = [];
      this.pendingRequests = [];
      if (config) {
        this.mount(config);
      }
    };
    util2.inherits(WebSocketServer, EventEmitter4);
    WebSocketServer.prototype.mount = function(config) {
      this.config = {
        // The http server instance to attach to.  Required.
        httpServer: null,
        // 64KiB max frame size.
        maxReceivedFrameSize: 65536,
        // 1MiB max message size, only applicable if
        // assembleFragments is true
        maxReceivedMessageSize: 1048576,
        // Outgoing messages larger than fragmentationThreshold will be
        // split into multiple fragments.
        fragmentOutgoingMessages: true,
        // Outgoing frames are fragmented if they exceed this threshold.
        // Default is 16KiB
        fragmentationThreshold: 16384,
        // If true, the server will automatically send a ping to all
        // clients every 'keepaliveInterval' milliseconds.  The timer is
        // reset on any received data from the client.
        keepalive: true,
        // The interval to send keepalive pings to connected clients if the
        // connection is idle.  Any received data will reset the counter.
        keepaliveInterval: 2e4,
        // If true, the server will consider any connection that has not
        // received any data within the amount of time specified by
        // 'keepaliveGracePeriod' after a keepalive ping has been sent to
        // be dead, and will drop the connection.
        // Ignored if keepalive is false.
        dropConnectionOnKeepaliveTimeout: true,
        // The amount of time to wait after sending a keepalive ping before
        // closing the connection if the connected peer does not respond.
        // Ignored if keepalive is false.
        keepaliveGracePeriod: 1e4,
        // Whether to use native TCP keep-alive instead of WebSockets ping
        // and pong packets.  Native TCP keep-alive sends smaller packets
        // on the wire and so uses bandwidth more efficiently.  This may
        // be more important when talking to mobile devices.
        // If this value is set to true, then these values will be ignored:
        //   keepaliveGracePeriod
        //   dropConnectionOnKeepaliveTimeout
        useNativeKeepalive: false,
        // If true, fragmented messages will be automatically assembled
        // and the full message will be emitted via a 'message' event.
        // If false, each frame will be emitted via a 'frame' event and
        // the application will be responsible for aggregating multiple
        // fragmented frames.  Single-frame messages will emit a 'message'
        // event in addition to the 'frame' event.
        // Most users will want to leave this set to 'true'
        assembleFragments: true,
        // If this is true, websocket connections will be accepted
        // regardless of the path and protocol specified by the client.
        // The protocol accepted will be the first that was requested
        // by the client.  Clients from any origin will be accepted.
        // This should only be used in the simplest of cases.  You should
        // probably leave this set to 'false' and inspect the request
        // object to make sure it's acceptable before accepting it.
        autoAcceptConnections: false,
        // Whether or not the X-Forwarded-For header should be respected.
        // It's important to set this to 'true' when accepting connections
        // from untrusted clients, as a malicious client could spoof its
        // IP address by simply setting this header.  It's meant to be added
        // by a trusted proxy or other intermediary within your own
        // infrastructure.
        // See:  http://en.wikipedia.org/wiki/X-Forwarded-For
        ignoreXForwardedFor: false,
        // If this is true, 'cookie' headers are parsed and exposed as WebSocketRequest.cookies
        parseCookies: true,
        // If this is true, 'sec-websocket-extensions' headers are parsed and exposed as WebSocketRequest.requestedExtensions
        parseExtensions: true,
        // The Nagle Algorithm makes more efficient use of network resources
        // by introducing a small delay before sending small packets so that
        // multiple messages can be batched together before going onto the
        // wire.  This however comes at the cost of latency, so the default
        // is to disable it.  If you don't need low latency and are streaming
        // lots of small messages, you can change this to 'false'
        disableNagleAlgorithm: true,
        // The number of milliseconds to wait after sending a close frame
        // for an acknowledgement to come back before giving up and just
        // closing the socket.
        closeTimeout: 5e3
      };
      extend(this.config, config);
      if (this.config.httpServer) {
        if (!Array.isArray(this.config.httpServer)) {
          this.config.httpServer = [this.config.httpServer];
        }
        var upgradeHandler = this._handlers.upgrade;
        this.config.httpServer.forEach(function(httpServer) {
          httpServer.on("upgrade", upgradeHandler);
        });
      } else {
        throw new Error("You must specify an httpServer on which to mount the WebSocket server.");
      }
    };
    WebSocketServer.prototype.unmount = function() {
      var upgradeHandler = this._handlers.upgrade;
      this.config.httpServer.forEach(function(httpServer) {
        httpServer.removeListener("upgrade", upgradeHandler);
      });
    };
    WebSocketServer.prototype.closeAllConnections = function() {
      this.connections.forEach(function(connection) {
        connection.close();
      });
      this.pendingRequests.forEach(function(request) {
        process.nextTick(function() {
          request.reject(503);
        });
      });
    };
    WebSocketServer.prototype.broadcast = function(data) {
      if (Buffer.isBuffer(data)) {
        this.broadcastBytes(data);
      } else if (typeof data.toString === "function") {
        this.broadcastUTF(data);
      }
    };
    WebSocketServer.prototype.broadcastUTF = function(utfData) {
      this.connections.forEach(function(connection) {
        connection.sendUTF(utfData);
      });
    };
    WebSocketServer.prototype.broadcastBytes = function(binaryData) {
      this.connections.forEach(function(connection) {
        connection.sendBytes(binaryData);
      });
    };
    WebSocketServer.prototype.shutDown = function() {
      this.unmount();
      this.closeAllConnections();
    };
    WebSocketServer.prototype.handleUpgrade = function(request, socket) {
      var self2 = this;
      var wsRequest = new WebSocketRequest(socket, request, this.config);
      try {
        wsRequest.readHandshake();
      } catch (e) {
        wsRequest.reject(
          e.httpCode ? e.httpCode : 400,
          e.message,
          e.headers
        );
        debug2("Invalid handshake: %s", e.message);
        this.emit("upgradeError", e);
        return;
      }
      this.pendingRequests.push(wsRequest);
      wsRequest.once("requestAccepted", this._handlers.requestAccepted);
      wsRequest.once("requestResolved", this._handlers.requestResolved);
      socket.once("close", function() {
        self2._handlers.requestResolved(wsRequest);
      });
      if (!this.config.autoAcceptConnections && utils.eventEmitterListenerCount(this, "request") > 0) {
        this.emit("request", wsRequest);
      } else if (this.config.autoAcceptConnections) {
        wsRequest.accept(wsRequest.requestedProtocols[0], wsRequest.origin);
      } else {
        wsRequest.reject(404, "No handler is configured to accept the connection.");
      }
    };
    WebSocketServer.prototype.handleRequestAccepted = function(connection) {
      var self2 = this;
      connection.once("close", function(closeReason, description) {
        self2.handleConnectionClose(connection, closeReason, description);
      });
      this.connections.push(connection);
      this.emit("connect", connection);
    };
    WebSocketServer.prototype.handleConnectionClose = function(connection, closeReason, description) {
      var index = this.connections.indexOf(connection);
      if (index !== -1) {
        this.connections.splice(index, 1);
      }
      this.emit("close", connection, closeReason, description);
    };
    WebSocketServer.prototype.handleRequestResolved = function(request) {
      var index = this.pendingRequests.indexOf(request);
      if (index !== -1) {
        this.pendingRequests.splice(index, 1);
      }
    };
    module2.exports = WebSocketServer;
  }
});

// ../../node_modules/websocket/lib/WebSocketClient.js
var require_WebSocketClient = __commonJS({
  "../../node_modules/websocket/lib/WebSocketClient.js"(exports2, module2) {
    "use strict";
    var utils = require_utils2();
    var extend = utils.extend;
    var util2 = require("util");
    var EventEmitter4 = require("events").EventEmitter;
    var http = require("http");
    var https = require("https");
    var url = require("url");
    var crypto2 = require("crypto");
    var WebSocketConnection = require_WebSocketConnection();
    var bufferAllocUnsafe = utils.bufferAllocUnsafe;
    var protocolSeparators = [
      "(",
      ")",
      "<",
      ">",
      "@",
      ",",
      ";",
      ":",
      "\\",
      '"',
      "/",
      "[",
      "]",
      "?",
      "=",
      "{",
      "}",
      " ",
      String.fromCharCode(9)
    ];
    var excludedTlsOptions = ["hostname", "port", "method", "path", "headers"];
    function WebSocketClient(config) {
      EventEmitter4.call(this);
      this.config = {
        // 1MiB max frame size.
        maxReceivedFrameSize: 1048576,
        // 8MiB max message size, only applicable if
        // assembleFragments is true
        maxReceivedMessageSize: 8388608,
        // Outgoing messages larger than fragmentationThreshold will be
        // split into multiple fragments.
        fragmentOutgoingMessages: true,
        // Outgoing frames are fragmented if they exceed this threshold.
        // Default is 16KiB
        fragmentationThreshold: 16384,
        // Which version of the protocol to use for this session.  This
        // option will be removed once the protocol is finalized by the IETF
        // It is only available to ease the transition through the
        // intermediate draft protocol versions.
        // At present, it only affects the name of the Origin header.
        webSocketVersion: 13,
        // If true, fragmented messages will be automatically assembled
        // and the full message will be emitted via a 'message' event.
        // If false, each frame will be emitted via a 'frame' event and
        // the application will be responsible for aggregating multiple
        // fragmented frames.  Single-frame messages will emit a 'message'
        // event in addition to the 'frame' event.
        // Most users will want to leave this set to 'true'
        assembleFragments: true,
        // The Nagle Algorithm makes more efficient use of network resources
        // by introducing a small delay before sending small packets so that
        // multiple messages can be batched together before going onto the
        // wire.  This however comes at the cost of latency, so the default
        // is to disable it.  If you don't need low latency and are streaming
        // lots of small messages, you can change this to 'false'
        disableNagleAlgorithm: true,
        // The number of milliseconds to wait after sending a close frame
        // for an acknowledgement to come back before giving up and just
        // closing the socket.
        closeTimeout: 5e3,
        // Options to pass to https.connect if connecting via TLS
        tlsOptions: {}
      };
      if (config) {
        var tlsOptions;
        if (config.tlsOptions) {
          tlsOptions = config.tlsOptions;
          delete config.tlsOptions;
        } else {
          tlsOptions = {};
        }
        extend(this.config, config);
        extend(this.config.tlsOptions, tlsOptions);
      }
      this._req = null;
      switch (this.config.webSocketVersion) {
        case 8:
        case 13:
          break;
        default:
          throw new Error("Requested webSocketVersion is not supported. Allowed values are 8 and 13.");
      }
    }
    util2.inherits(WebSocketClient, EventEmitter4);
    WebSocketClient.prototype.connect = function(requestUrl, protocols, origin, headers, extraRequestOptions) {
      var self2 = this;
      if (typeof protocols === "string") {
        if (protocols.length > 0) {
          protocols = [protocols];
        } else {
          protocols = [];
        }
      }
      if (!(protocols instanceof Array)) {
        protocols = [];
      }
      this.protocols = protocols;
      this.origin = origin;
      if (typeof requestUrl === "string") {
        this.url = url.parse(requestUrl);
      } else {
        this.url = requestUrl;
      }
      if (!this.url.protocol) {
        throw new Error("You must specify a full WebSocket URL, including protocol.");
      }
      if (!this.url.host) {
        throw new Error("You must specify a full WebSocket URL, including hostname. Relative URLs are not supported.");
      }
      this.secure = this.url.protocol === "wss:";
      this.protocols.forEach(function(protocol) {
        for (var i2 = 0; i2 < protocol.length; i2++) {
          var charCode = protocol.charCodeAt(i2);
          var character = protocol.charAt(i2);
          if (charCode < 33 || charCode > 126 || protocolSeparators.indexOf(character) !== -1) {
            throw new Error('Protocol list contains invalid character "' + String.fromCharCode(charCode) + '"');
          }
        }
      });
      var defaultPorts = {
        "ws:": "80",
        "wss:": "443"
      };
      if (!this.url.port) {
        this.url.port = defaultPorts[this.url.protocol];
      }
      var nonce = bufferAllocUnsafe(16);
      for (var i = 0; i < 16; i++) {
        nonce[i] = Math.round(Math.random() * 255);
      }
      this.base64nonce = nonce.toString("base64");
      var hostHeaderValue = this.url.hostname;
      if (this.url.protocol === "ws:" && this.url.port !== "80" || this.url.protocol === "wss:" && this.url.port !== "443") {
        hostHeaderValue += ":" + this.url.port;
      }
      var reqHeaders = {};
      if (this.secure && this.config.tlsOptions.hasOwnProperty("headers")) {
        extend(reqHeaders, this.config.tlsOptions.headers);
      }
      if (headers) {
        extend(reqHeaders, headers);
      }
      extend(reqHeaders, {
        "Upgrade": "websocket",
        "Connection": "Upgrade",
        "Sec-WebSocket-Version": this.config.webSocketVersion.toString(10),
        "Sec-WebSocket-Key": this.base64nonce,
        "Host": reqHeaders.Host || hostHeaderValue
      });
      if (this.protocols.length > 0) {
        reqHeaders["Sec-WebSocket-Protocol"] = this.protocols.join(", ");
      }
      if (this.origin) {
        if (this.config.webSocketVersion === 13) {
          reqHeaders["Origin"] = this.origin;
        } else if (this.config.webSocketVersion === 8) {
          reqHeaders["Sec-WebSocket-Origin"] = this.origin;
        }
      }
      var pathAndQuery;
      if (this.url.pathname) {
        pathAndQuery = this.url.path;
      } else if (this.url.path) {
        pathAndQuery = "/" + this.url.path;
      } else {
        pathAndQuery = "/";
      }
      function handleRequestError(error) {
        self2._req = null;
        self2.emit("connectFailed", error);
      }
      var requestOptions = {
        agent: false
      };
      if (extraRequestOptions) {
        extend(requestOptions, extraRequestOptions);
      }
      extend(requestOptions, {
        hostname: this.url.hostname,
        port: this.url.port,
        method: "GET",
        path: pathAndQuery,
        headers: reqHeaders
      });
      if (this.secure) {
        var tlsOptions = this.config.tlsOptions;
        for (var key in tlsOptions) {
          if (tlsOptions.hasOwnProperty(key) && excludedTlsOptions.indexOf(key) === -1) {
            requestOptions[key] = tlsOptions[key];
          }
        }
      }
      var req = this._req = (this.secure ? https : http).request(requestOptions);
      req.on("upgrade", function handleRequestUpgrade(response, socket, head) {
        self2._req = null;
        req.removeListener("error", handleRequestError);
        self2.socket = socket;
        self2.response = response;
        self2.firstDataChunk = head;
        self2.validateHandshake();
      });
      req.on("error", handleRequestError);
      req.on("response", function(response) {
        self2._req = null;
        if (utils.eventEmitterListenerCount(self2, "httpResponse") > 0) {
          self2.emit("httpResponse", response, self2);
          if (response.socket) {
            response.socket.end();
          }
        } else {
          var headerDumpParts = [];
          for (var headerName in response.headers) {
            headerDumpParts.push(headerName + ": " + response.headers[headerName]);
          }
          self2.failHandshake(
            "Server responded with a non-101 status: " + response.statusCode + " " + response.statusMessage + "\nResponse Headers Follow:\n" + headerDumpParts.join("\n") + "\n"
          );
        }
      });
      req.end();
    };
    WebSocketClient.prototype.validateHandshake = function() {
      var headers = this.response.headers;
      if (this.protocols.length > 0) {
        this.protocol = headers["sec-websocket-protocol"];
        if (this.protocol) {
          if (this.protocols.indexOf(this.protocol) === -1) {
            this.failHandshake("Server did not respond with a requested protocol.");
            return;
          }
        } else {
          this.failHandshake("Expected a Sec-WebSocket-Protocol header.");
          return;
        }
      }
      if (!(headers["connection"] && headers["connection"].toLocaleLowerCase() === "upgrade")) {
        this.failHandshake("Expected a Connection: Upgrade header from the server");
        return;
      }
      if (!(headers["upgrade"] && headers["upgrade"].toLocaleLowerCase() === "websocket")) {
        this.failHandshake("Expected an Upgrade: websocket header from the server");
        return;
      }
      var sha1 = crypto2.createHash("sha1");
      sha1.update(this.base64nonce + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11");
      var expectedKey = sha1.digest("base64");
      if (!headers["sec-websocket-accept"]) {
        this.failHandshake("Expected Sec-WebSocket-Accept header from server");
        return;
      }
      if (headers["sec-websocket-accept"] !== expectedKey) {
        this.failHandshake("Sec-WebSocket-Accept header from server didn't match expected value of " + expectedKey);
        return;
      }
      this.succeedHandshake();
    };
    WebSocketClient.prototype.failHandshake = function(errorDescription) {
      if (this.socket && this.socket.writable) {
        this.socket.end();
      }
      this.emit("connectFailed", new Error(errorDescription));
    };
    WebSocketClient.prototype.succeedHandshake = function() {
      var connection = new WebSocketConnection(this.socket, [], this.protocol, true, this.config);
      connection.webSocketVersion = this.config.webSocketVersion;
      connection._addSocketEventListeners();
      this.emit("connect", connection);
      if (this.firstDataChunk.length > 0) {
        connection.handleSocketData(this.firstDataChunk);
      }
      this.firstDataChunk = null;
    };
    WebSocketClient.prototype.abort = function() {
      if (this._req) {
        this._req.abort();
      }
    };
    module2.exports = WebSocketClient;
  }
});

// ../../node_modules/websocket/lib/WebSocketRouterRequest.js
var require_WebSocketRouterRequest = __commonJS({
  "../../node_modules/websocket/lib/WebSocketRouterRequest.js"(exports2, module2) {
    "use strict";
    var util2 = require("util");
    var EventEmitter4 = require("events").EventEmitter;
    function WebSocketRouterRequest(webSocketRequest, resolvedProtocol) {
      EventEmitter4.call(this);
      this.webSocketRequest = webSocketRequest;
      if (resolvedProtocol === "____no_protocol____") {
        this.protocol = null;
      } else {
        this.protocol = resolvedProtocol;
      }
      this.origin = webSocketRequest.origin;
      this.resource = webSocketRequest.resource;
      this.resourceURL = webSocketRequest.resourceURL;
      this.httpRequest = webSocketRequest.httpRequest;
      this.remoteAddress = webSocketRequest.remoteAddress;
      this.webSocketVersion = webSocketRequest.webSocketVersion;
      this.requestedExtensions = webSocketRequest.requestedExtensions;
      this.cookies = webSocketRequest.cookies;
    }
    util2.inherits(WebSocketRouterRequest, EventEmitter4);
    WebSocketRouterRequest.prototype.accept = function(origin, cookies) {
      var connection = this.webSocketRequest.accept(this.protocol, origin, cookies);
      this.emit("requestAccepted", connection);
      return connection;
    };
    WebSocketRouterRequest.prototype.reject = function(status, reason, extraHeaders) {
      this.webSocketRequest.reject(status, reason, extraHeaders);
      this.emit("requestRejected", this);
    };
    module2.exports = WebSocketRouterRequest;
  }
});

// ../../node_modules/websocket/lib/WebSocketRouter.js
var require_WebSocketRouter = __commonJS({
  "../../node_modules/websocket/lib/WebSocketRouter.js"(exports2, module2) {
    "use strict";
    var extend = require_utils2().extend;
    var util2 = require("util");
    var EventEmitter4 = require("events").EventEmitter;
    var WebSocketRouterRequest = require_WebSocketRouterRequest();
    function WebSocketRouter(config) {
      EventEmitter4.call(this);
      this.config = {
        // The WebSocketServer instance to attach to.
        server: null
      };
      if (config) {
        extend(this.config, config);
      }
      this.handlers = [];
      this._requestHandler = this.handleRequest.bind(this);
      if (this.config.server) {
        this.attachServer(this.config.server);
      }
    }
    util2.inherits(WebSocketRouter, EventEmitter4);
    WebSocketRouter.prototype.attachServer = function(server) {
      if (server) {
        this.server = server;
        this.server.on("request", this._requestHandler);
      } else {
        throw new Error("You must specify a WebSocketServer instance to attach to.");
      }
    };
    WebSocketRouter.prototype.detachServer = function() {
      if (this.server) {
        this.server.removeListener("request", this._requestHandler);
        this.server = null;
      } else {
        throw new Error("Cannot detach from server: not attached.");
      }
    };
    WebSocketRouter.prototype.mount = function(path11, protocol, callback2) {
      if (!path11) {
        throw new Error("You must specify a path for this handler.");
      }
      if (!protocol) {
        protocol = "____no_protocol____";
      }
      if (!callback2) {
        throw new Error("You must specify a callback for this handler.");
      }
      path11 = this.pathToRegExp(path11);
      if (!(path11 instanceof RegExp)) {
        throw new Error("Path must be specified as either a string or a RegExp.");
      }
      var pathString = path11.toString();
      protocol = protocol.toLocaleLowerCase();
      if (this.findHandlerIndex(pathString, protocol) !== -1) {
        throw new Error("You may only mount one handler per path/protocol combination.");
      }
      this.handlers.push({
        "path": path11,
        "pathString": pathString,
        "protocol": protocol,
        "callback": callback2
      });
    };
    WebSocketRouter.prototype.unmount = function(path11, protocol) {
      var index = this.findHandlerIndex(this.pathToRegExp(path11).toString(), protocol);
      if (index !== -1) {
        this.handlers.splice(index, 1);
      } else {
        throw new Error("Unable to find a route matching the specified path and protocol.");
      }
    };
    WebSocketRouter.prototype.findHandlerIndex = function(pathString, protocol) {
      protocol = protocol.toLocaleLowerCase();
      for (var i = 0, len = this.handlers.length; i < len; i++) {
        var handler = this.handlers[i];
        if (handler.pathString === pathString && handler.protocol === protocol) {
          return i;
        }
      }
      return -1;
    };
    WebSocketRouter.prototype.pathToRegExp = function(path11) {
      if (typeof path11 === "string") {
        if (path11 === "*") {
          path11 = /^.*$/;
        } else {
          path11 = path11.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
          path11 = new RegExp("^" + path11 + "$");
        }
      }
      return path11;
    };
    WebSocketRouter.prototype.handleRequest = function(request) {
      var requestedProtocols = request.requestedProtocols;
      if (requestedProtocols.length === 0) {
        requestedProtocols = ["____no_protocol____"];
      }
      for (var i = 0; i < requestedProtocols.length; i++) {
        var requestedProtocol = requestedProtocols[i].toLocaleLowerCase();
        for (var j = 0, len = this.handlers.length; j < len; j++) {
          var handler = this.handlers[j];
          if (handler.path.test(request.resourceURL.pathname)) {
            if (requestedProtocol === handler.protocol || handler.protocol === "*") {
              var routerRequest = new WebSocketRouterRequest(request, requestedProtocol);
              handler.callback(routerRequest);
              return;
            }
          }
        }
      }
      request.reject(404, "No handler is available for the given request.");
    };
    module2.exports = WebSocketRouter;
  }
});

// ../../node_modules/is-typedarray/index.js
var require_is_typedarray = __commonJS({
  "../../node_modules/is-typedarray/index.js"(exports2, module2) {
    "use strict";
    module2.exports = isTypedArray;
    isTypedArray.strict = isStrictTypedArray;
    isTypedArray.loose = isLooseTypedArray;
    var toString = Object.prototype.toString;
    var names = {
      "[object Int8Array]": true,
      "[object Int16Array]": true,
      "[object Int32Array]": true,
      "[object Uint8Array]": true,
      "[object Uint8ClampedArray]": true,
      "[object Uint16Array]": true,
      "[object Uint32Array]": true,
      "[object Float32Array]": true,
      "[object Float64Array]": true
    };
    function isTypedArray(arr) {
      return isStrictTypedArray(arr) || isLooseTypedArray(arr);
    }
    function isStrictTypedArray(arr) {
      return arr instanceof Int8Array || arr instanceof Int16Array || arr instanceof Int32Array || arr instanceof Uint8Array || arr instanceof Uint8ClampedArray || arr instanceof Uint16Array || arr instanceof Uint32Array || arr instanceof Float32Array || arr instanceof Float64Array;
    }
    function isLooseTypedArray(arr) {
      return names[toString.call(arr)];
    }
  }
});

// ../../node_modules/typedarray-to-buffer/index.js
var require_typedarray_to_buffer = __commonJS({
  "../../node_modules/typedarray-to-buffer/index.js"(exports2, module2) {
    "use strict";
    var isTypedArray = require_is_typedarray().strict;
    module2.exports = function typedarrayToBuffer(arr) {
      if (isTypedArray(arr)) {
        var buf = Buffer.from(arr.buffer);
        if (arr.byteLength !== arr.buffer.byteLength) {
          buf = buf.slice(arr.byteOffset, arr.byteOffset + arr.byteLength);
        }
        return buf;
      } else {
        return Buffer.from(arr);
      }
    };
  }
});

// ../../node_modules/yaeti/lib/EventTarget.js
var require_EventTarget = __commonJS({
  "../../node_modules/yaeti/lib/EventTarget.js"(exports2, module2) {
    "use strict";
    module2.exports = _EventTarget;
    function _EventTarget() {
      if (typeof this.addEventListener === "function") {
        return;
      }
      this._listeners = {};
      this.addEventListener = _addEventListener;
      this.removeEventListener = _removeEventListener;
      this.dispatchEvent = _dispatchEvent;
    }
    Object.defineProperties(_EventTarget.prototype, {
      listeners: {
        get: function() {
          return this._listeners;
        }
      }
    });
    function _addEventListener(type, newListener) {
      var listenersType, i, listener;
      if (!type || !newListener) {
        return;
      }
      listenersType = this._listeners[type];
      if (listenersType === void 0) {
        this._listeners[type] = listenersType = [];
      }
      for (i = 0; !!(listener = listenersType[i]); i++) {
        if (listener === newListener) {
          return;
        }
      }
      listenersType.push(newListener);
    }
    function _removeEventListener(type, oldListener) {
      var listenersType, i, listener;
      if (!type || !oldListener) {
        return;
      }
      listenersType = this._listeners[type];
      if (listenersType === void 0) {
        return;
      }
      for (i = 0; !!(listener = listenersType[i]); i++) {
        if (listener === oldListener) {
          listenersType.splice(i, 1);
          break;
        }
      }
      if (listenersType.length === 0) {
        delete this._listeners[type];
      }
    }
    function _dispatchEvent(event) {
      var type, listenersType, dummyListener, stopImmediatePropagation = false, i, listener;
      if (!event || typeof event.type !== "string") {
        throw new Error("`event` must have a valid `type` property");
      }
      if (event._yaeti) {
        event.target = this;
        event.cancelable = true;
      }
      try {
        event.stopImmediatePropagation = function() {
          stopImmediatePropagation = true;
        };
      } catch (error) {
      }
      type = event.type;
      listenersType = this._listeners[type] || [];
      dummyListener = this["on" + type];
      if (typeof dummyListener === "function") {
        dummyListener.call(this, event);
      }
      for (i = 0; !!(listener = listenersType[i]); i++) {
        if (stopImmediatePropagation) {
          break;
        }
        listener.call(this, event);
      }
      return !event.defaultPrevented;
    }
  }
});

// ../../node_modules/yaeti/lib/Event.js
var require_Event = __commonJS({
  "../../node_modules/yaeti/lib/Event.js"(exports2, module2) {
    "use strict";
    module2.exports = _Event;
    function _Event(type) {
      this.type = type;
      this.isTrusted = false;
      this._yaeti = true;
    }
  }
});

// ../../node_modules/yaeti/index.js
var require_yaeti = __commonJS({
  "../../node_modules/yaeti/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      EventTarget: require_EventTarget(),
      Event: require_Event()
    };
  }
});

// ../../node_modules/websocket/lib/W3CWebSocket.js
var require_W3CWebSocket = __commonJS({
  "../../node_modules/websocket/lib/W3CWebSocket.js"(exports2, module2) {
    "use strict";
    var WebSocketClient = require_WebSocketClient();
    var toBuffer = require_typedarray_to_buffer();
    var yaeti = require_yaeti();
    var CONNECTING = 0;
    var OPEN = 1;
    var CLOSING = 2;
    var CLOSED = 3;
    module2.exports = W3CWebSocket;
    function W3CWebSocket(url, protocols, origin, headers, requestOptions, clientConfig) {
      yaeti.EventTarget.call(this);
      clientConfig = clientConfig || {};
      clientConfig.assembleFragments = true;
      var self2 = this;
      this._url = url;
      this._readyState = CONNECTING;
      this._protocol = void 0;
      this._extensions = "";
      this._bufferedAmount = 0;
      this._binaryType = "arraybuffer";
      this._connection = void 0;
      this._client = new WebSocketClient(clientConfig);
      this._client.on("connect", function(connection) {
        onConnect.call(self2, connection);
      });
      this._client.on("connectFailed", function() {
        onConnectFailed.call(self2);
      });
      this._client.connect(url, protocols, origin, headers, requestOptions);
    }
    Object.defineProperties(W3CWebSocket.prototype, {
      url: { get: function() {
        return this._url;
      } },
      readyState: { get: function() {
        return this._readyState;
      } },
      protocol: { get: function() {
        return this._protocol;
      } },
      extensions: { get: function() {
        return this._extensions;
      } },
      bufferedAmount: { get: function() {
        return this._bufferedAmount;
      } }
    });
    Object.defineProperties(W3CWebSocket.prototype, {
      binaryType: {
        get: function() {
          return this._binaryType;
        },
        set: function(type) {
          if (type !== "arraybuffer") {
            throw new SyntaxError('just "arraybuffer" type allowed for "binaryType" attribute');
          }
          this._binaryType = type;
        }
      }
    });
    [["CONNECTING", CONNECTING], ["OPEN", OPEN], ["CLOSING", CLOSING], ["CLOSED", CLOSED]].forEach(function(property) {
      Object.defineProperty(W3CWebSocket.prototype, property[0], {
        get: function() {
          return property[1];
        }
      });
    });
    [["CONNECTING", CONNECTING], ["OPEN", OPEN], ["CLOSING", CLOSING], ["CLOSED", CLOSED]].forEach(function(property) {
      Object.defineProperty(W3CWebSocket, property[0], {
        get: function() {
          return property[1];
        }
      });
    });
    W3CWebSocket.prototype.send = function(data) {
      if (this._readyState !== OPEN) {
        throw new Error("cannot call send() while not connected");
      }
      if (typeof data === "string" || data instanceof String) {
        this._connection.sendUTF(data);
      } else {
        if (data instanceof Buffer) {
          this._connection.sendBytes(data);
        } else if (data.byteLength || data.byteLength === 0) {
          data = toBuffer(data);
          this._connection.sendBytes(data);
        } else {
          throw new Error("unknown binary data:", data);
        }
      }
    };
    W3CWebSocket.prototype.close = function(code, reason) {
      switch (this._readyState) {
        case CONNECTING:
          onConnectFailed.call(this);
          this._client.on("connect", function(connection) {
            if (code) {
              connection.close(code, reason);
            } else {
              connection.close();
            }
          });
          break;
        case OPEN:
          this._readyState = CLOSING;
          if (code) {
            this._connection.close(code, reason);
          } else {
            this._connection.close();
          }
          break;
        case CLOSING:
        case CLOSED:
          break;
      }
    };
    function createCloseEvent(code, reason) {
      var event = new yaeti.Event("close");
      event.code = code;
      event.reason = reason;
      event.wasClean = typeof code === "undefined" || code === 1e3;
      return event;
    }
    function createMessageEvent(data) {
      var event = new yaeti.Event("message");
      event.data = data;
      return event;
    }
    function onConnect(connection) {
      var self2 = this;
      this._readyState = OPEN;
      this._connection = connection;
      this._protocol = connection.protocol;
      this._extensions = connection.extensions;
      this._connection.on("close", function(code, reason) {
        onClose.call(self2, code, reason);
      });
      this._connection.on("message", function(msg) {
        onMessage.call(self2, msg);
      });
      this.dispatchEvent(new yaeti.Event("open"));
    }
    function onConnectFailed() {
      destroy.call(this);
      this._readyState = CLOSED;
      try {
        this.dispatchEvent(new yaeti.Event("error"));
      } finally {
        this.dispatchEvent(createCloseEvent(1006, "connection failed"));
      }
    }
    function onClose(code, reason) {
      destroy.call(this);
      this._readyState = CLOSED;
      this.dispatchEvent(createCloseEvent(code, reason || ""));
    }
    function onMessage(message) {
      if (message.utf8Data) {
        this.dispatchEvent(createMessageEvent(message.utf8Data));
      } else if (message.binaryData) {
        if (this.binaryType === "arraybuffer") {
          var buffer = message.binaryData;
          var arraybuffer = new ArrayBuffer(buffer.length);
          var view = new Uint8Array(arraybuffer);
          for (var i = 0, len = buffer.length; i < len; ++i) {
            view[i] = buffer[i];
          }
          this.dispatchEvent(createMessageEvent(arraybuffer));
        }
      }
    }
    function destroy() {
      this._client.removeAllListeners();
      if (this._connection) {
        this._connection.removeAllListeners();
      }
    }
  }
});

// ../../node_modules/websocket/lib/Deprecation.js
var require_Deprecation = __commonJS({
  "../../node_modules/websocket/lib/Deprecation.js"(exports2, module2) {
    "use strict";
    var Deprecation = {
      disableWarnings: false,
      deprecationWarningMap: {},
      warn: function(deprecationName) {
        if (!this.disableWarnings && this.deprecationWarningMap[deprecationName]) {
          console.warn("DEPRECATION WARNING: " + this.deprecationWarningMap[deprecationName]);
          this.deprecationWarningMap[deprecationName] = false;
        }
      }
    };
    module2.exports = Deprecation;
  }
});

// ../../node_modules/websocket/package.json
var require_package3 = __commonJS({
  "../../node_modules/websocket/package.json"(exports2, module2) {
    module2.exports = {
      name: "websocket",
      description: "Websocket Client & Server Library implementing the WebSocket protocol as specified in RFC 6455.",
      keywords: [
        "websocket",
        "websockets",
        "socket",
        "networking",
        "comet",
        "push",
        "RFC-6455",
        "realtime",
        "server",
        "client"
      ],
      author: "Brian McKelvey <theturtle32@gmail.com> (https://github.com/theturtle32)",
      contributors: [
        "I\xF1aki Baz Castillo <ibc@aliax.net> (http://dev.sipdoc.net)"
      ],
      version: "1.0.35",
      repository: {
        type: "git",
        url: "https://github.com/theturtle32/WebSocket-Node.git"
      },
      homepage: "https://github.com/theturtle32/WebSocket-Node",
      engines: {
        node: ">=4.0.0"
      },
      dependencies: {
        bufferutil: "^4.0.1",
        debug: "^2.2.0",
        "es5-ext": "^0.10.63",
        "typedarray-to-buffer": "^3.1.5",
        "utf-8-validate": "^5.0.2",
        yaeti: "^0.0.6"
      },
      devDependencies: {
        "buffer-equal": "^1.0.0",
        gulp: "^4.0.2",
        "gulp-jshint": "^2.0.4",
        "jshint-stylish": "^2.2.1",
        jshint: "^2.0.0",
        tape: "^4.9.1"
      },
      config: {
        verbose: false
      },
      scripts: {
        test: "tape test/unit/*.js",
        gulp: "gulp"
      },
      main: "index",
      directories: {
        lib: "./lib"
      },
      browser: "lib/browser.js",
      license: "Apache-2.0"
    };
  }
});

// ../../node_modules/websocket/lib/version.js
var require_version2 = __commonJS({
  "../../node_modules/websocket/lib/version.js"(exports2, module2) {
    "use strict";
    module2.exports = require_package3().version;
  }
});

// ../../node_modules/websocket/lib/websocket.js
var require_websocket = __commonJS({
  "../../node_modules/websocket/lib/websocket.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      "server": require_WebSocketServer(),
      "client": require_WebSocketClient(),
      "router": require_WebSocketRouter(),
      "frame": require_WebSocketFrame(),
      "request": require_WebSocketRequest(),
      "connection": require_WebSocketConnection(),
      "w3cwebsocket": require_W3CWebSocket(),
      "deprecation": require_Deprecation(),
      "version": require_version2()
    };
  }
});

// ../../node_modules/websocket/index.js
var require_websocket2 = __commonJS({
  "../../node_modules/websocket/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_websocket();
  }
});

// ../../node_modules/@microsoft/dev-tunnels-connections/sshHelpers.js
var require_sshHelpers = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-connections/sshHelpers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RelayConnectionError = exports2.RelayErrorType = exports2.isNode = exports2.SshHelpers = exports2.BrowserWebSocketRelayError = void 0;
    var ssh = require_dev_tunnels_ssh();
    var websocket_1 = require_websocket2();
    var BrowserWebSocketRelayError = class extends Error {
      constructor(message) {
        super(message);
      }
    };
    exports2.BrowserWebSocketRelayError = BrowserWebSocketRelayError;
    var SshHelpers = class _SshHelpers {
      /**
       * Open a connection to the relay uri depending on the running environment.
       * @param relayUri
       * @param protocols
       * @param headers
       * @param clientConfig
       * @returns
       */
      static openConnection(relayUri, protocols, headers, clientConfig) {
        if ((0, exports2.isNode)()) {
          return _SshHelpers.nodeSshStreamFactory(relayUri, protocols, headers, clientConfig);
        }
        return _SshHelpers.webSshStreamFactory(new WebSocket(relayUri, protocols));
      }
      /**
       * Creates a client SSH session with standard configuration for tunnels.
       * @param configure Optional callback for additional session configuration.
       * @returns The created SSH session.
       */
      static createSshClientSession(configure) {
        return _SshHelpers.createSshSession((config) => {
          if (configure)
            configure(config);
          return new ssh.SshClientSession(config);
        });
      }
      /**
       * Creates a SSH server session with standard configuration for tunnels.
       * @param reconnectableSessions Optional list that tracks reconnectable sessions.
       * @param configure Optional callback for additional session configuration.
       * @returns The created SSH session.
       */
      static createSshServerSession(reconnectableSessions, configure) {
        return _SshHelpers.createSshSession((config) => {
          if (configure)
            configure(config);
          return new ssh.SshServerSession(config, reconnectableSessions);
        });
      }
      /**
       * Create a websocketStream from a connection.
       * @param connection
       * @returns
       */
      static createWebSocketStreamAdapter(connection) {
        return new ssh.WebSocketStream(new WebsocketStreamAdapter(connection));
      }
      /**
       * Set up a web Ssh stream factory.
       * @param socket
       * @returns
       */
      static webSshStreamFactory(socket) {
        socket.binaryType = "arraybuffer";
        return new Promise((resolve8, reject) => {
          const relayError = "Failed to connect to relay url";
          socket.onopen = () => {
            resolve8(new ssh.WebSocketStream(socket));
          };
          socket.onerror = (e) => {
            setTimeout(() => reject(new BrowserWebSocketRelayError(relayError)), 100);
          };
          socket.onclose = (e) => {
            if (e.code !== 1e3) {
              reject(new BrowserWebSocketRelayError(`${relayError} Code: ${e.code} Reason: ${e.reason}`));
            }
          };
        });
      }
      static createSshSession(factoryCallback) {
        const config = new ssh.SshSessionConfiguration();
        config.keyExchangeAlgorithms.splice(0);
        config.keyExchangeAlgorithms.push(ssh.SshAlgorithms.keyExchange.ecdhNistp384Sha384);
        config.keyExchangeAlgorithms.push(ssh.SshAlgorithms.keyExchange.ecdhNistp256Sha256);
        config.keyExchangeAlgorithms.push(ssh.SshAlgorithms.keyExchange.dhGroup14Sha256);
        return factoryCallback(config);
      }
      static nodeSshStreamFactory(relayUri, protocols, headers, clientConfig) {
        const client = new websocket_1.client(clientConfig);
        return new Promise((resolve8, reject) => {
          client.on("connect", (connection) => {
            resolve8(new ssh.WebSocketStream(new WebsocketStreamAdapter(connection)));
          });
          client.on("httpResponse", ({ statusCode, statusMessage }) => {
            var _a2;
            const errorContext = (_a2 = webSocketClientContexts.find((c) => c.statusCode === statusCode)) !== null && _a2 !== void 0 ? _a2 : {
              statusCode,
              errorType: RelayErrorType.ServerError,
              error: `relayConnectionError Server responded with a non-101 status: ${statusCode} ${statusMessage}`
            };
            reject(new RelayConnectionError(`error.${errorContext.error}`, errorContext));
          });
          client.on("connectFailed", ({ message }) => {
            var _a2;
            if (message && message.startsWith("Error: ")) {
              message = message.substr(7);
            }
            const errorContext = (_a2 = webSocketClientContexts.find((c) => c.regex && c.regex.test(message))) !== null && _a2 !== void 0 ? _a2 : {
              // Other errors are most likely connectivity issues.
              // The original error message may have additional helpful details.
              errorType: RelayErrorType.ServerError,
              error: `relayConnectionError ${message}`
            };
            reject(new RelayConnectionError(`error.${errorContext.error}`, errorContext));
          });
          client.connect(relayUri, protocols, void 0, headers);
        });
      }
    };
    exports2.SshHelpers = SshHelpers;
    var WebsocketStreamAdapter = class {
      constructor(connection) {
        this.connection = connection;
      }
      get protocol() {
        return this.connection.protocol;
      }
      set onmessage(messageHandler) {
        if (messageHandler) {
          this.connection.on("message", (message) => {
            messageHandler({ data: message.binaryData });
          });
        } else {
        }
      }
      set onclose(closeHandler) {
        if (closeHandler) {
          this.connection.on("close", (code, reason) => {
            closeHandler({ code, reason, wasClean: !(code || reason) });
          });
        } else {
        }
      }
      send(data) {
        if (Buffer.isBuffer(data)) {
          this.connection.sendBytes(data);
        } else {
          this.connection.sendBytes(Buffer.from(data));
        }
      }
      close(code, reason) {
        if (code || reason) {
          this.connection.drop(code, reason);
        } else {
          this.connection.close();
        }
      }
    };
    var isNode = () => typeof process !== "undefined" && typeof process.release !== "undefined" && process.release.name === "node";
    exports2.isNode = isNode;
    var RelayErrorType;
    (function(RelayErrorType2) {
      RelayErrorType2[RelayErrorType2["ConnectionError"] = 1] = "ConnectionError";
      RelayErrorType2[RelayErrorType2["Unauthorized"] = 2] = "Unauthorized";
      RelayErrorType2[RelayErrorType2["EndpointNotFound"] = 3] = "EndpointNotFound";
      RelayErrorType2[RelayErrorType2["ListenerOffline"] = 4] = "ListenerOffline";
      RelayErrorType2[RelayErrorType2["ServerError"] = 5] = "ServerError";
      RelayErrorType2[RelayErrorType2["TunnelPortNotFound"] = 6] = "TunnelPortNotFound";
      RelayErrorType2[RelayErrorType2["TooManyRequests"] = 7] = "TooManyRequests";
      RelayErrorType2[RelayErrorType2["ServiceUnavailable"] = 8] = "ServiceUnavailable";
      RelayErrorType2[RelayErrorType2["BadGateway"] = 9] = "BadGateway";
    })(RelayErrorType = exports2.RelayErrorType || (exports2.RelayErrorType = {}));
    var RelayConnectionError = class extends Error {
      constructor(message, errorContext) {
        super(message);
        this.errorContext = errorContext;
      }
    };
    exports2.RelayConnectionError = RelayConnectionError;
    var webSocketClientContexts = [
      {
        regex: /status: 401/,
        statusCode: 401,
        error: "relayClientUnauthorized",
        errorType: RelayErrorType.Unauthorized
      },
      {
        regex: /status: 403/,
        statusCode: 403,
        error: "relayClientForbidden",
        errorType: RelayErrorType.Unauthorized
      },
      {
        regex: /status: 404/,
        statusCode: 404,
        error: "tunnelPortNotFound",
        errorType: RelayErrorType.TunnelPortNotFound
      },
      {
        regex: /status: 429/,
        statusCode: 429,
        error: "tooManyRequests",
        errorType: RelayErrorType.TooManyRequests
      },
      {
        regex: /status: 500/,
        statusCode: 500,
        error: "relayServerError",
        errorType: RelayErrorType.ServerError
      },
      {
        regex: /status: 502/,
        statusCode: 502,
        error: "badGateway",
        errorType: RelayErrorType.BadGateway
      },
      {
        regex: /status: 503/,
        statusCode: 503,
        error: "serviceUnavailable",
        errorType: RelayErrorType.ServiceUnavailable
      }
    ];
  }
});

// ../../node_modules/@microsoft/dev-tunnels-connections/tunnelRelayStreamFactory.js
var require_tunnelRelayStreamFactory = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-connections/tunnelRelayStreamFactory.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/@microsoft/dev-tunnels-connections/defaultTunnelRelayStreamFactory.js
var require_defaultTunnelRelayStreamFactory = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-connections/defaultTunnelRelayStreamFactory.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DefaultTunnelRelayStreamFactory = void 0;
    var sshHelpers_1 = require_sshHelpers();
    var DefaultTunnelRelayStreamFactory = class {
      async createRelayStream(relayUri, protocols, accessToken, clientConfig) {
        if ((0, sshHelpers_1.isNode)()) {
          const stream = await sshHelpers_1.SshHelpers.openConnection(relayUri, protocols, Object.assign({}, accessToken && { Authorization: `tunnel ${accessToken}` }), clientConfig);
          return { stream, protocol: stream.protocol };
        } else {
          if (accessToken) {
            protocols = [...protocols, accessToken];
          }
          const stream = await sshHelpers_1.SshHelpers.openConnection(relayUri, protocols);
          return { stream, protocol: stream.protocol };
        }
      }
    };
    exports2.DefaultTunnelRelayStreamFactory = DefaultTunnelRelayStreamFactory;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh-tcp/sshClient.js
var require_sshClient = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh-tcp/sshClient.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SshClient = void 0;
    var net2 = require("net");
    var dev_tunnels_ssh_1 = require_dev_tunnels_ssh();
    var SshClient = class _SshClient {
      constructor(config) {
        this.config = config;
        this.sessions = [];
        this.trace = (level, eventId, msg, err) => {
        };
        if (!config)
          throw new TypeError("SshSessionConfiguration is required.");
      }
      async openSession(serverHost, serverPort, cancellation) {
        if (!serverHost)
          throw new TypeError("Server host is reqiured.");
        const stream = await this.openConnection(serverHost, serverPort, cancellation);
        const session = new dev_tunnels_ssh_1.SshClientSession(this.config);
        session.trace = this.trace;
        await session.connect(stream, cancellation);
        this.sessions.push(session);
        return session;
      }
      async openConnection(serverHost, serverPort, cancellation) {
        const socket = new net2.Socket();
        await new Promise((resolve8, reject) => {
          socket.on("connect", resolve8);
          socket.on("error", reject);
          if (cancellation) {
            if (cancellation.isCancellationRequested) {
              reject(new dev_tunnels_ssh_1.CancellationError());
              return;
            }
            cancellation.onCancellationRequested(reject);
          }
          socket.connect(serverPort || _SshClient.defaultServerPort, serverHost);
        });
        return new dev_tunnels_ssh_1.NodeStream(socket);
      }
      async reconnectSession(session, serverHost, serverPort, cancellation) {
        const stream = await this.openConnection(serverHost, serverPort, cancellation);
        await session.reconnect(stream, cancellation);
      }
      dispose() {
        while (this.sessions.length > 0) {
          const session = this.sessions.shift();
          session.dispose();
        }
      }
    };
    exports2.SshClient = SshClient;
    SshClient.defaultServerPort = 22;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh-tcp/tcpListenerFactory.js
var require_tcpListenerFactory = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh-tcp/tcpListenerFactory.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DefaultTcpListenerFactory = void 0;
    var net2 = require("net");
    var DefaultTcpListenerFactory = class {
      async createTcpListener(remotePort, localIPAddress, localPort, canChangeLocalPort, cancellation) {
        if (!localIPAddress)
          throw new TypeError("Local IP address is required.");
        if (!Number.isInteger(localPort) || localPort < 0)
          throw new TypeError("Local port must be a non-negative integer.");
        const listener = net2.createServer();
        await new Promise((resolve8, reject) => {
          listener.listen({
            host: localIPAddress,
            port: localPort,
            ipv6Only: net2.isIPv6(localIPAddress),
            exclusive: false
          });
          listener.on("listening", resolve8);
          listener.on("error", reject);
        });
        return listener;
      }
    };
    exports2.DefaultTcpListenerFactory = DefaultTcpListenerFactory;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh-tcp/sshServer.js
var require_sshServer = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh-tcp/sshServer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SshServer = void 0;
    var vscode_jsonrpc_1 = require_main();
    var dev_tunnels_ssh_1 = require_dev_tunnels_ssh();
    var tcpListenerFactory_1 = require_tcpListenerFactory();
    var SshServer = class {
      constructor(config) {
        this.config = config;
        this.sessions = [];
        this.trace = (level, eventId, msg, err) => {
        };
        this.errorEmitter = new vscode_jsonrpc_1.Emitter();
        this.onError = this.errorEmitter.event;
        this.sessionOpenedEmitter = new vscode_jsonrpc_1.Emitter();
        this.onSessionOpened = this.sessionOpenedEmitter.event;
        this.credentials = { publicKeys: [] };
        this.tcpListenerFactory = new tcpListenerFactory_1.DefaultTcpListenerFactory();
        if (!config)
          throw new TypeError("SshSessionConfiguration is required.");
        if (config.protocolExtensions.includes(dev_tunnels_ssh_1.SshProtocolExtensionNames.sessionReconnect)) {
          this.reconnectableSessions = [];
        }
      }
      async acceptSessions(localPort, localAddress) {
        if (!localAddress) {
          localAddress = "0.0.0.0";
        }
        const portPrefix = localAddress === "0.0.0.0" ? "port " : localAddress + ":";
        try {
          this.tcpListener = await this.tcpListenerFactory.createTcpListener(
            void 0,
            // remotePort
            localAddress,
            localPort,
            false
          );
        } catch (e) {
          if (!(e instanceof Error))
            throw e;
          this.trace(dev_tunnels_ssh_1.TraceLevel.Error, dev_tunnels_ssh_1.SshTraceEventIds.serverListenFailed, `SshServer failed to listen on ${portPrefix}${localPort}: ${e.message}`, e);
          throw e;
        }
        this.tcpListener.addListener("connection", this.acceptSession.bind(this));
        this.trace(dev_tunnels_ssh_1.TraceLevel.Info, dev_tunnels_ssh_1.SshTraceEventIds.serverListening, `SshServer listening on ${portPrefix}${localPort}.`);
      }
      async acceptConnection(socket) {
        socket.setNoDelay(true);
        return new dev_tunnels_ssh_1.NodeStream(socket);
      }
      async acceptSession(socket) {
        this.trace(dev_tunnels_ssh_1.TraceLevel.Info, dev_tunnels_ssh_1.SshTraceEventIds.serverClientConnected, "SshServer client connected.");
        const stream = await this.acceptConnection(socket);
        const session = new dev_tunnels_ssh_1.SshServerSession(this.config, this.reconnectableSessions);
        session.trace = this.trace;
        session.credentials = this.credentials;
        this.sessions.push(session);
        session.onClosed((e) => {
          const sessionIndex = this.sessions.indexOf(session);
          if (sessionIndex >= 0) {
            this.sessions.splice(sessionIndex, 1);
          }
        });
        this.sessionOpenedEmitter.fire(session);
        try {
          await session.connect(stream);
        } catch (e) {
          if (!(e instanceof Error))
            throw e;
          if (e instanceof dev_tunnels_ssh_1.SshConnectionError) {
            await session.close(e.reason || dev_tunnels_ssh_1.SshDisconnectReason.connectionLost, e.message, e);
          } else {
            await session.close(dev_tunnels_ssh_1.SshDisconnectReason.protocolError, e.message, e);
          }
          this.errorEmitter.fire(e);
        }
      }
      dispose() {
        var _a2;
        (_a2 = this.tcpListener) === null || _a2 === void 0 ? void 0 : _a2.close();
      }
    };
    exports2.SshServer = SshServer;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh-tcp/events/forwardedPort.js
var require_forwardedPort = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh-tcp/events/forwardedPort.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ForwardedPort = void 0;
    var ForwardedPort = class {
      /** @internal */
      constructor(localPort, remotePort, isRemote) {
        if (localPort === null && remotePort === null) {
          throw new TypeError("Local and remote ports cannot both be null.");
        } else if (!isRemote && remotePort === null) {
          throw new TypeError("The report port number must not be null for locally forwarded ports.");
        }
        if (localPort !== null && (typeof localPort !== "number" || localPort <= 0)) {
          throw new TypeError("Local port must be a positive integer.");
        } else if (remotePort !== null && (typeof remotePort !== "number" || remotePort <= 0)) {
          throw new TypeError("Remote port must be a positive integer: " + remotePort);
        }
        this.localPort = localPort;
        this.remotePort = remotePort;
        const arrow = isRemote ? "->" : "<-";
        if (this.localPort === null) {
          this.str = `${arrow}${this.remotePort}`;
        } else if (this.remotePort == null) {
          this.str = `${this.localPort}${arrow}`;
        } else {
          this.str = `${this.localPort}${arrow}${this.remotePort}`;
        }
      }
      /**
       * Gets a string representation of the forwarded port, which includes both
       * local and remote port numbers if present.
       *
       * An arrow shows the direction of connections (channel open requests).
       * Once connections are opened, data may flow in both directions.
       */
      toString() {
        return this.str;
      }
    };
    exports2.ForwardedPort = ForwardedPort;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh-tcp/events/forwardedPortEventArgs.js
var require_forwardedPortEventArgs = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh-tcp/events/forwardedPortEventArgs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ForwardedPortConnectingEventArgs = exports2.ForwardedPortChannelEventArgs = exports2.ForwardedPortEventArgs = void 0;
    var ForwardedPortEventArgs = class {
      constructor(port) {
        this.port = port;
      }
      toString() {
        return this.port.toString();
      }
    };
    exports2.ForwardedPortEventArgs = ForwardedPortEventArgs;
    var ForwardedPortChannelEventArgs = class extends ForwardedPortEventArgs {
      constructor(port, channel) {
        super(port);
        this.port = port;
        this.channel = channel;
      }
      toString() {
        return `${this.port} ${this.channel}`;
      }
    };
    exports2.ForwardedPortChannelEventArgs = ForwardedPortChannelEventArgs;
    var ForwardedPortConnectingEventArgs = class {
      constructor(port, isIncoming, stream, cancellation) {
        this.port = port;
        this.isIncoming = isIncoming;
        this.stream = stream;
        this.cancellation = cancellation;
      }
      toString() {
        return `${this.port} isIncoming=${this.isIncoming}`;
      }
    };
    exports2.ForwardedPortConnectingEventArgs = ForwardedPortConnectingEventArgs;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh-tcp/events/forwardedPortsCollection.js
var require_forwardedPortsCollection = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh-tcp/events/forwardedPortsCollection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ForwardedPortsCollection = void 0;
    var vscode_jsonrpc_1 = require_main();
    var forwardedPortEventArgs_1 = require_forwardedPortEventArgs();
    var ForwardedPortsCollection = class {
      constructor() {
        this.portChannelMap = /* @__PURE__ */ new Map();
        this.portAddedEmitter = new vscode_jsonrpc_1.Emitter();
        this.onPortAdded = this.portAddedEmitter.event;
        this.portUpdatedEmitter = new vscode_jsonrpc_1.Emitter();
        this.onPortUpdated = this.portUpdatedEmitter.event;
        this.portRemovedEmitter = new vscode_jsonrpc_1.Emitter();
        this.onPortRemoved = this.portRemovedEmitter.event;
        this.portChannelAddedEmitter = new vscode_jsonrpc_1.Emitter();
        this.onPortChannelAdded = this.portChannelAddedEmitter.event;
        this.portChannelRemovedEmitter = new vscode_jsonrpc_1.Emitter();
        this.onPortChannelRemoved = this.portChannelRemovedEmitter.event;
      }
      /** Gets the number of ports in the collection. */
      get size() {
        return this.portChannelMap.size;
      }
      /** Checks whether a port is in the collection. */
      has(port) {
        return this.portChannelMap.has(port.toString());
      }
      /** Lists all the ports in the collection. */
      *values() {
        for (const [port, channels] of this.portChannelMap.values()) {
          yield port;
        }
      }
      /** Iterates over all the ports in the collection. */
      [Symbol.iterator]() {
        return this.values();
      }
      /** Lists all the ports in the collection. */
      *entries() {
        for (const [port, channels] of this.portChannelMap.values()) {
          yield [port, port];
        }
      }
      /**
       * Lists all the ports in the collection.
       * (In a set, the keys are the same as the values.)
       */
      keys() {
        return this.values();
      }
      /** Iterates over all the ports in the collection, invoking a callback function on each. */
      forEach(callbackfn, thisArg) {
        for (const [port, channels] of this.portChannelMap.values()) {
          callbackfn.apply(thisArg, [port, port, this]);
        }
      }
      getChannels(port) {
        const portAndChannels = this.portChannelMap.get(port.toString());
        if (!portAndChannels) {
          throw new Error(`Port ${port} is not in the collection.`);
        }
        return portAndChannels[1];
      }
      /** Finds the first port in the collection that matches a predicate. */
      find(predicate) {
        for (const port of this.values()) {
          if (predicate(port)) {
            return port;
          }
        }
        return void 0;
      }
      /* @internal */
      addOrUpdatePort(port) {
        if (this.has(port)) {
          this.portUpdatedEmitter.fire(new forwardedPortEventArgs_1.ForwardedPortEventArgs(port));
        }
        this.portChannelMap.set(port.toString(), [port, []]);
        this.portAddedEmitter.fire(new forwardedPortEventArgs_1.ForwardedPortEventArgs(port));
      }
      /* @internal */
      removePort(port) {
        if (!this.has(port)) {
          return false;
        }
        this.portChannelMap.delete(port.toString());
        this.portRemovedEmitter.fire(new forwardedPortEventArgs_1.ForwardedPortEventArgs(port));
        return true;
      }
      /* @internal */
      addChannel(port, channel) {
        const portAndChannels = this.portChannelMap.get(port.toString());
        if (!portAndChannels) {
          throw new Error(`Port ${port} is not in the collection.`);
        }
        const portChannels = portAndChannels[1];
        if (portChannels.find((c) => c.channelId === channel.channelId)) {
          throw new Error(`Channel ${channel.channelId} is already in the collection for port ${port}`);
        }
        portChannels.push(channel);
        channel.onClosed(() => this.tryRemoveChannel(port, channel));
        this.portChannelAddedEmitter.fire(new forwardedPortEventArgs_1.ForwardedPortChannelEventArgs(port, channel));
      }
      tryRemoveChannel(port, channel) {
        const portAndChannels = this.portChannelMap.get(port.toString());
        if (portAndChannels) {
          const portChannels = portAndChannels[1];
          const index = portChannels.findIndex((c) => c.channelId === channel.channelId);
          if (index >= 0) {
            portChannels.splice(index, 1);
            this.portChannelRemovedEmitter.fire(new forwardedPortEventArgs_1.ForwardedPortChannelEventArgs(port, channel));
          }
        }
      }
      toString() {
        return [...this].join(", ");
      }
    };
    exports2.ForwardedPortsCollection = ForwardedPortsCollection;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh-tcp/ipAddressConversions.js
var require_ipAddressConversions = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh-tcp/ipAddressConversions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IPAddressConversions = void 0;
    var IPAddressConversions = class {
      /**
       * Converts from an SSH-protocol address string to an IP address string.
       */
      static fromSshAddress(address) {
        if (!address) {
          return "0.0.0.0";
        } else if (address === "localhost") {
          return "127.0.0.1";
        } else {
          return address;
        }
      }
      /**
       * Converts from an IP Address to an SSH-protocol address string.
       */
      static toSshAddress(ipAddress) {
        if (!ipAddress) {
          return null;
        } else if (ipAddress === "0.0.0.0") {
          return "";
        } else if (ipAddress === "127.0.0.1") {
          return "localhost";
        } else {
          return ipAddress;
        }
      }
    };
    exports2.IPAddressConversions = IPAddressConversions;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh-tcp/messages/portForwardChannelOpenMessage.js
var require_portForwardChannelOpenMessage = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh-tcp/messages/portForwardChannelOpenMessage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PortForwardChannelOpenMessage = void 0;
    var dev_tunnels_ssh_1 = require_dev_tunnels_ssh();
    var PortForwardChannelOpenMessage = class extends dev_tunnels_ssh_1.ChannelOpenMessage {
      constructor() {
        super(...arguments);
        this.host = "";
        this.port = 0;
        this.originatorIPAddress = "";
        this.originatorPort = 0;
      }
      onRead(reader) {
        super.onRead(reader);
        this.host = reader.readString("ascii");
        this.port = reader.readUInt32();
        this.originatorIPAddress = reader.readString("ascii");
        this.originatorPort = reader.readUInt32();
      }
      onWrite(writer) {
        super.onWrite(writer);
        writer.writeString(this.validateField(this.host, "host"), "ascii");
        writer.writeUInt32(this.validateField(this.port, "port"));
        writer.writeString(this.originatorIPAddress || "", "ascii");
        writer.writeUInt32(this.originatorPort || 0);
      }
      toString() {
        return `${super.toString()} (host=${this.host} port=${this.port})`;
      }
    };
    exports2.PortForwardChannelOpenMessage = PortForwardChannelOpenMessage;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh-tcp/messages/portForwardRequestMessage.js
var require_portForwardRequestMessage = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh-tcp/messages/portForwardRequestMessage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PortForwardRequestMessage = void 0;
    var dev_tunnels_ssh_1 = require_dev_tunnels_ssh();
    var portForwardingService_1 = require_portForwardingService();
    var PortForwardRequestMessage = class extends dev_tunnels_ssh_1.SessionRequestMessage {
      constructor() {
        super();
        this.addressToBind = "";
        this.port = 0;
        this.requestType = portForwardingService_1.PortForwardingService.portForwardRequestType;
        this.wantReply = true;
      }
      onRead(reader) {
        super.onRead(reader);
        this.addressToBind = reader.readString("ascii");
        this.port = reader.readUInt32();
      }
      onWrite(writer) {
        super.onWrite(writer);
        writer.writeString(this.validateField(this.addressToBind, "address"), "ascii");
        writer.writeUInt32(this.validateField(this.port, "port"));
      }
      toString() {
        return `${super.toString()} (addressToBind=${this.addressToBind} port=${this.port})`;
      }
    };
    exports2.PortForwardRequestMessage = PortForwardRequestMessage;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh-tcp/messages/portForwardSuccessMessage.js
var require_portForwardSuccessMessage = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh-tcp/messages/portForwardSuccessMessage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PortForwardSuccessMessage = void 0;
    var dev_tunnels_ssh_1 = require_dev_tunnels_ssh();
    var PortForwardSuccessMessage = class extends dev_tunnels_ssh_1.SessionRequestSuccessMessage {
      constructor() {
        super(...arguments);
        this.port = 0;
      }
      onRead(reader) {
        super.onRead(reader);
        if (reader.available >= 4) {
          this.port = reader.readUInt32();
        }
      }
      onWrite(writer) {
        super.onWrite(writer);
        writer.writeUInt32(this.validateField(this.port, "port"));
      }
      toString() {
        return `${super.toString()} (port=${this.port})`;
      }
    };
    exports2.PortForwardSuccessMessage = PortForwardSuccessMessage;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh-tcp/portForwardMessageFactory.js
var require_portForwardMessageFactory = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh-tcp/portForwardMessageFactory.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DefaultPortForwardMessageFactory = void 0;
    var portForwardChannelOpenMessage_1 = require_portForwardChannelOpenMessage();
    var portForwardRequestMessage_1 = require_portForwardRequestMessage();
    var portForwardSuccessMessage_1 = require_portForwardSuccessMessage();
    var DefaultPortForwardMessageFactory = class {
      createRequestMessageAsync(port) {
        return Promise.resolve(new portForwardRequestMessage_1.PortForwardRequestMessage());
      }
      createSuccessMessageAsync(port) {
        return Promise.resolve(new portForwardSuccessMessage_1.PortForwardSuccessMessage());
      }
      createChannelOpenMessageAsync(port) {
        return Promise.resolve(new portForwardChannelOpenMessage_1.PortForwardChannelOpenMessage());
      }
    };
    exports2.DefaultPortForwardMessageFactory = DefaultPortForwardMessageFactory;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh-tcp/services/streamForwarder.js
var require_streamForwarder = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh-tcp/services/streamForwarder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StreamForwarder = void 0;
    var dev_tunnels_ssh_1 = require_dev_tunnels_ssh();
    var net_1 = require("net");
    var StreamForwarder = class {
      /* @internal */
      constructor(localStream, remoteStream, trace) {
        this.localStream = localStream;
        this.remoteStream = remoteStream;
        this.trace = trace;
        this.disposed = false;
        if (!localStream)
          throw new TypeError("Local stream is required.");
        if (!remoteStream)
          throw new TypeError("Remote stream is required.");
        localStream.pipe(remoteStream);
        remoteStream.pipe(localStream);
      }
      close(abort, errorMessage) {
        try {
          if (abort && this.localStream instanceof net_1.Socket) {
            this.localStream.destroy();
          } else {
            this.localStream.end();
          }
          if (this.remoteStream instanceof dev_tunnels_ssh_1.SshStream) {
            this.remoteStream.channel.close("SIGABRT", errorMessage).catch((e) => {
            });
          } else {
            this.remoteStream.end();
          }
          this.trace(dev_tunnels_ssh_1.TraceLevel.Verbose, dev_tunnels_ssh_1.SshTraceEventIds.portForwardChannelClosed, `Stream forwarder ${abort ? "aborted" : "closed"} connection.`);
        } catch (e) {
          if (!(e instanceof Error))
            throw e;
          this.trace(dev_tunnels_ssh_1.TraceLevel.Warning, dev_tunnels_ssh_1.SshTraceEventIds.unknownError, `Stream forwarder unexpected error closing connection:  ${e.message}`);
        }
      }
      dispose() {
        if (!this.disposed) {
          this.disposed = true;
          this.close(true);
        }
      }
    };
    exports2.StreamForwarder = StreamForwarder;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh-tcp/services/localPortForwarder.js
var require_localPortForwarder = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh-tcp/services/localPortForwarder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LocalPortForwarder = void 0;
    var dev_tunnels_ssh_1 = require_dev_tunnels_ssh();
    var streamForwarder_1 = require_streamForwarder();
    var LocalPortForwarder = class extends dev_tunnels_ssh_1.SshService {
      /* @internal */
      constructor(pfs, session, channelType, localIPAddress, localPort, remoteHost, remotePort) {
        super(session);
        this.pfs = pfs;
        this.channelType = channelType;
        this.localIPAddress = localIPAddress;
        this.port = localPort;
        this.remoteHost = remoteHost;
        this.remotePort = remotePort !== null && remotePort !== void 0 ? remotePort : localPort !== 0 ? localPort : void 0;
      }
      /**
       * Local port that the forwarder is listening on.
       */
      get localPort() {
        return this.port;
      }
      /* @internal */
      async startForwarding(cancellation) {
        var _a2;
        let listenAddress = this.localIPAddress;
        try {
          this.tcpListener = await this.pfs.tcpListenerFactory.createTcpListener(this.remotePort, listenAddress, this.port, true);
          const serverAddress = this.tcpListener.address();
          if (!(serverAddress.port > 0)) {
            this.tcpListener.close();
            throw new Error("Could not get server port.");
          }
          this.port = serverAddress.port;
          if (this.localIPAddress === "127.0.0.1" || this.localIPAddress === "0.0.0.0") {
            listenAddress = this.localIPAddress === "0.0.0.0" ? "::" : "::1";
            try {
              this.tcpListener2 = await this.pfs.tcpListenerFactory.createTcpListener(this.remotePort, listenAddress, this.port, false);
            } catch (e) {
              if (!(e instanceof Error) || e.code !== "EADDRNOTAVAIL") {
                throw e;
              }
              this.trace(dev_tunnels_ssh_1.TraceLevel.Warning, dev_tunnels_ssh_1.SshTraceEventIds.portForwardServerListenFailed, `PortForwardingService failed to listen on ${listenAddress}:{this.port}: ${e.message}`, e);
            }
          }
        } catch (e) {
          if (!(e instanceof Error))
            throw e;
          this.trace(dev_tunnels_ssh_1.TraceLevel.Error, dev_tunnels_ssh_1.SshTraceEventIds.portForwardServerListenFailed, `PortForwardingService failed to listen on ${listenAddress}:${this.port}: ${e.message}`, e);
          throw e;
        }
        this.tcpListener.on("connection", this.acceptConnection.bind(this));
        (_a2 = this.tcpListener2) === null || _a2 === void 0 ? void 0 : _a2.on("connection", this.acceptConnection.bind(this));
        this.trace(dev_tunnels_ssh_1.TraceLevel.Info, dev_tunnels_ssh_1.SshTraceEventIds.portForwardServerListening, `PortForwardingService listening on ${this.localIPAddress}:${this.port}.`);
        if (this.tcpListener2) {
          this.trace(dev_tunnels_ssh_1.TraceLevel.Info, dev_tunnels_ssh_1.SshTraceEventIds.portForwardServerListening, `PortForwardingService also listening on ${listenAddress}:${this.port}.`);
        }
      }
      async acceptConnection(socket) {
        var _a2, _b, _c, _d, _e;
        this.trace(dev_tunnels_ssh_1.TraceLevel.Info, dev_tunnels_ssh_1.SshTraceEventIds.portForwardConnectionAccepted, `PortForwardingService accepted connection from: ${socket.remoteAddress} on port ${this.port}`);
        let channel;
        try {
          channel = await this.pfs.openChannel(this.session, this.channelType, (_a2 = socket.remoteAddress) !== null && _a2 !== void 0 ? _a2 : null, (_b = socket.remotePort) !== null && _b !== void 0 ? _b : null, (_c = this.remoteHost) !== null && _c !== void 0 ? _c : this.localIPAddress, (_d = this.remotePort) !== null && _d !== void 0 ? _d : this.localPort);
        } catch (e) {
          if (!(e instanceof Error))
            throw e;
          socket.destroy();
          return;
        }
        const forwardedStream = await this.pfs.forwardedPortConnecting((_e = this.remotePort) !== null && _e !== void 0 ? _e : this.localPort, false, new dev_tunnels_ssh_1.SshStream(channel));
        if (!forwardedStream) {
          return;
        }
        const forwarder = new streamForwarder_1.StreamForwarder(socket, forwardedStream, channel.session.trace);
        this.pfs.streamForwarders.push(forwarder);
      }
      dispose() {
        var _a2, _b;
        (_a2 = this.tcpListener) === null || _a2 === void 0 ? void 0 : _a2.close();
        (_b = this.tcpListener2) === null || _b === void 0 ? void 0 : _b.close();
        this.trace(dev_tunnels_ssh_1.TraceLevel.Info, dev_tunnels_ssh_1.SshTraceEventIds.portForwardServerListening, `PortForwardingService stopped listening on ${this.localIPAddress}:${this.port}.`);
        super.dispose();
      }
    };
    exports2.LocalPortForwarder = LocalPortForwarder;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh-tcp/services/remotePortConnector.js
var require_remotePortConnector = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh-tcp/services/remotePortConnector.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RemotePortConnector = void 0;
    var dev_tunnels_ssh_1 = require_dev_tunnels_ssh();
    var portForwardRequestMessage_1 = require_portForwardRequestMessage();
    var portForwardSuccessMessage_1 = require_portForwardSuccessMessage();
    var portForwardingService_1 = require_portForwardingService();
    var RemotePortConnector = class extends dev_tunnels_ssh_1.SshService {
      /* @internal */
      constructor(session, remoteIPAddress, remotePort) {
        super(session);
        this.forwarding = false;
        this.remoteIPAddress = remoteIPAddress;
        this.port = remotePort;
      }
      /**
       * Port that the remote server is listening on. If the request specified port 0, this
       * property returns the actual available port that was chosen by the server.
       */
      get remotePort() {
        return this.port;
      }
      /* @internal */
      async request(request, cancellation) {
        if (this.forwarding) {
          throw new Error("Already forwarding.");
        }
        request.addressToBind = this.remoteIPAddress;
        request.port = this.remotePort;
        request.wantReply = true;
        const response = await this.session.requestResponse(request, portForwardSuccessMessage_1.PortForwardSuccessMessage, dev_tunnels_ssh_1.SessionRequestFailureMessage, cancellation);
        let result = false;
        if (response instanceof portForwardSuccessMessage_1.PortForwardSuccessMessage) {
          if (response.port !== 0) {
            this.port = response.port;
          }
          result = true;
        }
        this.forwarding = result;
        return result;
      }
      dispose() {
        if (this.forwarding) {
          this.forwarding = false;
          const request = new portForwardRequestMessage_1.PortForwardRequestMessage();
          request.requestType = portForwardingService_1.PortForwardingService.cancelPortForwardRequestType;
          request.addressToBind = this.remoteIPAddress;
          request.port = this.remotePort;
          request.wantReply = false;
          try {
            this.session.request(request).catch((e) => {
            });
          } catch (e) {
          }
        }
        super.dispose();
      }
    };
    exports2.RemotePortConnector = RemotePortConnector;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh-tcp/services/remotePortForwarder.js
var require_remotePortForwarder = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh-tcp/services/remotePortForwarder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RemotePortForwarder = void 0;
    var net2 = require("net");
    var dev_tunnels_ssh_1 = require_dev_tunnels_ssh();
    var streamForwarder_1 = require_streamForwarder();
    var remotePortConnector_1 = require_remotePortConnector();
    var RemotePortForwarder = class _RemotePortForwarder extends remotePortConnector_1.RemotePortConnector {
      /* @internal */
      constructor(pfs, session, remoteIPAddress, remotePort, localHost, localPort) {
        super(session, remoteIPAddress, remotePort);
        this.pfs = pfs;
        this.localHost = localHost;
        this.localPort = localPort;
      }
      /* @internal */
      async onPortChannelOpening(request, cancellation) {
        await _RemotePortForwarder.forwardChannel(this.pfs, request, this.localHost, this.localPort, this.remotePort, this.trace, cancellation);
      }
      /* @internal */
      static async forwardChannel(pfs, request, localHost, localPort, remotePort, trace, cancellation) {
        const channel = request.channel;
        const forwardedStream = await pfs.forwardedPortConnecting(remotePort !== null && remotePort !== void 0 ? remotePort : localPort, true, new dev_tunnels_ssh_1.SshStream(channel), cancellation);
        if (!forwardedStream) {
          request.failureReason = dev_tunnels_ssh_1.SshChannelOpenFailureReason.connectFailed;
          return;
        }
        const socket = net2.createConnection({
          host: localHost,
          port: localPort,
          // This option enables connection attempts for multiple resolved IP addresses,
          // aka "Happy Eyeballs" as described in https://datatracker.ietf.org/doc/html/rfc8305.
          // Effectively this enables fast connections to either 127.0.0.1 or ::1 when 'localhost'
          // is specified as the hostname. Note this option is available starting with Node.js
          // v18.13 and is enabled by default starting with Node.js v20.0.
          autoSelectFamily: true,
          // Use the minimum supported connection attempt delay when connecting to 'localhost'.
          // See https://nodejs.org/api/net.html#socketconnectoptions-connectlistener
          autoSelectFamilyAttemptTimeout: localHost === "localhost" ? 10 : 250
        });
        const connectCompletion = new dev_tunnels_ssh_1.PromiseCompletionSource();
        const cancellationRegistration = cancellation ? cancellation.onCancellationRequested(() => socket.destroy(new Error("Cancelled."))) : null;
        try {
          socket.once("connect", () => {
            connectCompletion.resolve();
          });
          socket.once("error", (e) => {
            connectCompletion.reject(e);
          });
          await connectCompletion.promise;
        } catch (e) {
          if (!(e instanceof Error) || (cancellation === null || cancellation === void 0 ? void 0 : cancellation.isCancellationRequested)) {
            throw e;
          }
          trace(dev_tunnels_ssh_1.TraceLevel.Warning, dev_tunnels_ssh_1.SshTraceEventIds.portForwardConnectionFailed, `PortForwardingService connection to ${localHost}:${localPort} failed: ${e.message}`, e);
          request.failureReason = dev_tunnels_ssh_1.SshChannelOpenFailureReason.connectFailed;
          request.failureDescription = e.message;
        } finally {
          cancellationRegistration === null || cancellationRegistration === void 0 ? void 0 : cancellationRegistration.dispose();
        }
        const streamForwarder = new streamForwarder_1.StreamForwarder(socket, forwardedStream, channel.session.trace);
        trace(dev_tunnels_ssh_1.TraceLevel.Info, dev_tunnels_ssh_1.SshTraceEventIds.portForwardConnectionOpened, `${channel.session} PortForwardingService forwarded channel #${channel.channelId} connection to ${localHost}:${localPort}.`);
        pfs.streamForwarders.push(streamForwarder);
      }
    };
    exports2.RemotePortForwarder = RemotePortForwarder;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh-tcp/services/remotePortStreamer.js
var require_remotePortStreamer = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh-tcp/services/remotePortStreamer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RemotePortStreamer = void 0;
    var vscode_jsonrpc_1 = require_main();
    var dev_tunnels_ssh_1 = require_dev_tunnels_ssh();
    var remotePortConnector_1 = require_remotePortConnector();
    var RemotePortStreamer = class extends remotePortConnector_1.RemotePortConnector {
      /* @internal */
      constructor(session, remoteIPAddress, remotePort) {
        super(session, remoteIPAddress, remotePort);
        this.streamOpenedEmitter = new vscode_jsonrpc_1.Emitter();
        this.onStreamOpened = this.streamOpenedEmitter.event;
      }
      /* @internal */
      async onPortChannelOpening(request, cancellation) {
        const stream = new dev_tunnels_ssh_1.SshStream(request.channel);
        this.streamOpenedEmitter.fire(stream);
      }
    };
    exports2.RemotePortStreamer = RemotePortStreamer;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh-tcp/services/portForwardingService.js
var require_portForwardingService = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh-tcp/services/portForwardingService.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var PortForwardingService_1;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PortForwardingService = void 0;
    var dev_tunnels_ssh_1 = require_dev_tunnels_ssh();
    var vscode_jsonrpc_1 = require_main();
    var forwardedPort_1 = require_forwardedPort();
    var forwardedPortsCollection_1 = require_forwardedPortsCollection();
    var ipAddressConversions_1 = require_ipAddressConversions();
    var portForwardChannelOpenMessage_1 = require_portForwardChannelOpenMessage();
    var portForwardRequestMessage_1 = require_portForwardRequestMessage();
    var portForwardSuccessMessage_1 = require_portForwardSuccessMessage();
    var tcpListenerFactory_1 = require_tcpListenerFactory();
    var portForwardMessageFactory_1 = require_portForwardMessageFactory();
    var localPortForwarder_1 = require_localPortForwarder();
    var remotePortForwarder_1 = require_remotePortForwarder();
    var remotePortStreamer_1 = require_remotePortStreamer();
    var forwardedPortEventArgs_1 = require_forwardedPortEventArgs();
    var PortForwardingService = PortForwardingService_1 = class PortForwardingService extends dev_tunnels_ssh_1.SshService {
      /* @internal */
      constructor(session) {
        super(session);
        this.localForwarders = /* @__PURE__ */ new Map();
        this.remoteConnectors = /* @__PURE__ */ new Map();
        this.streamForwarders = [];
        this.acceptLocalConnectionsForForwardedPorts = true;
        this.forwardConnectionsToLocalPorts = true;
        this.acceptRemoteConnectionsForNonForwardedPorts = true;
        this.localForwardedPorts = new forwardedPortsCollection_1.ForwardedPortsCollection();
        this.remoteForwardedPorts = new forwardedPortsCollection_1.ForwardedPortsCollection();
        this.tcpListenerFactory = new tcpListenerFactory_1.DefaultTcpListenerFactory();
        this.messageFactory = new portForwardMessageFactory_1.DefaultPortForwardMessageFactory();
        this.forwardedPortConnectingEmitter = new vscode_jsonrpc_1.Emitter();
        this.onForwardedPortConnecting = this.forwardedPortConnectingEmitter.event;
      }
      /* @internal */
      async forwardedPortConnecting(port, isIncoming, stream, cancellation) {
        try {
          const args = new forwardedPortEventArgs_1.ForwardedPortConnectingEventArgs(port, isIncoming, stream, cancellation);
          this.forwardedPortConnectingEmitter.fire(args);
          if (args.transformPromise) {
            return await args.transformPromise;
          }
        } catch (e) {
          if (!(e instanceof Error))
            throw e;
          this.trace(dev_tunnels_ssh_1.TraceLevel.Warning, dev_tunnels_ssh_1.SshTraceEventIds.portForwardConnectionFailed, `Forwarded port connecting event-handler failed: ${e.message}`);
          return null;
        }
        return stream;
      }
      async forwardFromRemotePort(remoteIPAddress, remotePort, localHostOrCancellation, localPort, cancellation) {
        const localHost = typeof localHostOrCancellation === "string" ? localHostOrCancellation : "127.0.0.1";
        if (typeof localPort === "undefined")
          localPort = remotePort;
        if (!remoteIPAddress)
          throw new TypeError("Remote IP address is required.");
        if (!Number.isInteger(remotePort) || remotePort < 0) {
          throw new TypeError("Remote port must be a non-negative integer.");
        }
        if (!localHost)
          throw new TypeError("Local host is required.");
        if (!Number.isInteger(localPort) || localPort <= 0) {
          throw new TypeError("Local port must be a positive integer.");
        }
        if (this.localForwardedPorts.find((p) => p.localPort === localPort)) {
          throw new Error(`Local port ${localPort} is already forwarded.`);
        } else if (remotePort > 0 && this.localForwardedPorts.find((p) => p.remotePort === remotePort)) {
          throw new Error(`Remote port ${remotePort} is already forwarded.`);
        }
        const forwarder = new remotePortForwarder_1.RemotePortForwarder(this, this.session, remoteIPAddress, remotePort, localHost, localPort);
        const request = await this.messageFactory.createRequestMessageAsync(remotePort);
        if (!await forwarder.request(request, cancellation)) {
          return null;
        }
        remotePort = forwarder.remotePort;
        if (this.remoteConnectors.has(remotePort)) {
          return null;
        }
        this.remoteConnectors.set(remotePort, forwarder);
        const forwardedPort = new forwardedPort_1.ForwardedPort(localPort, remotePort, false);
        this.localForwardedPorts.addOrUpdatePort(forwardedPort);
        forwarder.onDisposed(() => {
          this.localForwardedPorts.removePort(forwardedPort);
          this.remoteConnectors.delete(remotePort);
        });
        return forwarder;
      }
      async forwardToRemotePort(localIPAddress, localPort, remoteHostOrCancellation, remotePort, cancellation) {
        const remoteHost = typeof remoteHostOrCancellation === "string" ? remoteHostOrCancellation : "127.0.0.1";
        if (typeof remotePort === "undefined")
          remotePort = localPort;
        if (!localIPAddress)
          throw new TypeError("Local IP address is required.");
        if (!Number.isInteger(localPort) || localPort < 0) {
          throw new TypeError("Local port must be a non-negative integer.");
        }
        if (!remoteHost)
          throw new TypeError("Remote host is required.");
        if (!Number.isInteger(remotePort) || remotePort <= 0) {
          throw new TypeError("Remote port must be a positive integer.");
        }
        if (this.localForwarders.has(remotePort)) {
          throw new Error(`Port ${remotePort} is already forwarded.`);
        }
        const forwarder = new localPortForwarder_1.LocalPortForwarder(this, this.session, PortForwardingService_1.reversePortForwardChannelType, localIPAddress, localPort, remoteHost, remotePort);
        await forwarder.startForwarding(cancellation);
        this.localForwarders.set(remotePort, forwarder);
        forwarder.onDisposed(() => {
          this.localForwarders.delete(remotePort);
        });
        return forwarder;
      }
      /**
       * Sends a request to the remote side to listen on a port and forward incoming connections as
       * SSH channels of type 'forwarded-tcpip', which will then be relayed as local streams.
       *
       * @param remoteIPAddress IP address of the interface to bind to on the remote side.
       * @param remotePort The remote port to listen on, or 0 to choose an available port.
       * (The chosen port can then be obtained via the `remotePort` property on the returned object.)
       * @param cancellation Cancellation token for the request; note this cannot cancel forwarding
       * once it has started; use the returned disposable do do that.
       * @returns A disposable object that when disposed will cancel forwarding the port, or `null`
       * if the request was rejected by the remote side, possibly because the remote port was already
       * in use. Handle the `onStreamOpened` event on this object to receive streams.
       */
      async streamFromRemotePort(remoteIPAddress, remotePort, cancellation) {
        if (!remoteIPAddress)
          throw new TypeError("Remote IP address is required.");
        if (!Number.isInteger(remotePort) || remotePort < 0) {
          throw new TypeError("Remote port must be a non-negative integer.");
        }
        const streamer = new remotePortStreamer_1.RemotePortStreamer(this.session, remoteIPAddress, remotePort);
        const request = await this.messageFactory.createRequestMessageAsync(remotePort);
        if (!await streamer.request(request, cancellation)) {
          streamer.dispose();
          return null;
        }
        remotePort = streamer.remotePort;
        this.remoteConnectors.set(remotePort, streamer);
        const forwardedPort = new forwardedPort_1.ForwardedPort(null, remotePort, false);
        this.localForwardedPorts.addOrUpdatePort(forwardedPort);
        streamer.onDisposed(() => {
          this.localForwardedPorts.removePort(forwardedPort);
          this.remoteConnectors.delete(remotePort);
        });
        return streamer;
      }
      /**
       * Opens a stream for an SSH channel of type 'direct-tcpip' that is relayed to remote port,
       * regardless of whether the remote side has explicitly forwarded that port.
       *
       * @param remoteHost The destination hostname or IP address for forwarded connections, to be
       * resolved on the remote side. WARNING: Avoid using the hostname `localhost` as the destination
       * host; use `127.0.0.1` or `::1` instead. (OpenSSH does not recognize `localhost` as a valid
       * destination host.)
       * @param remotePort The destination port for the forwarded stream. (Must not be 0.)
       * @param cancellation Cancellation token for the request; note this cannot cancel streaming
       * once it has started; dipose the returned stream for that.
       * @returns A stream that is relayed to the remote port.
       * @throws `SshChannelError` if the streaming channel could not be opened, either because it
       * was rejected by the remote side, or the remote connection failed.
       */
      async streamToRemotePort(remoteHost, remotePort, cancellation) {
        if (!remoteHost)
          throw new TypeError("Remote host is required.");
        if (!Number.isInteger(remotePort) || remotePort <= 0) {
          throw new TypeError("Remote port must be a positive integer.");
        }
        const channel = await this.openChannel(this.session, PortForwardingService_1.reversePortForwardChannelType, null, null, remoteHost, remotePort, cancellation);
        return new dev_tunnels_ssh_1.SshStream(channel);
      }
      /**
       * Opens a stream for an SSH channel of type 'forwarded-tcpip' that is relayed to a remote
       * port. The port must have been explicitly forwarded by the remote side.
       *
       * It may be necessary to call `waitForForwardedPort` before this method
       * to ensure the port is ready for connections.
       *
       * An error is thrown if the requested port could not be forwarded, possibly because it was
       * rejected by the remote side, or the remote connection failed.
       *
       * @param forwardedPort Remote port number that was forwarded.
       * @param cancellation Cancellation token for the request; note this cannot
       * cancel streaming once it has started; dipose the returned stream for that.
       * @returns A stream that is relayed to the remote forwarded port.
       */
      async connectToForwardedPort(forwardedPort, cancellation) {
        if (!Number.isInteger(forwardedPort) || forwardedPort <= 0) {
          throw new TypeError("Forwarded port must be a positive integer.");
        }
        const channel = await this.openChannel(this.session, PortForwardingService_1.portForwardChannelType, null, null, "127.0.0.1", forwardedPort, cancellation);
        const forwardedStream = await this.forwardedPortConnecting(forwardedPort, false, new dev_tunnels_ssh_1.SshStream(channel), cancellation);
        if (!forwardedStream) {
          channel.close().catch((e) => {
          });
          throw new dev_tunnels_ssh_1.SshChannelError("The connection to the forwarded port was rejected by the connecting event-handler.");
        }
        return forwardedStream;
      }
      /**
       * Waits asynchronously for the remote side to forward an expected port number.
       *
       * A common pattern for some applications may be to call this method just before
       * `ConnectToForwardedPortAsync`.
       *
       * @param forwardedPort Port number that is expected to be forwarded.
       * @param cancellation Token that can be used to cancel waiting.
       * @returns A promise that completes when the expected port number has been forwarded.
       */
      async waitForForwardedPort(forwardedPort, cancellation) {
        if (this.remoteForwardedPorts.find((p) => p.remotePort === forwardedPort)) {
          return;
        }
        const waitCompletion = new dev_tunnels_ssh_1.PromiseCompletionSource();
        let cancellationRegistration;
        if (cancellation) {
          cancellationRegistration = cancellation.onCancellationRequested(() => waitCompletion.reject(new dev_tunnels_ssh_1.CancellationError()));
        }
        let portAddedRegistration;
        let sessionClosedRegistration;
        try {
          portAddedRegistration = this.remoteForwardedPorts.onPortAdded((e) => {
            if (e.port.remotePort === forwardedPort) {
              waitCompletion.resolve();
            }
          });
          sessionClosedRegistration = this.session.onClosed(() => {
            waitCompletion.reject(new dev_tunnels_ssh_1.ObjectDisposedError("The session was closed."));
          });
          await waitCompletion.promise;
        } finally {
          portAddedRegistration === null || portAddedRegistration === void 0 ? void 0 : portAddedRegistration.dispose();
          sessionClosedRegistration === null || sessionClosedRegistration === void 0 ? void 0 : sessionClosedRegistration.dispose();
          cancellationRegistration === null || cancellationRegistration === void 0 ? void 0 : cancellationRegistration.dispose();
        }
      }
      async onSessionRequest(request, cancellation) {
        if (!request)
          throw new TypeError("Request is required.");
        else if (request.requestType !== PortForwardingService_1.portForwardRequestType && request.requestType !== PortForwardingService_1.cancelPortForwardRequestType) {
          throw new Error(`Unexpected request type: ${request.requestType}`);
        }
        const portForwardRequest = request.request.convertTo(new portForwardRequestMessage_1.PortForwardRequestMessage());
        const localIPAddress = ipAddressConversions_1.IPAddressConversions.fromSshAddress(portForwardRequest.addressToBind);
        if (request.requestType === PortForwardingService_1.portForwardRequestType && portForwardRequest.port !== 0 && this.localForwarders.has(portForwardRequest.port)) {
          const message = `PortForwardingService port ${portForwardRequest.port} is already forwarded.`;
          this.session.trace(dev_tunnels_ssh_1.TraceLevel.Verbose, dev_tunnels_ssh_1.SshTraceEventIds.portForwardRequestInvalid, message);
          request.isAuthorized = false;
          return;
        }
        const args = new dev_tunnels_ssh_1.SshRequestEventArgs(request.requestType, portForwardRequest, this.session.principal);
        await super.onSessionRequest(args, cancellation);
        let response;
        let localPort = null;
        if (args.isAuthorized) {
          if (request.requestType === PortForwardingService_1.portForwardRequestType) {
            try {
              localPort = await this.startForwarding(localIPAddress, portForwardRequest.port, cancellation);
            } catch (e) {
            }
            if (localPort !== null) {
              const forwardedPort = portForwardRequest.port === 0 ? localPort : portForwardRequest.port;
              const portResponse = await this.messageFactory.createSuccessMessageAsync(forwardedPort);
              portResponse.port = forwardedPort;
              response = portResponse;
            }
          } else if (request.requestType === PortForwardingService_1.cancelPortForwardRequestType) {
            if (await this.cancelForwarding(portForwardRequest.port, cancellation)) {
              response = new dev_tunnels_ssh_1.SessionRequestSuccessMessage();
            }
          }
        }
        request.responsePromise = Promise.resolve(response !== null && response !== void 0 ? response : new dev_tunnels_ssh_1.SessionRequestFailureMessage());
        if (response instanceof portForwardSuccessMessage_1.PortForwardSuccessMessage) {
          const forwardedPort = new forwardedPort_1.ForwardedPort(localPort !== null && localPort !== void 0 ? localPort : response.port, response.port, true);
          this.remoteForwardedPorts.addOrUpdatePort(forwardedPort);
        }
      }
      async startForwarding(localIPAddress, remotePort, cancellation) {
        if (typeof remotePort !== "number")
          throw new TypeError("Remote port must be an integer.");
        if (this.acceptLocalConnectionsForForwardedPorts) {
          let localPort = remotePort;
          const forwarder = new localPortForwarder_1.LocalPortForwarder(this, this.session, PortForwardingService_1.portForwardChannelType, localIPAddress, localPort, void 0, remotePort === 0 ? void 0 : remotePort);
          await forwarder.startForwarding(cancellation);
          localPort = forwarder.localPort;
          if (remotePort === 0) {
            remotePort = localPort;
          }
          if (this.localForwarders.has(remotePort)) {
            forwarder.dispose();
            return null;
          }
          this.localForwarders.set(remotePort, forwarder);
          localPort = forwarder.localPort;
          forwarder.onDisposed(() => {
            const forwardedPort = new forwardedPort_1.ForwardedPort(localPort, remotePort, true);
            this.remoteForwardedPorts.removePort(forwardedPort);
            this.localForwarders.delete(remotePort);
          });
          return localPort;
        } else if (remotePort !== 0) {
          return remotePort;
        } else {
          return null;
        }
      }
      async cancelForwarding(forwardedPort, cancellation) {
        const forwarder = this.localForwarders.get(forwardedPort);
        if (forwarder) {
          this.localForwarders.delete(forwardedPort);
          forwarder.dispose();
          return true;
        }
        const port = new forwardedPort_1.ForwardedPort(forwardedPort, forwardedPort, true);
        if (this.remoteForwardedPorts.removePort(port)) {
          return true;
        }
        return false;
      }
      async onChannelOpening(request, cancellation) {
        var _a2;
        if (!request)
          throw new TypeError("Request is required.");
        const channelType = request.request.channelType;
        if (channelType !== PortForwardingService_1.portForwardChannelType && channelType !== PortForwardingService_1.reversePortForwardChannelType) {
          request.failureReason = dev_tunnels_ssh_1.SshChannelOpenFailureReason.unknownChannelType;
          return;
        }
        let remoteConnector = null;
        const portForwardMessage = request.request instanceof portForwardChannelOpenMessage_1.PortForwardChannelOpenMessage ? request.request : request.request.convertTo(new portForwardChannelOpenMessage_1.PortForwardChannelOpenMessage());
        if (request.isRemoteRequest) {
          if (channelType === PortForwardingService_1.portForwardChannelType) {
            const remoteIPAddress = ipAddressConversions_1.IPAddressConversions.fromSshAddress(portForwardMessage.host);
            const remoteEndPoint = `${remoteIPAddress}:${portForwardMessage.port}`;
            remoteConnector = (_a2 = this.remoteConnectors.get(portForwardMessage.port)) !== null && _a2 !== void 0 ? _a2 : null;
            if (!remoteConnector) {
              this.trace(dev_tunnels_ssh_1.TraceLevel.Error, dev_tunnels_ssh_1.SshTraceEventIds.portForwardRequestInvalid, `PortForwardingService received forwarding channel for ${remoteEndPoint} that was not requested.`);
              request.failureReason = dev_tunnels_ssh_1.SshChannelOpenFailureReason.connectFailed;
              request.failureDescription = "Forwarding channel was not requested.";
              return;
            }
          } else if (!this.acceptRemoteConnectionsForNonForwardedPorts) {
            const errorMessage = "The session has disabled connections to non-forwarded ports.";
            this.session.trace(dev_tunnels_ssh_1.TraceLevel.Warning, dev_tunnels_ssh_1.SshTraceEventIds.portForwardChannelOpenFailed, errorMessage);
            request.failureReason = dev_tunnels_ssh_1.SshChannelOpenFailureReason.administrativelyProhibited;
            request.failureDescription = errorMessage;
            return;
          }
        }
        const portForwardRequest = new dev_tunnels_ssh_1.SshChannelOpeningEventArgs(portForwardMessage, request.channel, request.isRemoteRequest);
        await super.onChannelOpening(portForwardRequest, cancellation);
        request.failureReason = portForwardRequest.failureReason;
        request.failureDescription = portForwardRequest.failureDescription;
        request.openingPromise = portForwardRequest.openingPromise;
        if (request.failureReason === dev_tunnels_ssh_1.SshChannelOpenFailureReason.none && request.isRemoteRequest && this.forwardConnectionsToLocalPorts) {
          if (remoteConnector) {
            await remoteConnector.onPortChannelOpening(request, cancellation);
            const localPort = remoteConnector instanceof remotePortForwarder_1.RemotePortForwarder ? remoteConnector.localPort : null;
            const remotePort = remoteConnector instanceof remotePortForwarder_1.RemotePortForwarder ? remoteConnector.remotePort : portForwardMessage.port;
            const forwardedPort = new forwardedPort_1.ForwardedPort(localPort, remotePort, false);
            this.localForwardedPorts.addChannel(forwardedPort, request.channel);
          } else {
            await remotePortForwarder_1.RemotePortForwarder.forwardChannel(this, request, portForwardMessage.host, portForwardMessage.port, portForwardMessage.port, this.trace, cancellation);
            if (request.failureReason !== dev_tunnels_ssh_1.SshChannelOpenFailureReason.none) {
              await request.channel.close(cancellation);
            }
          }
        }
      }
      /* @internal */
      async openChannel(session, channelType, originatorIPAddress, originatorPort, host, port, cancellation) {
        let forwardedPort = void 0;
        if (channelType === PortForwardingService_1.portForwardChannelType) {
          forwardedPort = this.remoteForwardedPorts.find((p) => p.remotePort === port || p.remotePort === null && p.localPort === port);
          if (!forwardedPort) {
            throw new Error(`Port ${port} is not being forwarded.`);
          }
        }
        const openMessage = await this.messageFactory.createChannelOpenMessageAsync(port);
        openMessage.channelType = channelType;
        openMessage.originatorIPAddress = originatorIPAddress !== null && originatorIPAddress !== void 0 ? originatorIPAddress : "";
        openMessage.originatorPort = originatorPort !== null && originatorPort !== void 0 ? originatorPort : 0;
        openMessage.host = host;
        openMessage.port = port;
        const trace = this.session.trace;
        let channel;
        try {
          channel = await session.openChannel(openMessage, null, cancellation);
          trace(dev_tunnels_ssh_1.TraceLevel.Info, dev_tunnels_ssh_1.SshTraceEventIds.portForwardChannelOpened, `PortForwardingService opened ${channelType} channel #${channel.channelId} for ${host}:${port}.`);
        } catch (e) {
          if (!(e instanceof Error))
            throw e;
          trace(dev_tunnels_ssh_1.TraceLevel.Error, dev_tunnels_ssh_1.SshTraceEventIds.portForwardChannelOpenFailed, `PortForwardingService failed to open ${channelType} channel for ${host}:${port}: ${e.message}`, e);
          throw e;
        }
        if (channelType === PortForwardingService_1.portForwardChannelType) {
          this.remoteForwardedPorts.addChannel(forwardedPort, channel);
        }
        return channel;
      }
      dispose() {
        const disposables = [
          ...this.localForwarders.values(),
          ...this.remoteConnectors.values()
        ];
        this.streamForwarders.splice(0, this.streamForwarders.length);
        this.localForwarders.clear();
        this.remoteConnectors.clear();
        for (const disposable of disposables) {
          disposable.dispose();
        }
        super.dispose();
      }
    };
    PortForwardingService.portForwardRequestType = "tcpip-forward";
    PortForwardingService.cancelPortForwardRequestType = "cancel-tcpip-forward";
    PortForwardingService.portForwardChannelType = "forwarded-tcpip";
    PortForwardingService.reversePortForwardChannelType = "direct-tcpip";
    PortForwardingService = PortForwardingService_1 = __decorate([
      (0, dev_tunnels_ssh_1.serviceActivation)({ sessionRequest: PortForwardingService_1.portForwardRequestType }),
      (0, dev_tunnels_ssh_1.serviceActivation)({ sessionRequest: PortForwardingService_1.cancelPortForwardRequestType }),
      (0, dev_tunnels_ssh_1.serviceActivation)({ channelType: PortForwardingService_1.portForwardChannelType }),
      (0, dev_tunnels_ssh_1.serviceActivation)({ channelType: PortForwardingService_1.reversePortForwardChannelType })
    ], PortForwardingService);
    exports2.PortForwardingService = PortForwardingService;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-ssh-tcp/index.js
var require_dev_tunnels_ssh_tcp = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-ssh-tcp/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ForwardedPortConnectingEventArgs = exports2.ForwardedPortChannelEventArgs = exports2.ForwardedPortEventArgs = exports2.ForwardedPortsCollection = exports2.ForwardedPort = exports2.PortForwardChannelOpenMessage = exports2.PortForwardSuccessMessage = exports2.PortForwardRequestMessage = exports2.RemotePortStreamer = exports2.RemotePortForwarder = exports2.LocalPortForwarder = exports2.PortForwardingService = exports2.SshServer = exports2.SshClient = void 0;
    var sshClient_1 = require_sshClient();
    Object.defineProperty(exports2, "SshClient", { enumerable: true, get: function() {
      return sshClient_1.SshClient;
    } });
    var sshServer_1 = require_sshServer();
    Object.defineProperty(exports2, "SshServer", { enumerable: true, get: function() {
      return sshServer_1.SshServer;
    } });
    var portForwardingService_1 = require_portForwardingService();
    Object.defineProperty(exports2, "PortForwardingService", { enumerable: true, get: function() {
      return portForwardingService_1.PortForwardingService;
    } });
    var localPortForwarder_1 = require_localPortForwarder();
    Object.defineProperty(exports2, "LocalPortForwarder", { enumerable: true, get: function() {
      return localPortForwarder_1.LocalPortForwarder;
    } });
    var remotePortForwarder_1 = require_remotePortForwarder();
    Object.defineProperty(exports2, "RemotePortForwarder", { enumerable: true, get: function() {
      return remotePortForwarder_1.RemotePortForwarder;
    } });
    var remotePortStreamer_1 = require_remotePortStreamer();
    Object.defineProperty(exports2, "RemotePortStreamer", { enumerable: true, get: function() {
      return remotePortStreamer_1.RemotePortStreamer;
    } });
    var portForwardRequestMessage_1 = require_portForwardRequestMessage();
    Object.defineProperty(exports2, "PortForwardRequestMessage", { enumerable: true, get: function() {
      return portForwardRequestMessage_1.PortForwardRequestMessage;
    } });
    var portForwardSuccessMessage_1 = require_portForwardSuccessMessage();
    Object.defineProperty(exports2, "PortForwardSuccessMessage", { enumerable: true, get: function() {
      return portForwardSuccessMessage_1.PortForwardSuccessMessage;
    } });
    var portForwardChannelOpenMessage_1 = require_portForwardChannelOpenMessage();
    Object.defineProperty(exports2, "PortForwardChannelOpenMessage", { enumerable: true, get: function() {
      return portForwardChannelOpenMessage_1.PortForwardChannelOpenMessage;
    } });
    var forwardedPort_1 = require_forwardedPort();
    Object.defineProperty(exports2, "ForwardedPort", { enumerable: true, get: function() {
      return forwardedPort_1.ForwardedPort;
    } });
    var forwardedPortsCollection_1 = require_forwardedPortsCollection();
    Object.defineProperty(exports2, "ForwardedPortsCollection", { enumerable: true, get: function() {
      return forwardedPortsCollection_1.ForwardedPortsCollection;
    } });
    var forwardedPortEventArgs_1 = require_forwardedPortEventArgs();
    Object.defineProperty(exports2, "ForwardedPortEventArgs", { enumerable: true, get: function() {
      return forwardedPortEventArgs_1.ForwardedPortEventArgs;
    } });
    Object.defineProperty(exports2, "ForwardedPortChannelEventArgs", { enumerable: true, get: function() {
      return forwardedPortEventArgs_1.ForwardedPortChannelEventArgs;
    } });
    Object.defineProperty(exports2, "ForwardedPortConnectingEventArgs", { enumerable: true, get: function() {
      return forwardedPortEventArgs_1.ForwardedPortConnectingEventArgs;
    } });
  }
});

// ../../node_modules/@microsoft/dev-tunnels-connections/messages/portRelayConnectResponseMessage.js
var require_portRelayConnectResponseMessage = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-connections/messages/portRelayConnectResponseMessage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PortRelayConnectResponseMessage = void 0;
    var dev_tunnels_ssh_1 = require_dev_tunnels_ssh();
    var PortRelayConnectResponseMessage = class extends dev_tunnels_ssh_1.ChannelOpenConfirmationMessage {
      constructor() {
        super(...arguments);
        this.isE2EEncryptionEnabled = false;
      }
      onWrite(writer) {
        super.onWrite(writer);
        writer.writeBoolean(this.isE2EEncryptionEnabled);
      }
      onRead(reader) {
        super.onRead(reader);
        this.isE2EEncryptionEnabled = reader.readBoolean();
      }
    };
    exports2.PortRelayConnectResponseMessage = PortRelayConnectResponseMessage;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-connections/retryingTunnelConnectionEventArgs.js
var require_retryingTunnelConnectionEventArgs = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-connections/retryingTunnelConnectionEventArgs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RetryingTunnelConnectionEventArgs = void 0;
    var RetryingTunnelConnectionEventArgs = class {
      constructor(error, delayMs) {
        this.error = error;
        this.delayMs = delayMs;
        this.retry = true;
      }
    };
    exports2.RetryingTunnelConnectionEventArgs = RetryingTunnelConnectionEventArgs;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-connections/relayTunnelConnector.js
var require_relayTunnelConnector = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-connections/relayTunnelConnector.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RelayTunnelConnector = exports2.maxReconnectDelayMs = void 0;
    var dev_tunnels_ssh_1 = require_dev_tunnels_ssh();
    var utils_1 = require_utils();
    var sshHelpers_1 = require_sshHelpers();
    var retryingTunnelConnectionEventArgs_1 = require_retryingTunnelConnectionEventArgs();
    exports2.maxReconnectDelayMs = 13e3;
    var reconnectInitialDelayMs = 1e3;
    var maxBrowserReconnectAttempts = 5;
    var RelayTunnelConnector = class {
      constructor(tunnelSession) {
        this.tunnelSession = tunnelSession;
      }
      get trace() {
        return this.tunnelSession.trace;
      }
      /**
       * Connect or reconnect tunnel SSH session.
       * @param isReconnect A value indicating if this is a reconnect (true) or regular connect (false).
       * @param cancellation Cancellation token.
       */
      async connectSession(isReconnect, options, cancellation) {
        var _a2, _b;
        let disconnectReason;
        let error;
        function throwIfCancellation(e) {
          if (e instanceof dev_tunnels_ssh_1.CancellationError && (cancellation === null || cancellation === void 0 ? void 0 : cancellation.isCancellationRequested) || e instanceof dev_tunnels_ssh_1.ObjectDisposedError) {
            error = void 0;
            disconnectReason = dev_tunnels_ssh_1.SshDisconnectReason.byApplication;
            throw e;
          }
        }
        function throwError(message) {
          if (error) {
            error.message = message;
          } else {
            error = new Error(message);
          }
          throw error;
        }
        let browserReconnectAttempt = 0;
        let attemptDelayMs = reconnectInitialDelayMs;
        let isTunnelAccessTokenRefreshed = false;
        let isDelayNeeded = true;
        let errorDescription;
        this.tunnelSession.startConnecting();
        try {
          for (let attempt = 0; ; attempt++) {
            if (cancellation === null || cancellation === void 0 ? void 0 : cancellation.isCancellationRequested) {
              throw new dev_tunnels_ssh_1.CancellationError();
            }
            if (attempt > 0) {
              if (error) {
                if (!((_a2 = options === null || options === void 0 ? void 0 : options.enableRetry) !== null && _a2 !== void 0 ? _a2 : true)) {
                  throw error;
                }
                const args = new retryingTunnelConnectionEventArgs_1.RetryingTunnelConnectionEventArgs(error, attemptDelayMs);
                this.tunnelSession.onRetrying(args);
                if (!args.retry) {
                  throw error;
                }
                if (args.delayMs >= reconnectInitialDelayMs) {
                  attemptDelayMs = args.delayMs;
                } else {
                  isDelayNeeded = false;
                }
              }
              const retryTiming = isDelayNeeded ? ` in ${attemptDelayMs < 1e3 ? `0.${attemptDelayMs / 100}s` : `${attemptDelayMs / 1e3}s`}` : "";
              this.trace(dev_tunnels_ssh_1.TraceLevel.Verbose, 0, `Error connecting to tunnel SSH session, retrying${retryTiming}${errorDescription ? `: ${errorDescription}` : ""}`);
              if (isDelayNeeded) {
                try {
                  await (0, utils_1.delay)(attemptDelayMs, cancellation);
                } catch (e) {
                  throwIfCancellation(e);
                  throw e;
                }
                if (attemptDelayMs < exports2.maxReconnectDelayMs) {
                  attemptDelayMs = attemptDelayMs << 1;
                }
              }
            }
            isDelayNeeded = true;
            let stream = void 0;
            errorDescription = void 0;
            disconnectReason = dev_tunnels_ssh_1.SshDisconnectReason.connectionLost;
            error = void 0;
            try {
              const streamAndProtocol = await this.tunnelSession.createSessionStream(options, cancellation);
              stream = streamAndProtocol.stream;
              await this.tunnelSession.configureSession(stream, streamAndProtocol.protocol, isReconnect, cancellation);
              stream = void 0;
              disconnectReason = void 0;
              return;
            } catch (e) {
              if (!(e instanceof Error)) {
                throwError(`Failed to connect to the tunnel service and start tunnel SSH session: ${e}`);
              }
              throwIfCancellation(e);
              error = e;
              errorDescription = error.message;
              if (e instanceof sshHelpers_1.BrowserWebSocketRelayError) {
                if (browserReconnectAttempt++ >= maxBrowserReconnectAttempts) {
                  throw e;
                }
                continue;
              }
              if (e instanceof dev_tunnels_ssh_1.SshReconnectError) {
                disconnectReason = dev_tunnels_ssh_1.SshDisconnectReason.protocolError;
                isDelayNeeded = false;
                isReconnect = false;
                continue;
              }
              if (e instanceof dev_tunnels_ssh_1.SshConnectionError) {
                const reason = e.reason;
                if (reason === dev_tunnels_ssh_1.SshDisconnectReason.connectionLost) {
                  continue;
                }
                disconnectReason = reason || dev_tunnels_ssh_1.SshDisconnectReason.byApplication;
                throwError(`Failed to start tunnel SSH session: ${errorDescription}`);
              }
              if (e instanceof sshHelpers_1.RelayConnectionError) {
                const statusCode = (_b = e.errorContext) === null || _b === void 0 ? void 0 : _b.statusCode;
                const statusCodeText = statusCode ? ` (${statusCode})` : "";
                switch (errorDescription) {
                  case "error.relayClientUnauthorized": {
                    const notAuthorizedText = "Not authorized" + statusCodeText;
                    disconnectReason = dev_tunnels_ssh_1.SshDisconnectReason.authCancelledByUser;
                    if (isTunnelAccessTokenRefreshed) {
                      throwError(`${notAuthorizedText}. Refreshed tunnel access token also does not work.`);
                    }
                    try {
                      isTunnelAccessTokenRefreshed = await this.tunnelSession.refreshTunnelAccessToken(cancellation);
                    } catch (refreshError) {
                      throwIfCancellation(refreshError);
                      throwError(`${notAuthorizedText}. Refreshing tunnel access token failed with error ${(0, utils_1.getErrorMessage)(refreshError)}`);
                    }
                    if (!isTunnelAccessTokenRefreshed) {
                      throwError(`${notAuthorizedText}. Provide a fresh tunnel access token with '${this.tunnelSession.tunnelAccessScope}' scope.`);
                    }
                    isDelayNeeded = false;
                    errorDescription = "The tunnel access token was no longer valid and had just been refreshed.";
                    continue;
                  }
                  case "error.relayClientForbidden":
                    disconnectReason = dev_tunnels_ssh_1.SshDisconnectReason.authCancelledByUser;
                    throwError(`Forbidden${statusCodeText}. Provide a fresh tunnel access token with '${this.tunnelSession.tunnelAccessScope}' scope.`);
                    break;
                  case "error.tunnelPortNotFound":
                    throwError(`The tunnel or port is not found${statusCodeText}`);
                    break;
                  // Normally nginx choses another healthy pod when it cannot establish connection to a pod.
                  // However, if there are no other pods, it may returns 502 (Bad Gateway) to the client.
                  // This rare case may happen when the cluster recovers from a failure
                  // and the nginx controller has started but Relay service has not yet.
                  // 503 (Service Unavailable) can happen when Relay calls control plane to authenticate the request,
                  // control plane hits 429s from Cosmos DB and replies back with 503.
                  // 429 (Too Many Requests) can happen if client exceeds request rate limits.
                  case "error.badGateway":
                  case "error.serviceUnavailable":
                  case "error.tooManyRequests":
                    errorDescription = errorDescription === "error.tooManyRequests" ? `Rate limit exceeded${statusCodeText}. Too many requests in a given amount of time.` : `Service temporarily unavailable${statusCodeText}`;
                    disconnectReason = dev_tunnels_ssh_1.SshDisconnectReason.serviceNotAvailable;
                    if (attempt > 3) {
                      throwError(errorDescription);
                    }
                    if (attemptDelayMs < exports2.maxReconnectDelayMs / 2) {
                      attemptDelayMs = exports2.maxReconnectDelayMs / 2;
                    }
                    continue;
                  default:
                    if (errorDescription === null || errorDescription === void 0 ? void 0 : errorDescription.startsWith("error.relayConnectionError ")) {
                      const recoverableError = recoverableNetworkErrors.find((s) => errorDescription.includes(s));
                      if (recoverableError) {
                        errorDescription = `Failed to connect to Relay server: ${recoverableError}`;
                        continue;
                      }
                    }
                }
              }
              throw e;
            } finally {
              if (error && disconnectReason && !error.reason) {
                error.reason = disconnectReason;
              }
              if (disconnectReason) {
                await this.tunnelSession.closeSession(disconnectReason, error);
              }
              if (stream) {
                await stream.close(error);
              }
            }
          }
        } finally {
          this.tunnelSession.finishConnecting(disconnectReason, error);
        }
      }
    };
    exports2.RelayTunnelConnector = RelayTunnelConnector;
    var recoverableNetworkErrors = [
      "ECONNRESET",
      "ENOTFOUND",
      "ESOCKETTIMEDOUT",
      "ETIMEDOUT",
      "ECONNREFUSED",
      "EHOSTUNREACH",
      "EPIPE",
      "EAI_AGAIN",
      "EBUSY"
    ];
  }
});

// ../../node_modules/@microsoft/dev-tunnels-connections/messages/portRelayRequestMessage.js
var require_portRelayRequestMessage = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-connections/messages/portRelayRequestMessage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PortRelayRequestMessage = void 0;
    var dev_tunnels_ssh_tcp_1 = require_dev_tunnels_ssh_tcp();
    var PortRelayRequestMessage = class extends dev_tunnels_ssh_tcp_1.PortForwardRequestMessage {
      onWrite(writer) {
        super.onWrite(writer);
        if (!this.accessToken) {
          throw new Error("An access token is required.");
        }
        writer.writeString(this.accessToken, "utf8");
      }
      onRead(reader) {
        super.onRead(reader);
        this.accessToken = reader.readString("utf8");
      }
    };
    exports2.PortRelayRequestMessage = PortRelayRequestMessage;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-connections/messages/portRelayConnectRequestMessage.js
var require_portRelayConnectRequestMessage = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-connections/messages/portRelayConnectRequestMessage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PortRelayConnectRequestMessage = void 0;
    var dev_tunnels_ssh_tcp_1 = require_dev_tunnels_ssh_tcp();
    var PortRelayConnectRequestMessage = class extends dev_tunnels_ssh_tcp_1.PortForwardChannelOpenMessage {
      constructor() {
        super(...arguments);
        this.isE2EEncryptionRequested = false;
      }
      onWrite(writer) {
        var _a2;
        super.onWrite(writer);
        writer.writeString((_a2 = this.accessToken) !== null && _a2 !== void 0 ? _a2 : "", "utf8");
        writer.writeBoolean(this.isE2EEncryptionRequested);
      }
      onRead(reader) {
        super.onRead(reader);
        this.accessToken = reader.readString("utf8");
        this.isE2EEncryptionRequested = reader.readBoolean();
      }
    };
    exports2.PortRelayConnectRequestMessage = PortRelayConnectRequestMessage;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-connections/refreshingTunnelEventArgs.js
var require_refreshingTunnelEventArgs = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-connections/refreshingTunnelEventArgs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RefreshingTunnelEventArgs = void 0;
    var RefreshingTunnelEventArgs = class {
      /**
       * Creates a new instance of RefreshingTunnelAccessTokenEventArgs class.
       */
      constructor(tunnelAccessScope, tunnel, includePorts, managementClient, cancellation) {
        this.tunnelAccessScope = tunnelAccessScope;
        this.tunnel = tunnel;
        this.includePorts = includePorts;
        this.managementClient = managementClient;
        this.cancellation = cancellation;
      }
    };
    exports2.RefreshingTunnelEventArgs = RefreshingTunnelEventArgs;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-connections/tunnelConnectionSession.js
var require_tunnelConnectionSession = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-connections/tunnelConnectionSession.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TunnelConnectionSession = void 0;
    var dev_tunnels_contracts_1 = require_dev_tunnels_contracts();
    var dev_tunnels_management_1 = require_dev_tunnels_management();
    var dev_tunnels_ssh_1 = require_dev_tunnels_ssh();
    var vscode_jsonrpc_1 = require_main();
    var connectionStatus_1 = require_connectionStatus();
    var relayTunnelConnector_1 = require_relayTunnelConnector();
    var utils_1 = require_utils();
    var tunnelConnectionBase_1 = require_tunnelConnectionBase();
    var dev_tunnels_ssh_tcp_1 = require_dev_tunnels_ssh_tcp();
    var portRelayRequestMessage_1 = require_portRelayRequestMessage();
    var portRelayConnectRequestMessage_1 = require_portRelayConnectRequestMessage();
    var refreshingTunnelEventArgs_1 = require_refreshingTunnelEventArgs();
    var defaultTunnelRelayStreamFactory_1 = require_defaultTunnelRelayStreamFactory();
    var uuid_1 = require_uuid();
    var TunnelConnectionSession = class extends tunnelConnectionBase_1.TunnelConnectionBase {
      /**
       * Name of the protocol used to connect to the tunnel.
       */
      get connectionProtocol() {
        return this.connectionProtocolValue;
      }
      set connectionProtocol(value) {
        this.connectionProtocolValue = value;
      }
      /**
       * Gets an ID that is unique to this instance of `TunnelConnectionSession`,
       * useful for correlating connection events over time.
       */
      get connectionId() {
        return this.uniqueConnectionId;
      }
      /**
       * A value indicating if this is a client tunnel connection (as opposed to host connection).
       */
      get isClientConnection() {
        return this.tunnelAccessScope === dev_tunnels_contracts_1.TunnelAccessScopes.Connect;
      }
      /**
       * tunnel connection role, either "client", or "host", depending on @link tunnelAccessScope.
       */
      get connectionRole() {
        return this.isClientConnection ? "client" : "host";
      }
      /**
       * @internal onRetrying override to report tunnel events.
       */
      onRetrying(event) {
        var _a2;
        if (this.tunnel && this.managementClient) {
          const retryingEvent = {
            name: `${this.connectionRole}_connect_retrying`,
            severity: dev_tunnels_contracts_1.TunnelEvent.warning,
            details: (_a2 = event.error) === null || _a2 === void 0 ? void 0 : _a2.toString(),
            properties: {
              "Retry": event.retry.toString(),
              "Delay": event.delayMs.toString()
            }
          };
          this.managementClient.reportEvent(this.tunnel, retryingEvent);
        }
        super.onRetrying(event);
      }
      /**
       * @internal onConnectionStatusChanged override to report tunnel events.
       */
      onConnectionStatusChanged(previousStatus, status) {
        if (this.tunnel && this.managementClient) {
          const statusEvent = {
            name: `${this.connectionRole}_connection_status`,
            severity: dev_tunnels_contracts_1.TunnelEvent.info,
            details: void 0,
            properties: {
              ConnectionStatus: status.toString(),
              PreviousConnectionStatus: previousStatus.toString()
            }
          };
          if (previousStatus !== connectionStatus_1.ConnectionStatus.None) {
            const duration = Date.now() - this.connectionStartTime;
            const formattedDuration = new Date(duration).toISOString().substring(11, 23);
            statusEvent.properties[`${previousStatus}Duration`] = formattedDuration;
          }
          if (this.isClientConnection) {
            statusEvent.properties.ClientSessionId = this.getShortSessionId(this.sshSession);
          } else {
            statusEvent.properties.HostSessionId = this.connectionId;
          }
          this.managementClient.reportEvent(this.tunnel, statusEvent);
        }
        this.connectionStartTime = Date.now();
        super.onConnectionStatusChanged(previousStatus, status);
      }
      constructor(tunnelAccessScope, connectionProtocols, managementClient, trace) {
        super(tunnelAccessScope);
        this.connectionProtocols = connectionProtocols;
        this.managementClient = managementClient;
        this.connectedTunnel = null;
        this.connectionStartTime = Date.now();
        this.uniqueConnectionId = (0, uuid_1.v4)();
        this.refreshingTunnelEmitter = new utils_1.TrackingEmitter();
        this.reportProgressEmitter = new vscode_jsonrpc_1.Emitter();
        this.onReportProgress = this.reportProgressEmitter.event;
        this.streamFactory = new defaultTunnelRelayStreamFactory_1.DefaultTunnelRelayStreamFactory();
        this.sshSessionDisposables = [];
        this.refreshingTunnel = this.refreshingTunnelEmitter.event;
        this.enableE2EEncryption = true;
        this.trace = trace !== null && trace !== void 0 ? trace : (() => {
        });
        this.httpAgent = managementClient === null || managementClient === void 0 ? void 0 : managementClient.httpsAgent;
      }
      /* @internal */
      raiseReportProgress(progress, sessionNumber) {
        const args = {
          progress,
          sessionNumber
        };
        this.reportProgressEmitter.fire(args);
      }
      /**
       * Get the tunnel of this tunnel connection.
       */
      get tunnel() {
        return this.connectedTunnel;
      }
      set tunnel(value) {
        if (value !== this.connectedTunnel) {
          this.connectedTunnel = value;
          this.tunnelChanged();
        }
      }
      /**
       * Tunnel has been assigned to or changed.
       */
      tunnelChanged() {
        if (this.tunnel) {
          this.accessToken = dev_tunnels_management_1.TunnelAccessTokenProperties.getTunnelAccessToken(this.tunnel, this.tunnelAccessScope);
        } else {
          this.accessToken = void 0;
        }
      }
      /**
       * Gets a value indicating that this connection has already created its connector
       * and so can be reconnected if needed.
       */
      get isReconnectable() {
        return !!this.connector;
      }
      /**
       * Gets the disconnection reason.
       * {@link SshDisconnectReason.none } if not yet disconnected.
       * {@link SshDisconnectReason.connectionLost} if network connection was lost and reconnects are not enabled or unsuccesfull.
       * {@link SshDisconnectReason.byApplication} if connection was disposed.
       * {@link SshDisconnectReason.tooManyConnections} if host connection was disconnected because another host connected for the same tunnel.
       */
      get disconnectReason() {
        return this.disconnectionReason;
      }
      /**
       * Sets the disconnect reason that caused disconnection.
       */
      set disconnectReason(reason) {
        this.disconnectionReason = reason;
      }
      /**
       * @internal Creates a stream to the tunnel.
       */
      async createSessionStream(options, cancellation) {
        if (!this.relayUri) {
          throw new Error("Cannot create tunnel session stream. Tunnel relay endpoint URI is missing");
        }
        if (this.isClientConnection) {
          this.raiseReportProgress(dev_tunnels_ssh_1.Progress.OpeningClientConnectionToRelay);
        } else {
          this.raiseReportProgress(dev_tunnels_ssh_1.Progress.OpeningHostConnectionToRelay);
        }
        this.trace(dev_tunnels_ssh_1.TraceLevel.Info, 0, `Connecting to ${this.connectionRole} tunnel relay ${this.relayUri}`);
        this.trace(dev_tunnels_ssh_1.TraceLevel.Verbose, 0, `Sec-WebSocket-Protocol: ${this.connectionProtocols.join(", ")}`);
        if (this.accessToken) {
          const tokenTrace = dev_tunnels_management_1.TunnelAccessTokenProperties.getTokenTrace(this.accessToken);
          this.trace(dev_tunnels_ssh_1.TraceLevel.Verbose, 0, `Authorization: tunnel <${tokenTrace}>`);
        }
        const clientConfig = {
          tlsOptions: {
            agent: this.httpAgent
          }
        };
        const streamAndProtocol = await this.streamFactory.createRelayStream(this.relayUri, this.connectionProtocols, this.accessToken, clientConfig);
        this.trace(dev_tunnels_ssh_1.TraceLevel.Verbose, 0, `Connected with subprotocol '${streamAndProtocol.protocol}'`);
        if (this.isClientConnection) {
          this.raiseReportProgress(dev_tunnels_ssh_1.Progress.OpenedClientConnectionToRelay);
        } else {
          this.raiseReportProgress(dev_tunnels_ssh_1.Progress.OpenedHostConnectionToRelay);
        }
        return streamAndProtocol;
      }
      /**
       * @internal Configures the tunnel session with the given stream.
       */
      configureSession(stream, protocol, isReconnect, cancellation) {
        throw new Error("Not implemented");
      }
      /**
       * @internal Closes the tunnel session due to an error.
       */
      async closeSession(reason, error) {
        this.unsubscribeSessionEvents();
        const session = this.sshSession;
        if (!session) {
          return;
        }
        if (!session.isClosed) {
          await session.close(reason || dev_tunnels_ssh_1.SshDisconnectReason.none, void 0, error);
        } else {
          this.sshSession = void 0;
        }
        session.dispose();
      }
      /**
       * Disposes this tunnel session, closing the SSH session used for it.
       */
      async dispose() {
        if (this.disconnectReason === dev_tunnels_ssh_1.SshDisconnectReason.none || this.disconnectReason === void 0) {
          this.disconnectReason = dev_tunnels_ssh_1.SshDisconnectReason.byApplication;
        }
        await super.dispose();
        try {
          await this.closeSession(this.disconnectReason, this.disconnectError);
        } catch (e) {
          if (!(e instanceof dev_tunnels_ssh_1.ObjectDisposedError))
            throw e;
        }
      }
      /**
       * Refreshes the tunnel access token. This may be useful when the Relay service responds with 401 Unauthorized.
       * Does nothing if the object is disposed, or there is no way to refresh the token.
       * @internal
       */
      async refreshTunnelAccessToken(cancellation) {
        var _a2;
        if (this.isDisposed) {
          return false;
        }
        if (!this.isRefreshingTunnelAccessTokenEventHandled && !this.canRefreshTunnel) {
          return false;
        }
        this.connectionStatus = connectionStatus_1.ConnectionStatus.RefreshingTunnelAccessToken;
        try {
          this.traceVerbose(`Refreshing tunnel access token. Current token: ${dev_tunnels_management_1.TunnelAccessTokenProperties.getTokenTrace(this.accessToken)}`);
          if (this.isRefreshingTunnelAccessTokenEventHandled) {
            this.accessToken = (_a2 = await this.getFreshTunnelAccessToken(cancellation)) !== null && _a2 !== void 0 ? _a2 : void 0;
          } else {
            await this.refreshTunnel(false, cancellation);
          }
          this.traceVerbose(`Refreshed tunnel access token. New token: ${dev_tunnels_management_1.TunnelAccessTokenProperties.getTokenTrace(this.accessToken)}`);
          return true;
        } finally {
          this.connectionStatus = connectionStatus_1.ConnectionStatus.Connecting;
        }
      }
      /**
       * @internal Start connecting relay client.
       */
      startConnecting() {
        this.connectionStatus = connectionStatus_1.ConnectionStatus.Connecting;
      }
      /**
       * @internal Finish connecting relay client.
       */
      finishConnecting(reason, disconnectError) {
        if (reason === void 0 || reason === dev_tunnels_ssh_1.SshDisconnectReason.none) {
          if (this.connectionStatus === connectionStatus_1.ConnectionStatus.Connecting) {
            this.disconnectError = void 0;
            this.disconnectReason = void 0;
          }
          this.connectionStatus = connectionStatus_1.ConnectionStatus.Connected;
        } else if (this.connectionStatus !== connectionStatus_1.ConnectionStatus.Disconnected) {
          this.disconnectReason = reason;
          if (disconnectError) {
            this.disconnectError = disconnectError;
          }
          this.connectionStatus = connectionStatus_1.ConnectionStatus.Disconnected;
        }
      }
      /**
       * Get a value indicating whether this session can attempt refreshing tunnel.
       * Note: tunnel refresh may still fail if the tunnel doesn't exist in the service,
       * tunnel access has changed, or tunnel access token has expired.
       */
      get canRefreshTunnel() {
        return this.tunnel && this.managementClient || this.refreshingTunnelEmitter.isSubscribed;
      }
      /**
       * Fetch the tunnel from the service if {@link managementClient} and {@link tunnel} are set.
       */
      async refreshTunnel(includePorts, cancellation) {
        this.traceInfo("Refreshing tunnel.");
        let isRefreshed = false;
        const e = new refreshingTunnelEventArgs_1.RefreshingTunnelEventArgs(this.tunnelAccessScope, this.tunnel, !!includePorts, this.managementClient, cancellation);
        this.refreshingTunnelEmitter.fire(e);
        if (e.tunnelPromise) {
          this.tunnel = await e.tunnelPromise;
          isRefreshed = true;
        }
        if (!isRefreshed && this.tunnel && this.managementClient) {
          const options = {
            tokenScopes: [this.tunnelAccessScope],
            includePorts
          };
          this.tunnel = await (0, utils_1.withCancellation)(this.managementClient.getTunnel(this.tunnel, options), cancellation);
          isRefreshed = true;
        }
        if (isRefreshed) {
          if (this.tunnel) {
            this.traceInfo("Refreshed tunnel.");
          } else {
            this.traceInfo("Tunnel not found.");
          }
        }
        return true;
      }
      /**
       * Creates a tunnel connector
       */
      createTunnelConnector() {
        return new relayTunnelConnector_1.RelayTunnelConnector(this);
      }
      /**
       * Trace info message.
       */
      traceInfo(msg) {
        this.trace(dev_tunnels_ssh_1.TraceLevel.Info, 0, msg);
      }
      /**
       * Trace verbose message.
       */
      traceVerbose(msg) {
        this.trace(dev_tunnels_ssh_1.TraceLevel.Verbose, 0, msg);
      }
      /**
       * Trace warning message.
       */
      traceWarning(msg, err) {
        this.trace(dev_tunnels_ssh_1.TraceLevel.Warning, 0, msg, err);
      }
      /**
       * Trace error message.
       */
      traceError(msg, err) {
        this.trace(dev_tunnels_ssh_1.TraceLevel.Error, 0, msg, err);
      }
      /**
       * SSH session closed event handler. Child classes may use it unsubscribe session events and maybe start reconnecting.
       */
      onSshSessionClosed(e) {
        this.unsubscribeSessionEvents();
        this.sshSession = void 0;
        this.maybeStartReconnecting(e.reason, e.message, e.error);
      }
      /**
       * Start reconnecting if the tunnel connection is not yet disposed.
       */
      maybeStartReconnecting(reason, message, error) {
        var _a2, _b, _c, _d;
        const traceMessage = `Connection to ${this.connectionRole} tunnel relay closed.${this.getDisconnectReason(reason, message, error)}`;
        if (this.isDisposed || this.connectionStatus === connectionStatus_1.ConnectionStatus.Disconnected) {
          this.traceInfo(traceMessage);
          return;
        }
        if (error) {
          this.disconnectError = error;
          this.disconnectReason = reason;
        }
        if (this.connectionStatus !== connectionStatus_1.ConnectionStatus.Connected || this.reconnectPromise) {
          this.traceInfo(traceMessage);
          return;
        }
        if (((_b = (_a2 = this.connectionOptions) === null || _a2 === void 0 ? void 0 : _a2.enableReconnect) !== null && _b !== void 0 ? _b : true) && reason === dev_tunnels_ssh_1.SshDisconnectReason.connectionLost && this.connector) {
          if (this.tunnel && this.managementClient) {
            const reconnectEvent = {
              name: `${this.connectionRole}_reconnect`,
              severity: dev_tunnels_contracts_1.TunnelEvent.warning,
              details: (_c = error === null || error === void 0 ? void 0 : error.toString()) !== null && _c !== void 0 ? _c : message,
              properties: {
                ClientSessionId: this.getShortSessionId(this.sshSession)
              }
            };
            this.managementClient.reportEvent(this.tunnel, reconnectEvent);
          }
          this.traceInfo(`${traceMessage} Reconnecting.`);
          this.reconnectPromise = (async () => {
            try {
              await this.connectTunnelSession();
            } catch (ex) {
              if (this.tunnel && this.managementClient) {
                const reconnectFailedEvent = {
                  name: `${this.connectionRole}_reconnect_failed`,
                  severity: dev_tunnels_contracts_1.TunnelEvent.error,
                  details: ex instanceof Error ? ex.toString() : String(ex),
                  properties: {
                    ClientSessionId: this.getShortSessionId(this.sshSession)
                  }
                };
                this.managementClient.reportEvent(this.tunnel, reconnectFailedEvent);
              }
            }
            this.reconnectPromise = void 0;
          })();
        } else {
          if (this.tunnel && this.managementClient) {
            const disconnectEvent = {
              name: `${this.connectionRole}_disconnect`,
              severity: dev_tunnels_contracts_1.TunnelEvent.warning,
              details: (_d = error === null || error === void 0 ? void 0 : error.toString()) !== null && _d !== void 0 ? _d : message,
              properties: {
                ClientSessionId: this.getShortSessionId(this.sshSession)
              }
            };
            this.managementClient.reportEvent(this.tunnel, disconnectEvent);
          }
          this.traceInfo(traceMessage);
          this.connectionStatus = connectionStatus_1.ConnectionStatus.Disconnected;
        }
      }
      /**
       * Get a user-readable reason for SSH session disconnection, or an empty string.
       */
      getDisconnectReason(reason, message, error) {
        switch (reason) {
          case dev_tunnels_ssh_1.SshDisconnectReason.connectionLost:
            return ` ${message || (error === null || error === void 0 ? void 0 : error.message) || "Connection lost."}`;
          case dev_tunnels_ssh_1.SshDisconnectReason.authCancelledByUser:
          case dev_tunnels_ssh_1.SshDisconnectReason.noMoreAuthMethodsAvailable:
          case dev_tunnels_ssh_1.SshDisconnectReason.hostNotAllowedToConnect:
          case dev_tunnels_ssh_1.SshDisconnectReason.illegalUserName:
            return " Not authorized.";
          case dev_tunnels_ssh_1.SshDisconnectReason.serviceNotAvailable:
            return " Service not available.";
          case dev_tunnels_ssh_1.SshDisconnectReason.compressionError:
          case dev_tunnels_ssh_1.SshDisconnectReason.keyExchangeFailed:
          case dev_tunnels_ssh_1.SshDisconnectReason.macError:
          case dev_tunnels_ssh_1.SshDisconnectReason.protocolError:
            return " Protocol error.";
          case dev_tunnels_ssh_1.SshDisconnectReason.tooManyConnections:
            return this.isClientConnection ? " Too many client connections." : " Another host for the tunnel has connected.";
          default:
            return "";
        }
      }
      /**
       * Connect to the tunnel session by running the provided {@link action}.
       */
      async connectSession(action) {
        try {
          await action();
        } catch (e) {
          if (!(e instanceof dev_tunnels_ssh_1.CancellationError)) {
            if (e instanceof Error) {
              this.traceError(`Error connecting ${this.connectionRole} tunnel session: ${e.message}`, e);
            } else {
              const message = `Error connecting ${this.connectionRole} tunnel session: ${e}`;
              this.traceError(message);
            }
            if (this.tunnel && this.managementClient) {
              const connectFailedEvent = {
                name: `${this.connectionRole}_connect_failed`,
                severity: dev_tunnels_contracts_1.TunnelEvent.error,
                details: e instanceof Error ? e.toString() : String(e)
              };
              this.managementClient.reportEvent(this.tunnel, connectFailedEvent);
            }
          }
          throw e;
        }
      }
      /**
       * Connect to the tunnel session with the tunnel connector.
       * @param tunnel Tunnel to use for the connection.
       *     Undefined if the connection information is already known and the tunnel is not needed.
       *     Tunnel object to get the connection information from that tunnel.
       */
      async connectTunnelSession(tunnel, options, cancellation) {
        var _a2;
        if (tunnel) {
          this.tunnel = tunnel;
        }
        if (options) {
          this.connectionOptions = options;
          (_a2 = this.httpAgent) !== null && _a2 !== void 0 ? _a2 : this.httpAgent = options === null || options === void 0 ? void 0 : options.httpAgent;
        }
        await this.connectSession(async () => {
          const isReconnect = this.isReconnectable && !tunnel;
          await this.onConnectingToTunnel();
          if (!this.connector) {
            this.connector = this.createTunnelConnector();
          }
          const disposables = [];
          if (cancellation) {
            const linkedCancellationSource = new vscode_jsonrpc_1.CancellationTokenSource();
            disposables.push(linkedCancellationSource, cancellation.onCancellationRequested(() => linkedCancellationSource.cancel()), this.disposeToken.onCancellationRequested(() => linkedCancellationSource.cancel()));
            cancellation = linkedCancellationSource.token;
          } else {
            cancellation = this.disposeToken;
          }
          try {
            await this.connector.connectSession(isReconnect, options, cancellation);
          } catch (e) {
            if (e instanceof dev_tunnels_ssh_1.CancellationError) {
              this.throwIfDisposed(`CancelationError: ${e.message}`, e.stack);
            }
            throw e;
          } finally {
            for (const disposable of disposables)
              disposable.dispose();
          }
        });
      }
      /**
       * Validate the {@link tunnel} and get data needed to connect to it, if the tunnel is provided;
       * otherwise, ensure that there is already sufficient data to connect to a tunnel.
       */
      onConnectingToTunnel() {
        return Promise.resolve();
      }
      /**
       * Validates tunnel access token if it's present. Returns the token.
       * Note: uses client's system time for the validation.
       */
      validateAccessToken() {
        if (this.accessToken) {
          dev_tunnels_management_1.TunnelAccessTokenProperties.validateTokenExpiration(this.accessToken);
          return this.accessToken;
        }
      }
      /** @internal */
      createRequestMessageAsync(port) {
        const message = new portRelayRequestMessage_1.PortRelayRequestMessage();
        message.accessToken = this.accessToken;
        return Promise.resolve(message);
      }
      /** @internal */
      createSuccessMessageAsync(port) {
        const message = new dev_tunnels_ssh_tcp_1.PortForwardSuccessMessage();
        return Promise.resolve(message);
      }
      /** @internal */
      createChannelOpenMessageAsync(port) {
        const message = new portRelayConnectRequestMessage_1.PortRelayConnectRequestMessage();
        message.accessToken = this.accessToken;
        message.isE2EEncryptionRequested = this.enableE2EEncryption;
        return Promise.resolve(message);
      }
      /**
       * Unsubscribe SSH session events in @link TunnelSshConnectionSession.sshSessionDisposables
       */
      unsubscribeSessionEvents() {
        this.sshSessionDisposables.forEach((d) => d.dispose());
        this.sshSessionDisposables = [];
      }
      /** @internal */
      getShortSessionId(session) {
        const b = session === null || session === void 0 ? void 0 : session.sessionId;
        if (!b || b.length < 16) {
          return "";
        }
        return b.subarray(0, 4).toString("hex") + "-" + b.subarray(4, 6).toString("hex") + "-" + b.subarray(6, 8).toString("hex") + "-" + b.subarray(8, 10).toString("hex") + "-" + b.subarray(10, 16).toString("hex");
      }
    };
    exports2.TunnelConnectionSession = TunnelConnectionSession;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-connections/portForwardingEventArgs.js
var require_portForwardingEventArgs = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-connections/portForwardingEventArgs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PortForwardingEventArgs = void 0;
    var PortForwardingEventArgs = class {
      /**
       * Creates a new instance of PortForwardingEventArgs.
       */
      constructor(portNumber) {
        this.portNumber = portNumber;
        this.cancel = false;
      }
    };
    exports2.PortForwardingEventArgs = PortForwardingEventArgs;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-connections/tunnelRelayTunnelClient.js
var require_tunnelRelayTunnelClient = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-connections/tunnelRelayTunnelClient.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TunnelRelayTunnelClient = exports2.webSocketSubProtocolv2 = exports2.webSocketSubProtocol = void 0;
    var dev_tunnels_contracts_1 = require_dev_tunnels_contracts();
    var dev_tunnels_ssh_1 = require_dev_tunnels_ssh();
    var dev_tunnels_ssh_tcp_1 = require_dev_tunnels_ssh_tcp();
    var retryTcpListenerFactory_1 = require_retryTcpListenerFactory();
    var sshHelpers_1 = require_sshHelpers();
    var utils_1 = require_utils();
    var vscode_jsonrpc_1 = require_main();
    var portRelayConnectResponseMessage_1 = require_portRelayConnectResponseMessage();
    var tunnelConnectionSession_1 = require_tunnelConnectionSession();
    var portForwardingEventArgs_1 = require_portForwardingEventArgs();
    exports2.webSocketSubProtocol = "tunnel-relay-client";
    exports2.webSocketSubProtocolv2 = "tunnel-relay-client-v2-dev";
    var protocolVersion = (process === null || process === void 0 ? void 0 : process.env) && process.env.DEVTUNNELS_PROTOCOL_VERSION;
    var connectionProtocols = protocolVersion === "1" ? [exports2.webSocketSubProtocol] : protocolVersion === "2" ? [exports2.webSocketSubProtocolv2] : [exports2.webSocketSubProtocolv2, exports2.webSocketSubProtocol];
    var TunnelRelayTunnelClient = class extends tunnelConnectionSession_1.TunnelConnectionSession {
      constructor(managementClient, trace) {
        super(dev_tunnels_contracts_1.TunnelAccessScopes.Connect, connectionProtocols, managementClient, trace);
        this.portForwardingEmitter = new vscode_jsonrpc_1.Emitter();
        this.sshSessionClosedEmitter = new vscode_jsonrpc_1.Emitter();
        this.acceptLocalConnectionsForForwardedPortsValue = (0, sshHelpers_1.isNode)();
        this.localForwardingHostAddressValue = "127.0.0.1";
        this.disconnectedStreams = /* @__PURE__ */ new Map();
        this.connectionModes = [];
        this.portForwarding = this.portForwardingEmitter.event;
        this.sshSessionClosed = this.sshSessionClosedEmitter.event;
      }
      get isSshSessionActive() {
        var _a2;
        return !!((_a2 = this.sshSession) === null || _a2 === void 0 ? void 0 : _a2.isConnected);
      }
      /**
       * Get a value indicating if remote port is forwarded and has any channels open on the client,
       * whether used by local tcp listener if {AcceptLocalConnectionsForForwardedPorts} is true, or
       * streamed via <see cref="ConnectToForwardedPortAsync(int, CancellationToken)"/>.
       */
      hasForwardedChannels(port) {
        var _a2;
        if (!this.isSshSessionActive) {
          return false;
        }
        const pfs = (_a2 = this.sshSession) === null || _a2 === void 0 ? void 0 : _a2.activateService(dev_tunnels_ssh_tcp_1.PortForwardingService);
        const remoteForwardedPorts = pfs === null || pfs === void 0 ? void 0 : pfs.remoteForwardedPorts;
        const forwardedPort = remoteForwardedPorts === null || remoteForwardedPorts === void 0 ? void 0 : remoteForwardedPorts.find((p) => p.remotePort === port);
        return !!forwardedPort && remoteForwardedPorts.getChannels(forwardedPort).length > 0;
      }
      /**
       * A value indicating whether local connections for forwarded ports are accepted.
       * Local connections are not accepted if the host is not NodeJS (e.g. browser).
       */
      get acceptLocalConnectionsForForwardedPorts() {
        return this.acceptLocalConnectionsForForwardedPortsValue;
      }
      set acceptLocalConnectionsForForwardedPorts(value) {
        if (value === this.acceptLocalConnectionsForForwardedPortsValue) {
          return;
        }
        if (value && !(0, sshHelpers_1.isNode)()) {
          throw new Error("Cannot accept local connections for forwarded ports on this platform.");
        }
        this.acceptLocalConnectionsForForwardedPortsValue = value;
        this.configurePortForwardingService();
      }
      /**
       * Gets the local network interface address that the tunnel client listens on when
       * accepting connections for forwarded ports.
       */
      get localForwardingHostAddress() {
        return this.localForwardingHostAddressValue;
      }
      set localForwardingHostAddress(value) {
        if (value !== this.localForwardingHostAddressValue) {
          this.localForwardingHostAddressValue = value;
          this.configurePortForwardingService();
        }
      }
      get forwardedPorts() {
        var _a2;
        const pfs = (_a2 = this.sshSession) === null || _a2 === void 0 ? void 0 : _a2.activateService(dev_tunnels_ssh_tcp_1.PortForwardingService);
        return pfs === null || pfs === void 0 ? void 0 : pfs.remoteForwardedPorts;
      }
      async connect(tunnel, options, cancellation) {
        this.hostId = options === null || options === void 0 ? void 0 : options.hostId;
        await this.connectTunnelSession(tunnel, options, cancellation);
      }
      tunnelChanged() {
        var _a2;
        super.tunnelChanged();
        this.endpoints = void 0;
        if (this.tunnel) {
          if (!this.tunnel.endpoints) {
            throw new Error("Tunnel endpoints cannot be null");
          }
          if (this.tunnel.endpoints.length === 0) {
            throw new Error("No hosts are currently accepting connections for the tunnel.");
          }
          const endpointGroups = utils_1.List.groupBy(this.tunnel.endpoints, (ep) => ep.hostId);
          if (this.hostId) {
            this.endpoints = endpointGroups.get(this.hostId);
            if (!this.endpoints) {
              throw new Error("The specified host is not currently accepting connections to the tunnel.");
            }
          } else if (endpointGroups.size > 1) {
            throw new Error("There are multiple hosts for the tunnel. Specify a host ID to connect to.");
          } else {
            this.endpoints = (_a2 = endpointGroups.entries().next().value) === null || _a2 === void 0 ? void 0 : _a2[1];
          }
          const tunnelEndpoints = this.endpoints.filter((ep) => ep.connectionMode === dev_tunnels_contracts_1.TunnelConnectionMode.TunnelRelay);
          if (tunnelEndpoints.length === 0) {
            throw new Error("The host is not currently accepting Tunnel relay connections.");
          }
          const endpoint = tunnelEndpoints[0];
          this.hostPublicKeys = endpoint.hostPublicKeys;
          this.relayUri = endpoint.clientRelayUri;
        } else {
          this.relayUri = void 0;
        }
      }
      onRequest(e) {
        if (e.request.requestType === dev_tunnels_ssh_tcp_1.PortForwardingService.portForwardRequestType) {
          const request = e.request;
          const args = new portForwardingEventArgs_1.PortForwardingEventArgs(request.port);
          this.portForwardingEmitter.fire(args);
          e.isAuthorized = !args.cancel;
        } else if (e.request.requestType === dev_tunnels_ssh_tcp_1.PortForwardingService.cancelPortForwardRequestType) {
          e.isAuthorized = true;
        }
      }
      /**
       * Configures the tunnel session with the given stream.
       * @internal
       */
      async configureSession(stream, protocol, isReconnect, cancellation) {
        this.connectionProtocol = protocol;
        if (isReconnect && this.sshSession && !this.sshSession.isClosed) {
          await this.sshSession.reconnect(stream, cancellation);
        } else {
          await this.startSshSession(stream, cancellation);
        }
      }
      startSshSession(stream, cancellation) {
        return this.connectSession(async () => {
          this.sshSession = sshHelpers_1.SshHelpers.createSshClientSession((config) => {
            var _a2;
            config.addService(dev_tunnels_ssh_tcp_1.PortForwardingService);
            if (this.connectionProtocol === exports2.webSocketSubProtocol) {
              config.protocolExtensions.push(dev_tunnels_ssh_1.SshProtocolExtensionNames.sessionReconnect);
            } else {
              config.keyExchangeAlgorithms.splice(0, 0, dev_tunnels_ssh_1.SshAlgorithms.keyExchange.none);
            }
            const keepAliveInterval = (_a2 = this.connectionOptions) === null || _a2 === void 0 ? void 0 : _a2.keepAliveIntervalInSeconds;
            if (keepAliveInterval && keepAliveInterval > 0) {
              config.keepAliveTimeoutInSeconds = keepAliveInterval;
            }
          });
          this.sshSession.trace = this.trace;
          this.sshSession.onReportProgress((args) => this.raiseReportProgress(args.progress, args.sessionNumber), this, this.sshSessionDisposables);
          this.sshSession.onClosed(this.onSshSessionClosed, this, this.sshSessionDisposables);
          this.sshSession.onAuthenticating(this.onSshServerAuthenticating, this, this.sshSessionDisposables);
          this.sshSession.onDisconnected(this.onSshSessionDisconnected, this, this.sshSessionDisposables);
          this.sshSession.onRequest(this.onRequest, this, this.sshSessionDisposables);
          this.sshSession.onKeepAliveFailed((count) => this.onKeepAliveFailed(count));
          this.sshSession.onKeepAliveSucceeded((count) => this.onKeepAliveSucceeded(count));
          const pfs = this.sshSession.activateService(dev_tunnels_ssh_tcp_1.PortForwardingService);
          if (this.connectionProtocol === exports2.webSocketSubProtocolv2) {
            pfs.messageFactory = this;
            pfs.onForwardedPortConnecting(this.onForwardedPortConnecting, this, this.sshSessionDisposables);
            pfs.remoteForwardedPorts.onPortAdded((e) => this.onForwardedPortAdded(pfs, e), this, this.sshSessionDisposables);
            pfs.remoteForwardedPorts.onPortUpdated((e) => this.onForwardedPortAdded(pfs, e), this, this.sshSessionDisposables);
          }
          this.configurePortForwardingService();
          await this.sshSession.connect(stream, cancellation);
          if (this.sshSession.sessionId) {
            const session = this.sshSession;
            const clientCredentials = { username: "tunnel" };
            if (!await session.authenticate(clientCredentials, cancellation)) {
              throw new Error(session.principal ? "SSH client authentication failed." : "SSH server authentication failed.");
            }
          }
        });
      }
      configurePortForwardingService() {
        const pfs = this.getSshSessionPfs();
        if (!pfs) {
          return;
        }
        if (this.acceptLocalConnectionsForForwardedPortsValue && (0, sshHelpers_1.isNode)()) {
          pfs.tcpListenerFactory = new retryTcpListenerFactory_1.RetryTcpListenerFactory(this.localForwardingHostAddressValue);
        } else {
          pfs.acceptLocalConnectionsForForwardedPorts = false;
        }
      }
      onForwardedPortAdded(pfs, e) {
        var _a2, _b;
        const port = e.port.remotePort;
        if (typeof port !== "number") {
          return;
        }
        const disconnectedStreamsCount = (_b = (_a2 = this.disconnectedStreams.get(port)) === null || _a2 === void 0 ? void 0 : _a2.length) !== null && _b !== void 0 ? _b : 0;
        for (let i = 0; i < disconnectedStreamsCount; i++) {
          pfs.connectToForwardedPort(port).then(() => {
            this.trace(dev_tunnels_ssh_1.TraceLevel.Verbose, 0, `Reconnected stream to fowarded port ${port}`);
          }).catch((error) => {
            this.trace(dev_tunnels_ssh_1.TraceLevel.Warning, 0, `Failed to reconnect to forwarded port ${port}: ${error}`);
            const streams = this.disconnectedStreams.get(port);
            if (streams) {
              while (streams.length > 0) {
                streams.pop().dispose();
              }
            }
          });
        }
      }
      /**
       * Invoked when a forwarded port is connecting. (Only for V2 protocol.)
       */
      onForwardedPortConnecting(e) {
        const channel = e.stream.channel;
        const relayResponseMessage = channel.openConfirmationMessage.convertTo(new portRelayConnectResponseMessage_1.PortRelayConnectResponseMessage());
        if (relayResponseMessage.isE2EEncryptionEnabled) {
          const clientCredentials = { username: "tunnel" };
          e.transformPromise = new Promise((resolve8, reject) => {
            var _a2;
            let secureStream = (_a2 = this.disconnectedStreams.get(e.port)) === null || _a2 === void 0 ? void 0 : _a2.shift();
            if (secureStream) {
              this.trace(dev_tunnels_ssh_1.TraceLevel.Verbose, 0, `Reconnecting encrypted stream for port ${e.port}...`);
              secureStream.reconnect(e.stream).then(() => {
                this.trace(dev_tunnels_ssh_1.TraceLevel.Verbose, 0, `Reconnecting encrypted stream for port ${e.port} succeeded.`);
                resolve8(secureStream);
              }).catch(reject);
            } else {
              secureStream = new dev_tunnels_ssh_1.SecureStream(e.stream, clientCredentials);
              secureStream.trace = this.trace;
              secureStream.onAuthenticating((authEvent) => authEvent.authenticationPromise = this.onHostAuthenticating(authEvent).catch());
              secureStream.onDisconnected(() => this.onSecureStreamDisconnected(e.port, secureStream));
              secureStream.connect().then(() => resolve8(secureStream)).catch(reject);
            }
          });
        }
        super.onForwardedPortConnecting(e);
      }
      onSecureStreamDisconnected(port, secureStream) {
        this.trace(dev_tunnels_ssh_1.TraceLevel.Verbose, 0, `Encrypted stream for port ${port} disconnected.`);
        const streams = this.disconnectedStreams.get(port);
        if (streams) {
          streams.push(secureStream);
        } else {
          this.disconnectedStreams.set(port, [secureStream]);
        }
      }
      async onHostAuthenticating(e) {
        var _a2, _b;
        if (e.authenticationType !== dev_tunnels_ssh_1.SshAuthenticationType.serverPublicKey || !e.publicKey) {
          this.traceWarning("Invalid host authenticating event.");
          return null;
        }
        const hostKey = (_b = (_a2 = await e.publicKey.getPublicKeyBytes(e.publicKey.keyAlgorithmName)) === null || _a2 === void 0 ? void 0 : _a2.toString("base64")) !== null && _b !== void 0 ? _b : "";
        if (!this.hostPublicKeys) {
          this.traceWarning("Host identity could not be verified because no public keys were provided.");
          this.traceVerbose(`Host key: ${hostKey}`);
          return {};
        }
        if (this.hostPublicKeys.includes(hostKey)) {
          this.traceVerbose(`Verified host identity with public key ${hostKey}`);
          return {};
        }
        if (!this.disposeToken.isCancellationRequested && await this.refreshTunnel(false, this.disposeToken) && this.hostPublicKeys.includes(hostKey)) {
          this.traceVerbose("Verified host identity with public key " + hostKey);
          return {};
        }
        this.traceError("Host public key verification failed.");
        this.traceVerbose(`Host key: ${hostKey}`);
        this.traceVerbose(`Expected key(s): ${this.hostPublicKeys.join(", ")}`);
        return null;
      }
      onSshServerAuthenticating(e) {
        if (this.connectionProtocol === exports2.webSocketSubProtocol) {
          e.authenticationPromise = this.onHostAuthenticating(e);
        } else {
          e.authenticationPromise = Promise.resolve({});
        }
      }
      async connectToForwardedPort(fowardedPort, cancellation) {
        const pfs = this.getSshSessionPfs();
        if (!pfs) {
          throw new Error("Failed to connect to remote port. Ensure that the client has connected by calling connectClient.");
        }
        return pfs.connectToForwardedPort(fowardedPort, cancellation);
      }
      async waitForForwardedPort(forwardedPort, cancellation) {
        const pfs = this.getSshSessionPfs();
        if (!pfs) {
          throw new Error("Port forwarding has not been started. Ensure that the client has connected by calling connectClient.");
        }
        this.trace(dev_tunnels_ssh_1.TraceLevel.Verbose, 0, "Waiting for forwarded port " + forwardedPort);
        await pfs.waitForForwardedPort(forwardedPort, cancellation);
        this.trace(dev_tunnels_ssh_1.TraceLevel.Verbose, 0, "Forwarded port " + forwardedPort + " is ready.");
      }
      getSshSessionPfs() {
        var _a2, _b;
        return (_b = (_a2 = this.sshSession) === null || _a2 === void 0 ? void 0 : _a2.getService(dev_tunnels_ssh_tcp_1.PortForwardingService)) !== null && _b !== void 0 ? _b : void 0;
      }
      async refreshPorts() {
        if (!this.sshSession || this.sshSession.isClosed) {
          throw new Error("Not connected.");
        }
        const request = new dev_tunnels_ssh_1.SessionRequestMessage();
        request.requestType = "RefreshPorts";
        request.wantReply = true;
        await this.sshSession.request(request);
      }
      /**
       * @internal Closes the tunnel session due to an error.
       */
      async closeSession(reason, error) {
        if (this.isSshSessionActive) {
          this.sshSessionClosedEmitter.fire(this);
        }
        await super.closeSession(reason, error);
      }
      /**
       * SSH session closed event handler.
       */
      onSshSessionClosed(e) {
        this.sshSessionClosedEmitter.fire(this);
        super.onSshSessionClosed(e);
      }
      onSshSessionDisconnected() {
        this.sshSessionClosedEmitter.fire(this);
        const reason = dev_tunnels_ssh_1.SshDisconnectReason.connectionLost;
        const error = new dev_tunnels_ssh_1.SshConnectionError("Connection lost.", dev_tunnels_ssh_1.SshDisconnectReason.connectionLost);
        this.maybeStartReconnecting(reason, void 0, error);
      }
      /**
       * Connect to the tunnel session on the relay service using the given access token for authorization.
       */
      async connectClientToRelayServer(clientRelayUri, accessToken) {
        if (!clientRelayUri) {
          throw new Error("Client relay URI must be a non-empty string");
        }
        this.relayUri = clientRelayUri;
        this.accessToken = accessToken;
        await this.connectTunnelSession();
      }
    };
    exports2.TunnelRelayTunnelClient = TunnelRelayTunnelClient;
    TunnelRelayTunnelClient.webSocketSubProtocol = exports2.webSocketSubProtocol;
    TunnelRelayTunnelClient.webSocketSubProtocolv2 = exports2.webSocketSubProtocolv2;
  }
});

// ../../node_modules/@microsoft/dev-tunnels-connections/tunnelRelayTunnelHost.js
var require_tunnelRelayTunnelHost = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-connections/tunnelRelayTunnelHost.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TunnelRelayTunnelHost = void 0;
    var dev_tunnels_contracts_1 = require_dev_tunnels_contracts();
    var dev_tunnels_ssh_1 = require_dev_tunnels_ssh();
    var dev_tunnels_ssh_tcp_1 = require_dev_tunnels_ssh_tcp();
    var sshHelpers_1 = require_sshHelpers();
    var multiModeTunnelHost_1 = require_multiModeTunnelHost();
    var sessionPortKey_1 = require_sessionPortKey();
    var portRelayConnectRequestMessage_1 = require_portRelayConnectRequestMessage();
    var portRelayConnectResponseMessage_1 = require_portRelayConnectResponseMessage();
    var uuid_1 = require_uuid();
    var sshHelpers_2 = require_sshHelpers();
    var tunnelConnectionSession_1 = require_tunnelConnectionSession();
    var webSocketSubProtocol = "tunnel-relay-host";
    var webSocketSubProtocolv2 = "tunnel-relay-host-v2-dev";
    var protocolVersion = (process === null || process === void 0 ? void 0 : process.env) && process.env.DEVTUNNELS_PROTOCOL_VERSION;
    var connectionProtocols = protocolVersion === "1" ? [webSocketSubProtocol] : protocolVersion === "2" ? [webSocketSubProtocolv2] : [webSocketSubProtocolv2, webSocketSubProtocol];
    var TunnelRelayTunnelHost2 = class _TunnelRelayTunnelHost extends tunnelConnectionSession_1.TunnelConnectionSession {
      constructor(managementClient, trace) {
        super(dev_tunnels_contracts_1.TunnelAccessScopes.Host, connectionProtocols, managementClient, trace);
        this.clientSessionPromises = [];
        this.reconnectableSessions = [];
        this.sshSessions = [];
        this.remoteForwarders = /* @__PURE__ */ new Map();
        this.loopbackIp = "127.0.0.1";
        this.forwardConnectionsToLocalPortsValue = (0, sshHelpers_2.isNode)();
        const publicKey = dev_tunnels_ssh_1.SshAlgorithms.publicKey.ecdsaSha2Nistp384;
        if (publicKey) {
          this.hostPrivateKeyPromise = publicKey.generateKeyPair();
        }
        this.hostId = multiModeTunnelHost_1.MultiModeTunnelHost.hostId;
        this.id = (0, uuid_1.v4)() + "-relay";
      }
      get connectionId() {
        return this.hostId;
      }
      /**
       * A value indicating whether the port-forwarding service forwards connections to local TCP sockets.
       * Forwarded connections are not possible if the host is not NodeJS (e.g. browser).
       * The default value for NodeJS hosts is true.
       */
      get forwardConnectionsToLocalPorts() {
        return this.forwardConnectionsToLocalPortsValue;
      }
      set forwardConnectionsToLocalPorts(value) {
        if (value === this.forwardConnectionsToLocalPortsValue) {
          return;
        }
        if (value && !(0, sshHelpers_2.isNode)()) {
          throw new Error("Cannot forward connections to local TCP sockets on this platform.");
        }
        this.forwardConnectionsToLocalPortsValue = value;
      }
      /**
       * Connects to a tunnel as a host and starts accepting incoming connections
       * to local ports as defined on the tunnel.
       * @deprecated Use `connect()` instead.
       */
      async start(tunnel) {
        await this.connect(tunnel);
      }
      /**
       * Connects to a tunnel as a host and starts accepting incoming connections
       * to local ports as defined on the tunnel.
       */
      async connect(tunnel, options, cancellation) {
        await this.connectTunnelSession(tunnel, options, cancellation);
      }
      /**
       * Connect to the tunnel session with the tunnel connector.
       * @param tunnel Tunnel to use for the connection.
       *     Undefined if the connection information is already known and the tunnel is not needed.
       *     Tunnel object to get the connection information from that tunnel.
       */
      async connectTunnelSession(tunnel, options, cancellation) {
        if (this.disconnectReason === dev_tunnels_ssh_1.SshDisconnectReason.tooManyConnections) {
          throw new dev_tunnels_ssh_1.SshConnectionError("Cannot retry connection because another host for this tunnel has connected. Only one host connection at a time is supported.", dev_tunnels_ssh_1.SshDisconnectReason.tooManyConnections);
        }
        await super.connectTunnelSession(tunnel, options, cancellation);
      }
      /**
       * Configures the tunnel session with the given stream.
       * @internal
       */
      async configureSession(stream, protocol, isReconnect, cancellation) {
        this.connectionProtocol = protocol;
        let session;
        if (this.connectionProtocol === webSocketSubProtocol) {
          session = new dev_tunnels_ssh_1.SshClientSession(new dev_tunnels_ssh_1.SshSessionConfiguration(false));
        } else {
          session = sshHelpers_1.SshHelpers.createSshClientSession((config) => {
            config.keyExchangeAlgorithms.splice(0, 0, dev_tunnels_ssh_1.SshAlgorithms.keyExchange.none);
            config.addService(dev_tunnels_ssh_tcp_1.PortForwardingService);
          });
          const hostPfs = session.activateService(dev_tunnels_ssh_tcp_1.PortForwardingService);
          hostPfs.messageFactory = this;
          hostPfs.onForwardedPortConnecting(this.onForwardedPortConnecting, this, this.sshSessionDisposables);
        }
        session.onChannelOpening(this.hostSession_ChannelOpening, this, this.sshSessionDisposables);
        session.onClosed(this.onSshSessionClosed, this, this.sshSessionDisposables);
        session.trace = this.trace;
        session.onReportProgress((args) => this.raiseReportProgress(args.progress, args.sessionNumber), this, this.sshSessionDisposables);
        this.sshSession = session;
        await session.connect(stream, cancellation);
        if (session.sessionId) {
          await session.authenticate({ username: "tunnel" });
        }
        if (this.connectionProtocol === webSocketSubProtocolv2) {
          await this.startForwardingExistingPorts(session);
        }
      }
      /**
       * Validate the {@link tunnel} and get data needed to connect to it, if the tunnel is provided;
       * otherwise, ensure that there is already sufficient data to connect to a tunnel.
       * @internal
       */
      async onConnectingToTunnel() {
        var _a2, _b, _c, _d, _e;
        if (!this.hostPrivateKey || !this.hostPublicKeys) {
          if (!this.hostPrivateKeyPromise) {
            throw new Error("Cannot create host keys");
          }
          this.hostPrivateKey = await this.hostPrivateKeyPromise;
          const buffer = await this.hostPrivateKey.getPublicKeyBytes(this.hostPrivateKey.keyAlgorithmName);
          if (!buffer) {
            throw new Error("Host private key public key bytes is not initialized");
          }
          this.hostPublicKeys = [buffer.toString("base64")];
        }
        const tunnelHasSshPort = ((_a2 = this.tunnel) === null || _a2 === void 0 ? void 0 : _a2.ports) != null && this.tunnel.ports.find((v) => v.protocol === dev_tunnels_contracts_1.TunnelProtocol.Ssh);
        const endpointSignature = `${(_b = this.tunnel) === null || _b === void 0 ? void 0 : _b.tunnelId}.${(_c = this.tunnel) === null || _c === void 0 ? void 0 : _c.clusterId}:${(_d = this.tunnel) === null || _d === void 0 ? void 0 : _d.name}.${(_e = this.tunnel) === null || _e === void 0 ? void 0 : _e.domain}:${tunnelHasSshPort}:${this.hostId}:${this.hostPublicKeys}`;
        if (!this.relayUri || this.endpointSignature !== endpointSignature) {
          if (!this.tunnel) {
            throw new Error("Tunnel is required");
          }
          let endpoint = {
            id: this.id,
            hostId: this.hostId,
            hostPublicKeys: this.hostPublicKeys,
            connectionMode: dev_tunnels_contracts_1.TunnelConnectionMode.TunnelRelay
          };
          let additionalQueryParameters = void 0;
          if (tunnelHasSshPort) {
            additionalQueryParameters = { includeSshGatewayPublicKey: "true" };
          }
          endpoint = await this.managementClient.updateTunnelEndpoint(this.tunnel, endpoint, {
            additionalQueryParameters
          });
          this.relayUri = endpoint.hostRelayUri;
          this.endpointSignature = endpointSignature;
        }
      }
      /**
       * Disposes this tunnel session, closing all client connections, the host SSH session, and deleting the endpoint.
       */
      async dispose() {
        await super.dispose();
        const promises2 = Object.assign([], this.clientSessionPromises);
        this.clientSessionPromises.length = 0;
        if (this.tunnel && this.endpointSignature && this.disconnectReason !== dev_tunnels_ssh_1.SshDisconnectReason.tooManyConnections) {
          const promise2 = this.managementClient.deleteTunnelEndpoints(this.tunnel, this.id);
          promises2.push(promise2);
        }
        for (const forwarder of this.remoteForwarders.values()) {
          forwarder.dispose();
        }
        await Promise.all(promises2);
      }
      hostSession_ChannelOpening(e) {
        if (!e.isRemoteRequest) {
          return;
        }
        if (this.connectionProtocol === webSocketSubProtocolv2 && e.channel.channelType === "forwarded-tcpip") {
          const relayRequestMessage = e.channel.openMessage.convertTo(new portRelayConnectRequestMessage_1.PortRelayConnectRequestMessage());
          const responseMessage = new portRelayConnectResponseMessage_1.PortRelayConnectResponseMessage();
          responseMessage.isE2EEncryptionEnabled = this.enableE2EEncryption && relayRequestMessage.isE2EEncryptionRequested;
          e.openingPromise = Promise.resolve(responseMessage);
          return;
        } else if (e.channel.channelType !== _TunnelRelayTunnelHost.clientStreamChannelType) {
          e.failureDescription = `Unknown channel type: ${e.channel.channelType}`;
          e.failureReason = dev_tunnels_ssh_1.SshChannelOpenFailureReason.unknownChannelType;
          return;
        }
        e.channel.maxWindowSize = dev_tunnels_ssh_1.SshChannel.defaultMaxWindowSize * 5;
        if (this.isDisposed) {
          e.failureDescription = "The host is disconnecting.";
          e.failureReason = dev_tunnels_ssh_1.SshChannelOpenFailureReason.connectFailed;
          return;
        }
        const promise2 = this.acceptClientSession(e.channel, this.disposeToken);
        this.clientSessionPromises.push(promise2);
        promise2.then(() => {
          const index = this.clientSessionPromises.indexOf(promise2);
          this.clientSessionPromises.splice(index, 1);
        });
      }
      onForwardedPortConnecting(e) {
        const channel = e.stream.channel;
        const relayRequestMessage = channel.openMessage.convertTo(new portRelayConnectRequestMessage_1.PortRelayConnectRequestMessage());
        const isE2EEncryptionEnabled = this.enableE2EEncryption && relayRequestMessage.isE2EEncryptionRequested;
        if (isE2EEncryptionEnabled) {
          channel.maxWindowSize = dev_tunnels_ssh_1.SshChannel.defaultMaxWindowSize * 2;
          const serverCredentials = {
            publicKeys: [this.hostPrivateKey]
          };
          const secureStream = new dev_tunnels_ssh_1.SecureStream(e.stream, serverCredentials, this.reconnectableSessions);
          secureStream.trace = this.trace;
          secureStream.onAuthenticating((authEvent) => authEvent.authenticationPromise = Promise.resolve({}));
          secureStream.connect().catch((err) => {
            this.trace(dev_tunnels_ssh_1.TraceLevel.Error, 0, `Error connecting encrypted channel: ${err}`);
          });
          e.transformPromise = Promise.resolve(secureStream);
        }
        super.onForwardedPortConnecting(e);
      }
      async acceptClientSession(clientSessionChannel, cancellation) {
        try {
          const stream = new dev_tunnels_ssh_1.SshStream(clientSessionChannel);
          await this.connectAndRunClientSession(stream, cancellation);
        } catch (ex) {
          if (!(ex instanceof dev_tunnels_ssh_1.CancellationError) || !cancellation.isCancellationRequested) {
            this.trace(dev_tunnels_ssh_1.TraceLevel.Error, 0, `Error running client SSH session: ${ex}`);
          }
        }
      }
      /**
       * Creates an SSH server session for a client (V1 protocol), runs the session,
       * and waits for it to close.
       */
      async connectAndRunClientSession(stream, cancellation) {
        if (cancellation.isCancellationRequested) {
          stream.destroy();
          throw new dev_tunnels_ssh_1.CancellationError();
        }
        const clientChannelId = stream.channel.channelId;
        const session = sshHelpers_1.SshHelpers.createSshServerSession(this.reconnectableSessions, (config) => {
          var _a2;
          config.protocolExtensions.push(dev_tunnels_ssh_1.SshProtocolExtensionNames.sessionReconnect);
          config.addService(dev_tunnels_ssh_tcp_1.PortForwardingService);
          const keepAliveInterval = (_a2 = this.connectionOptions) === null || _a2 === void 0 ? void 0 : _a2.keepAliveIntervalInSeconds;
          if (keepAliveInterval && keepAliveInterval > 0) {
            config.keepAliveTimeoutInSeconds = keepAliveInterval;
          }
        });
        session.trace = this.trace;
        session.onReportProgress((args) => this.raiseReportProgress(args.progress, args.sessionNumber), this, this.sshSessionDisposables);
        session.credentials = {
          publicKeys: [this.hostPrivateKey]
        };
        const tcs = new dev_tunnels_ssh_1.PromiseCompletionSource();
        const authenticatingEventRegistration = session.onAuthenticating((e) => {
          this.onSshClientAuthenticating(e);
        });
        session.onClientAuthenticated(() => {
          void this.onSshClientAuthenticated(session);
        });
        const requestRegistration = session.onRequest((e) => {
          this.onClientSessionRequest(e, session);
        });
        const channelOpeningEventRegistration = session.onChannelOpening((e) => {
          this.onSshChannelOpening(e, session);
        });
        const reconnectedEventRegistration = session.onReconnected(() => {
          this.onClientSessionReconnecting(session, clientChannelId);
        });
        const closedEventRegistration = session.onClosed((e) => {
          this.onClientSessionClosed(session, e, clientChannelId, cancellation);
          tcs.resolve();
        });
        session.onKeepAliveFailed((count) => this.onKeepAliveFailed(count));
        session.onKeepAliveSucceeded((count) => this.onKeepAliveSucceeded(count));
        try {
          const nodeStream = new dev_tunnels_ssh_1.NodeStream(stream);
          await session.connect(nodeStream);
          this.sshSessions.push(session);
          cancellation.onCancellationRequested((e) => {
            tcs.reject(new dev_tunnels_ssh_1.CancellationError());
          });
          if (this.tunnel && this.managementClient) {
            const connectedEvent = {
              name: "host_client_connect",
              properties: {
                ClientChannelId: clientChannelId.toString(),
                ClientSessionId: this.getShortSessionId(session),
                HostSessionId: this.connectionId
              }
            };
            this.managementClient.reportEvent(this.tunnel, connectedEvent);
          }
          await tcs.promise;
        } finally {
          authenticatingEventRegistration.dispose();
          requestRegistration.dispose();
          channelOpeningEventRegistration.dispose();
          reconnectedEventRegistration.dispose();
          closedEventRegistration.dispose();
          await session.close(dev_tunnels_ssh_1.SshDisconnectReason.byApplication);
          session.dispose();
        }
      }
      onSshClientAuthenticating(e) {
        if (e.authenticationType === dev_tunnels_ssh_1.SshAuthenticationType.clientNone) {
          e.authenticationPromise = Promise.resolve({});
        } else {
        }
      }
      async onSshClientAuthenticated(session) {
        void this.startForwardingExistingPorts(session);
      }
      async startForwardingExistingPorts(session) {
        var _a2, _b;
        const pfs = session.activateService(dev_tunnels_ssh_tcp_1.PortForwardingService);
        pfs.forwardConnectionsToLocalPorts = this.forwardConnectionsToLocalPorts;
        for (const port of (_b = (_a2 = this.tunnel) === null || _a2 === void 0 ? void 0 : _a2.ports) !== null && _b !== void 0 ? _b : []) {
          this.trace(dev_tunnels_ssh_1.TraceLevel.Verbose, 0, `Forwarding port ${port.portNumber}`);
          try {
            await this.forwardPort(pfs, port);
          } catch (ex) {
            this.traceError(`Error forwarding port ${port.portNumber}: ${ex}`);
          }
        }
      }
      onClientSessionRequest(e, session) {
        if (e.requestType === "RefreshPorts") {
          e.responsePromise = (async () => {
            await this.refreshPorts();
            return new dev_tunnels_ssh_1.SessionRequestSuccessMessage();
          })();
        }
      }
      onSshChannelOpening(e, session) {
        if (!(e.request instanceof dev_tunnels_ssh_tcp_1.PortForwardChannelOpenMessage)) {
          if (e.request.channelType === dev_tunnels_ssh_1.SshChannel.sessionChannelType) {
            return;
          }
          this.trace(dev_tunnels_ssh_1.TraceLevel.Warning, 0, "Rejecting request to open non-portforwarding channel.");
          e.failureReason = dev_tunnels_ssh_1.SshChannelOpenFailureReason.administrativelyProhibited;
          return;
        }
        const portForwardRequest = e.request;
        if (portForwardRequest.channelType === "direct-tcpip") {
          if (!this.tunnel.ports.some((p) => p.portNumber === portForwardRequest.port)) {
            this.trace(dev_tunnels_ssh_1.TraceLevel.Warning, 0, "Rejecting request to connect to non-forwarded port:" + portForwardRequest.port);
            e.failureReason = dev_tunnels_ssh_1.SshChannelOpenFailureReason.administrativelyProhibited;
          }
        } else if (portForwardRequest.channelType === "forwarded-tcpip") {
          const eventArgs = new dev_tunnels_ssh_tcp_1.ForwardedPortConnectingEventArgs(portForwardRequest.port, false, new dev_tunnels_ssh_1.SshStream(e.channel));
          super.onForwardedPortConnecting(eventArgs);
        } else {
          this.trace(dev_tunnels_ssh_1.TraceLevel.Warning, 0, "Nonrecognized channel type " + portForwardRequest.channelType);
          e.failureReason = dev_tunnels_ssh_1.SshChannelOpenFailureReason.unknownChannelType;
        }
      }
      onClientSessionReconnecting(session, clientChannelId) {
        if (this.tunnel && this.managementClient) {
          const reconnectedEvent = {
            name: "host_client_reconnect",
            properties: {
              ClientChannelId: clientChannelId.toString(),
              ClientSessionId: this.getShortSessionId(session),
              HostSessionId: this.connectionId
            }
          };
          this.managementClient.reportEvent(this.tunnel, reconnectedEvent);
        }
      }
      onClientSessionClosed(session, e, clientChannelId, cancellation) {
        let severity;
        let details;
        if (e.reason === dev_tunnels_ssh_1.SshDisconnectReason.byApplication) {
          details = "Client ssh session closed by application.";
          this.traceInfo(details);
        } else if (cancellation.isCancellationRequested) {
          details = "Client ssh session cancelled.";
          this.traceInfo(details);
        } else if (e.reason !== dev_tunnels_ssh_1.SshDisconnectReason.none) {
          severity = dev_tunnels_contracts_1.TunnelEvent.error;
          details = `Client ssh session closed unexpectedly due to ${e.reason}, "${e.message}"
${e.error}`;
          this.traceError(details);
        } else {
          details = "Client ssh session closed.";
        }
        if (this.tunnel && this.managementClient) {
          const disconnectedEvent = {
            timestamp: /* @__PURE__ */ new Date(),
            name: "host_client_disconnect",
            severity,
            details,
            properties: {
              ClientChannelId: clientChannelId.toString(),
              ClientSessionId: this.getShortSessionId(session),
              HostSessionId: this.connectionId
            }
          };
          this.managementClient.reportEvent(this.tunnel, disconnectedEvent);
        }
        for (const [key, forwarder] of this.remoteForwarders.entries()) {
          if (forwarder.session === session) {
            forwarder.dispose();
            this.remoteForwarders.delete(key);
          }
        }
        const index = this.sshSessions.indexOf(session);
        if (index >= 0) {
          this.sshSessions.splice(index, 1);
        }
      }
      async refreshPorts(cancellation) {
        var _a2, _b;
        this.raiseReportProgress(dev_tunnels_contracts_1.TunnelProgress.StartingRefreshPorts);
        if (!await this.refreshTunnel(true, cancellation)) {
          return;
        }
        const ports = (_b = (_a2 = this.tunnel) === null || _a2 === void 0 ? void 0 : _a2.ports) !== null && _b !== void 0 ? _b : [];
        let sessions = this.sshSessions;
        if (this.connectionProtocol === webSocketSubProtocolv2 && this.sshSession) {
          sessions = [...sessions, this.sshSession];
        }
        const forwardPromises = [];
        for (const port of ports) {
          for (const session of sessions.filter((s) => s.isConnected && (!s.sessionId || s.principal))) {
            const key = new sessionPortKey_1.SessionPortKey(session.sessionId, Number(port.portNumber));
            const forwarder = this.remoteForwarders.get(key.toString());
            if (!forwarder) {
              const pfs = session.getService(dev_tunnels_ssh_tcp_1.PortForwardingService);
              forwardPromises.push(this.forwardPort(pfs, port));
            }
          }
        }
        for (const [key, forwarder] of Object.entries(this.remoteForwarders)) {
          if (!ports.some((p) => p.portNumber === forwarder.localPort)) {
            this.remoteForwarders.delete(key);
            forwarder.dispose();
          }
        }
        await Promise.all(forwardPromises);
        this.raiseReportProgress(dev_tunnels_contracts_1.TunnelProgress.CompletedRefreshPorts);
      }
      async forwardPort(pfs, port) {
        const portNumber = Number(port.portNumber);
        if (pfs.localForwardedPorts.find((p) => p.localPort === portNumber)) {
          return;
        }
        const forwarder = await pfs.forwardFromRemotePort(this.loopbackIp, portNumber, "localhost", portNumber);
        if (!forwarder) {
          return;
        }
        const key = new sessionPortKey_1.SessionPortKey(pfs.session.sessionId, Number(forwarder.localPort));
        this.remoteForwarders.set(key.toString(), forwarder);
      }
    };
    exports2.TunnelRelayTunnelHost = TunnelRelayTunnelHost2;
    TunnelRelayTunnelHost2.webSocketSubProtocol = webSocketSubProtocol;
    TunnelRelayTunnelHost2.webSocketSubProtocolv2 = webSocketSubProtocolv2;
    TunnelRelayTunnelHost2.clientStreamChannelType = "client-ssh-session-stream";
  }
});

// ../../node_modules/@microsoft/dev-tunnels-connections/tunnelConnection.js
var require_tunnelConnection = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-connections/tunnelConnection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/@microsoft/dev-tunnels-connections/tunnelConnectionOptions.js
var require_tunnelConnectionOptions = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-connections/tunnelConnectionOptions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/@microsoft/dev-tunnels-connections/tunnelConnector.js
var require_tunnelConnector = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-connections/tunnelConnector.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/@microsoft/dev-tunnels-connections/index.js
var require_dev_tunnels_connections = __commonJS({
  "../../node_modules/@microsoft/dev-tunnels-connections/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.maxReconnectDelayMs = void 0;
    __exportStar(require_tunnelClient(), exports2);
    __exportStar(require_tunnelHost(), exports2);
    __exportStar(require_multiModeTunnelClient(), exports2);
    __exportStar(require_multiModeTunnelHost(), exports2);
    __exportStar(require_retryTcpListenerFactory(), exports2);
    __exportStar(require_sessionPortKey(), exports2);
    __exportStar(require_sshHelpers(), exports2);
    __exportStar(require_tunnelClient(), exports2);
    __exportStar(require_tunnelHost(), exports2);
    __exportStar(require_tunnelRelayStreamFactory(), exports2);
    __exportStar(require_defaultTunnelRelayStreamFactory(), exports2);
    __exportStar(require_tunnelRelayTunnelClient(), exports2);
    __exportStar(require_tunnelRelayTunnelHost(), exports2);
    __exportStar(require_tunnelConnection(), exports2);
    __exportStar(require_tunnelConnectionBase(), exports2);
    __exportStar(require_tunnelConnectionOptions(), exports2);
    __exportStar(require_sshKeepAliveEventArgs(), exports2);
    __exportStar(require_connectionStatus(), exports2);
    __exportStar(require_connectionStatusChangedEventArgs(), exports2);
    var relayTunnelConnector_1 = require_relayTunnelConnector();
    Object.defineProperty(exports2, "maxReconnectDelayMs", { enumerable: true, get: function() {
      return relayTunnelConnector_1.maxReconnectDelayMs;
    } });
    __exportStar(require_refreshingTunnelAccessTokenEventArgs(), exports2);
    __exportStar(require_refreshingTunnelEventArgs(), exports2);
    __exportStar(require_retryingTunnelConnectionEventArgs(), exports2);
    __exportStar(require_portForwardingEventArgs(), exports2);
    __exportStar(require_tunnelConnector(), exports2);
  }
});

// ../../node_modules/picomatch/lib/constants.js
var require_constants = __commonJS({
  "../../node_modules/picomatch/lib/constants.js"(exports2, module2) {
    "use strict";
    var WIN_SLASH = "\\\\/";
    var WIN_NO_SLASH = `[^${WIN_SLASH}]`;
    var DOT_LITERAL = "\\.";
    var PLUS_LITERAL = "\\+";
    var QMARK_LITERAL = "\\?";
    var SLASH_LITERAL = "\\/";
    var ONE_CHAR = "(?=.)";
    var QMARK = "[^/]";
    var END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
    var START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
    var DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
    var NO_DOT = `(?!${DOT_LITERAL})`;
    var NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
    var NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
    var NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
    var QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
    var STAR = `${QMARK}*?`;
    var SEP = "/";
    var POSIX_CHARS = {
      DOT_LITERAL,
      PLUS_LITERAL,
      QMARK_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      QMARK,
      END_ANCHOR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOTS,
      NO_DOT_SLASH,
      NO_DOTS_SLASH,
      QMARK_NO_DOT,
      STAR,
      START_ANCHOR,
      SEP
    };
    var WINDOWS_CHARS = {
      ...POSIX_CHARS,
      SLASH_LITERAL: `[${WIN_SLASH}]`,
      QMARK: WIN_NO_SLASH,
      STAR: `${WIN_NO_SLASH}*?`,
      DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
      NO_DOT: `(?!${DOT_LITERAL})`,
      NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
      NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
      START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
      END_ANCHOR: `(?:[${WIN_SLASH}]|$)`,
      SEP: "\\"
    };
    var POSIX_REGEX_SOURCE = {
      alnum: "a-zA-Z0-9",
      alpha: "a-zA-Z",
      ascii: "\\x00-\\x7F",
      blank: " \\t",
      cntrl: "\\x00-\\x1F\\x7F",
      digit: "0-9",
      graph: "\\x21-\\x7E",
      lower: "a-z",
      print: "\\x20-\\x7E ",
      punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
      space: " \\t\\r\\n\\v\\f",
      upper: "A-Z",
      word: "A-Za-z0-9_",
      xdigit: "A-Fa-f0-9"
    };
    module2.exports = {
      MAX_LENGTH: 1024 * 64,
      POSIX_REGEX_SOURCE,
      // regular expressions
      REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
      REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
      REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
      REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
      REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
      REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
      // Replace globs with equivalent patterns to reduce parsing time.
      REPLACEMENTS: {
        __proto__: null,
        "***": "*",
        "**/**": "**",
        "**/**/**": "**"
      },
      // Digits
      CHAR_0: 48,
      /* 0 */
      CHAR_9: 57,
      /* 9 */
      // Alphabet chars.
      CHAR_UPPERCASE_A: 65,
      /* A */
      CHAR_LOWERCASE_A: 97,
      /* a */
      CHAR_UPPERCASE_Z: 90,
      /* Z */
      CHAR_LOWERCASE_Z: 122,
      /* z */
      CHAR_LEFT_PARENTHESES: 40,
      /* ( */
      CHAR_RIGHT_PARENTHESES: 41,
      /* ) */
      CHAR_ASTERISK: 42,
      /* * */
      // Non-alphabetic chars.
      CHAR_AMPERSAND: 38,
      /* & */
      CHAR_AT: 64,
      /* @ */
      CHAR_BACKWARD_SLASH: 92,
      /* \ */
      CHAR_CARRIAGE_RETURN: 13,
      /* \r */
      CHAR_CIRCUMFLEX_ACCENT: 94,
      /* ^ */
      CHAR_COLON: 58,
      /* : */
      CHAR_COMMA: 44,
      /* , */
      CHAR_DOT: 46,
      /* . */
      CHAR_DOUBLE_QUOTE: 34,
      /* " */
      CHAR_EQUAL: 61,
      /* = */
      CHAR_EXCLAMATION_MARK: 33,
      /* ! */
      CHAR_FORM_FEED: 12,
      /* \f */
      CHAR_FORWARD_SLASH: 47,
      /* / */
      CHAR_GRAVE_ACCENT: 96,
      /* ` */
      CHAR_HASH: 35,
      /* # */
      CHAR_HYPHEN_MINUS: 45,
      /* - */
      CHAR_LEFT_ANGLE_BRACKET: 60,
      /* < */
      CHAR_LEFT_CURLY_BRACE: 123,
      /* { */
      CHAR_LEFT_SQUARE_BRACKET: 91,
      /* [ */
      CHAR_LINE_FEED: 10,
      /* \n */
      CHAR_NO_BREAK_SPACE: 160,
      /* \u00A0 */
      CHAR_PERCENT: 37,
      /* % */
      CHAR_PLUS: 43,
      /* + */
      CHAR_QUESTION_MARK: 63,
      /* ? */
      CHAR_RIGHT_ANGLE_BRACKET: 62,
      /* > */
      CHAR_RIGHT_CURLY_BRACE: 125,
      /* } */
      CHAR_RIGHT_SQUARE_BRACKET: 93,
      /* ] */
      CHAR_SEMICOLON: 59,
      /* ; */
      CHAR_SINGLE_QUOTE: 39,
      /* ' */
      CHAR_SPACE: 32,
      /*   */
      CHAR_TAB: 9,
      /* \t */
      CHAR_UNDERSCORE: 95,
      /* _ */
      CHAR_VERTICAL_LINE: 124,
      /* | */
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
      /* \uFEFF */
      /**
       * Create EXTGLOB_CHARS
       */
      extglobChars(chars) {
        return {
          "!": { type: "negate", open: "(?:(?!(?:", close: `))${chars.STAR})` },
          "?": { type: "qmark", open: "(?:", close: ")?" },
          "+": { type: "plus", open: "(?:", close: ")+" },
          "*": { type: "star", open: "(?:", close: ")*" },
          "@": { type: "at", open: "(?:", close: ")" }
        };
      },
      /**
       * Create GLOB_CHARS
       */
      globChars(win32) {
        return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
      }
    };
  }
});

// ../../node_modules/picomatch/lib/utils.js
var require_utils3 = __commonJS({
  "../../node_modules/picomatch/lib/utils.js"(exports2) {
    "use strict";
    var {
      REGEX_BACKSLASH,
      REGEX_REMOVE_BACKSLASH,
      REGEX_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_GLOBAL
    } = require_constants();
    exports2.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    exports2.hasRegexChars = (str) => REGEX_SPECIAL_CHARS.test(str);
    exports2.isRegexChar = (str) => str.length === 1 && exports2.hasRegexChars(str);
    exports2.escapeRegex = (str) => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
    exports2.toPosixSlashes = (str) => str.replace(REGEX_BACKSLASH, "/");
    exports2.isWindows = () => {
      if (typeof navigator !== "undefined" && navigator.platform) {
        const platform = navigator.platform.toLowerCase();
        return platform === "win32" || platform === "windows";
      }
      if (typeof process !== "undefined" && process.platform) {
        return process.platform === "win32";
      }
      return false;
    };
    exports2.removeBackslashes = (str) => {
      return str.replace(REGEX_REMOVE_BACKSLASH, (match) => {
        return match === "\\" ? "" : match;
      });
    };
    exports2.escapeLast = (input, char, lastIdx) => {
      const idx = input.lastIndexOf(char, lastIdx);
      if (idx === -1) return input;
      if (input[idx - 1] === "\\") return exports2.escapeLast(input, char, idx - 1);
      return `${input.slice(0, idx)}\\${input.slice(idx)}`;
    };
    exports2.removePrefix = (input, state = {}) => {
      let output = input;
      if (output.startsWith("./")) {
        output = output.slice(2);
        state.prefix = "./";
      }
      return output;
    };
    exports2.wrapOutput = (input, state = {}, options = {}) => {
      const prepend = options.contains ? "" : "^";
      const append2 = options.contains ? "" : "$";
      let output = `${prepend}(?:${input})${append2}`;
      if (state.negated === true) {
        output = `(?:^(?!${output}).*$)`;
      }
      return output;
    };
    exports2.basename = (path11, { windows } = {}) => {
      const segs = path11.split(windows ? /[\\/]/ : "/");
      const last2 = segs[segs.length - 1];
      if (last2 === "") {
        return segs[segs.length - 2];
      }
      return last2;
    };
  }
});

// ../../node_modules/picomatch/lib/scan.js
var require_scan = __commonJS({
  "../../node_modules/picomatch/lib/scan.js"(exports2, module2) {
    "use strict";
    var utils = require_utils3();
    var {
      CHAR_ASTERISK,
      /* * */
      CHAR_AT,
      /* @ */
      CHAR_BACKWARD_SLASH,
      /* \ */
      CHAR_COMMA,
      /* , */
      CHAR_DOT,
      /* . */
      CHAR_EXCLAMATION_MARK,
      /* ! */
      CHAR_FORWARD_SLASH,
      /* / */
      CHAR_LEFT_CURLY_BRACE,
      /* { */
      CHAR_LEFT_PARENTHESES,
      /* ( */
      CHAR_LEFT_SQUARE_BRACKET,
      /* [ */
      CHAR_PLUS,
      /* + */
      CHAR_QUESTION_MARK,
      /* ? */
      CHAR_RIGHT_CURLY_BRACE,
      /* } */
      CHAR_RIGHT_PARENTHESES,
      /* ) */
      CHAR_RIGHT_SQUARE_BRACKET
      /* ] */
    } = require_constants();
    var isPathSeparator = (code) => {
      return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
    };
    var depth = (token) => {
      if (token.isPrefix !== true) {
        token.depth = token.isGlobstar ? Infinity : 1;
      }
    };
    var scan = (input, options) => {
      const opts = options || {};
      const length = input.length - 1;
      const scanToEnd = opts.parts === true || opts.scanToEnd === true;
      const slashes = [];
      const tokens = [];
      const parts = [];
      let str = input;
      let index = -1;
      let start = 0;
      let lastIndex = 0;
      let isBrace = false;
      let isBracket = false;
      let isGlob = false;
      let isExtglob = false;
      let isGlobstar = false;
      let braceEscaped = false;
      let backslashes = false;
      let negated = false;
      let negatedExtglob = false;
      let finished = false;
      let braces = 0;
      let prev;
      let code;
      let token = { value: "", depth: 0, isGlob: false };
      const eos = () => index >= length;
      const peek = () => str.charCodeAt(index + 1);
      const advance = () => {
        prev = code;
        return str.charCodeAt(++index);
      };
      while (index < length) {
        code = advance();
        let next;
        if (code === CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = true;
          code = advance();
          if (code === CHAR_LEFT_CURLY_BRACE) {
            braceEscaped = true;
          }
          continue;
        }
        if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
          braces++;
          while (eos() !== true && (code = advance())) {
            if (code === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (code === CHAR_LEFT_CURLY_BRACE) {
              braces++;
              continue;
            }
            if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (braceEscaped !== true && code === CHAR_COMMA) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (code === CHAR_RIGHT_CURLY_BRACE) {
              braces--;
              if (braces === 0) {
                braceEscaped = false;
                isBrace = token.isBrace = true;
                finished = true;
                break;
              }
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_FORWARD_SLASH) {
          slashes.push(index);
          tokens.push(token);
          token = { value: "", depth: 0, isGlob: false };
          if (finished === true) continue;
          if (prev === CHAR_DOT && index === start + 1) {
            start += 2;
            continue;
          }
          lastIndex = index + 1;
          continue;
        }
        if (opts.noext !== true) {
          const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;
          if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
            isGlob = token.isGlob = true;
            isExtglob = token.isExtglob = true;
            finished = true;
            if (code === CHAR_EXCLAMATION_MARK && index === start) {
              negatedExtglob = true;
            }
            if (scanToEnd === true) {
              while (eos() !== true && (code = advance())) {
                if (code === CHAR_BACKWARD_SLASH) {
                  backslashes = token.backslashes = true;
                  code = advance();
                  continue;
                }
                if (code === CHAR_RIGHT_PARENTHESES) {
                  isGlob = token.isGlob = true;
                  finished = true;
                  break;
                }
              }
              continue;
            }
            break;
          }
        }
        if (code === CHAR_ASTERISK) {
          if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_QUESTION_MARK) {
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_LEFT_SQUARE_BRACKET) {
          while (eos() !== true && (next = advance())) {
            if (next === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              isBracket = token.isBracket = true;
              isGlob = token.isGlob = true;
              finished = true;
              break;
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
          negated = token.negated = true;
          start++;
          continue;
        }
        if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
          isGlob = token.isGlob = true;
          if (scanToEnd === true) {
            while (eos() !== true && (code = advance())) {
              if (code === CHAR_LEFT_PARENTHESES) {
                backslashes = token.backslashes = true;
                code = advance();
                continue;
              }
              if (code === CHAR_RIGHT_PARENTHESES) {
                finished = true;
                break;
              }
            }
            continue;
          }
          break;
        }
        if (isGlob === true) {
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
      }
      if (opts.noext === true) {
        isExtglob = false;
        isGlob = false;
      }
      let base = str;
      let prefix = "";
      let glob = "";
      if (start > 0) {
        prefix = str.slice(0, start);
        str = str.slice(start);
        lastIndex -= start;
      }
      if (base && isGlob === true && lastIndex > 0) {
        base = str.slice(0, lastIndex);
        glob = str.slice(lastIndex);
      } else if (isGlob === true) {
        base = "";
        glob = str;
      } else {
        base = str;
      }
      if (base && base !== "" && base !== "/" && base !== str) {
        if (isPathSeparator(base.charCodeAt(base.length - 1))) {
          base = base.slice(0, -1);
        }
      }
      if (opts.unescape === true) {
        if (glob) glob = utils.removeBackslashes(glob);
        if (base && backslashes === true) {
          base = utils.removeBackslashes(base);
        }
      }
      const state = {
        prefix,
        input,
        start,
        base,
        glob,
        isBrace,
        isBracket,
        isGlob,
        isExtglob,
        isGlobstar,
        negated,
        negatedExtglob
      };
      if (opts.tokens === true) {
        state.maxDepth = 0;
        if (!isPathSeparator(code)) {
          tokens.push(token);
        }
        state.tokens = tokens;
      }
      if (opts.parts === true || opts.tokens === true) {
        let prevIndex;
        for (let idx = 0; idx < slashes.length; idx++) {
          const n = prevIndex ? prevIndex + 1 : start;
          const i = slashes[idx];
          const value = input.slice(n, i);
          if (opts.tokens) {
            if (idx === 0 && start !== 0) {
              tokens[idx].isPrefix = true;
              tokens[idx].value = prefix;
            } else {
              tokens[idx].value = value;
            }
            depth(tokens[idx]);
            state.maxDepth += tokens[idx].depth;
          }
          if (idx !== 0 || value !== "") {
            parts.push(value);
          }
          prevIndex = i;
        }
        if (prevIndex && prevIndex + 1 < input.length) {
          const value = input.slice(prevIndex + 1);
          parts.push(value);
          if (opts.tokens) {
            tokens[tokens.length - 1].value = value;
            depth(tokens[tokens.length - 1]);
            state.maxDepth += tokens[tokens.length - 1].depth;
          }
        }
        state.slashes = slashes;
        state.parts = parts;
      }
      return state;
    };
    module2.exports = scan;
  }
});

// ../../node_modules/picomatch/lib/parse.js
var require_parse = __commonJS({
  "../../node_modules/picomatch/lib/parse.js"(exports2, module2) {
    "use strict";
    var constants = require_constants();
    var utils = require_utils3();
    var {
      MAX_LENGTH,
      POSIX_REGEX_SOURCE,
      REGEX_NON_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_BACKREF,
      REPLACEMENTS
    } = constants;
    var expandRange = (args, options) => {
      if (typeof options.expandRange === "function") {
        return options.expandRange(...args, options);
      }
      args.sort();
      const value = `[${args.join("-")}]`;
      try {
        new RegExp(value);
      } catch (ex) {
        return args.map((v) => utils.escapeRegex(v)).join("..");
      }
      return value;
    };
    var syntaxError = (type, char) => {
      return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
    };
    var parse2 = (input, options) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      input = REPLACEMENTS[input] || input;
      const opts = { ...options };
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      let len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      const bos = { type: "bos", value: "", output: opts.prepend || "" };
      const tokens = [bos];
      const capture = opts.capture ? "" : "?:";
      const PLATFORM_CHARS = constants.globChars(opts.windows);
      const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);
      const {
        DOT_LITERAL,
        PLUS_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOT_SLASH,
        NO_DOTS_SLASH,
        QMARK,
        QMARK_NO_DOT,
        STAR,
        START_ANCHOR
      } = PLATFORM_CHARS;
      const globstar = (opts2) => {
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const nodot = opts.dot ? "" : NO_DOT;
      const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
      let star = opts.bash === true ? globstar(opts) : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      if (typeof opts.noext === "boolean") {
        opts.noextglob = opts.noext;
      }
      const state = {
        input,
        index: -1,
        start: 0,
        dot: opts.dot === true,
        consumed: "",
        output: "",
        prefix: "",
        backtrack: false,
        negated: false,
        brackets: 0,
        braces: 0,
        parens: 0,
        quotes: 0,
        globstar: false,
        tokens
      };
      input = utils.removePrefix(input, state);
      len = input.length;
      const extglobs = [];
      const braces = [];
      const stack = [];
      let prev = bos;
      let value;
      const eos = () => state.index === len - 1;
      const peek = state.peek = (n = 1) => input[state.index + n];
      const advance = state.advance = () => input[++state.index] || "";
      const remaining = () => input.slice(state.index + 1);
      const consume = (value2 = "", num = 0) => {
        state.consumed += value2;
        state.index += num;
      };
      const append2 = (token) => {
        state.output += token.output != null ? token.output : token.value;
        consume(token.value);
      };
      const negate = () => {
        let count = 1;
        while (peek() === "!" && (peek(2) !== "(" || peek(3) === "?")) {
          advance();
          state.start++;
          count++;
        }
        if (count % 2 === 0) {
          return false;
        }
        state.negated = true;
        state.start++;
        return true;
      };
      const increment = (type) => {
        state[type]++;
        stack.push(type);
      };
      const decrement = (type) => {
        state[type]--;
        stack.pop();
      };
      const push = (tok) => {
        if (prev.type === "globstar") {
          const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace");
          const isExtglob = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
          if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob) {
            state.output = state.output.slice(0, -prev.output.length);
            prev.type = "star";
            prev.value = "*";
            prev.output = star;
            state.output += prev.output;
          }
        }
        if (extglobs.length && tok.type !== "paren") {
          extglobs[extglobs.length - 1].inner += tok.value;
        }
        if (tok.value || tok.output) append2(tok);
        if (prev && prev.type === "text" && tok.type === "text") {
          prev.output = (prev.output || prev.value) + tok.value;
          prev.value += tok.value;
          return;
        }
        tok.prev = prev;
        tokens.push(tok);
        prev = tok;
      };
      const extglobOpen = (type, value2) => {
        const token = { ...EXTGLOB_CHARS[value2], conditions: 1, inner: "" };
        token.prev = prev;
        token.parens = state.parens;
        token.output = state.output;
        const output = (opts.capture ? "(" : "") + token.open;
        increment("parens");
        push({ type, value: value2, output: state.output ? "" : ONE_CHAR });
        push({ type: "paren", extglob: true, value: advance(), output });
        extglobs.push(token);
      };
      const extglobClose = (token) => {
        let output = token.close + (opts.capture ? ")" : "");
        let rest;
        if (token.type === "negate") {
          let extglobStar = star;
          if (token.inner && token.inner.length > 1 && token.inner.includes("/")) {
            extglobStar = globstar(opts);
          }
          if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
            output = token.close = `)$))${extglobStar}`;
          }
          if (token.inner.includes("*") && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
            const expression = parse2(rest, { ...options, fastpaths: false }).output;
            output = token.close = `)${expression})${extglobStar})`;
          }
          if (token.prev.type === "bos") {
            state.negatedExtglob = true;
          }
        }
        push({ type: "paren", extglob: true, value, output });
        decrement("parens");
      };
      if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
        let backslashes = false;
        let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first2, rest, index) => {
          if (first2 === "\\") {
            backslashes = true;
            return m;
          }
          if (first2 === "?") {
            if (esc) {
              return esc + first2 + (rest ? QMARK.repeat(rest.length) : "");
            }
            if (index === 0) {
              return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : "");
            }
            return QMARK.repeat(chars.length);
          }
          if (first2 === ".") {
            return DOT_LITERAL.repeat(chars.length);
          }
          if (first2 === "*") {
            if (esc) {
              return esc + first2 + (rest ? star : "");
            }
            return star;
          }
          return esc ? m : `\\${m}`;
        });
        if (backslashes === true) {
          if (opts.unescape === true) {
            output = output.replace(/\\/g, "");
          } else {
            output = output.replace(/\\+/g, (m) => {
              return m.length % 2 === 0 ? "\\\\" : m ? "\\" : "";
            });
          }
        }
        if (output === input && opts.contains === true) {
          state.output = input;
          return state;
        }
        state.output = utils.wrapOutput(output, state, options);
        return state;
      }
      while (!eos()) {
        value = advance();
        if (value === "\0") {
          continue;
        }
        if (value === "\\") {
          const next = peek();
          if (next === "/" && opts.bash !== true) {
            continue;
          }
          if (next === "." || next === ";") {
            continue;
          }
          if (!next) {
            value += "\\";
            push({ type: "text", value });
            continue;
          }
          const match = /^\\+/.exec(remaining());
          let slashes = 0;
          if (match && match[0].length > 2) {
            slashes = match[0].length;
            state.index += slashes;
            if (slashes % 2 !== 0) {
              value += "\\";
            }
          }
          if (opts.unescape === true) {
            value = advance();
          } else {
            value += advance();
          }
          if (state.brackets === 0) {
            push({ type: "text", value });
            continue;
          }
        }
        if (state.brackets > 0 && (value !== "]" || prev.value === "[" || prev.value === "[^")) {
          if (opts.posix !== false && value === ":") {
            const inner = prev.value.slice(1);
            if (inner.includes("[")) {
              prev.posix = true;
              if (inner.includes(":")) {
                const idx = prev.value.lastIndexOf("[");
                const pre = prev.value.slice(0, idx);
                const rest2 = prev.value.slice(idx + 2);
                const posix = POSIX_REGEX_SOURCE[rest2];
                if (posix) {
                  prev.value = pre + posix;
                  state.backtrack = true;
                  advance();
                  if (!bos.output && tokens.indexOf(prev) === 1) {
                    bos.output = ONE_CHAR;
                  }
                  continue;
                }
              }
            }
          }
          if (value === "[" && peek() !== ":" || value === "-" && peek() === "]") {
            value = `\\${value}`;
          }
          if (value === "]" && (prev.value === "[" || prev.value === "[^")) {
            value = `\\${value}`;
          }
          if (opts.posix === true && value === "!" && prev.value === "[") {
            value = "^";
          }
          prev.value += value;
          append2({ value });
          continue;
        }
        if (state.quotes === 1 && value !== '"') {
          value = utils.escapeRegex(value);
          prev.value += value;
          append2({ value });
          continue;
        }
        if (value === '"') {
          state.quotes = state.quotes === 1 ? 0 : 1;
          if (opts.keepQuotes === true) {
            push({ type: "text", value });
          }
          continue;
        }
        if (value === "(") {
          increment("parens");
          push({ type: "paren", value });
          continue;
        }
        if (value === ")") {
          if (state.parens === 0 && opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError("opening", "("));
          }
          const extglob = extglobs[extglobs.length - 1];
          if (extglob && state.parens === extglob.parens + 1) {
            extglobClose(extglobs.pop());
            continue;
          }
          push({ type: "paren", value, output: state.parens ? ")" : "\\)" });
          decrement("parens");
          continue;
        }
        if (value === "[") {
          if (opts.nobracket === true || !remaining().includes("]")) {
            if (opts.nobracket !== true && opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("closing", "]"));
            }
            value = `\\${value}`;
          } else {
            increment("brackets");
          }
          push({ type: "bracket", value });
          continue;
        }
        if (value === "]") {
          if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
            push({ type: "text", value, output: `\\${value}` });
            continue;
          }
          if (state.brackets === 0) {
            if (opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("opening", "["));
            }
            push({ type: "text", value, output: `\\${value}` });
            continue;
          }
          decrement("brackets");
          const prevValue = prev.value.slice(1);
          if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
            value = `/${value}`;
          }
          prev.value += value;
          append2({ value });
          if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
            continue;
          }
          const escaped = utils.escapeRegex(prev.value);
          state.output = state.output.slice(0, -prev.value.length);
          if (opts.literalBrackets === true) {
            state.output += escaped;
            prev.value = escaped;
            continue;
          }
          prev.value = `(${capture}${escaped}|${prev.value})`;
          state.output += prev.value;
          continue;
        }
        if (value === "{" && opts.nobrace !== true) {
          increment("braces");
          const open = {
            type: "brace",
            value,
            output: "(",
            outputIndex: state.output.length,
            tokensIndex: state.tokens.length
          };
          braces.push(open);
          push(open);
          continue;
        }
        if (value === "}") {
          const brace = braces[braces.length - 1];
          if (opts.nobrace === true || !brace) {
            push({ type: "text", value, output: value });
            continue;
          }
          let output = ")";
          if (brace.dots === true) {
            const arr = tokens.slice();
            const range = [];
            for (let i = arr.length - 1; i >= 0; i--) {
              tokens.pop();
              if (arr[i].type === "brace") {
                break;
              }
              if (arr[i].type !== "dots") {
                range.unshift(arr[i].value);
              }
            }
            output = expandRange(range, opts);
            state.backtrack = true;
          }
          if (brace.comma !== true && brace.dots !== true) {
            const out = state.output.slice(0, brace.outputIndex);
            const toks = state.tokens.slice(brace.tokensIndex);
            brace.value = brace.output = "\\{";
            value = output = "\\}";
            state.output = out;
            for (const t of toks) {
              state.output += t.output || t.value;
            }
          }
          push({ type: "brace", value, output });
          decrement("braces");
          braces.pop();
          continue;
        }
        if (value === "|") {
          if (extglobs.length > 0) {
            extglobs[extglobs.length - 1].conditions++;
          }
          push({ type: "text", value });
          continue;
        }
        if (value === ",") {
          let output = value;
          const brace = braces[braces.length - 1];
          if (brace && stack[stack.length - 1] === "braces") {
            brace.comma = true;
            output = "|";
          }
          push({ type: "comma", value, output });
          continue;
        }
        if (value === "/") {
          if (prev.type === "dot" && state.index === state.start + 1) {
            state.start = state.index + 1;
            state.consumed = "";
            state.output = "";
            tokens.pop();
            prev = bos;
            continue;
          }
          push({ type: "slash", value, output: SLASH_LITERAL });
          continue;
        }
        if (value === ".") {
          if (state.braces > 0 && prev.type === "dot") {
            if (prev.value === ".") prev.output = DOT_LITERAL;
            const brace = braces[braces.length - 1];
            prev.type = "dots";
            prev.output += value;
            prev.value += value;
            brace.dots = true;
            continue;
          }
          if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
            push({ type: "text", value, output: DOT_LITERAL });
            continue;
          }
          push({ type: "dot", value, output: DOT_LITERAL });
          continue;
        }
        if (value === "?") {
          const isGroup = prev && prev.value === "(";
          if (!isGroup && opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("qmark", value);
            continue;
          }
          if (prev && prev.type === "paren") {
            const next = peek();
            let output = value;
            if (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) {
              output = `\\${value}`;
            }
            push({ type: "text", value, output });
            continue;
          }
          if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
            push({ type: "qmark", value, output: QMARK_NO_DOT });
            continue;
          }
          push({ type: "qmark", value, output: QMARK });
          continue;
        }
        if (value === "!") {
          if (opts.noextglob !== true && peek() === "(") {
            if (peek(2) !== "?" || !/[!=<:]/.test(peek(3))) {
              extglobOpen("negate", value);
              continue;
            }
          }
          if (opts.nonegate !== true && state.index === 0) {
            negate();
            continue;
          }
        }
        if (value === "+") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("plus", value);
            continue;
          }
          if (prev && prev.value === "(" || opts.regex === false) {
            push({ type: "plus", value, output: PLUS_LITERAL });
            continue;
          }
          if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
            push({ type: "plus", value });
            continue;
          }
          push({ type: "plus", value: PLUS_LITERAL });
          continue;
        }
        if (value === "@") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            push({ type: "at", extglob: true, value, output: "" });
            continue;
          }
          push({ type: "text", value });
          continue;
        }
        if (value !== "*") {
          if (value === "$" || value === "^") {
            value = `\\${value}`;
          }
          const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
          if (match) {
            value += match[0];
            state.index += match[0].length;
          }
          push({ type: "text", value });
          continue;
        }
        if (prev && (prev.type === "globstar" || prev.star === true)) {
          prev.type = "star";
          prev.star = true;
          prev.value += value;
          prev.output = star;
          state.backtrack = true;
          state.globstar = true;
          consume(value);
          continue;
        }
        let rest = remaining();
        if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
          extglobOpen("star", value);
          continue;
        }
        if (prev.type === "star") {
          if (opts.noglobstar === true) {
            consume(value);
            continue;
          }
          const prior = prev.prev;
          const before = prior.prev;
          const isStart = prior.type === "slash" || prior.type === "bos";
          const afterStar = before && (before.type === "star" || before.type === "globstar");
          if (opts.bash === true && (!isStart || rest[0] && rest[0] !== "/")) {
            push({ type: "star", value, output: "" });
            continue;
          }
          const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace");
          const isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
          if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
            push({ type: "star", value, output: "" });
            continue;
          }
          while (rest.slice(0, 3) === "/**") {
            const after = input[state.index + 4];
            if (after && after !== "/") {
              break;
            }
            rest = rest.slice(3);
            consume("/**", 3);
          }
          if (prior.type === "bos" && eos()) {
            prev.type = "globstar";
            prev.value += value;
            prev.output = globstar(opts);
            state.output = prev.output;
            state.globstar = true;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
            prev.value += value;
            state.globstar = true;
            state.output += prior.output + prev.output;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
            const end = rest[1] !== void 0 ? "|$" : "";
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
            prev.value += value;
            state.output += prior.output + prev.output;
            state.globstar = true;
            consume(value + advance());
            push({ type: "slash", value: "/", output: "" });
            continue;
          }
          if (prior.type === "bos" && rest[0] === "/") {
            prev.type = "globstar";
            prev.value += value;
            prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
            state.output = prev.output;
            state.globstar = true;
            consume(value + advance());
            push({ type: "slash", value: "/", output: "" });
            continue;
          }
          state.output = state.output.slice(0, -prev.output.length);
          prev.type = "globstar";
          prev.output = globstar(opts);
          prev.value += value;
          state.output += prev.output;
          state.globstar = true;
          consume(value);
          continue;
        }
        const token = { type: "star", value, output: star };
        if (opts.bash === true) {
          token.output = ".*?";
          if (prev.type === "bos" || prev.type === "slash") {
            token.output = nodot + token.output;
          }
          push(token);
          continue;
        }
        if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
          token.output = value;
          push(token);
          continue;
        }
        if (state.index === state.start || prev.type === "slash" || prev.type === "dot") {
          if (prev.type === "dot") {
            state.output += NO_DOT_SLASH;
            prev.output += NO_DOT_SLASH;
          } else if (opts.dot === true) {
            state.output += NO_DOTS_SLASH;
            prev.output += NO_DOTS_SLASH;
          } else {
            state.output += nodot;
            prev.output += nodot;
          }
          if (peek() !== "*") {
            state.output += ONE_CHAR;
            prev.output += ONE_CHAR;
          }
        }
        push(token);
      }
      while (state.brackets > 0) {
        if (opts.strictBrackets === true) throw new SyntaxError(syntaxError("closing", "]"));
        state.output = utils.escapeLast(state.output, "[");
        decrement("brackets");
      }
      while (state.parens > 0) {
        if (opts.strictBrackets === true) throw new SyntaxError(syntaxError("closing", ")"));
        state.output = utils.escapeLast(state.output, "(");
        decrement("parens");
      }
      while (state.braces > 0) {
        if (opts.strictBrackets === true) throw new SyntaxError(syntaxError("closing", "}"));
        state.output = utils.escapeLast(state.output, "{");
        decrement("braces");
      }
      if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
        push({ type: "maybe_slash", value: "", output: `${SLASH_LITERAL}?` });
      }
      if (state.backtrack === true) {
        state.output = "";
        for (const token of state.tokens) {
          state.output += token.output != null ? token.output : token.value;
          if (token.suffix) {
            state.output += token.suffix;
          }
        }
      }
      return state;
    };
    parse2.fastpaths = (input, options) => {
      const opts = { ...options };
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      const len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      input = REPLACEMENTS[input] || input;
      const {
        DOT_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOTS,
        NO_DOTS_SLASH,
        STAR,
        START_ANCHOR
      } = constants.globChars(opts.windows);
      const nodot = opts.dot ? NO_DOTS : NO_DOT;
      const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
      const capture = opts.capture ? "" : "?:";
      const state = { negated: false, prefix: "" };
      let star = opts.bash === true ? ".*?" : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      const globstar = (opts2) => {
        if (opts2.noglobstar === true) return star;
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const create = (str) => {
        switch (str) {
          case "*":
            return `${nodot}${ONE_CHAR}${star}`;
          case ".*":
            return `${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*.*":
            return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*/*":
            return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;
          case "**":
            return nodot + globstar(opts);
          case "**/*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;
          case "**/*.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "**/.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;
          default: {
            const match = /^(.*?)\.(\w+)$/.exec(str);
            if (!match) return;
            const source2 = create(match[1]);
            if (!source2) return;
            return source2 + DOT_LITERAL + match[2];
          }
        }
      };
      const output = utils.removePrefix(input, state);
      let source = create(output);
      if (source && opts.strictSlashes !== true) {
        source += `${SLASH_LITERAL}?`;
      }
      return source;
    };
    module2.exports = parse2;
  }
});

// ../../node_modules/picomatch/lib/picomatch.js
var require_picomatch = __commonJS({
  "../../node_modules/picomatch/lib/picomatch.js"(exports2, module2) {
    "use strict";
    var scan = require_scan();
    var parse2 = require_parse();
    var utils = require_utils3();
    var constants = require_constants();
    var isObject = (val) => val && typeof val === "object" && !Array.isArray(val);
    var picomatch2 = (glob, options, returnState = false) => {
      if (Array.isArray(glob)) {
        const fns = glob.map((input) => picomatch2(input, options, returnState));
        const arrayMatcher = (str) => {
          for (const isMatch of fns) {
            const state2 = isMatch(str);
            if (state2) return state2;
          }
          return false;
        };
        return arrayMatcher;
      }
      const isState = isObject(glob) && glob.tokens && glob.input;
      if (glob === "" || typeof glob !== "string" && !isState) {
        throw new TypeError("Expected pattern to be a non-empty string");
      }
      const opts = options || {};
      const posix = opts.windows;
      const regex = isState ? picomatch2.compileRe(glob, options) : picomatch2.makeRe(glob, options, false, true);
      const state = regex.state;
      delete regex.state;
      let isIgnored = () => false;
      if (opts.ignore) {
        const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };
        isIgnored = picomatch2(opts.ignore, ignoreOpts, returnState);
      }
      const matcher = (input, returnObject = false) => {
        const { isMatch, match, output } = picomatch2.test(input, regex, options, { glob, posix });
        const result = { glob, state, regex, posix, input, output, match, isMatch };
        if (typeof opts.onResult === "function") {
          opts.onResult(result);
        }
        if (isMatch === false) {
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (isIgnored(input)) {
          if (typeof opts.onIgnore === "function") {
            opts.onIgnore(result);
          }
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (typeof opts.onMatch === "function") {
          opts.onMatch(result);
        }
        return returnObject ? result : true;
      };
      if (returnState) {
        matcher.state = state;
      }
      return matcher;
    };
    picomatch2.test = (input, regex, options, { glob, posix } = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected input to be a string");
      }
      if (input === "") {
        return { isMatch: false, output: "" };
      }
      const opts = options || {};
      const format = opts.format || (posix ? utils.toPosixSlashes : null);
      let match = input === glob;
      let output = match && format ? format(input) : input;
      if (match === false) {
        output = format ? format(input) : input;
        match = output === glob;
      }
      if (match === false || opts.capture === true) {
        if (opts.matchBase === true || opts.basename === true) {
          match = picomatch2.matchBase(input, regex, options, posix);
        } else {
          match = regex.exec(output);
        }
      }
      return { isMatch: Boolean(match), match, output };
    };
    picomatch2.matchBase = (input, glob, options) => {
      const regex = glob instanceof RegExp ? glob : picomatch2.makeRe(glob, options);
      return regex.test(utils.basename(input));
    };
    picomatch2.isMatch = (str, patterns, options) => picomatch2(patterns, options)(str);
    picomatch2.parse = (pattern, options) => {
      if (Array.isArray(pattern)) return pattern.map((p) => picomatch2.parse(p, options));
      return parse2(pattern, { ...options, fastpaths: false });
    };
    picomatch2.scan = (input, options) => scan(input, options);
    picomatch2.compileRe = (state, options, returnOutput = false, returnState = false) => {
      if (returnOutput === true) {
        return state.output;
      }
      const opts = options || {};
      const prepend = opts.contains ? "" : "^";
      const append2 = opts.contains ? "" : "$";
      let source = `${prepend}(?:${state.output})${append2}`;
      if (state && state.negated === true) {
        source = `^(?!${source}).*$`;
      }
      const regex = picomatch2.toRegex(source, options);
      if (returnState === true) {
        regex.state = state;
      }
      return regex;
    };
    picomatch2.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {
      if (!input || typeof input !== "string") {
        throw new TypeError("Expected a non-empty string");
      }
      let parsed = { negated: false, fastpaths: true };
      if (options.fastpaths !== false && (input[0] === "." || input[0] === "*")) {
        parsed.output = parse2.fastpaths(input, options);
      }
      if (!parsed.output) {
        parsed = parse2(input, options);
      }
      return picomatch2.compileRe(parsed, options, returnOutput, returnState);
    };
    picomatch2.toRegex = (source, options) => {
      try {
        const opts = options || {};
        return new RegExp(source, opts.flags || (opts.nocase ? "i" : ""));
      } catch (err) {
        if (options && options.debug === true) throw err;
        return /$^/;
      }
    };
    picomatch2.constants = constants;
    module2.exports = picomatch2;
  }
});

// ../../node_modules/picomatch/index.js
var require_picomatch2 = __commonJS({
  "../../node_modules/picomatch/index.js"(exports2, module2) {
    "use strict";
    var pico = require_picomatch();
    var utils = require_utils3();
    function picomatch2(glob, options, returnState = false) {
      if (options && (options.windows === null || options.windows === void 0)) {
        options = { ...options, windows: utils.isWindows() };
      }
      return pico(glob, options, returnState);
    }
    Object.assign(picomatch2, pico);
    module2.exports = picomatch2;
  }
});

// ../../node_modules/ignore/index.js
var require_ignore = __commonJS({
  "../../node_modules/ignore/index.js"(exports2, module2) {
    "use strict";
    function makeArray(subject) {
      return Array.isArray(subject) ? subject : [subject];
    }
    var UNDEFINED = void 0;
    var EMPTY = "";
    var SPACE = " ";
    var ESCAPE = "\\";
    var REGEX_TEST_BLANK_LINE = /^\s+$/;
    var REGEX_INVALID_TRAILING_BACKSLASH = /(?:[^\\]|^)\\$/;
    var REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\!/;
    var REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\#/;
    var REGEX_SPLITALL_CRLF = /\r?\n/g;
    var REGEX_TEST_INVALID_PATH = /^\.{0,2}\/|^\.{1,2}$/;
    var REGEX_TEST_TRAILING_SLASH = /\/$/;
    var SLASH = "/";
    var TMP_KEY_IGNORE = "node-ignore";
    if (typeof Symbol !== "undefined") {
      TMP_KEY_IGNORE = /* @__PURE__ */ Symbol.for("node-ignore");
    }
    var KEY_IGNORE = TMP_KEY_IGNORE;
    var define = (object, key, value) => {
      Object.defineProperty(object, key, { value });
      return value;
    };
    var REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g;
    var RETURN_FALSE = () => false;
    var sanitizeRange = (range) => range.replace(
      REGEX_REGEXP_RANGE,
      (match, from, to) => from.charCodeAt(0) <= to.charCodeAt(0) ? match : EMPTY
    );
    var cleanRangeBackSlash = (slashes) => {
      const { length } = slashes;
      return slashes.slice(0, length - length % 2);
    };
    var REPLACERS = [
      [
        // Remove BOM
        // TODO:
        // Other similar zero-width characters?
        /^\uFEFF/,
        () => EMPTY
      ],
      // > Trailing spaces are ignored unless they are quoted with backslash ("\")
      [
        // (a\ ) -> (a )
        // (a  ) -> (a)
        // (a ) -> (a)
        // (a \ ) -> (a  )
        /((?:\\\\)*?)(\\?\s+)$/,
        (_, m1, m2) => m1 + (m2.indexOf("\\") === 0 ? SPACE : EMPTY)
      ],
      // Replace (\ ) with ' '
      // (\ ) -> ' '
      // (\\ ) -> '\\ '
      // (\\\ ) -> '\\ '
      [
        /(\\+?)\s/g,
        (_, m1) => {
          const { length } = m1;
          return m1.slice(0, length - length % 2) + SPACE;
        }
      ],
      // Escape metacharacters
      // which is written down by users but means special for regular expressions.
      // > There are 12 characters with special meanings:
      // > - the backslash \,
      // > - the caret ^,
      // > - the dollar sign $,
      // > - the period or dot .,
      // > - the vertical bar or pipe symbol |,
      // > - the question mark ?,
      // > - the asterisk or star *,
      // > - the plus sign +,
      // > - the opening parenthesis (,
      // > - the closing parenthesis ),
      // > - and the opening square bracket [,
      // > - the opening curly brace {,
      // > These special characters are often called "metacharacters".
      [
        /[\\$.|*+(){^]/g,
        (match) => `\\${match}`
      ],
      [
        // > a question mark (?) matches a single character
        /(?!\\)\?/g,
        () => "[^/]"
      ],
      // leading slash
      [
        // > A leading slash matches the beginning of the pathname.
        // > For example, "/*.c" matches "cat-file.c" but not "mozilla-sha1/sha1.c".
        // A leading slash matches the beginning of the pathname
        /^\//,
        () => "^"
      ],
      // replace special metacharacter slash after the leading slash
      [
        /\//g,
        () => "\\/"
      ],
      [
        // > A leading "**" followed by a slash means match in all directories.
        // > For example, "**/foo" matches file or directory "foo" anywhere,
        // > the same as pattern "foo".
        // > "**/foo/bar" matches file or directory "bar" anywhere that is directly
        // >   under directory "foo".
        // Notice that the '*'s have been replaced as '\\*'
        /^\^*\\\*\\\*\\\//,
        // '**/foo' <-> 'foo'
        () => "^(?:.*\\/)?"
      ],
      // starting
      [
        // there will be no leading '/'
        //   (which has been replaced by section "leading slash")
        // If starts with '**', adding a '^' to the regular expression also works
        /^(?=[^^])/,
        function startingReplacer() {
          return !/\/(?!$)/.test(this) ? "(?:^|\\/)" : "^";
        }
      ],
      // two globstars
      [
        // Use lookahead assertions so that we could match more than one `'/**'`
        /\\\/\\\*\\\*(?=\\\/|$)/g,
        // Zero, one or several directories
        // should not use '*', or it will be replaced by the next replacer
        // Check if it is not the last `'/**'`
        (_, index, str) => index + 6 < str.length ? "(?:\\/[^\\/]+)*" : "\\/.+"
      ],
      // normal intermediate wildcards
      [
        // Never replace escaped '*'
        // ignore rule '\*' will match the path '*'
        // 'abc.*/' -> go
        // 'abc.*'  -> skip this rule,
        //    coz trailing single wildcard will be handed by [trailing wildcard]
        /(^|[^\\]+)(\\\*)+(?=.+)/g,
        // '*.js' matches '.js'
        // '*.js' doesn't match 'abc'
        (_, p1, p2) => {
          const unescaped = p2.replace(/\\\*/g, "[^\\/]*");
          return p1 + unescaped;
        }
      ],
      [
        // unescape, revert step 3 except for back slash
        // For example, if a user escape a '\\*',
        // after step 3, the result will be '\\\\\\*'
        /\\\\\\(?=[$.|*+(){^])/g,
        () => ESCAPE
      ],
      [
        // '\\\\' -> '\\'
        /\\\\/g,
        () => ESCAPE
      ],
      [
        // > The range notation, e.g. [a-zA-Z],
        // > can be used to match one of the characters in a range.
        // `\` is escaped by step 3
        /(\\)?\[([^\]/]*?)(\\*)($|\])/g,
        (match, leadEscape, range, endEscape, close) => leadEscape === ESCAPE ? `\\[${range}${cleanRangeBackSlash(endEscape)}${close}` : close === "]" ? endEscape.length % 2 === 0 ? `[${sanitizeRange(range)}${endEscape}]` : "[]" : "[]"
      ],
      // ending
      [
        // 'js' will not match 'js.'
        // 'ab' will not match 'abc'
        /(?:[^*])$/,
        // WTF!
        // https://git-scm.com/docs/gitignore
        // changes in [2.22.1](https://git-scm.com/docs/gitignore/2.22.1)
        // which re-fixes #24, #38
        // > If there is a separator at the end of the pattern then the pattern
        // > will only match directories, otherwise the pattern can match both
        // > files and directories.
        // 'js*' will not match 'a.js'
        // 'js/' will not match 'a.js'
        // 'js' will match 'a.js' and 'a.js/'
        (match) => /\/$/.test(match) ? `${match}$` : `${match}(?=$|\\/$)`
      ]
    ];
    var REGEX_REPLACE_TRAILING_WILDCARD = /(^|\\\/)?\\\*$/;
    var MODE_IGNORE = "regex";
    var MODE_CHECK_IGNORE = "checkRegex";
    var UNDERSCORE = "_";
    var TRAILING_WILD_CARD_REPLACERS = {
      [MODE_IGNORE](_, p1) {
        const prefix = p1 ? `${p1}[^/]+` : "[^/]*";
        return `${prefix}(?=$|\\/$)`;
      },
      [MODE_CHECK_IGNORE](_, p1) {
        const prefix = p1 ? `${p1}[^/]*` : "[^/]*";
        return `${prefix}(?=$|\\/$)`;
      }
    };
    var makeRegexPrefix = (pattern) => REPLACERS.reduce(
      (prev, [matcher, replacer]) => prev.replace(matcher, replacer.bind(pattern)),
      pattern
    );
    var isString = (subject) => typeof subject === "string";
    var checkPattern = (pattern) => pattern && isString(pattern) && !REGEX_TEST_BLANK_LINE.test(pattern) && !REGEX_INVALID_TRAILING_BACKSLASH.test(pattern) && pattern.indexOf("#") !== 0;
    var splitPattern = (pattern) => pattern.split(REGEX_SPLITALL_CRLF).filter(Boolean);
    var IgnoreRule = class {
      constructor(pattern, mark, body, ignoreCase, negative, prefix) {
        this.pattern = pattern;
        this.mark = mark;
        this.negative = negative;
        define(this, "body", body);
        define(this, "ignoreCase", ignoreCase);
        define(this, "regexPrefix", prefix);
      }
      get regex() {
        const key = UNDERSCORE + MODE_IGNORE;
        if (this[key]) {
          return this[key];
        }
        return this._make(MODE_IGNORE, key);
      }
      get checkRegex() {
        const key = UNDERSCORE + MODE_CHECK_IGNORE;
        if (this[key]) {
          return this[key];
        }
        return this._make(MODE_CHECK_IGNORE, key);
      }
      _make(mode, key) {
        const str = this.regexPrefix.replace(
          REGEX_REPLACE_TRAILING_WILDCARD,
          // It does not need to bind pattern
          TRAILING_WILD_CARD_REPLACERS[mode]
        );
        const regex = this.ignoreCase ? new RegExp(str, "i") : new RegExp(str);
        return define(this, key, regex);
      }
    };
    var createRule = ({
      pattern,
      mark
    }, ignoreCase) => {
      let negative = false;
      let body = pattern;
      if (body.indexOf("!") === 0) {
        negative = true;
        body = body.substr(1);
      }
      body = body.replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, "!").replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, "#");
      const regexPrefix = makeRegexPrefix(body);
      return new IgnoreRule(
        pattern,
        mark,
        body,
        ignoreCase,
        negative,
        regexPrefix
      );
    };
    var RuleManager = class {
      constructor(ignoreCase) {
        this._ignoreCase = ignoreCase;
        this._rules = [];
      }
      _add(pattern) {
        if (pattern && pattern[KEY_IGNORE]) {
          this._rules = this._rules.concat(pattern._rules._rules);
          this._added = true;
          return;
        }
        if (isString(pattern)) {
          pattern = {
            pattern
          };
        }
        if (checkPattern(pattern.pattern)) {
          const rule = createRule(pattern, this._ignoreCase);
          this._added = true;
          this._rules.push(rule);
        }
      }
      // @param {Array<string> | string | Ignore} pattern
      add(pattern) {
        this._added = false;
        makeArray(
          isString(pattern) ? splitPattern(pattern) : pattern
        ).forEach(this._add, this);
        return this._added;
      }
      // Test one single path without recursively checking parent directories
      //
      // - checkUnignored `boolean` whether should check if the path is unignored,
      //   setting `checkUnignored` to `false` could reduce additional
      //   path matching.
      // - check `string` either `MODE_IGNORE` or `MODE_CHECK_IGNORE`
      // @returns {TestResult} true if a file is ignored
      test(path11, checkUnignored, mode) {
        let ignored = false;
        let unignored = false;
        let matchedRule;
        this._rules.forEach((rule) => {
          const { negative } = rule;
          if (unignored === negative && ignored !== unignored || negative && !ignored && !unignored && !checkUnignored) {
            return;
          }
          const matched = rule[mode].test(path11);
          if (!matched) {
            return;
          }
          ignored = !negative;
          unignored = negative;
          matchedRule = negative ? UNDEFINED : rule;
        });
        const ret = {
          ignored,
          unignored
        };
        if (matchedRule) {
          ret.rule = matchedRule;
        }
        return ret;
      }
    };
    var throwError = (message, Ctor) => {
      throw new Ctor(message);
    };
    var checkPath = (path11, originalPath, doThrow) => {
      if (!isString(path11)) {
        return doThrow(
          `path must be a string, but got \`${originalPath}\``,
          TypeError
        );
      }
      if (!path11) {
        return doThrow(`path must not be empty`, TypeError);
      }
      if (checkPath.isNotRelative(path11)) {
        const r = "`path.relative()`d";
        return doThrow(
          `path should be a ${r} string, but got "${originalPath}"`,
          RangeError
        );
      }
      return true;
    };
    var isNotRelative = (path11) => REGEX_TEST_INVALID_PATH.test(path11);
    checkPath.isNotRelative = isNotRelative;
    checkPath.convert = (p) => p;
    var Ignore = class {
      constructor({
        ignorecase = true,
        ignoreCase = ignorecase,
        allowRelativePaths = false
      } = {}) {
        define(this, KEY_IGNORE, true);
        this._rules = new RuleManager(ignoreCase);
        this._strictPathCheck = !allowRelativePaths;
        this._initCache();
      }
      _initCache() {
        this._ignoreCache = /* @__PURE__ */ Object.create(null);
        this._testCache = /* @__PURE__ */ Object.create(null);
      }
      add(pattern) {
        if (this._rules.add(pattern)) {
          this._initCache();
        }
        return this;
      }
      // legacy
      addPattern(pattern) {
        return this.add(pattern);
      }
      // @returns {TestResult}
      _test(originalPath, cache2, checkUnignored, slices) {
        const path11 = originalPath && checkPath.convert(originalPath);
        checkPath(
          path11,
          originalPath,
          this._strictPathCheck ? throwError : RETURN_FALSE
        );
        return this._t(path11, cache2, checkUnignored, slices);
      }
      checkIgnore(path11) {
        if (!REGEX_TEST_TRAILING_SLASH.test(path11)) {
          return this.test(path11);
        }
        const slices = path11.split(SLASH).filter(Boolean);
        slices.pop();
        if (slices.length) {
          const parent = this._t(
            slices.join(SLASH) + SLASH,
            this._testCache,
            true,
            slices
          );
          if (parent.ignored) {
            return parent;
          }
        }
        return this._rules.test(path11, false, MODE_CHECK_IGNORE);
      }
      _t(path11, cache2, checkUnignored, slices) {
        if (path11 in cache2) {
          return cache2[path11];
        }
        if (!slices) {
          slices = path11.split(SLASH).filter(Boolean);
        }
        slices.pop();
        if (!slices.length) {
          return cache2[path11] = this._rules.test(path11, checkUnignored, MODE_IGNORE);
        }
        const parent = this._t(
          slices.join(SLASH) + SLASH,
          cache2,
          checkUnignored,
          slices
        );
        return cache2[path11] = parent.ignored ? parent : this._rules.test(path11, checkUnignored, MODE_IGNORE);
      }
      ignores(path11) {
        return this._test(path11, this._ignoreCache, false).ignored;
      }
      createFilter() {
        return (path11) => !this.ignores(path11);
      }
      filter(paths) {
        return makeArray(paths).filter(this.createFilter());
      }
      // @returns {TestResult}
      test(path11) {
        return this._test(path11, this._testCache, true);
      }
    };
    var factory = (options) => new Ignore(options);
    var isPathValid = (path11) => checkPath(path11 && checkPath.convert(path11), path11, RETURN_FALSE);
    var setupWindows = () => {
      const makePosix = (str) => /^\\\\\?\\/.test(str) || /["<>|\u0000-\u001F]+/u.test(str) ? str : str.replace(/\\/g, "/");
      checkPath.convert = makePosix;
      const REGEX_TEST_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\//i;
      checkPath.isNotRelative = (path11) => REGEX_TEST_WINDOWS_PATH_ABSOLUTE.test(path11) || isNotRelative(path11);
    };
    if (
      // Detect `process` so that it can run in browsers.
      typeof process !== "undefined" && process.platform === "win32"
    ) {
      setupWindows();
    }
    module2.exports = factory;
    factory.default = factory;
    module2.exports.isPathValid = isPathValid;
    define(module2.exports, /* @__PURE__ */ Symbol.for("setupWindows"), setupWindows);
  }
});

// ../../node_modules/@kwsites/file-exists/dist/src/index.js
var require_src3 = __commonJS({
  "../../node_modules/@kwsites/file-exists/dist/src/index.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var fs_1 = require("fs");
    var debug_1 = __importDefault(require_src());
    var log = debug_1.default("@kwsites/file-exists");
    function check(path11, isFile, isDirectory) {
      log(`checking %s`, path11);
      try {
        const stat3 = fs_1.statSync(path11);
        if (stat3.isFile() && isFile) {
          log(`[OK] path represents a file`);
          return true;
        }
        if (stat3.isDirectory() && isDirectory) {
          log(`[OK] path represents a directory`);
          return true;
        }
        log(`[FAIL] path represents something other than a file or directory`);
        return false;
      } catch (e) {
        if (e.code === "ENOENT") {
          log(`[FAIL] path is not accessible: %o`, e);
          return false;
        }
        log(`[FATAL] %o`, e);
        throw e;
      }
    }
    function exists2(path11, type = exports2.READABLE) {
      return check(path11, (type & exports2.FILE) > 0, (type & exports2.FOLDER) > 0);
    }
    exports2.exists = exists2;
    exports2.FILE = 1;
    exports2.FOLDER = 2;
    exports2.READABLE = exports2.FILE + exports2.FOLDER;
  }
});

// ../../node_modules/@kwsites/file-exists/dist/index.js
var require_dist = __commonJS({
  "../../node_modules/@kwsites/file-exists/dist/index.js"(exports2) {
    "use strict";
    function __export3(m) {
      for (var p in m) if (!exports2.hasOwnProperty(p)) exports2[p] = m[p];
    }
    Object.defineProperty(exports2, "__esModule", { value: true });
    __export3(require_src3());
  }
});

// ../../node_modules/@kwsites/promise-deferred/dist/index.js
var require_dist2 = __commonJS({
  "../../node_modules/@kwsites/promise-deferred/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createDeferred = exports2.deferred = void 0;
    function deferred2() {
      let done;
      let fail;
      let status = "pending";
      const promise2 = new Promise((_done, _fail) => {
        done = _done;
        fail = _fail;
      });
      return {
        promise: promise2,
        done(result) {
          if (status === "pending") {
            status = "resolved";
            done(result);
          }
        },
        fail(error) {
          if (status === "pending") {
            status = "rejected";
            fail(error);
          }
        },
        get fulfilled() {
          return status !== "pending";
        },
        get status() {
          return status;
        }
      };
    }
    exports2.deferred = deferred2;
    exports2.createDeferred = deferred2;
    exports2.default = deferred2;
  }
});

// ../../node_modules/yaml/dist/nodes/identity.js
var require_identity = __commonJS({
  "../../node_modules/yaml/dist/nodes/identity.js"(exports2) {
    "use strict";
    var ALIAS = /* @__PURE__ */ Symbol.for("yaml.alias");
    var DOC = /* @__PURE__ */ Symbol.for("yaml.document");
    var MAP = /* @__PURE__ */ Symbol.for("yaml.map");
    var PAIR = /* @__PURE__ */ Symbol.for("yaml.pair");
    var SCALAR = /* @__PURE__ */ Symbol.for("yaml.scalar");
    var SEQ = /* @__PURE__ */ Symbol.for("yaml.seq");
    var NODE_TYPE = /* @__PURE__ */ Symbol.for("yaml.node.type");
    var isAlias = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === ALIAS;
    var isDocument = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === DOC;
    var isMap = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === MAP;
    var isPair = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === PAIR;
    var isScalar = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SCALAR;
    var isSeq = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SEQ;
    function isCollection(node) {
      if (node && typeof node === "object")
        switch (node[NODE_TYPE]) {
          case MAP:
          case SEQ:
            return true;
        }
      return false;
    }
    function isNode(node) {
      if (node && typeof node === "object")
        switch (node[NODE_TYPE]) {
          case ALIAS:
          case MAP:
          case SCALAR:
          case SEQ:
            return true;
        }
      return false;
    }
    var hasAnchor = (node) => (isScalar(node) || isCollection(node)) && !!node.anchor;
    exports2.ALIAS = ALIAS;
    exports2.DOC = DOC;
    exports2.MAP = MAP;
    exports2.NODE_TYPE = NODE_TYPE;
    exports2.PAIR = PAIR;
    exports2.SCALAR = SCALAR;
    exports2.SEQ = SEQ;
    exports2.hasAnchor = hasAnchor;
    exports2.isAlias = isAlias;
    exports2.isCollection = isCollection;
    exports2.isDocument = isDocument;
    exports2.isMap = isMap;
    exports2.isNode = isNode;
    exports2.isPair = isPair;
    exports2.isScalar = isScalar;
    exports2.isSeq = isSeq;
  }
});

// ../../node_modules/yaml/dist/visit.js
var require_visit = __commonJS({
  "../../node_modules/yaml/dist/visit.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var BREAK = /* @__PURE__ */ Symbol("break visit");
    var SKIP = /* @__PURE__ */ Symbol("skip children");
    var REMOVE = /* @__PURE__ */ Symbol("remove node");
    function visit(node, visitor) {
      const visitor_ = initVisitor(visitor);
      if (identity.isDocument(node)) {
        const cd = visit_(null, node.contents, visitor_, Object.freeze([node]));
        if (cd === REMOVE)
          node.contents = null;
      } else
        visit_(null, node, visitor_, Object.freeze([]));
    }
    visit.BREAK = BREAK;
    visit.SKIP = SKIP;
    visit.REMOVE = REMOVE;
    function visit_(key, node, visitor, path11) {
      const ctrl = callVisitor(key, node, visitor, path11);
      if (identity.isNode(ctrl) || identity.isPair(ctrl)) {
        replaceNode(key, path11, ctrl);
        return visit_(key, ctrl, visitor, path11);
      }
      if (typeof ctrl !== "symbol") {
        if (identity.isCollection(node)) {
          path11 = Object.freeze(path11.concat(node));
          for (let i = 0; i < node.items.length; ++i) {
            const ci = visit_(i, node.items[i], visitor, path11);
            if (typeof ci === "number")
              i = ci - 1;
            else if (ci === BREAK)
              return BREAK;
            else if (ci === REMOVE) {
              node.items.splice(i, 1);
              i -= 1;
            }
          }
        } else if (identity.isPair(node)) {
          path11 = Object.freeze(path11.concat(node));
          const ck = visit_("key", node.key, visitor, path11);
          if (ck === BREAK)
            return BREAK;
          else if (ck === REMOVE)
            node.key = null;
          const cv = visit_("value", node.value, visitor, path11);
          if (cv === BREAK)
            return BREAK;
          else if (cv === REMOVE)
            node.value = null;
        }
      }
      return ctrl;
    }
    async function visitAsync(node, visitor) {
      const visitor_ = initVisitor(visitor);
      if (identity.isDocument(node)) {
        const cd = await visitAsync_(null, node.contents, visitor_, Object.freeze([node]));
        if (cd === REMOVE)
          node.contents = null;
      } else
        await visitAsync_(null, node, visitor_, Object.freeze([]));
    }
    visitAsync.BREAK = BREAK;
    visitAsync.SKIP = SKIP;
    visitAsync.REMOVE = REMOVE;
    async function visitAsync_(key, node, visitor, path11) {
      const ctrl = await callVisitor(key, node, visitor, path11);
      if (identity.isNode(ctrl) || identity.isPair(ctrl)) {
        replaceNode(key, path11, ctrl);
        return visitAsync_(key, ctrl, visitor, path11);
      }
      if (typeof ctrl !== "symbol") {
        if (identity.isCollection(node)) {
          path11 = Object.freeze(path11.concat(node));
          for (let i = 0; i < node.items.length; ++i) {
            const ci = await visitAsync_(i, node.items[i], visitor, path11);
            if (typeof ci === "number")
              i = ci - 1;
            else if (ci === BREAK)
              return BREAK;
            else if (ci === REMOVE) {
              node.items.splice(i, 1);
              i -= 1;
            }
          }
        } else if (identity.isPair(node)) {
          path11 = Object.freeze(path11.concat(node));
          const ck = await visitAsync_("key", node.key, visitor, path11);
          if (ck === BREAK)
            return BREAK;
          else if (ck === REMOVE)
            node.key = null;
          const cv = await visitAsync_("value", node.value, visitor, path11);
          if (cv === BREAK)
            return BREAK;
          else if (cv === REMOVE)
            node.value = null;
        }
      }
      return ctrl;
    }
    function initVisitor(visitor) {
      if (typeof visitor === "object" && (visitor.Collection || visitor.Node || visitor.Value)) {
        return Object.assign({
          Alias: visitor.Node,
          Map: visitor.Node,
          Scalar: visitor.Node,
          Seq: visitor.Node
        }, visitor.Value && {
          Map: visitor.Value,
          Scalar: visitor.Value,
          Seq: visitor.Value
        }, visitor.Collection && {
          Map: visitor.Collection,
          Seq: visitor.Collection
        }, visitor);
      }
      return visitor;
    }
    function callVisitor(key, node, visitor, path11) {
      if (typeof visitor === "function")
        return visitor(key, node, path11);
      if (identity.isMap(node))
        return visitor.Map?.(key, node, path11);
      if (identity.isSeq(node))
        return visitor.Seq?.(key, node, path11);
      if (identity.isPair(node))
        return visitor.Pair?.(key, node, path11);
      if (identity.isScalar(node))
        return visitor.Scalar?.(key, node, path11);
      if (identity.isAlias(node))
        return visitor.Alias?.(key, node, path11);
      return void 0;
    }
    function replaceNode(key, path11, node) {
      const parent = path11[path11.length - 1];
      if (identity.isCollection(parent)) {
        parent.items[key] = node;
      } else if (identity.isPair(parent)) {
        if (key === "key")
          parent.key = node;
        else
          parent.value = node;
      } else if (identity.isDocument(parent)) {
        parent.contents = node;
      } else {
        const pt = identity.isAlias(parent) ? "alias" : "scalar";
        throw new Error(`Cannot replace node with ${pt} parent`);
      }
    }
    exports2.visit = visit;
    exports2.visitAsync = visitAsync;
  }
});

// ../../node_modules/yaml/dist/doc/directives.js
var require_directives = __commonJS({
  "../../node_modules/yaml/dist/doc/directives.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var visit = require_visit();
    var escapeChars = {
      "!": "%21",
      ",": "%2C",
      "[": "%5B",
      "]": "%5D",
      "{": "%7B",
      "}": "%7D"
    };
    var escapeTagName = (tn) => tn.replace(/[!,[\]{}]/g, (ch) => escapeChars[ch]);
    var Directives = class _Directives {
      constructor(yaml, tags) {
        this.docStart = null;
        this.docEnd = false;
        this.yaml = Object.assign({}, _Directives.defaultYaml, yaml);
        this.tags = Object.assign({}, _Directives.defaultTags, tags);
      }
      clone() {
        const copy = new _Directives(this.yaml, this.tags);
        copy.docStart = this.docStart;
        return copy;
      }
      /**
       * During parsing, get a Directives instance for the current document and
       * update the stream state according to the current version's spec.
       */
      atDocument() {
        const res = new _Directives(this.yaml, this.tags);
        switch (this.yaml.version) {
          case "1.1":
            this.atNextDocument = true;
            break;
          case "1.2":
            this.atNextDocument = false;
            this.yaml = {
              explicit: _Directives.defaultYaml.explicit,
              version: "1.2"
            };
            this.tags = Object.assign({}, _Directives.defaultTags);
            break;
        }
        return res;
      }
      /**
       * @param onError - May be called even if the action was successful
       * @returns `true` on success
       */
      add(line, onError2) {
        if (this.atNextDocument) {
          this.yaml = { explicit: _Directives.defaultYaml.explicit, version: "1.1" };
          this.tags = Object.assign({}, _Directives.defaultTags);
          this.atNextDocument = false;
        }
        const parts = line.trim().split(/[ \t]+/);
        const name = parts.shift();
        switch (name) {
          case "%TAG": {
            if (parts.length !== 2) {
              onError2(0, "%TAG directive should contain exactly two parts");
              if (parts.length < 2)
                return false;
            }
            const [handle, prefix] = parts;
            this.tags[handle] = prefix;
            return true;
          }
          case "%YAML": {
            this.yaml.explicit = true;
            if (parts.length !== 1) {
              onError2(0, "%YAML directive should contain exactly one part");
              return false;
            }
            const [version] = parts;
            if (version === "1.1" || version === "1.2") {
              this.yaml.version = version;
              return true;
            } else {
              const isValid2 = /^\d+\.\d+$/.test(version);
              onError2(6, `Unsupported YAML version ${version}`, isValid2);
              return false;
            }
          }
          default:
            onError2(0, `Unknown directive ${name}`, true);
            return false;
        }
      }
      /**
       * Resolves a tag, matching handles to those defined in %TAG directives.
       *
       * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
       *   `'!local'` tag, or `null` if unresolvable.
       */
      tagName(source, onError2) {
        if (source === "!")
          return "!";
        if (source[0] !== "!") {
          onError2(`Not a valid tag: ${source}`);
          return null;
        }
        if (source[1] === "<") {
          const verbatim = source.slice(2, -1);
          if (verbatim === "!" || verbatim === "!!") {
            onError2(`Verbatim tags aren't resolved, so ${source} is invalid.`);
            return null;
          }
          if (source[source.length - 1] !== ">")
            onError2("Verbatim tags must end with a >");
          return verbatim;
        }
        const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/s);
        if (!suffix)
          onError2(`The ${source} tag has no suffix`);
        const prefix = this.tags[handle];
        if (prefix) {
          try {
            return prefix + decodeURIComponent(suffix);
          } catch (error) {
            onError2(String(error));
            return null;
          }
        }
        if (handle === "!")
          return source;
        onError2(`Could not resolve tag: ${source}`);
        return null;
      }
      /**
       * Given a fully resolved tag, returns its printable string form,
       * taking into account current tag prefixes and defaults.
       */
      tagString(tag) {
        for (const [handle, prefix] of Object.entries(this.tags)) {
          if (tag.startsWith(prefix))
            return handle + escapeTagName(tag.substring(prefix.length));
        }
        return tag[0] === "!" ? tag : `!<${tag}>`;
      }
      toString(doc) {
        const lines = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [];
        const tagEntries = Object.entries(this.tags);
        let tagNames;
        if (doc && tagEntries.length > 0 && identity.isNode(doc.contents)) {
          const tags = {};
          visit.visit(doc.contents, (_key, node) => {
            if (identity.isNode(node) && node.tag)
              tags[node.tag] = true;
          });
          tagNames = Object.keys(tags);
        } else
          tagNames = [];
        for (const [handle, prefix] of tagEntries) {
          if (handle === "!!" && prefix === "tag:yaml.org,2002:")
            continue;
          if (!doc || tagNames.some((tn) => tn.startsWith(prefix)))
            lines.push(`%TAG ${handle} ${prefix}`);
        }
        return lines.join("\n");
      }
    };
    Directives.defaultYaml = { explicit: false, version: "1.2" };
    Directives.defaultTags = { "!!": "tag:yaml.org,2002:" };
    exports2.Directives = Directives;
  }
});

// ../../node_modules/yaml/dist/doc/anchors.js
var require_anchors = __commonJS({
  "../../node_modules/yaml/dist/doc/anchors.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var visit = require_visit();
    function anchorIsValid(anchor) {
      if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
        const sa = JSON.stringify(anchor);
        const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
        throw new Error(msg);
      }
      return true;
    }
    function anchorNames(root) {
      const anchors = /* @__PURE__ */ new Set();
      visit.visit(root, {
        Value(_key, node) {
          if (node.anchor)
            anchors.add(node.anchor);
        }
      });
      return anchors;
    }
    function findNewAnchor(prefix, exclude) {
      for (let i = 1; true; ++i) {
        const name = `${prefix}${i}`;
        if (!exclude.has(name))
          return name;
      }
    }
    function createNodeAnchors(doc, prefix) {
      const aliasObjects = [];
      const sourceObjects = /* @__PURE__ */ new Map();
      let prevAnchors = null;
      return {
        onAnchor: (source) => {
          aliasObjects.push(source);
          prevAnchors ?? (prevAnchors = anchorNames(doc));
          const anchor = findNewAnchor(prefix, prevAnchors);
          prevAnchors.add(anchor);
          return anchor;
        },
        /**
         * With circular references, the source node is only resolved after all
         * of its child nodes are. This is why anchors are set only after all of
         * the nodes have been created.
         */
        setAnchors: () => {
          for (const source of aliasObjects) {
            const ref = sourceObjects.get(source);
            if (typeof ref === "object" && ref.anchor && (identity.isScalar(ref.node) || identity.isCollection(ref.node))) {
              ref.node.anchor = ref.anchor;
            } else {
              const error = new Error("Failed to resolve repeated object (this should not happen)");
              error.source = source;
              throw error;
            }
          }
        },
        sourceObjects
      };
    }
    exports2.anchorIsValid = anchorIsValid;
    exports2.anchorNames = anchorNames;
    exports2.createNodeAnchors = createNodeAnchors;
    exports2.findNewAnchor = findNewAnchor;
  }
});

// ../../node_modules/yaml/dist/doc/applyReviver.js
var require_applyReviver = __commonJS({
  "../../node_modules/yaml/dist/doc/applyReviver.js"(exports2) {
    "use strict";
    function applyReviver(reviver, obj, key, val) {
      if (val && typeof val === "object") {
        if (Array.isArray(val)) {
          for (let i = 0, len = val.length; i < len; ++i) {
            const v0 = val[i];
            const v1 = applyReviver(reviver, val, String(i), v0);
            if (v1 === void 0)
              delete val[i];
            else if (v1 !== v0)
              val[i] = v1;
          }
        } else if (val instanceof Map) {
          for (const k of Array.from(val.keys())) {
            const v0 = val.get(k);
            const v1 = applyReviver(reviver, val, k, v0);
            if (v1 === void 0)
              val.delete(k);
            else if (v1 !== v0)
              val.set(k, v1);
          }
        } else if (val instanceof Set) {
          for (const v0 of Array.from(val)) {
            const v1 = applyReviver(reviver, val, v0, v0);
            if (v1 === void 0)
              val.delete(v0);
            else if (v1 !== v0) {
              val.delete(v0);
              val.add(v1);
            }
          }
        } else {
          for (const [k, v0] of Object.entries(val)) {
            const v1 = applyReviver(reviver, val, k, v0);
            if (v1 === void 0)
              delete val[k];
            else if (v1 !== v0)
              val[k] = v1;
          }
        }
      }
      return reviver.call(obj, key, val);
    }
    exports2.applyReviver = applyReviver;
  }
});

// ../../node_modules/yaml/dist/nodes/toJS.js
var require_toJS = __commonJS({
  "../../node_modules/yaml/dist/nodes/toJS.js"(exports2) {
    "use strict";
    var identity = require_identity();
    function toJS(value, arg, ctx) {
      if (Array.isArray(value))
        return value.map((v, i) => toJS(v, String(i), ctx));
      if (value && typeof value.toJSON === "function") {
        if (!ctx || !identity.hasAnchor(value))
          return value.toJSON(arg, ctx);
        const data = { aliasCount: 0, count: 1, res: void 0 };
        ctx.anchors.set(value, data);
        ctx.onCreate = (res2) => {
          data.res = res2;
          delete ctx.onCreate;
        };
        const res = value.toJSON(arg, ctx);
        if (ctx.onCreate)
          ctx.onCreate(res);
        return res;
      }
      if (typeof value === "bigint" && !ctx?.keep)
        return Number(value);
      return value;
    }
    exports2.toJS = toJS;
  }
});

// ../../node_modules/yaml/dist/nodes/Node.js
var require_Node = __commonJS({
  "../../node_modules/yaml/dist/nodes/Node.js"(exports2) {
    "use strict";
    var applyReviver = require_applyReviver();
    var identity = require_identity();
    var toJS = require_toJS();
    var NodeBase = class {
      constructor(type) {
        Object.defineProperty(this, identity.NODE_TYPE, { value: type });
      }
      /** Create a copy of this node.  */
      clone() {
        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
        if (this.range)
          copy.range = this.range.slice();
        return copy;
      }
      /** A plain JavaScript representation of this node. */
      toJS(doc, { mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
        if (!identity.isDocument(doc))
          throw new TypeError("A document argument is required");
        const ctx = {
          anchors: /* @__PURE__ */ new Map(),
          doc,
          keep: true,
          mapAsMap: mapAsMap === true,
          mapKeyWarned: false,
          maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
        };
        const res = toJS.toJS(this, "", ctx);
        if (typeof onAnchor === "function")
          for (const { count, res: res2 } of ctx.anchors.values())
            onAnchor(res2, count);
        return typeof reviver === "function" ? applyReviver.applyReviver(reviver, { "": res }, "", res) : res;
      }
    };
    exports2.NodeBase = NodeBase;
  }
});

// ../../node_modules/yaml/dist/nodes/Alias.js
var require_Alias = __commonJS({
  "../../node_modules/yaml/dist/nodes/Alias.js"(exports2) {
    "use strict";
    var anchors = require_anchors();
    var visit = require_visit();
    var identity = require_identity();
    var Node = require_Node();
    var toJS = require_toJS();
    var Alias = class extends Node.NodeBase {
      constructor(source) {
        super(identity.ALIAS);
        this.source = source;
        Object.defineProperty(this, "tag", {
          set() {
            throw new Error("Alias nodes cannot have tags");
          }
        });
      }
      /**
       * Resolve the value of this alias within `doc`, finding the last
       * instance of the `source` anchor before this node.
       */
      resolve(doc, ctx) {
        let nodes;
        if (ctx?.aliasResolveCache) {
          nodes = ctx.aliasResolveCache;
        } else {
          nodes = [];
          visit.visit(doc, {
            Node: (_key, node) => {
              if (identity.isAlias(node) || identity.hasAnchor(node))
                nodes.push(node);
            }
          });
          if (ctx)
            ctx.aliasResolveCache = nodes;
        }
        let found = void 0;
        for (const node of nodes) {
          if (node === this)
            break;
          if (node.anchor === this.source)
            found = node;
        }
        return found;
      }
      toJSON(_arg, ctx) {
        if (!ctx)
          return { source: this.source };
        const { anchors: anchors2, doc, maxAliasCount } = ctx;
        const source = this.resolve(doc, ctx);
        if (!source) {
          const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
          throw new ReferenceError(msg);
        }
        let data = anchors2.get(source);
        if (!data) {
          toJS.toJS(source, null, ctx);
          data = anchors2.get(source);
        }
        if (data?.res === void 0) {
          const msg = "This should not happen: Alias anchor was not resolved?";
          throw new ReferenceError(msg);
        }
        if (maxAliasCount >= 0) {
          data.count += 1;
          if (data.aliasCount === 0)
            data.aliasCount = getAliasCount(doc, source, anchors2);
          if (data.count * data.aliasCount > maxAliasCount) {
            const msg = "Excessive alias count indicates a resource exhaustion attack";
            throw new ReferenceError(msg);
          }
        }
        return data.res;
      }
      toString(ctx, _onComment, _onChompKeep) {
        const src = `*${this.source}`;
        if (ctx) {
          anchors.anchorIsValid(this.source);
          if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
            const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
            throw new Error(msg);
          }
          if (ctx.implicitKey)
            return `${src} `;
        }
        return src;
      }
    };
    function getAliasCount(doc, node, anchors2) {
      if (identity.isAlias(node)) {
        const source = node.resolve(doc);
        const anchor = anchors2 && source && anchors2.get(source);
        return anchor ? anchor.count * anchor.aliasCount : 0;
      } else if (identity.isCollection(node)) {
        let count = 0;
        for (const item of node.items) {
          const c = getAliasCount(doc, item, anchors2);
          if (c > count)
            count = c;
        }
        return count;
      } else if (identity.isPair(node)) {
        const kc = getAliasCount(doc, node.key, anchors2);
        const vc = getAliasCount(doc, node.value, anchors2);
        return Math.max(kc, vc);
      }
      return 1;
    }
    exports2.Alias = Alias;
  }
});

// ../../node_modules/yaml/dist/nodes/Scalar.js
var require_Scalar = __commonJS({
  "../../node_modules/yaml/dist/nodes/Scalar.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var Node = require_Node();
    var toJS = require_toJS();
    var isScalarValue = (value) => !value || typeof value !== "function" && typeof value !== "object";
    var Scalar = class extends Node.NodeBase {
      constructor(value) {
        super(identity.SCALAR);
        this.value = value;
      }
      toJSON(arg, ctx) {
        return ctx?.keep ? this.value : toJS.toJS(this.value, arg, ctx);
      }
      toString() {
        return String(this.value);
      }
    };
    Scalar.BLOCK_FOLDED = "BLOCK_FOLDED";
    Scalar.BLOCK_LITERAL = "BLOCK_LITERAL";
    Scalar.PLAIN = "PLAIN";
    Scalar.QUOTE_DOUBLE = "QUOTE_DOUBLE";
    Scalar.QUOTE_SINGLE = "QUOTE_SINGLE";
    exports2.Scalar = Scalar;
    exports2.isScalarValue = isScalarValue;
  }
});

// ../../node_modules/yaml/dist/doc/createNode.js
var require_createNode = __commonJS({
  "../../node_modules/yaml/dist/doc/createNode.js"(exports2) {
    "use strict";
    var Alias = require_Alias();
    var identity = require_identity();
    var Scalar = require_Scalar();
    var defaultTagPrefix = "tag:yaml.org,2002:";
    function findTagObject(value, tagName, tags) {
      if (tagName) {
        const match = tags.filter((t) => t.tag === tagName);
        const tagObj = match.find((t) => !t.format) ?? match[0];
        if (!tagObj)
          throw new Error(`Tag ${tagName} not found`);
        return tagObj;
      }
      return tags.find((t) => t.identify?.(value) && !t.format);
    }
    function createNode(value, tagName, ctx) {
      if (identity.isDocument(value))
        value = value.contents;
      if (identity.isNode(value))
        return value;
      if (identity.isPair(value)) {
        const map = ctx.schema[identity.MAP].createNode?.(ctx.schema, null, ctx);
        map.items.push(value);
        return map;
      }
      if (value instanceof String || value instanceof Number || value instanceof Boolean || typeof BigInt !== "undefined" && value instanceof BigInt) {
        value = value.valueOf();
      }
      const { aliasDuplicateObjects, onAnchor, onTagObj, schema, sourceObjects } = ctx;
      let ref = void 0;
      if (aliasDuplicateObjects && value && typeof value === "object") {
        ref = sourceObjects.get(value);
        if (ref) {
          ref.anchor ?? (ref.anchor = onAnchor(value));
          return new Alias.Alias(ref.anchor);
        } else {
          ref = { anchor: null, node: null };
          sourceObjects.set(value, ref);
        }
      }
      if (tagName?.startsWith("!!"))
        tagName = defaultTagPrefix + tagName.slice(2);
      let tagObj = findTagObject(value, tagName, schema.tags);
      if (!tagObj) {
        if (value && typeof value.toJSON === "function") {
          value = value.toJSON();
        }
        if (!value || typeof value !== "object") {
          const node2 = new Scalar.Scalar(value);
          if (ref)
            ref.node = node2;
          return node2;
        }
        tagObj = value instanceof Map ? schema[identity.MAP] : Symbol.iterator in Object(value) ? schema[identity.SEQ] : schema[identity.MAP];
      }
      if (onTagObj) {
        onTagObj(tagObj);
        delete ctx.onTagObj;
      }
      const node = tagObj?.createNode ? tagObj.createNode(ctx.schema, value, ctx) : typeof tagObj?.nodeClass?.from === "function" ? tagObj.nodeClass.from(ctx.schema, value, ctx) : new Scalar.Scalar(value);
      if (tagName)
        node.tag = tagName;
      else if (!tagObj.default)
        node.tag = tagObj.tag;
      if (ref)
        ref.node = node;
      return node;
    }
    exports2.createNode = createNode;
  }
});

// ../../node_modules/yaml/dist/nodes/Collection.js
var require_Collection = __commonJS({
  "../../node_modules/yaml/dist/nodes/Collection.js"(exports2) {
    "use strict";
    var createNode = require_createNode();
    var identity = require_identity();
    var Node = require_Node();
    function collectionFromPath(schema, path11, value) {
      let v = value;
      for (let i = path11.length - 1; i >= 0; --i) {
        const k = path11[i];
        if (typeof k === "number" && Number.isInteger(k) && k >= 0) {
          const a = [];
          a[k] = v;
          v = a;
        } else {
          v = /* @__PURE__ */ new Map([[k, v]]);
        }
      }
      return createNode.createNode(v, void 0, {
        aliasDuplicateObjects: false,
        keepUndefined: false,
        onAnchor: () => {
          throw new Error("This should not happen, please report a bug.");
        },
        schema,
        sourceObjects: /* @__PURE__ */ new Map()
      });
    }
    var isEmptyPath = (path11) => path11 == null || typeof path11 === "object" && !!path11[Symbol.iterator]().next().done;
    var Collection = class extends Node.NodeBase {
      constructor(type, schema) {
        super(type);
        Object.defineProperty(this, "schema", {
          value: schema,
          configurable: true,
          enumerable: false,
          writable: true
        });
      }
      /**
       * Create a copy of this collection.
       *
       * @param schema - If defined, overwrites the original's schema
       */
      clone(schema) {
        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
        if (schema)
          copy.schema = schema;
        copy.items = copy.items.map((it) => identity.isNode(it) || identity.isPair(it) ? it.clone(schema) : it);
        if (this.range)
          copy.range = this.range.slice();
        return copy;
      }
      /**
       * Adds a value to the collection. For `!!map` and `!!omap` the value must
       * be a Pair instance or a `{ key, value }` object, which may not have a key
       * that already exists in the map.
       */
      addIn(path11, value) {
        if (isEmptyPath(path11))
          this.add(value);
        else {
          const [key, ...rest] = path11;
          const node = this.get(key, true);
          if (identity.isCollection(node))
            node.addIn(rest, value);
          else if (node === void 0 && this.schema)
            this.set(key, collectionFromPath(this.schema, rest, value));
          else
            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
      }
      /**
       * Removes a value from the collection.
       * @returns `true` if the item was found and removed.
       */
      deleteIn(path11) {
        const [key, ...rest] = path11;
        if (rest.length === 0)
          return this.delete(key);
        const node = this.get(key, true);
        if (identity.isCollection(node))
          return node.deleteIn(rest);
        else
          throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
      }
      /**
       * Returns item at `key`, or `undefined` if not found. By default unwraps
       * scalar values from their surrounding node; to disable set `keepScalar` to
       * `true` (collections are always returned intact).
       */
      getIn(path11, keepScalar) {
        const [key, ...rest] = path11;
        const node = this.get(key, true);
        if (rest.length === 0)
          return !keepScalar && identity.isScalar(node) ? node.value : node;
        else
          return identity.isCollection(node) ? node.getIn(rest, keepScalar) : void 0;
      }
      hasAllNullValues(allowScalar) {
        return this.items.every((node) => {
          if (!identity.isPair(node))
            return false;
          const n = node.value;
          return n == null || allowScalar && identity.isScalar(n) && n.value == null && !n.commentBefore && !n.comment && !n.tag;
        });
      }
      /**
       * Checks if the collection includes a value with the key `key`.
       */
      hasIn(path11) {
        const [key, ...rest] = path11;
        if (rest.length === 0)
          return this.has(key);
        const node = this.get(key, true);
        return identity.isCollection(node) ? node.hasIn(rest) : false;
      }
      /**
       * Sets a value in this collection. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       */
      setIn(path11, value) {
        const [key, ...rest] = path11;
        if (rest.length === 0) {
          this.set(key, value);
        } else {
          const node = this.get(key, true);
          if (identity.isCollection(node))
            node.setIn(rest, value);
          else if (node === void 0 && this.schema)
            this.set(key, collectionFromPath(this.schema, rest, value));
          else
            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
      }
    };
    exports2.Collection = Collection;
    exports2.collectionFromPath = collectionFromPath;
    exports2.isEmptyPath = isEmptyPath;
  }
});

// ../../node_modules/yaml/dist/stringify/stringifyComment.js
var require_stringifyComment = __commonJS({
  "../../node_modules/yaml/dist/stringify/stringifyComment.js"(exports2) {
    "use strict";
    var stringifyComment = (str) => str.replace(/^(?!$)(?: $)?/gm, "#");
    function indentComment(comment, indent) {
      if (/^\n+$/.test(comment))
        return comment.substring(1);
      return indent ? comment.replace(/^(?! *$)/gm, indent) : comment;
    }
    var lineComment = (str, indent, comment) => str.endsWith("\n") ? indentComment(comment, indent) : comment.includes("\n") ? "\n" + indentComment(comment, indent) : (str.endsWith(" ") ? "" : " ") + comment;
    exports2.indentComment = indentComment;
    exports2.lineComment = lineComment;
    exports2.stringifyComment = stringifyComment;
  }
});

// ../../node_modules/yaml/dist/stringify/foldFlowLines.js
var require_foldFlowLines = __commonJS({
  "../../node_modules/yaml/dist/stringify/foldFlowLines.js"(exports2) {
    "use strict";
    var FOLD_FLOW = "flow";
    var FOLD_BLOCK = "block";
    var FOLD_QUOTED = "quoted";
    function foldFlowLines(text, indent, mode = "flow", { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
      if (!lineWidth || lineWidth < 0)
        return text;
      if (lineWidth < minContentWidth)
        minContentWidth = 0;
      const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
      if (text.length <= endStep)
        return text;
      const folds = [];
      const escapedFolds = {};
      let end = lineWidth - indent.length;
      if (typeof indentAtStart === "number") {
        if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
          folds.push(0);
        else
          end = lineWidth - indentAtStart;
      }
      let split = void 0;
      let prev = void 0;
      let overflow = false;
      let i = -1;
      let escStart = -1;
      let escEnd = -1;
      if (mode === FOLD_BLOCK) {
        i = consumeMoreIndentedLines(text, i, indent.length);
        if (i !== -1)
          end = i + endStep;
      }
      for (let ch; ch = text[i += 1]; ) {
        if (mode === FOLD_QUOTED && ch === "\\") {
          escStart = i;
          switch (text[i + 1]) {
            case "x":
              i += 3;
              break;
            case "u":
              i += 5;
              break;
            case "U":
              i += 9;
              break;
            default:
              i += 1;
          }
          escEnd = i;
        }
        if (ch === "\n") {
          if (mode === FOLD_BLOCK)
            i = consumeMoreIndentedLines(text, i, indent.length);
          end = i + indent.length + endStep;
          split = void 0;
        } else {
          if (ch === " " && prev && prev !== " " && prev !== "\n" && prev !== "	") {
            const next = text[i + 1];
            if (next && next !== " " && next !== "\n" && next !== "	")
              split = i;
          }
          if (i >= end) {
            if (split) {
              folds.push(split);
              end = split + endStep;
              split = void 0;
            } else if (mode === FOLD_QUOTED) {
              while (prev === " " || prev === "	") {
                prev = ch;
                ch = text[i += 1];
                overflow = true;
              }
              const j = i > escEnd + 1 ? i - 2 : escStart - 1;
              if (escapedFolds[j])
                return text;
              folds.push(j);
              escapedFolds[j] = true;
              end = j + endStep;
              split = void 0;
            } else {
              overflow = true;
            }
          }
        }
        prev = ch;
      }
      if (overflow && onOverflow)
        onOverflow();
      if (folds.length === 0)
        return text;
      if (onFold)
        onFold();
      let res = text.slice(0, folds[0]);
      for (let i2 = 0; i2 < folds.length; ++i2) {
        const fold = folds[i2];
        const end2 = folds[i2 + 1] || text.length;
        if (fold === 0)
          res = `
${indent}${text.slice(0, end2)}`;
        else {
          if (mode === FOLD_QUOTED && escapedFolds[fold])
            res += `${text[fold]}\\`;
          res += `
${indent}${text.slice(fold + 1, end2)}`;
        }
      }
      return res;
    }
    function consumeMoreIndentedLines(text, i, indent) {
      let end = i;
      let start = i + 1;
      let ch = text[start];
      while (ch === " " || ch === "	") {
        if (i < start + indent) {
          ch = text[++i];
        } else {
          do {
            ch = text[++i];
          } while (ch && ch !== "\n");
          end = i;
          start = i + 1;
          ch = text[start];
        }
      }
      return end;
    }
    exports2.FOLD_BLOCK = FOLD_BLOCK;
    exports2.FOLD_FLOW = FOLD_FLOW;
    exports2.FOLD_QUOTED = FOLD_QUOTED;
    exports2.foldFlowLines = foldFlowLines;
  }
});

// ../../node_modules/yaml/dist/stringify/stringifyString.js
var require_stringifyString = __commonJS({
  "../../node_modules/yaml/dist/stringify/stringifyString.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar();
    var foldFlowLines = require_foldFlowLines();
    var getFoldOptions = (ctx, isBlock) => ({
      indentAtStart: isBlock ? ctx.indent.length : ctx.indentAtStart,
      lineWidth: ctx.options.lineWidth,
      minContentWidth: ctx.options.minContentWidth
    });
    var containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
    function lineLengthOverLimit(str, lineWidth, indentLength) {
      if (!lineWidth || lineWidth < 0)
        return false;
      const limit = lineWidth - indentLength;
      const strLen = str.length;
      if (strLen <= limit)
        return false;
      for (let i = 0, start = 0; i < strLen; ++i) {
        if (str[i] === "\n") {
          if (i - start > limit)
            return true;
          start = i + 1;
          if (strLen - start <= limit)
            return false;
        }
      }
      return true;
    }
    function doubleQuotedString(value, ctx) {
      const json = JSON.stringify(value);
      if (ctx.options.doubleQuotedAsJSON)
        return json;
      const { implicitKey } = ctx;
      const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
      const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
      let str = "";
      let start = 0;
      for (let i = 0, ch = json[i]; ch; ch = json[++i]) {
        if (ch === " " && json[i + 1] === "\\" && json[i + 2] === "n") {
          str += json.slice(start, i) + "\\ ";
          i += 1;
          start = i;
          ch = "\\";
        }
        if (ch === "\\")
          switch (json[i + 1]) {
            case "u":
              {
                str += json.slice(start, i);
                const code = json.substr(i + 2, 4);
                switch (code) {
                  case "0000":
                    str += "\\0";
                    break;
                  case "0007":
                    str += "\\a";
                    break;
                  case "000b":
                    str += "\\v";
                    break;
                  case "001b":
                    str += "\\e";
                    break;
                  case "0085":
                    str += "\\N";
                    break;
                  case "00a0":
                    str += "\\_";
                    break;
                  case "2028":
                    str += "\\L";
                    break;
                  case "2029":
                    str += "\\P";
                    break;
                  default:
                    if (code.substr(0, 2) === "00")
                      str += "\\x" + code.substr(2);
                    else
                      str += json.substr(i, 6);
                }
                i += 5;
                start = i + 1;
              }
              break;
            case "n":
              if (implicitKey || json[i + 2] === '"' || json.length < minMultiLineLength) {
                i += 1;
              } else {
                str += json.slice(start, i) + "\n\n";
                while (json[i + 2] === "\\" && json[i + 3] === "n" && json[i + 4] !== '"') {
                  str += "\n";
                  i += 2;
                }
                str += indent;
                if (json[i + 2] === " ")
                  str += "\\";
                i += 1;
                start = i + 1;
              }
              break;
            default:
              i += 1;
          }
      }
      str = start ? str + json.slice(start) : json;
      return implicitKey ? str : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_QUOTED, getFoldOptions(ctx, false));
    }
    function singleQuotedString(value, ctx) {
      if (ctx.options.singleQuote === false || ctx.implicitKey && value.includes("\n") || /[ \t]\n|\n[ \t]/.test(value))
        return doubleQuotedString(value, ctx);
      const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
      const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&
${indent}`) + "'";
      return ctx.implicitKey ? res : foldFlowLines.foldFlowLines(res, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, false));
    }
    function quotedString(value, ctx) {
      const { singleQuote } = ctx.options;
      let qs;
      if (singleQuote === false)
        qs = doubleQuotedString;
      else {
        const hasDouble = value.includes('"');
        const hasSingle = value.includes("'");
        if (hasDouble && !hasSingle)
          qs = singleQuotedString;
        else if (hasSingle && !hasDouble)
          qs = doubleQuotedString;
        else
          qs = singleQuote ? singleQuotedString : doubleQuotedString;
      }
      return qs(value, ctx);
    }
    var blockEndNewlines;
    try {
      blockEndNewlines = new RegExp("(^|(?<!\n))\n+(?!\n|$)", "g");
    } catch {
      blockEndNewlines = /\n+(?!\n|$)/g;
    }
    function blockString({ comment, type, value }, ctx, onComment, onChompKeep) {
      const { blockQuote, commentString, lineWidth } = ctx.options;
      if (!blockQuote || /\n[\t ]+$/.test(value)) {
        return quotedString(value, ctx);
      }
      const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? "  " : "");
      const literal = blockQuote === "literal" ? true : blockQuote === "folded" || type === Scalar.Scalar.BLOCK_FOLDED ? false : type === Scalar.Scalar.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, lineWidth, indent.length);
      if (!value)
        return literal ? "|\n" : ">\n";
      let chomp;
      let endStart;
      for (endStart = value.length; endStart > 0; --endStart) {
        const ch = value[endStart - 1];
        if (ch !== "\n" && ch !== "	" && ch !== " ")
          break;
      }
      let end = value.substring(endStart);
      const endNlPos = end.indexOf("\n");
      if (endNlPos === -1) {
        chomp = "-";
      } else if (value === end || endNlPos !== end.length - 1) {
        chomp = "+";
        if (onChompKeep)
          onChompKeep();
      } else {
        chomp = "";
      }
      if (end) {
        value = value.slice(0, -end.length);
        if (end[end.length - 1] === "\n")
          end = end.slice(0, -1);
        end = end.replace(blockEndNewlines, `$&${indent}`);
      }
      let startWithSpace = false;
      let startEnd;
      let startNlPos = -1;
      for (startEnd = 0; startEnd < value.length; ++startEnd) {
        const ch = value[startEnd];
        if (ch === " ")
          startWithSpace = true;
        else if (ch === "\n")
          startNlPos = startEnd;
        else
          break;
      }
      let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
      if (start) {
        value = value.substring(start.length);
        start = start.replace(/\n+/g, `$&${indent}`);
      }
      const indentSize = indent ? "2" : "1";
      let header = (startWithSpace ? indentSize : "") + chomp;
      if (comment) {
        header += " " + commentString(comment.replace(/ ?[\r\n]+/g, " "));
        if (onComment)
          onComment();
      }
      if (!literal) {
        const foldedValue = value.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent}`);
        let literalFallback = false;
        const foldOptions = getFoldOptions(ctx, true);
        if (blockQuote !== "folded" && type !== Scalar.Scalar.BLOCK_FOLDED) {
          foldOptions.onOverflow = () => {
            literalFallback = true;
          };
        }
        const body = foldFlowLines.foldFlowLines(`${start}${foldedValue}${end}`, indent, foldFlowLines.FOLD_BLOCK, foldOptions);
        if (!literalFallback)
          return `>${header}
${indent}${body}`;
      }
      value = value.replace(/\n+/g, `$&${indent}`);
      return `|${header}
${indent}${start}${value}${end}`;
    }
    function plainString(item, ctx, onComment, onChompKeep) {
      const { type, value } = item;
      const { actualString, implicitKey, indent, indentStep, inFlow } = ctx;
      if (implicitKey && value.includes("\n") || inFlow && /[[\]{},]/.test(value)) {
        return quotedString(value, ctx);
      }
      if (/^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
        return implicitKey || inFlow || !value.includes("\n") ? quotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
      }
      if (!implicitKey && !inFlow && type !== Scalar.Scalar.PLAIN && value.includes("\n")) {
        return blockString(item, ctx, onComment, onChompKeep);
      }
      if (containsDocumentMarker(value)) {
        if (indent === "") {
          ctx.forceBlockIndent = true;
          return blockString(item, ctx, onComment, onChompKeep);
        } else if (implicitKey && indent === indentStep) {
          return quotedString(value, ctx);
        }
      }
      const str = value.replace(/\n+/g, `$&
${indent}`);
      if (actualString) {
        const test = (tag) => tag.default && tag.tag !== "tag:yaml.org,2002:str" && tag.test?.test(str);
        const { compat, tags } = ctx.doc.schema;
        if (tags.some(test) || compat?.some(test))
          return quotedString(value, ctx);
      }
      return implicitKey ? str : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, false));
    }
    function stringifyString(item, ctx, onComment, onChompKeep) {
      const { implicitKey, inFlow } = ctx;
      const ss = typeof item.value === "string" ? item : Object.assign({}, item, { value: String(item.value) });
      let { type } = item;
      if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
        if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value))
          type = Scalar.Scalar.QUOTE_DOUBLE;
      }
      const _stringify = (_type) => {
        switch (_type) {
          case Scalar.Scalar.BLOCK_FOLDED:
          case Scalar.Scalar.BLOCK_LITERAL:
            return implicitKey || inFlow ? quotedString(ss.value, ctx) : blockString(ss, ctx, onComment, onChompKeep);
          case Scalar.Scalar.QUOTE_DOUBLE:
            return doubleQuotedString(ss.value, ctx);
          case Scalar.Scalar.QUOTE_SINGLE:
            return singleQuotedString(ss.value, ctx);
          case Scalar.Scalar.PLAIN:
            return plainString(ss, ctx, onComment, onChompKeep);
          default:
            return null;
        }
      };
      let res = _stringify(type);
      if (res === null) {
        const { defaultKeyType, defaultStringType } = ctx.options;
        const t = implicitKey && defaultKeyType || defaultStringType;
        res = _stringify(t);
        if (res === null)
          throw new Error(`Unsupported default string type ${t}`);
      }
      return res;
    }
    exports2.stringifyString = stringifyString;
  }
});

// ../../node_modules/yaml/dist/stringify/stringify.js
var require_stringify = __commonJS({
  "../../node_modules/yaml/dist/stringify/stringify.js"(exports2) {
    "use strict";
    var anchors = require_anchors();
    var identity = require_identity();
    var stringifyComment = require_stringifyComment();
    var stringifyString = require_stringifyString();
    function createStringifyContext(doc, options) {
      const opt = Object.assign({
        blockQuote: true,
        commentString: stringifyComment.stringifyComment,
        defaultKeyType: null,
        defaultStringType: "PLAIN",
        directives: null,
        doubleQuotedAsJSON: false,
        doubleQuotedMinMultiLineLength: 40,
        falseStr: "false",
        flowCollectionPadding: true,
        indentSeq: true,
        lineWidth: 80,
        minContentWidth: 20,
        nullStr: "null",
        simpleKeys: false,
        singleQuote: null,
        trueStr: "true",
        verifyAliasOrder: true
      }, doc.schema.toStringOptions, options);
      let inFlow;
      switch (opt.collectionStyle) {
        case "block":
          inFlow = false;
          break;
        case "flow":
          inFlow = true;
          break;
        default:
          inFlow = null;
      }
      return {
        anchors: /* @__PURE__ */ new Set(),
        doc,
        flowCollectionPadding: opt.flowCollectionPadding ? " " : "",
        indent: "",
        indentStep: typeof opt.indent === "number" ? " ".repeat(opt.indent) : "  ",
        inFlow,
        options: opt
      };
    }
    function getTagObject(tags, item) {
      if (item.tag) {
        const match = tags.filter((t) => t.tag === item.tag);
        if (match.length > 0)
          return match.find((t) => t.format === item.format) ?? match[0];
      }
      let tagObj = void 0;
      let obj;
      if (identity.isScalar(item)) {
        obj = item.value;
        let match = tags.filter((t) => t.identify?.(obj));
        if (match.length > 1) {
          const testMatch = match.filter((t) => t.test);
          if (testMatch.length > 0)
            match = testMatch;
        }
        tagObj = match.find((t) => t.format === item.format) ?? match.find((t) => !t.format);
      } else {
        obj = item;
        tagObj = tags.find((t) => t.nodeClass && obj instanceof t.nodeClass);
      }
      if (!tagObj) {
        const name = obj?.constructor?.name ?? (obj === null ? "null" : typeof obj);
        throw new Error(`Tag not resolved for ${name} value`);
      }
      return tagObj;
    }
    function stringifyProps(node, tagObj, { anchors: anchors$1, doc }) {
      if (!doc.directives)
        return "";
      const props = [];
      const anchor = (identity.isScalar(node) || identity.isCollection(node)) && node.anchor;
      if (anchor && anchors.anchorIsValid(anchor)) {
        anchors$1.add(anchor);
        props.push(`&${anchor}`);
      }
      const tag = node.tag ?? (tagObj.default ? null : tagObj.tag);
      if (tag)
        props.push(doc.directives.tagString(tag));
      return props.join(" ");
    }
    function stringify(item, ctx, onComment, onChompKeep) {
      if (identity.isPair(item))
        return item.toString(ctx, onComment, onChompKeep);
      if (identity.isAlias(item)) {
        if (ctx.doc.directives)
          return item.toString(ctx);
        if (ctx.resolvedAliases?.has(item)) {
          throw new TypeError(`Cannot stringify circular structure without alias nodes`);
        } else {
          if (ctx.resolvedAliases)
            ctx.resolvedAliases.add(item);
          else
            ctx.resolvedAliases = /* @__PURE__ */ new Set([item]);
          item = item.resolve(ctx.doc);
        }
      }
      let tagObj = void 0;
      const node = identity.isNode(item) ? item : ctx.doc.createNode(item, { onTagObj: (o) => tagObj = o });
      tagObj ?? (tagObj = getTagObject(ctx.doc.schema.tags, node));
      const props = stringifyProps(node, tagObj, ctx);
      if (props.length > 0)
        ctx.indentAtStart = (ctx.indentAtStart ?? 0) + props.length + 1;
      const str = typeof tagObj.stringify === "function" ? tagObj.stringify(node, ctx, onComment, onChompKeep) : identity.isScalar(node) ? stringifyString.stringifyString(node, ctx, onComment, onChompKeep) : node.toString(ctx, onComment, onChompKeep);
      if (!props)
        return str;
      return identity.isScalar(node) || str[0] === "{" || str[0] === "[" ? `${props} ${str}` : `${props}
${ctx.indent}${str}`;
    }
    exports2.createStringifyContext = createStringifyContext;
    exports2.stringify = stringify;
  }
});

// ../../node_modules/yaml/dist/stringify/stringifyPair.js
var require_stringifyPair = __commonJS({
  "../../node_modules/yaml/dist/stringify/stringifyPair.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var Scalar = require_Scalar();
    var stringify = require_stringify();
    var stringifyComment = require_stringifyComment();
    function stringifyPair({ key, value }, ctx, onComment, onChompKeep) {
      const { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;
      let keyComment = identity.isNode(key) && key.comment || null;
      if (simpleKeys) {
        if (keyComment) {
          throw new Error("With simple keys, key nodes cannot have comments");
        }
        if (identity.isCollection(key) || !identity.isNode(key) && typeof key === "object") {
          const msg = "With simple keys, collection cannot be used as a key value";
          throw new Error(msg);
        }
      }
      let explicitKey = !simpleKeys && (!key || keyComment && value == null && !ctx.inFlow || identity.isCollection(key) || (identity.isScalar(key) ? key.type === Scalar.Scalar.BLOCK_FOLDED || key.type === Scalar.Scalar.BLOCK_LITERAL : typeof key === "object"));
      ctx = Object.assign({}, ctx, {
        allNullValues: false,
        implicitKey: !explicitKey && (simpleKeys || !allNullValues),
        indent: indent + indentStep
      });
      let keyCommentDone = false;
      let chompKeep = false;
      let str = stringify.stringify(key, ctx, () => keyCommentDone = true, () => chompKeep = true);
      if (!explicitKey && !ctx.inFlow && str.length > 1024) {
        if (simpleKeys)
          throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
        explicitKey = true;
      }
      if (ctx.inFlow) {
        if (allNullValues || value == null) {
          if (keyCommentDone && onComment)
            onComment();
          return str === "" ? "?" : explicitKey ? `? ${str}` : str;
        }
      } else if (allNullValues && !simpleKeys || value == null && explicitKey) {
        str = `? ${str}`;
        if (keyComment && !keyCommentDone) {
          str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
        } else if (chompKeep && onChompKeep)
          onChompKeep();
        return str;
      }
      if (keyCommentDone)
        keyComment = null;
      if (explicitKey) {
        if (keyComment)
          str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
        str = `? ${str}
${indent}:`;
      } else {
        str = `${str}:`;
        if (keyComment)
          str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
      }
      let vsb, vcb, valueComment;
      if (identity.isNode(value)) {
        vsb = !!value.spaceBefore;
        vcb = value.commentBefore;
        valueComment = value.comment;
      } else {
        vsb = false;
        vcb = null;
        valueComment = null;
        if (value && typeof value === "object")
          value = doc.createNode(value);
      }
      ctx.implicitKey = false;
      if (!explicitKey && !keyComment && identity.isScalar(value))
        ctx.indentAtStart = str.length + 1;
      chompKeep = false;
      if (!indentSeq && indentStep.length >= 2 && !ctx.inFlow && !explicitKey && identity.isSeq(value) && !value.flow && !value.tag && !value.anchor) {
        ctx.indent = ctx.indent.substring(2);
      }
      let valueCommentDone = false;
      const valueStr = stringify.stringify(value, ctx, () => valueCommentDone = true, () => chompKeep = true);
      let ws = " ";
      if (keyComment || vsb || vcb) {
        ws = vsb ? "\n" : "";
        if (vcb) {
          const cs = commentString(vcb);
          ws += `
${stringifyComment.indentComment(cs, ctx.indent)}`;
        }
        if (valueStr === "" && !ctx.inFlow) {
          if (ws === "\n" && valueComment)
            ws = "\n\n";
        } else {
          ws += `
${ctx.indent}`;
        }
      } else if (!explicitKey && identity.isCollection(value)) {
        const vs0 = valueStr[0];
        const nl0 = valueStr.indexOf("\n");
        const hasNewline = nl0 !== -1;
        const flow = ctx.inFlow ?? value.flow ?? value.items.length === 0;
        if (hasNewline || !flow) {
          let hasPropsLine = false;
          if (hasNewline && (vs0 === "&" || vs0 === "!")) {
            let sp0 = valueStr.indexOf(" ");
            if (vs0 === "&" && sp0 !== -1 && sp0 < nl0 && valueStr[sp0 + 1] === "!") {
              sp0 = valueStr.indexOf(" ", sp0 + 1);
            }
            if (sp0 === -1 || nl0 < sp0)
              hasPropsLine = true;
          }
          if (!hasPropsLine)
            ws = `
${ctx.indent}`;
        }
      } else if (valueStr === "" || valueStr[0] === "\n") {
        ws = "";
      }
      str += ws + valueStr;
      if (ctx.inFlow) {
        if (valueCommentDone && onComment)
          onComment();
      } else if (valueComment && !valueCommentDone) {
        str += stringifyComment.lineComment(str, ctx.indent, commentString(valueComment));
      } else if (chompKeep && onChompKeep) {
        onChompKeep();
      }
      return str;
    }
    exports2.stringifyPair = stringifyPair;
  }
});

// ../../node_modules/yaml/dist/log.js
var require_log = __commonJS({
  "../../node_modules/yaml/dist/log.js"(exports2) {
    "use strict";
    var node_process = require("process");
    function debug2(logLevel, ...messages) {
      if (logLevel === "debug")
        console.log(...messages);
    }
    function warn(logLevel, warning) {
      if (logLevel === "debug" || logLevel === "warn") {
        if (typeof node_process.emitWarning === "function")
          node_process.emitWarning(warning);
        else
          console.warn(warning);
      }
    }
    exports2.debug = debug2;
    exports2.warn = warn;
  }
});

// ../../node_modules/yaml/dist/schema/yaml-1.1/merge.js
var require_merge = __commonJS({
  "../../node_modules/yaml/dist/schema/yaml-1.1/merge.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var Scalar = require_Scalar();
    var MERGE_KEY = "<<";
    var merge = {
      identify: (value) => value === MERGE_KEY || typeof value === "symbol" && value.description === MERGE_KEY,
      default: "key",
      tag: "tag:yaml.org,2002:merge",
      test: /^<<$/,
      resolve: () => Object.assign(new Scalar.Scalar(Symbol(MERGE_KEY)), {
        addToJSMap: addMergeToJSMap
      }),
      stringify: () => MERGE_KEY
    };
    var isMergeKey = (ctx, key) => (merge.identify(key) || identity.isScalar(key) && (!key.type || key.type === Scalar.Scalar.PLAIN) && merge.identify(key.value)) && ctx?.doc.schema.tags.some((tag) => tag.tag === merge.tag && tag.default);
    function addMergeToJSMap(ctx, map, value) {
      value = ctx && identity.isAlias(value) ? value.resolve(ctx.doc) : value;
      if (identity.isSeq(value))
        for (const it of value.items)
          mergeValue(ctx, map, it);
      else if (Array.isArray(value))
        for (const it of value)
          mergeValue(ctx, map, it);
      else
        mergeValue(ctx, map, value);
    }
    function mergeValue(ctx, map, value) {
      const source = ctx && identity.isAlias(value) ? value.resolve(ctx.doc) : value;
      if (!identity.isMap(source))
        throw new Error("Merge sources must be maps or map aliases");
      const srcMap = source.toJSON(null, ctx, Map);
      for (const [key, value2] of srcMap) {
        if (map instanceof Map) {
          if (!map.has(key))
            map.set(key, value2);
        } else if (map instanceof Set) {
          map.add(key);
        } else if (!Object.prototype.hasOwnProperty.call(map, key)) {
          Object.defineProperty(map, key, {
            value: value2,
            writable: true,
            enumerable: true,
            configurable: true
          });
        }
      }
      return map;
    }
    exports2.addMergeToJSMap = addMergeToJSMap;
    exports2.isMergeKey = isMergeKey;
    exports2.merge = merge;
  }
});

// ../../node_modules/yaml/dist/nodes/addPairToJSMap.js
var require_addPairToJSMap = __commonJS({
  "../../node_modules/yaml/dist/nodes/addPairToJSMap.js"(exports2) {
    "use strict";
    var log = require_log();
    var merge = require_merge();
    var stringify = require_stringify();
    var identity = require_identity();
    var toJS = require_toJS();
    function addPairToJSMap(ctx, map, { key, value }) {
      if (identity.isNode(key) && key.addToJSMap)
        key.addToJSMap(ctx, map, value);
      else if (merge.isMergeKey(ctx, key))
        merge.addMergeToJSMap(ctx, map, value);
      else {
        const jsKey = toJS.toJS(key, "", ctx);
        if (map instanceof Map) {
          map.set(jsKey, toJS.toJS(value, jsKey, ctx));
        } else if (map instanceof Set) {
          map.add(jsKey);
        } else {
          const stringKey = stringifyKey(key, jsKey, ctx);
          const jsValue = toJS.toJS(value, stringKey, ctx);
          if (stringKey in map)
            Object.defineProperty(map, stringKey, {
              value: jsValue,
              writable: true,
              enumerable: true,
              configurable: true
            });
          else
            map[stringKey] = jsValue;
        }
      }
      return map;
    }
    function stringifyKey(key, jsKey, ctx) {
      if (jsKey === null)
        return "";
      if (typeof jsKey !== "object")
        return String(jsKey);
      if (identity.isNode(key) && ctx?.doc) {
        const strCtx = stringify.createStringifyContext(ctx.doc, {});
        strCtx.anchors = /* @__PURE__ */ new Set();
        for (const node of ctx.anchors.keys())
          strCtx.anchors.add(node.anchor);
        strCtx.inFlow = true;
        strCtx.inStringifyKey = true;
        const strKey = key.toString(strCtx);
        if (!ctx.mapKeyWarned) {
          let jsonStr = JSON.stringify(strKey);
          if (jsonStr.length > 40)
            jsonStr = jsonStr.substring(0, 36) + '..."';
          log.warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
          ctx.mapKeyWarned = true;
        }
        return strKey;
      }
      return JSON.stringify(jsKey);
    }
    exports2.addPairToJSMap = addPairToJSMap;
  }
});

// ../../node_modules/yaml/dist/nodes/Pair.js
var require_Pair = __commonJS({
  "../../node_modules/yaml/dist/nodes/Pair.js"(exports2) {
    "use strict";
    var createNode = require_createNode();
    var stringifyPair = require_stringifyPair();
    var addPairToJSMap = require_addPairToJSMap();
    var identity = require_identity();
    function createPair(key, value, ctx) {
      const k = createNode.createNode(key, void 0, ctx);
      const v = createNode.createNode(value, void 0, ctx);
      return new Pair(k, v);
    }
    var Pair = class _Pair {
      constructor(key, value = null) {
        Object.defineProperty(this, identity.NODE_TYPE, { value: identity.PAIR });
        this.key = key;
        this.value = value;
      }
      clone(schema) {
        let { key, value } = this;
        if (identity.isNode(key))
          key = key.clone(schema);
        if (identity.isNode(value))
          value = value.clone(schema);
        return new _Pair(key, value);
      }
      toJSON(_, ctx) {
        const pair = ctx?.mapAsMap ? /* @__PURE__ */ new Map() : {};
        return addPairToJSMap.addPairToJSMap(ctx, pair, this);
      }
      toString(ctx, onComment, onChompKeep) {
        return ctx?.doc ? stringifyPair.stringifyPair(this, ctx, onComment, onChompKeep) : JSON.stringify(this);
      }
    };
    exports2.Pair = Pair;
    exports2.createPair = createPair;
  }
});

// ../../node_modules/yaml/dist/stringify/stringifyCollection.js
var require_stringifyCollection = __commonJS({
  "../../node_modules/yaml/dist/stringify/stringifyCollection.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var stringify = require_stringify();
    var stringifyComment = require_stringifyComment();
    function stringifyCollection(collection, ctx, options) {
      const flow = ctx.inFlow ?? collection.flow;
      const stringify2 = flow ? stringifyFlowCollection : stringifyBlockCollection;
      return stringify2(collection, ctx, options);
    }
    function stringifyBlockCollection({ comment, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
      const { indent, options: { commentString } } = ctx;
      const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });
      let chompKeep = false;
      const lines = [];
      for (let i = 0; i < items.length; ++i) {
        const item = items[i];
        let comment2 = null;
        if (identity.isNode(item)) {
          if (!chompKeep && item.spaceBefore)
            lines.push("");
          addCommentBefore(ctx, lines, item.commentBefore, chompKeep);
          if (item.comment)
            comment2 = item.comment;
        } else if (identity.isPair(item)) {
          const ik = identity.isNode(item.key) ? item.key : null;
          if (ik) {
            if (!chompKeep && ik.spaceBefore)
              lines.push("");
            addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);
          }
        }
        chompKeep = false;
        let str2 = stringify.stringify(item, itemCtx, () => comment2 = null, () => chompKeep = true);
        if (comment2)
          str2 += stringifyComment.lineComment(str2, itemIndent, commentString(comment2));
        if (chompKeep && comment2)
          chompKeep = false;
        lines.push(blockItemPrefix + str2);
      }
      let str;
      if (lines.length === 0) {
        str = flowChars.start + flowChars.end;
      } else {
        str = lines[0];
        for (let i = 1; i < lines.length; ++i) {
          const line = lines[i];
          str += line ? `
${indent}${line}` : "\n";
        }
      }
      if (comment) {
        str += "\n" + stringifyComment.indentComment(commentString(comment), indent);
        if (onComment)
          onComment();
      } else if (chompKeep && onChompKeep)
        onChompKeep();
      return str;
    }
    function stringifyFlowCollection({ items }, ctx, { flowChars, itemIndent }) {
      const { indent, indentStep, flowCollectionPadding: fcPadding, options: { commentString } } = ctx;
      itemIndent += indentStep;
      const itemCtx = Object.assign({}, ctx, {
        indent: itemIndent,
        inFlow: true,
        type: null
      });
      let reqNewline = false;
      let linesAtValue = 0;
      const lines = [];
      for (let i = 0; i < items.length; ++i) {
        const item = items[i];
        let comment = null;
        if (identity.isNode(item)) {
          if (item.spaceBefore)
            lines.push("");
          addCommentBefore(ctx, lines, item.commentBefore, false);
          if (item.comment)
            comment = item.comment;
        } else if (identity.isPair(item)) {
          const ik = identity.isNode(item.key) ? item.key : null;
          if (ik) {
            if (ik.spaceBefore)
              lines.push("");
            addCommentBefore(ctx, lines, ik.commentBefore, false);
            if (ik.comment)
              reqNewline = true;
          }
          const iv = identity.isNode(item.value) ? item.value : null;
          if (iv) {
            if (iv.comment)
              comment = iv.comment;
            if (iv.commentBefore)
              reqNewline = true;
          } else if (item.value == null && ik?.comment) {
            comment = ik.comment;
          }
        }
        if (comment)
          reqNewline = true;
        let str = stringify.stringify(item, itemCtx, () => comment = null);
        if (i < items.length - 1)
          str += ",";
        if (comment)
          str += stringifyComment.lineComment(str, itemIndent, commentString(comment));
        if (!reqNewline && (lines.length > linesAtValue || str.includes("\n")))
          reqNewline = true;
        lines.push(str);
        linesAtValue = lines.length;
      }
      const { start, end } = flowChars;
      if (lines.length === 0) {
        return start + end;
      } else {
        if (!reqNewline) {
          const len = lines.reduce((sum, line) => sum + line.length + 2, 2);
          reqNewline = ctx.options.lineWidth > 0 && len > ctx.options.lineWidth;
        }
        if (reqNewline) {
          let str = start;
          for (const line of lines)
            str += line ? `
${indentStep}${indent}${line}` : "\n";
          return `${str}
${indent}${end}`;
        } else {
          return `${start}${fcPadding}${lines.join(" ")}${fcPadding}${end}`;
        }
      }
    }
    function addCommentBefore({ indent, options: { commentString } }, lines, comment, chompKeep) {
      if (comment && chompKeep)
        comment = comment.replace(/^\n+/, "");
      if (comment) {
        const ic = stringifyComment.indentComment(commentString(comment), indent);
        lines.push(ic.trimStart());
      }
    }
    exports2.stringifyCollection = stringifyCollection;
  }
});

// ../../node_modules/yaml/dist/nodes/YAMLMap.js
var require_YAMLMap = __commonJS({
  "../../node_modules/yaml/dist/nodes/YAMLMap.js"(exports2) {
    "use strict";
    var stringifyCollection = require_stringifyCollection();
    var addPairToJSMap = require_addPairToJSMap();
    var Collection = require_Collection();
    var identity = require_identity();
    var Pair = require_Pair();
    var Scalar = require_Scalar();
    function findPair(items, key) {
      const k = identity.isScalar(key) ? key.value : key;
      for (const it of items) {
        if (identity.isPair(it)) {
          if (it.key === key || it.key === k)
            return it;
          if (identity.isScalar(it.key) && it.key.value === k)
            return it;
        }
      }
      return void 0;
    }
    var YAMLMap = class extends Collection.Collection {
      static get tagName() {
        return "tag:yaml.org,2002:map";
      }
      constructor(schema) {
        super(identity.MAP, schema);
        this.items = [];
      }
      /**
       * A generic collection parsing method that can be extended
       * to other node classes that inherit from YAMLMap
       */
      static from(schema, obj, ctx) {
        const { keepUndefined, replacer } = ctx;
        const map = new this(schema);
        const add = (key, value) => {
          if (typeof replacer === "function")
            value = replacer.call(obj, key, value);
          else if (Array.isArray(replacer) && !replacer.includes(key))
            return;
          if (value !== void 0 || keepUndefined)
            map.items.push(Pair.createPair(key, value, ctx));
        };
        if (obj instanceof Map) {
          for (const [key, value] of obj)
            add(key, value);
        } else if (obj && typeof obj === "object") {
          for (const key of Object.keys(obj))
            add(key, obj[key]);
        }
        if (typeof schema.sortMapEntries === "function") {
          map.items.sort(schema.sortMapEntries);
        }
        return map;
      }
      /**
       * Adds a value to the collection.
       *
       * @param overwrite - If not set `true`, using a key that is already in the
       *   collection will throw. Otherwise, overwrites the previous value.
       */
      add(pair, overwrite) {
        let _pair;
        if (identity.isPair(pair))
          _pair = pair;
        else if (!pair || typeof pair !== "object" || !("key" in pair)) {
          _pair = new Pair.Pair(pair, pair?.value);
        } else
          _pair = new Pair.Pair(pair.key, pair.value);
        const prev = findPair(this.items, _pair.key);
        const sortEntries = this.schema?.sortMapEntries;
        if (prev) {
          if (!overwrite)
            throw new Error(`Key ${_pair.key} already set`);
          if (identity.isScalar(prev.value) && Scalar.isScalarValue(_pair.value))
            prev.value.value = _pair.value;
          else
            prev.value = _pair.value;
        } else if (sortEntries) {
          const i = this.items.findIndex((item) => sortEntries(_pair, item) < 0);
          if (i === -1)
            this.items.push(_pair);
          else
            this.items.splice(i, 0, _pair);
        } else {
          this.items.push(_pair);
        }
      }
      delete(key) {
        const it = findPair(this.items, key);
        if (!it)
          return false;
        const del = this.items.splice(this.items.indexOf(it), 1);
        return del.length > 0;
      }
      get(key, keepScalar) {
        const it = findPair(this.items, key);
        const node = it?.value;
        return (!keepScalar && identity.isScalar(node) ? node.value : node) ?? void 0;
      }
      has(key) {
        return !!findPair(this.items, key);
      }
      set(key, value) {
        this.add(new Pair.Pair(key, value), true);
      }
      /**
       * @param ctx - Conversion context, originally set in Document#toJS()
       * @param {Class} Type - If set, forces the returned collection type
       * @returns Instance of Type, Map, or Object
       */
      toJSON(_, ctx, Type) {
        const map = Type ? new Type() : ctx?.mapAsMap ? /* @__PURE__ */ new Map() : {};
        if (ctx?.onCreate)
          ctx.onCreate(map);
        for (const item of this.items)
          addPairToJSMap.addPairToJSMap(ctx, map, item);
        return map;
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        for (const item of this.items) {
          if (!identity.isPair(item))
            throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
        }
        if (!ctx.allNullValues && this.hasAllNullValues(false))
          ctx = Object.assign({}, ctx, { allNullValues: true });
        return stringifyCollection.stringifyCollection(this, ctx, {
          blockItemPrefix: "",
          flowChars: { start: "{", end: "}" },
          itemIndent: ctx.indent || "",
          onChompKeep,
          onComment
        });
      }
    };
    exports2.YAMLMap = YAMLMap;
    exports2.findPair = findPair;
  }
});

// ../../node_modules/yaml/dist/schema/common/map.js
var require_map = __commonJS({
  "../../node_modules/yaml/dist/schema/common/map.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var YAMLMap = require_YAMLMap();
    var map = {
      collection: "map",
      default: true,
      nodeClass: YAMLMap.YAMLMap,
      tag: "tag:yaml.org,2002:map",
      resolve(map2, onError2) {
        if (!identity.isMap(map2))
          onError2("Expected a mapping for this tag");
        return map2;
      },
      createNode: (schema, obj, ctx) => YAMLMap.YAMLMap.from(schema, obj, ctx)
    };
    exports2.map = map;
  }
});

// ../../node_modules/yaml/dist/nodes/YAMLSeq.js
var require_YAMLSeq = __commonJS({
  "../../node_modules/yaml/dist/nodes/YAMLSeq.js"(exports2) {
    "use strict";
    var createNode = require_createNode();
    var stringifyCollection = require_stringifyCollection();
    var Collection = require_Collection();
    var identity = require_identity();
    var Scalar = require_Scalar();
    var toJS = require_toJS();
    var YAMLSeq = class extends Collection.Collection {
      static get tagName() {
        return "tag:yaml.org,2002:seq";
      }
      constructor(schema) {
        super(identity.SEQ, schema);
        this.items = [];
      }
      add(value) {
        this.items.push(value);
      }
      /**
       * Removes a value from the collection.
       *
       * `key` must contain a representation of an integer for this to succeed.
       * It may be wrapped in a `Scalar`.
       *
       * @returns `true` if the item was found and removed.
       */
      delete(key) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number")
          return false;
        const del = this.items.splice(idx, 1);
        return del.length > 0;
      }
      get(key, keepScalar) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number")
          return void 0;
        const it = this.items[idx];
        return !keepScalar && identity.isScalar(it) ? it.value : it;
      }
      /**
       * Checks if the collection includes a value with the key `key`.
       *
       * `key` must contain a representation of an integer for this to succeed.
       * It may be wrapped in a `Scalar`.
       */
      has(key) {
        const idx = asItemIndex(key);
        return typeof idx === "number" && idx < this.items.length;
      }
      /**
       * Sets a value in this collection. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       *
       * If `key` does not contain a representation of an integer, this will throw.
       * It may be wrapped in a `Scalar`.
       */
      set(key, value) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number")
          throw new Error(`Expected a valid index, not ${key}.`);
        const prev = this.items[idx];
        if (identity.isScalar(prev) && Scalar.isScalarValue(value))
          prev.value = value;
        else
          this.items[idx] = value;
      }
      toJSON(_, ctx) {
        const seq = [];
        if (ctx?.onCreate)
          ctx.onCreate(seq);
        let i = 0;
        for (const item of this.items)
          seq.push(toJS.toJS(item, String(i++), ctx));
        return seq;
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        return stringifyCollection.stringifyCollection(this, ctx, {
          blockItemPrefix: "- ",
          flowChars: { start: "[", end: "]" },
          itemIndent: (ctx.indent || "") + "  ",
          onChompKeep,
          onComment
        });
      }
      static from(schema, obj, ctx) {
        const { replacer } = ctx;
        const seq = new this(schema);
        if (obj && Symbol.iterator in Object(obj)) {
          let i = 0;
          for (let it of obj) {
            if (typeof replacer === "function") {
              const key = obj instanceof Set ? it : String(i++);
              it = replacer.call(obj, key, it);
            }
            seq.items.push(createNode.createNode(it, void 0, ctx));
          }
        }
        return seq;
      }
    };
    function asItemIndex(key) {
      let idx = identity.isScalar(key) ? key.value : key;
      if (idx && typeof idx === "string")
        idx = Number(idx);
      return typeof idx === "number" && Number.isInteger(idx) && idx >= 0 ? idx : null;
    }
    exports2.YAMLSeq = YAMLSeq;
  }
});

// ../../node_modules/yaml/dist/schema/common/seq.js
var require_seq = __commonJS({
  "../../node_modules/yaml/dist/schema/common/seq.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var YAMLSeq = require_YAMLSeq();
    var seq = {
      collection: "seq",
      default: true,
      nodeClass: YAMLSeq.YAMLSeq,
      tag: "tag:yaml.org,2002:seq",
      resolve(seq2, onError2) {
        if (!identity.isSeq(seq2))
          onError2("Expected a sequence for this tag");
        return seq2;
      },
      createNode: (schema, obj, ctx) => YAMLSeq.YAMLSeq.from(schema, obj, ctx)
    };
    exports2.seq = seq;
  }
});

// ../../node_modules/yaml/dist/schema/common/string.js
var require_string = __commonJS({
  "../../node_modules/yaml/dist/schema/common/string.js"(exports2) {
    "use strict";
    var stringifyString = require_stringifyString();
    var string = {
      identify: (value) => typeof value === "string",
      default: true,
      tag: "tag:yaml.org,2002:str",
      resolve: (str) => str,
      stringify(item, ctx, onComment, onChompKeep) {
        ctx = Object.assign({ actualString: true }, ctx);
        return stringifyString.stringifyString(item, ctx, onComment, onChompKeep);
      }
    };
    exports2.string = string;
  }
});

// ../../node_modules/yaml/dist/schema/common/null.js
var require_null = __commonJS({
  "../../node_modules/yaml/dist/schema/common/null.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar();
    var nullTag = {
      identify: (value) => value == null,
      createNode: () => new Scalar.Scalar(null),
      default: true,
      tag: "tag:yaml.org,2002:null",
      test: /^(?:~|[Nn]ull|NULL)?$/,
      resolve: () => new Scalar.Scalar(null),
      stringify: ({ source }, ctx) => typeof source === "string" && nullTag.test.test(source) ? source : ctx.options.nullStr
    };
    exports2.nullTag = nullTag;
  }
});

// ../../node_modules/yaml/dist/schema/core/bool.js
var require_bool = __commonJS({
  "../../node_modules/yaml/dist/schema/core/bool.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar();
    var boolTag = {
      identify: (value) => typeof value === "boolean",
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
      resolve: (str) => new Scalar.Scalar(str[0] === "t" || str[0] === "T"),
      stringify({ source, value }, ctx) {
        if (source && boolTag.test.test(source)) {
          const sv = source[0] === "t" || source[0] === "T";
          if (value === sv)
            return source;
        }
        return value ? ctx.options.trueStr : ctx.options.falseStr;
      }
    };
    exports2.boolTag = boolTag;
  }
});

// ../../node_modules/yaml/dist/stringify/stringifyNumber.js
var require_stringifyNumber = __commonJS({
  "../../node_modules/yaml/dist/stringify/stringifyNumber.js"(exports2) {
    "use strict";
    function stringifyNumber({ format, minFractionDigits, tag, value }) {
      if (typeof value === "bigint")
        return String(value);
      const num = typeof value === "number" ? value : Number(value);
      if (!isFinite(num))
        return isNaN(num) ? ".nan" : num < 0 ? "-.inf" : ".inf";
      let n = Object.is(value, -0) ? "-0" : JSON.stringify(value);
      if (!format && minFractionDigits && (!tag || tag === "tag:yaml.org,2002:float") && /^\d/.test(n)) {
        let i = n.indexOf(".");
        if (i < 0) {
          i = n.length;
          n += ".";
        }
        let d = minFractionDigits - (n.length - i - 1);
        while (d-- > 0)
          n += "0";
      }
      return n;
    }
    exports2.stringifyNumber = stringifyNumber;
  }
});

// ../../node_modules/yaml/dist/schema/core/float.js
var require_float = __commonJS({
  "../../node_modules/yaml/dist/schema/core/float.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar();
    var stringifyNumber = require_stringifyNumber();
    var floatNaN = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
      resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
      stringify: stringifyNumber.stringifyNumber
    };
    var floatExp = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "EXP",
      test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
      resolve: (str) => parseFloat(str),
      stringify(node) {
        const num = Number(node.value);
        return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
      }
    };
    var float = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
      resolve(str) {
        const node = new Scalar.Scalar(parseFloat(str));
        const dot = str.indexOf(".");
        if (dot !== -1 && str[str.length - 1] === "0")
          node.minFractionDigits = str.length - dot - 1;
        return node;
      },
      stringify: stringifyNumber.stringifyNumber
    };
    exports2.float = float;
    exports2.floatExp = floatExp;
    exports2.floatNaN = floatNaN;
  }
});

// ../../node_modules/yaml/dist/schema/core/int.js
var require_int = __commonJS({
  "../../node_modules/yaml/dist/schema/core/int.js"(exports2) {
    "use strict";
    var stringifyNumber = require_stringifyNumber();
    var intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
    var intResolve = (str, offset, radix, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix);
    function intStringify(node, radix, prefix) {
      const { value } = node;
      if (intIdentify(value) && value >= 0)
        return prefix + value.toString(radix);
      return stringifyNumber.stringifyNumber(node);
    }
    var intOct = {
      identify: (value) => intIdentify(value) && value >= 0,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "OCT",
      test: /^0o[0-7]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 2, 8, opt),
      stringify: (node) => intStringify(node, 8, "0o")
    };
    var int = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^[-+]?[0-9]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
      stringify: stringifyNumber.stringifyNumber
    };
    var intHex = {
      identify: (value) => intIdentify(value) && value >= 0,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "HEX",
      test: /^0x[0-9a-fA-F]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
      stringify: (node) => intStringify(node, 16, "0x")
    };
    exports2.int = int;
    exports2.intHex = intHex;
    exports2.intOct = intOct;
  }
});

// ../../node_modules/yaml/dist/schema/core/schema.js
var require_schema = __commonJS({
  "../../node_modules/yaml/dist/schema/core/schema.js"(exports2) {
    "use strict";
    var map = require_map();
    var _null = require_null();
    var seq = require_seq();
    var string = require_string();
    var bool = require_bool();
    var float = require_float();
    var int = require_int();
    var schema = [
      map.map,
      seq.seq,
      string.string,
      _null.nullTag,
      bool.boolTag,
      int.intOct,
      int.int,
      int.intHex,
      float.floatNaN,
      float.floatExp,
      float.float
    ];
    exports2.schema = schema;
  }
});

// ../../node_modules/yaml/dist/schema/json/schema.js
var require_schema2 = __commonJS({
  "../../node_modules/yaml/dist/schema/json/schema.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar();
    var map = require_map();
    var seq = require_seq();
    function intIdentify(value) {
      return typeof value === "bigint" || Number.isInteger(value);
    }
    var stringifyJSON = ({ value }) => JSON.stringify(value);
    var jsonScalars = [
      {
        identify: (value) => typeof value === "string",
        default: true,
        tag: "tag:yaml.org,2002:str",
        resolve: (str) => str,
        stringify: stringifyJSON
      },
      {
        identify: (value) => value == null,
        createNode: () => new Scalar.Scalar(null),
        default: true,
        tag: "tag:yaml.org,2002:null",
        test: /^null$/,
        resolve: () => null,
        stringify: stringifyJSON
      },
      {
        identify: (value) => typeof value === "boolean",
        default: true,
        tag: "tag:yaml.org,2002:bool",
        test: /^true$|^false$/,
        resolve: (str) => str === "true",
        stringify: stringifyJSON
      },
      {
        identify: intIdentify,
        default: true,
        tag: "tag:yaml.org,2002:int",
        test: /^-?(?:0|[1-9][0-9]*)$/,
        resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),
        stringify: ({ value }) => intIdentify(value) ? value.toString() : JSON.stringify(value)
      },
      {
        identify: (value) => typeof value === "number",
        default: true,
        tag: "tag:yaml.org,2002:float",
        test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
        resolve: (str) => parseFloat(str),
        stringify: stringifyJSON
      }
    ];
    var jsonError = {
      default: true,
      tag: "",
      test: /^/,
      resolve(str, onError2) {
        onError2(`Unresolved plain scalar ${JSON.stringify(str)}`);
        return str;
      }
    };
    var schema = [map.map, seq.seq].concat(jsonScalars, jsonError);
    exports2.schema = schema;
  }
});

// ../../node_modules/yaml/dist/schema/yaml-1.1/binary.js
var require_binary = __commonJS({
  "../../node_modules/yaml/dist/schema/yaml-1.1/binary.js"(exports2) {
    "use strict";
    var node_buffer = require("buffer");
    var Scalar = require_Scalar();
    var stringifyString = require_stringifyString();
    var binary = {
      identify: (value) => value instanceof Uint8Array,
      // Buffer inherits from Uint8Array
      default: false,
      tag: "tag:yaml.org,2002:binary",
      /**
       * Returns a Buffer in node and an Uint8Array in browsers
       *
       * To use the resulting buffer as an image, you'll want to do something like:
       *
       *   const blob = new Blob([buffer], { type: 'image/jpeg' })
       *   document.querySelector('#photo').src = URL.createObjectURL(blob)
       */
      resolve(src, onError2) {
        if (typeof node_buffer.Buffer === "function") {
          return node_buffer.Buffer.from(src, "base64");
        } else if (typeof atob === "function") {
          const str = atob(src.replace(/[\n\r]/g, ""));
          const buffer = new Uint8Array(str.length);
          for (let i = 0; i < str.length; ++i)
            buffer[i] = str.charCodeAt(i);
          return buffer;
        } else {
          onError2("This environment does not support reading binary tags; either Buffer or atob is required");
          return src;
        }
      },
      stringify({ comment, type, value }, ctx, onComment, onChompKeep) {
        if (!value)
          return "";
        const buf = value;
        let str;
        if (typeof node_buffer.Buffer === "function") {
          str = buf instanceof node_buffer.Buffer ? buf.toString("base64") : node_buffer.Buffer.from(buf.buffer).toString("base64");
        } else if (typeof btoa === "function") {
          let s = "";
          for (let i = 0; i < buf.length; ++i)
            s += String.fromCharCode(buf[i]);
          str = btoa(s);
        } else {
          throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
        }
        type ?? (type = Scalar.Scalar.BLOCK_LITERAL);
        if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
          const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
          const n = Math.ceil(str.length / lineWidth);
          const lines = new Array(n);
          for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {
            lines[i] = str.substr(o, lineWidth);
          }
          str = lines.join(type === Scalar.Scalar.BLOCK_LITERAL ? "\n" : " ");
        }
        return stringifyString.stringifyString({ comment, type, value: str }, ctx, onComment, onChompKeep);
      }
    };
    exports2.binary = binary;
  }
});

// ../../node_modules/yaml/dist/schema/yaml-1.1/pairs.js
var require_pairs = __commonJS({
  "../../node_modules/yaml/dist/schema/yaml-1.1/pairs.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var Pair = require_Pair();
    var Scalar = require_Scalar();
    var YAMLSeq = require_YAMLSeq();
    function resolvePairs(seq, onError2) {
      if (identity.isSeq(seq)) {
        for (let i = 0; i < seq.items.length; ++i) {
          let item = seq.items[i];
          if (identity.isPair(item))
            continue;
          else if (identity.isMap(item)) {
            if (item.items.length > 1)
              onError2("Each pair must have its own sequence indicator");
            const pair = item.items[0] || new Pair.Pair(new Scalar.Scalar(null));
            if (item.commentBefore)
              pair.key.commentBefore = pair.key.commentBefore ? `${item.commentBefore}
${pair.key.commentBefore}` : item.commentBefore;
            if (item.comment) {
              const cn = pair.value ?? pair.key;
              cn.comment = cn.comment ? `${item.comment}
${cn.comment}` : item.comment;
            }
            item = pair;
          }
          seq.items[i] = identity.isPair(item) ? item : new Pair.Pair(item);
        }
      } else
        onError2("Expected a sequence for this tag");
      return seq;
    }
    function createPairs(schema, iterable, ctx) {
      const { replacer } = ctx;
      const pairs2 = new YAMLSeq.YAMLSeq(schema);
      pairs2.tag = "tag:yaml.org,2002:pairs";
      let i = 0;
      if (iterable && Symbol.iterator in Object(iterable))
        for (let it of iterable) {
          if (typeof replacer === "function")
            it = replacer.call(iterable, String(i++), it);
          let key, value;
          if (Array.isArray(it)) {
            if (it.length === 2) {
              key = it[0];
              value = it[1];
            } else
              throw new TypeError(`Expected [key, value] tuple: ${it}`);
          } else if (it && it instanceof Object) {
            const keys = Object.keys(it);
            if (keys.length === 1) {
              key = keys[0];
              value = it[key];
            } else {
              throw new TypeError(`Expected tuple with one key, not ${keys.length} keys`);
            }
          } else {
            key = it;
          }
          pairs2.items.push(Pair.createPair(key, value, ctx));
        }
      return pairs2;
    }
    var pairs = {
      collection: "seq",
      default: false,
      tag: "tag:yaml.org,2002:pairs",
      resolve: resolvePairs,
      createNode: createPairs
    };
    exports2.createPairs = createPairs;
    exports2.pairs = pairs;
    exports2.resolvePairs = resolvePairs;
  }
});

// ../../node_modules/yaml/dist/schema/yaml-1.1/omap.js
var require_omap = __commonJS({
  "../../node_modules/yaml/dist/schema/yaml-1.1/omap.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var toJS = require_toJS();
    var YAMLMap = require_YAMLMap();
    var YAMLSeq = require_YAMLSeq();
    var pairs = require_pairs();
    var YAMLOMap = class _YAMLOMap extends YAMLSeq.YAMLSeq {
      constructor() {
        super();
        this.add = YAMLMap.YAMLMap.prototype.add.bind(this);
        this.delete = YAMLMap.YAMLMap.prototype.delete.bind(this);
        this.get = YAMLMap.YAMLMap.prototype.get.bind(this);
        this.has = YAMLMap.YAMLMap.prototype.has.bind(this);
        this.set = YAMLMap.YAMLMap.prototype.set.bind(this);
        this.tag = _YAMLOMap.tag;
      }
      /**
       * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
       * but TypeScript won't allow widening the signature of a child method.
       */
      toJSON(_, ctx) {
        if (!ctx)
          return super.toJSON(_);
        const map = /* @__PURE__ */ new Map();
        if (ctx?.onCreate)
          ctx.onCreate(map);
        for (const pair of this.items) {
          let key, value;
          if (identity.isPair(pair)) {
            key = toJS.toJS(pair.key, "", ctx);
            value = toJS.toJS(pair.value, key, ctx);
          } else {
            key = toJS.toJS(pair, "", ctx);
          }
          if (map.has(key))
            throw new Error("Ordered maps must not include duplicate keys");
          map.set(key, value);
        }
        return map;
      }
      static from(schema, iterable, ctx) {
        const pairs$1 = pairs.createPairs(schema, iterable, ctx);
        const omap2 = new this();
        omap2.items = pairs$1.items;
        return omap2;
      }
    };
    YAMLOMap.tag = "tag:yaml.org,2002:omap";
    var omap = {
      collection: "seq",
      identify: (value) => value instanceof Map,
      nodeClass: YAMLOMap,
      default: false,
      tag: "tag:yaml.org,2002:omap",
      resolve(seq, onError2) {
        const pairs$1 = pairs.resolvePairs(seq, onError2);
        const seenKeys = [];
        for (const { key } of pairs$1.items) {
          if (identity.isScalar(key)) {
            if (seenKeys.includes(key.value)) {
              onError2(`Ordered maps must not include duplicate keys: ${key.value}`);
            } else {
              seenKeys.push(key.value);
            }
          }
        }
        return Object.assign(new YAMLOMap(), pairs$1);
      },
      createNode: (schema, iterable, ctx) => YAMLOMap.from(schema, iterable, ctx)
    };
    exports2.YAMLOMap = YAMLOMap;
    exports2.omap = omap;
  }
});

// ../../node_modules/yaml/dist/schema/yaml-1.1/bool.js
var require_bool2 = __commonJS({
  "../../node_modules/yaml/dist/schema/yaml-1.1/bool.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar();
    function boolStringify({ value, source }, ctx) {
      const boolObj = value ? trueTag : falseTag;
      if (source && boolObj.test.test(source))
        return source;
      return value ? ctx.options.trueStr : ctx.options.falseStr;
    }
    var trueTag = {
      identify: (value) => value === true,
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
      resolve: () => new Scalar.Scalar(true),
      stringify: boolStringify
    };
    var falseTag = {
      identify: (value) => value === false,
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,
      resolve: () => new Scalar.Scalar(false),
      stringify: boolStringify
    };
    exports2.falseTag = falseTag;
    exports2.trueTag = trueTag;
  }
});

// ../../node_modules/yaml/dist/schema/yaml-1.1/float.js
var require_float2 = __commonJS({
  "../../node_modules/yaml/dist/schema/yaml-1.1/float.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar();
    var stringifyNumber = require_stringifyNumber();
    var floatNaN = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
      resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
      stringify: stringifyNumber.stringifyNumber
    };
    var floatExp = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "EXP",
      test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
      resolve: (str) => parseFloat(str.replace(/_/g, "")),
      stringify(node) {
        const num = Number(node.value);
        return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
      }
    };
    var float = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
      resolve(str) {
        const node = new Scalar.Scalar(parseFloat(str.replace(/_/g, "")));
        const dot = str.indexOf(".");
        if (dot !== -1) {
          const f = str.substring(dot + 1).replace(/_/g, "");
          if (f[f.length - 1] === "0")
            node.minFractionDigits = f.length;
        }
        return node;
      },
      stringify: stringifyNumber.stringifyNumber
    };
    exports2.float = float;
    exports2.floatExp = floatExp;
    exports2.floatNaN = floatNaN;
  }
});

// ../../node_modules/yaml/dist/schema/yaml-1.1/int.js
var require_int2 = __commonJS({
  "../../node_modules/yaml/dist/schema/yaml-1.1/int.js"(exports2) {
    "use strict";
    var stringifyNumber = require_stringifyNumber();
    var intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
    function intResolve(str, offset, radix, { intAsBigInt }) {
      const sign = str[0];
      if (sign === "-" || sign === "+")
        offset += 1;
      str = str.substring(offset).replace(/_/g, "");
      if (intAsBigInt) {
        switch (radix) {
          case 2:
            str = `0b${str}`;
            break;
          case 8:
            str = `0o${str}`;
            break;
          case 16:
            str = `0x${str}`;
            break;
        }
        const n2 = BigInt(str);
        return sign === "-" ? BigInt(-1) * n2 : n2;
      }
      const n = parseInt(str, radix);
      return sign === "-" ? -1 * n : n;
    }
    function intStringify(node, radix, prefix) {
      const { value } = node;
      if (intIdentify(value)) {
        const str = value.toString(radix);
        return value < 0 ? "-" + prefix + str.substr(1) : prefix + str;
      }
      return stringifyNumber.stringifyNumber(node);
    }
    var intBin = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "BIN",
      test: /^[-+]?0b[0-1_]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 2, 2, opt),
      stringify: (node) => intStringify(node, 2, "0b")
    };
    var intOct = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "OCT",
      test: /^[-+]?0[0-7_]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 1, 8, opt),
      stringify: (node) => intStringify(node, 8, "0")
    };
    var int = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^[-+]?[0-9][0-9_]*$/,
      resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
      stringify: stringifyNumber.stringifyNumber
    };
    var intHex = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "HEX",
      test: /^[-+]?0x[0-9a-fA-F_]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
      stringify: (node) => intStringify(node, 16, "0x")
    };
    exports2.int = int;
    exports2.intBin = intBin;
    exports2.intHex = intHex;
    exports2.intOct = intOct;
  }
});

// ../../node_modules/yaml/dist/schema/yaml-1.1/set.js
var require_set = __commonJS({
  "../../node_modules/yaml/dist/schema/yaml-1.1/set.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var Pair = require_Pair();
    var YAMLMap = require_YAMLMap();
    var YAMLSet = class _YAMLSet extends YAMLMap.YAMLMap {
      constructor(schema) {
        super(schema);
        this.tag = _YAMLSet.tag;
      }
      add(key) {
        let pair;
        if (identity.isPair(key))
          pair = key;
        else if (key && typeof key === "object" && "key" in key && "value" in key && key.value === null)
          pair = new Pair.Pair(key.key, null);
        else
          pair = new Pair.Pair(key, null);
        const prev = YAMLMap.findPair(this.items, pair.key);
        if (!prev)
          this.items.push(pair);
      }
      /**
       * If `keepPair` is `true`, returns the Pair matching `key`.
       * Otherwise, returns the value of that Pair's key.
       */
      get(key, keepPair) {
        const pair = YAMLMap.findPair(this.items, key);
        return !keepPair && identity.isPair(pair) ? identity.isScalar(pair.key) ? pair.key.value : pair.key : pair;
      }
      set(key, value) {
        if (typeof value !== "boolean")
          throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
        const prev = YAMLMap.findPair(this.items, key);
        if (prev && !value) {
          this.items.splice(this.items.indexOf(prev), 1);
        } else if (!prev && value) {
          this.items.push(new Pair.Pair(key));
        }
      }
      toJSON(_, ctx) {
        return super.toJSON(_, ctx, Set);
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        if (this.hasAllNullValues(true))
          return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);
        else
          throw new Error("Set items must all have null values");
      }
      static from(schema, iterable, ctx) {
        const { replacer } = ctx;
        const set2 = new this(schema);
        if (iterable && Symbol.iterator in Object(iterable))
          for (let value of iterable) {
            if (typeof replacer === "function")
              value = replacer.call(iterable, value, value);
            set2.items.push(Pair.createPair(value, null, ctx));
          }
        return set2;
      }
    };
    YAMLSet.tag = "tag:yaml.org,2002:set";
    var set = {
      collection: "map",
      identify: (value) => value instanceof Set,
      nodeClass: YAMLSet,
      default: false,
      tag: "tag:yaml.org,2002:set",
      createNode: (schema, iterable, ctx) => YAMLSet.from(schema, iterable, ctx),
      resolve(map, onError2) {
        if (identity.isMap(map)) {
          if (map.hasAllNullValues(true))
            return Object.assign(new YAMLSet(), map);
          else
            onError2("Set items must all have null values");
        } else
          onError2("Expected a mapping for this tag");
        return map;
      }
    };
    exports2.YAMLSet = YAMLSet;
    exports2.set = set;
  }
});

// ../../node_modules/yaml/dist/schema/yaml-1.1/timestamp.js
var require_timestamp = __commonJS({
  "../../node_modules/yaml/dist/schema/yaml-1.1/timestamp.js"(exports2) {
    "use strict";
    var stringifyNumber = require_stringifyNumber();
    function parseSexagesimal(str, asBigInt) {
      const sign = str[0];
      const parts = sign === "-" || sign === "+" ? str.substring(1) : str;
      const num = (n) => asBigInt ? BigInt(n) : Number(n);
      const res = parts.replace(/_/g, "").split(":").reduce((res2, p) => res2 * num(60) + num(p), num(0));
      return sign === "-" ? num(-1) * res : res;
    }
    function stringifySexagesimal(node) {
      let { value } = node;
      let num = (n) => n;
      if (typeof value === "bigint")
        num = (n) => BigInt(n);
      else if (isNaN(value) || !isFinite(value))
        return stringifyNumber.stringifyNumber(node);
      let sign = "";
      if (value < 0) {
        sign = "-";
        value *= num(-1);
      }
      const _60 = num(60);
      const parts = [value % _60];
      if (value < 60) {
        parts.unshift(0);
      } else {
        value = (value - parts[0]) / _60;
        parts.unshift(value % _60);
        if (value >= 60) {
          value = (value - parts[0]) / _60;
          parts.unshift(value);
        }
      }
      return sign + parts.map((n) => String(n).padStart(2, "0")).join(":").replace(/000000\d*$/, "");
    }
    var intTime = {
      identify: (value) => typeof value === "bigint" || Number.isInteger(value),
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "TIME",
      test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
      resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),
      stringify: stringifySexagesimal
    };
    var floatTime = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "TIME",
      test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
      resolve: (str) => parseSexagesimal(str, false),
      stringify: stringifySexagesimal
    };
    var timestamp = {
      identify: (value) => value instanceof Date,
      default: true,
      tag: "tag:yaml.org,2002:timestamp",
      // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
      // may be omitted altogether, resulting in a date format. In such a case, the time part is
      // assumed to be 00:00:00Z (start of day, UTC).
      test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
      resolve(str) {
        const match = str.match(timestamp.test);
        if (!match)
          throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
        const [, year, month, day, hour, minute, second] = match.map(Number);
        const millisec = match[7] ? Number((match[7] + "00").substr(1, 3)) : 0;
        let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
        const tz = match[8];
        if (tz && tz !== "Z") {
          let d = parseSexagesimal(tz, false);
          if (Math.abs(d) < 30)
            d *= 60;
          date -= 6e4 * d;
        }
        return new Date(date);
      },
      stringify: ({ value }) => value?.toISOString().replace(/(T00:00:00)?\.000Z$/, "") ?? ""
    };
    exports2.floatTime = floatTime;
    exports2.intTime = intTime;
    exports2.timestamp = timestamp;
  }
});

// ../../node_modules/yaml/dist/schema/yaml-1.1/schema.js
var require_schema3 = __commonJS({
  "../../node_modules/yaml/dist/schema/yaml-1.1/schema.js"(exports2) {
    "use strict";
    var map = require_map();
    var _null = require_null();
    var seq = require_seq();
    var string = require_string();
    var binary = require_binary();
    var bool = require_bool2();
    var float = require_float2();
    var int = require_int2();
    var merge = require_merge();
    var omap = require_omap();
    var pairs = require_pairs();
    var set = require_set();
    var timestamp = require_timestamp();
    var schema = [
      map.map,
      seq.seq,
      string.string,
      _null.nullTag,
      bool.trueTag,
      bool.falseTag,
      int.intBin,
      int.intOct,
      int.int,
      int.intHex,
      float.floatNaN,
      float.floatExp,
      float.float,
      binary.binary,
      merge.merge,
      omap.omap,
      pairs.pairs,
      set.set,
      timestamp.intTime,
      timestamp.floatTime,
      timestamp.timestamp
    ];
    exports2.schema = schema;
  }
});

// ../../node_modules/yaml/dist/schema/tags.js
var require_tags = __commonJS({
  "../../node_modules/yaml/dist/schema/tags.js"(exports2) {
    "use strict";
    var map = require_map();
    var _null = require_null();
    var seq = require_seq();
    var string = require_string();
    var bool = require_bool();
    var float = require_float();
    var int = require_int();
    var schema = require_schema();
    var schema$1 = require_schema2();
    var binary = require_binary();
    var merge = require_merge();
    var omap = require_omap();
    var pairs = require_pairs();
    var schema$2 = require_schema3();
    var set = require_set();
    var timestamp = require_timestamp();
    var schemas = /* @__PURE__ */ new Map([
      ["core", schema.schema],
      ["failsafe", [map.map, seq.seq, string.string]],
      ["json", schema$1.schema],
      ["yaml11", schema$2.schema],
      ["yaml-1.1", schema$2.schema]
    ]);
    var tagsByName = {
      binary: binary.binary,
      bool: bool.boolTag,
      float: float.float,
      floatExp: float.floatExp,
      floatNaN: float.floatNaN,
      floatTime: timestamp.floatTime,
      int: int.int,
      intHex: int.intHex,
      intOct: int.intOct,
      intTime: timestamp.intTime,
      map: map.map,
      merge: merge.merge,
      null: _null.nullTag,
      omap: omap.omap,
      pairs: pairs.pairs,
      seq: seq.seq,
      set: set.set,
      timestamp: timestamp.timestamp
    };
    var coreKnownTags = {
      "tag:yaml.org,2002:binary": binary.binary,
      "tag:yaml.org,2002:merge": merge.merge,
      "tag:yaml.org,2002:omap": omap.omap,
      "tag:yaml.org,2002:pairs": pairs.pairs,
      "tag:yaml.org,2002:set": set.set,
      "tag:yaml.org,2002:timestamp": timestamp.timestamp
    };
    function getTags(customTags, schemaName, addMergeTag) {
      const schemaTags = schemas.get(schemaName);
      if (schemaTags && !customTags) {
        return addMergeTag && !schemaTags.includes(merge.merge) ? schemaTags.concat(merge.merge) : schemaTags.slice();
      }
      let tags = schemaTags;
      if (!tags) {
        if (Array.isArray(customTags))
          tags = [];
        else {
          const keys = Array.from(schemas.keys()).filter((key) => key !== "yaml11").map((key) => JSON.stringify(key)).join(", ");
          throw new Error(`Unknown schema "${schemaName}"; use one of ${keys} or define customTags array`);
        }
      }
      if (Array.isArray(customTags)) {
        for (const tag of customTags)
          tags = tags.concat(tag);
      } else if (typeof customTags === "function") {
        tags = customTags(tags.slice());
      }
      if (addMergeTag)
        tags = tags.concat(merge.merge);
      return tags.reduce((tags2, tag) => {
        const tagObj = typeof tag === "string" ? tagsByName[tag] : tag;
        if (!tagObj) {
          const tagName = JSON.stringify(tag);
          const keys = Object.keys(tagsByName).map((key) => JSON.stringify(key)).join(", ");
          throw new Error(`Unknown custom tag ${tagName}; use one of ${keys}`);
        }
        if (!tags2.includes(tagObj))
          tags2.push(tagObj);
        return tags2;
      }, []);
    }
    exports2.coreKnownTags = coreKnownTags;
    exports2.getTags = getTags;
  }
});

// ../../node_modules/yaml/dist/schema/Schema.js
var require_Schema = __commonJS({
  "../../node_modules/yaml/dist/schema/Schema.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var map = require_map();
    var seq = require_seq();
    var string = require_string();
    var tags = require_tags();
    var sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;
    var Schema = class _Schema {
      constructor({ compat, customTags, merge, resolveKnownTags, schema, sortMapEntries, toStringDefaults }) {
        this.compat = Array.isArray(compat) ? tags.getTags(compat, "compat") : compat ? tags.getTags(null, compat) : null;
        this.name = typeof schema === "string" && schema || "core";
        this.knownTags = resolveKnownTags ? tags.coreKnownTags : {};
        this.tags = tags.getTags(customTags, this.name, merge);
        this.toStringOptions = toStringDefaults ?? null;
        Object.defineProperty(this, identity.MAP, { value: map.map });
        Object.defineProperty(this, identity.SCALAR, { value: string.string });
        Object.defineProperty(this, identity.SEQ, { value: seq.seq });
        this.sortMapEntries = typeof sortMapEntries === "function" ? sortMapEntries : sortMapEntries === true ? sortMapEntriesByKey : null;
      }
      clone() {
        const copy = Object.create(_Schema.prototype, Object.getOwnPropertyDescriptors(this));
        copy.tags = this.tags.slice();
        return copy;
      }
    };
    exports2.Schema = Schema;
  }
});

// ../../node_modules/yaml/dist/stringify/stringifyDocument.js
var require_stringifyDocument = __commonJS({
  "../../node_modules/yaml/dist/stringify/stringifyDocument.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var stringify = require_stringify();
    var stringifyComment = require_stringifyComment();
    function stringifyDocument(doc, options) {
      const lines = [];
      let hasDirectives = options.directives === true;
      if (options.directives !== false && doc.directives) {
        const dir = doc.directives.toString(doc);
        if (dir) {
          lines.push(dir);
          hasDirectives = true;
        } else if (doc.directives.docStart)
          hasDirectives = true;
      }
      if (hasDirectives)
        lines.push("---");
      const ctx = stringify.createStringifyContext(doc, options);
      const { commentString } = ctx.options;
      if (doc.commentBefore) {
        if (lines.length !== 1)
          lines.unshift("");
        const cs = commentString(doc.commentBefore);
        lines.unshift(stringifyComment.indentComment(cs, ""));
      }
      let chompKeep = false;
      let contentComment = null;
      if (doc.contents) {
        if (identity.isNode(doc.contents)) {
          if (doc.contents.spaceBefore && hasDirectives)
            lines.push("");
          if (doc.contents.commentBefore) {
            const cs = commentString(doc.contents.commentBefore);
            lines.push(stringifyComment.indentComment(cs, ""));
          }
          ctx.forceBlockIndent = !!doc.comment;
          contentComment = doc.contents.comment;
        }
        const onChompKeep = contentComment ? void 0 : () => chompKeep = true;
        let body = stringify.stringify(doc.contents, ctx, () => contentComment = null, onChompKeep);
        if (contentComment)
          body += stringifyComment.lineComment(body, "", commentString(contentComment));
        if ((body[0] === "|" || body[0] === ">") && lines[lines.length - 1] === "---") {
          lines[lines.length - 1] = `--- ${body}`;
        } else
          lines.push(body);
      } else {
        lines.push(stringify.stringify(doc.contents, ctx));
      }
      if (doc.directives?.docEnd) {
        if (doc.comment) {
          const cs = commentString(doc.comment);
          if (cs.includes("\n")) {
            lines.push("...");
            lines.push(stringifyComment.indentComment(cs, ""));
          } else {
            lines.push(`... ${cs}`);
          }
        } else {
          lines.push("...");
        }
      } else {
        let dc = doc.comment;
        if (dc && chompKeep)
          dc = dc.replace(/^\n+/, "");
        if (dc) {
          if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "")
            lines.push("");
          lines.push(stringifyComment.indentComment(commentString(dc), ""));
        }
      }
      return lines.join("\n") + "\n";
    }
    exports2.stringifyDocument = stringifyDocument;
  }
});

// ../../node_modules/yaml/dist/doc/Document.js
var require_Document = __commonJS({
  "../../node_modules/yaml/dist/doc/Document.js"(exports2) {
    "use strict";
    var Alias = require_Alias();
    var Collection = require_Collection();
    var identity = require_identity();
    var Pair = require_Pair();
    var toJS = require_toJS();
    var Schema = require_Schema();
    var stringifyDocument = require_stringifyDocument();
    var anchors = require_anchors();
    var applyReviver = require_applyReviver();
    var createNode = require_createNode();
    var directives = require_directives();
    var Document = class _Document {
      constructor(value, replacer, options) {
        this.commentBefore = null;
        this.comment = null;
        this.errors = [];
        this.warnings = [];
        Object.defineProperty(this, identity.NODE_TYPE, { value: identity.DOC });
        let _replacer = null;
        if (typeof replacer === "function" || Array.isArray(replacer)) {
          _replacer = replacer;
        } else if (options === void 0 && replacer) {
          options = replacer;
          replacer = void 0;
        }
        const opt = Object.assign({
          intAsBigInt: false,
          keepSourceTokens: false,
          logLevel: "warn",
          prettyErrors: true,
          strict: true,
          stringKeys: false,
          uniqueKeys: true,
          version: "1.2"
        }, options);
        this.options = opt;
        let { version } = opt;
        if (options?._directives) {
          this.directives = options._directives.atDocument();
          if (this.directives.yaml.explicit)
            version = this.directives.yaml.version;
        } else
          this.directives = new directives.Directives({ version });
        this.setSchema(version, options);
        this.contents = value === void 0 ? null : this.createNode(value, _replacer, options);
      }
      /**
       * Create a deep copy of this Document and its contents.
       *
       * Custom Node values that inherit from `Object` still refer to their original instances.
       */
      clone() {
        const copy = Object.create(_Document.prototype, {
          [identity.NODE_TYPE]: { value: identity.DOC }
        });
        copy.commentBefore = this.commentBefore;
        copy.comment = this.comment;
        copy.errors = this.errors.slice();
        copy.warnings = this.warnings.slice();
        copy.options = Object.assign({}, this.options);
        if (this.directives)
          copy.directives = this.directives.clone();
        copy.schema = this.schema.clone();
        copy.contents = identity.isNode(this.contents) ? this.contents.clone(copy.schema) : this.contents;
        if (this.range)
          copy.range = this.range.slice();
        return copy;
      }
      /** Adds a value to the document. */
      add(value) {
        if (assertCollection(this.contents))
          this.contents.add(value);
      }
      /** Adds a value to the document. */
      addIn(path11, value) {
        if (assertCollection(this.contents))
          this.contents.addIn(path11, value);
      }
      /**
       * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
       *
       * If `node` already has an anchor, `name` is ignored.
       * Otherwise, the `node.anchor` value will be set to `name`,
       * or if an anchor with that name is already present in the document,
       * `name` will be used as a prefix for a new unique anchor.
       * If `name` is undefined, the generated anchor will use 'a' as a prefix.
       */
      createAlias(node, name) {
        if (!node.anchor) {
          const prev = anchors.anchorNames(this);
          node.anchor = // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
          !name || prev.has(name) ? anchors.findNewAnchor(name || "a", prev) : name;
        }
        return new Alias.Alias(node.anchor);
      }
      createNode(value, replacer, options) {
        let _replacer = void 0;
        if (typeof replacer === "function") {
          value = replacer.call({ "": value }, "", value);
          _replacer = replacer;
        } else if (Array.isArray(replacer)) {
          const keyToStr = (v) => typeof v === "number" || v instanceof String || v instanceof Number;
          const asStr = replacer.filter(keyToStr).map(String);
          if (asStr.length > 0)
            replacer = replacer.concat(asStr);
          _replacer = replacer;
        } else if (options === void 0 && replacer) {
          options = replacer;
          replacer = void 0;
        }
        const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options ?? {};
        const { onAnchor, setAnchors, sourceObjects } = anchors.createNodeAnchors(
          this,
          // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
          anchorPrefix || "a"
        );
        const ctx = {
          aliasDuplicateObjects: aliasDuplicateObjects ?? true,
          keepUndefined: keepUndefined ?? false,
          onAnchor,
          onTagObj,
          replacer: _replacer,
          schema: this.schema,
          sourceObjects
        };
        const node = createNode.createNode(value, tag, ctx);
        if (flow && identity.isCollection(node))
          node.flow = true;
        setAnchors();
        return node;
      }
      /**
       * Convert a key and a value into a `Pair` using the current schema,
       * recursively wrapping all values as `Scalar` or `Collection` nodes.
       */
      createPair(key, value, options = {}) {
        const k = this.createNode(key, null, options);
        const v = this.createNode(value, null, options);
        return new Pair.Pair(k, v);
      }
      /**
       * Removes a value from the document.
       * @returns `true` if the item was found and removed.
       */
      delete(key) {
        return assertCollection(this.contents) ? this.contents.delete(key) : false;
      }
      /**
       * Removes a value from the document.
       * @returns `true` if the item was found and removed.
       */
      deleteIn(path11) {
        if (Collection.isEmptyPath(path11)) {
          if (this.contents == null)
            return false;
          this.contents = null;
          return true;
        }
        return assertCollection(this.contents) ? this.contents.deleteIn(path11) : false;
      }
      /**
       * Returns item at `key`, or `undefined` if not found. By default unwraps
       * scalar values from their surrounding node; to disable set `keepScalar` to
       * `true` (collections are always returned intact).
       */
      get(key, keepScalar) {
        return identity.isCollection(this.contents) ? this.contents.get(key, keepScalar) : void 0;
      }
      /**
       * Returns item at `path`, or `undefined` if not found. By default unwraps
       * scalar values from their surrounding node; to disable set `keepScalar` to
       * `true` (collections are always returned intact).
       */
      getIn(path11, keepScalar) {
        if (Collection.isEmptyPath(path11))
          return !keepScalar && identity.isScalar(this.contents) ? this.contents.value : this.contents;
        return identity.isCollection(this.contents) ? this.contents.getIn(path11, keepScalar) : void 0;
      }
      /**
       * Checks if the document includes a value with the key `key`.
       */
      has(key) {
        return identity.isCollection(this.contents) ? this.contents.has(key) : false;
      }
      /**
       * Checks if the document includes a value at `path`.
       */
      hasIn(path11) {
        if (Collection.isEmptyPath(path11))
          return this.contents !== void 0;
        return identity.isCollection(this.contents) ? this.contents.hasIn(path11) : false;
      }
      /**
       * Sets a value in this document. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       */
      set(key, value) {
        if (this.contents == null) {
          this.contents = Collection.collectionFromPath(this.schema, [key], value);
        } else if (assertCollection(this.contents)) {
          this.contents.set(key, value);
        }
      }
      /**
       * Sets a value in this document. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       */
      setIn(path11, value) {
        if (Collection.isEmptyPath(path11)) {
          this.contents = value;
        } else if (this.contents == null) {
          this.contents = Collection.collectionFromPath(this.schema, Array.from(path11), value);
        } else if (assertCollection(this.contents)) {
          this.contents.setIn(path11, value);
        }
      }
      /**
       * Change the YAML version and schema used by the document.
       * A `null` version disables support for directives, explicit tags, anchors, and aliases.
       * It also requires the `schema` option to be given as a `Schema` instance value.
       *
       * Overrides all previously set schema options.
       */
      setSchema(version, options = {}) {
        if (typeof version === "number")
          version = String(version);
        let opt;
        switch (version) {
          case "1.1":
            if (this.directives)
              this.directives.yaml.version = "1.1";
            else
              this.directives = new directives.Directives({ version: "1.1" });
            opt = { resolveKnownTags: false, schema: "yaml-1.1" };
            break;
          case "1.2":
          case "next":
            if (this.directives)
              this.directives.yaml.version = version;
            else
              this.directives = new directives.Directives({ version });
            opt = { resolveKnownTags: true, schema: "core" };
            break;
          case null:
            if (this.directives)
              delete this.directives;
            opt = null;
            break;
          default: {
            const sv = JSON.stringify(version);
            throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
          }
        }
        if (options.schema instanceof Object)
          this.schema = options.schema;
        else if (opt)
          this.schema = new Schema.Schema(Object.assign(opt, options));
        else
          throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
      }
      // json & jsonArg are only used from toJSON()
      toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
        const ctx = {
          anchors: /* @__PURE__ */ new Map(),
          doc: this,
          keep: !json,
          mapAsMap: mapAsMap === true,
          mapKeyWarned: false,
          maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
        };
        const res = toJS.toJS(this.contents, jsonArg ?? "", ctx);
        if (typeof onAnchor === "function")
          for (const { count, res: res2 } of ctx.anchors.values())
            onAnchor(res2, count);
        return typeof reviver === "function" ? applyReviver.applyReviver(reviver, { "": res }, "", res) : res;
      }
      /**
       * A JSON representation of the document `contents`.
       *
       * @param jsonArg Used by `JSON.stringify` to indicate the array index or
       *   property name.
       */
      toJSON(jsonArg, onAnchor) {
        return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });
      }
      /** A YAML representation of the document. */
      toString(options = {}) {
        if (this.errors.length > 0)
          throw new Error("Document with errors cannot be stringified");
        if ("indent" in options && (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {
          const s = JSON.stringify(options.indent);
          throw new Error(`"indent" option must be a positive integer, not ${s}`);
        }
        return stringifyDocument.stringifyDocument(this, options);
      }
    };
    function assertCollection(contents) {
      if (identity.isCollection(contents))
        return true;
      throw new Error("Expected a YAML collection as document contents");
    }
    exports2.Document = Document;
  }
});

// ../../node_modules/yaml/dist/errors.js
var require_errors2 = __commonJS({
  "../../node_modules/yaml/dist/errors.js"(exports2) {
    "use strict";
    var YAMLError = class extends Error {
      constructor(name, pos, code, message) {
        super();
        this.name = name;
        this.code = code;
        this.message = message;
        this.pos = pos;
      }
    };
    var YAMLParseError = class extends YAMLError {
      constructor(pos, code, message) {
        super("YAMLParseError", pos, code, message);
      }
    };
    var YAMLWarning = class extends YAMLError {
      constructor(pos, code, message) {
        super("YAMLWarning", pos, code, message);
      }
    };
    var prettifyError = (src, lc) => (error) => {
      if (error.pos[0] === -1)
        return;
      error.linePos = error.pos.map((pos) => lc.linePos(pos));
      const { line, col } = error.linePos[0];
      error.message += ` at line ${line}, column ${col}`;
      let ci = col - 1;
      let lineStr = src.substring(lc.lineStarts[line - 1], lc.lineStarts[line]).replace(/[\n\r]+$/, "");
      if (ci >= 60 && lineStr.length > 80) {
        const trimStart = Math.min(ci - 39, lineStr.length - 79);
        lineStr = "\u2026" + lineStr.substring(trimStart);
        ci -= trimStart - 1;
      }
      if (lineStr.length > 80)
        lineStr = lineStr.substring(0, 79) + "\u2026";
      if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
        let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
        if (prev.length > 80)
          prev = prev.substring(0, 79) + "\u2026\n";
        lineStr = prev + lineStr;
      }
      if (/[^ ]/.test(lineStr)) {
        let count = 1;
        const end = error.linePos[1];
        if (end?.line === line && end.col > col) {
          count = Math.max(1, Math.min(end.col - col, 80 - ci));
        }
        const pointer = " ".repeat(ci) + "^".repeat(count);
        error.message += `:

${lineStr}
${pointer}
`;
      }
    };
    exports2.YAMLError = YAMLError;
    exports2.YAMLParseError = YAMLParseError;
    exports2.YAMLWarning = YAMLWarning;
    exports2.prettifyError = prettifyError;
  }
});

// ../../node_modules/yaml/dist/compose/resolve-props.js
var require_resolve_props = __commonJS({
  "../../node_modules/yaml/dist/compose/resolve-props.js"(exports2) {
    "use strict";
    function resolveProps(tokens, { flow, indicator, next, offset, onError: onError2, parentIndent, startOnNewline }) {
      let spaceBefore = false;
      let atNewline = startOnNewline;
      let hasSpace = startOnNewline;
      let comment = "";
      let commentSep = "";
      let hasNewline = false;
      let reqSpace = false;
      let tab = null;
      let anchor = null;
      let tag = null;
      let newlineAfterProp = null;
      let comma = null;
      let found = null;
      let start = null;
      for (const token of tokens) {
        if (reqSpace) {
          if (token.type !== "space" && token.type !== "newline" && token.type !== "comma")
            onError2(token.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
          reqSpace = false;
        }
        if (tab) {
          if (atNewline && token.type !== "comment" && token.type !== "newline") {
            onError2(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
          }
          tab = null;
        }
        switch (token.type) {
          case "space":
            if (!flow && (indicator !== "doc-start" || next?.type !== "flow-collection") && token.source.includes("	")) {
              tab = token;
            }
            hasSpace = true;
            break;
          case "comment": {
            if (!hasSpace)
              onError2(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
            const cb = token.source.substring(1) || " ";
            if (!comment)
              comment = cb;
            else
              comment += commentSep + cb;
            commentSep = "";
            atNewline = false;
            break;
          }
          case "newline":
            if (atNewline) {
              if (comment)
                comment += token.source;
              else if (!found || indicator !== "seq-item-ind")
                spaceBefore = true;
            } else
              commentSep += token.source;
            atNewline = true;
            hasNewline = true;
            if (anchor || tag)
              newlineAfterProp = token;
            hasSpace = true;
            break;
          case "anchor":
            if (anchor)
              onError2(token, "MULTIPLE_ANCHORS", "A node can have at most one anchor");
            if (token.source.endsWith(":"))
              onError2(token.offset + token.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", true);
            anchor = token;
            start ?? (start = token.offset);
            atNewline = false;
            hasSpace = false;
            reqSpace = true;
            break;
          case "tag": {
            if (tag)
              onError2(token, "MULTIPLE_TAGS", "A node can have at most one tag");
            tag = token;
            start ?? (start = token.offset);
            atNewline = false;
            hasSpace = false;
            reqSpace = true;
            break;
          }
          case indicator:
            if (anchor || tag)
              onError2(token, "BAD_PROP_ORDER", `Anchors and tags must be after the ${token.source} indicator`);
            if (found)
              onError2(token, "UNEXPECTED_TOKEN", `Unexpected ${token.source} in ${flow ?? "collection"}`);
            found = token;
            atNewline = indicator === "seq-item-ind" || indicator === "explicit-key-ind";
            hasSpace = false;
            break;
          case "comma":
            if (flow) {
              if (comma)
                onError2(token, "UNEXPECTED_TOKEN", `Unexpected , in ${flow}`);
              comma = token;
              atNewline = false;
              hasSpace = false;
              break;
            }
          // else fallthrough
          default:
            onError2(token, "UNEXPECTED_TOKEN", `Unexpected ${token.type} token`);
            atNewline = false;
            hasSpace = false;
        }
      }
      const last2 = tokens[tokens.length - 1];
      const end = last2 ? last2.offset + last2.source.length : offset;
      if (reqSpace && next && next.type !== "space" && next.type !== "newline" && next.type !== "comma" && (next.type !== "scalar" || next.source !== "")) {
        onError2(next.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
      }
      if (tab && (atNewline && tab.indent <= parentIndent || next?.type === "block-map" || next?.type === "block-seq"))
        onError2(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
      return {
        comma,
        found,
        spaceBefore,
        comment,
        hasNewline,
        anchor,
        tag,
        newlineAfterProp,
        end,
        start: start ?? end
      };
    }
    exports2.resolveProps = resolveProps;
  }
});

// ../../node_modules/yaml/dist/compose/util-contains-newline.js
var require_util_contains_newline = __commonJS({
  "../../node_modules/yaml/dist/compose/util-contains-newline.js"(exports2) {
    "use strict";
    function containsNewline(key) {
      if (!key)
        return null;
      switch (key.type) {
        case "alias":
        case "scalar":
        case "double-quoted-scalar":
        case "single-quoted-scalar":
          if (key.source.includes("\n"))
            return true;
          if (key.end) {
            for (const st of key.end)
              if (st.type === "newline")
                return true;
          }
          return false;
        case "flow-collection":
          for (const it of key.items) {
            for (const st of it.start)
              if (st.type === "newline")
                return true;
            if (it.sep) {
              for (const st of it.sep)
                if (st.type === "newline")
                  return true;
            }
            if (containsNewline(it.key) || containsNewline(it.value))
              return true;
          }
          return false;
        default:
          return true;
      }
    }
    exports2.containsNewline = containsNewline;
  }
});

// ../../node_modules/yaml/dist/compose/util-flow-indent-check.js
var require_util_flow_indent_check = __commonJS({
  "../../node_modules/yaml/dist/compose/util-flow-indent-check.js"(exports2) {
    "use strict";
    var utilContainsNewline = require_util_contains_newline();
    function flowIndentCheck(indent, fc, onError2) {
      if (fc?.type === "flow-collection") {
        const end = fc.end[0];
        if (end.indent === indent && (end.source === "]" || end.source === "}") && utilContainsNewline.containsNewline(fc)) {
          const msg = "Flow end indicator should be more indented than parent";
          onError2(end, "BAD_INDENT", msg, true);
        }
      }
    }
    exports2.flowIndentCheck = flowIndentCheck;
  }
});

// ../../node_modules/yaml/dist/compose/util-map-includes.js
var require_util_map_includes = __commonJS({
  "../../node_modules/yaml/dist/compose/util-map-includes.js"(exports2) {
    "use strict";
    var identity = require_identity();
    function mapIncludes(ctx, items, search) {
      const { uniqueKeys } = ctx.options;
      if (uniqueKeys === false)
        return false;
      const isEqual = typeof uniqueKeys === "function" ? uniqueKeys : (a, b) => a === b || identity.isScalar(a) && identity.isScalar(b) && a.value === b.value;
      return items.some((pair) => isEqual(pair.key, search));
    }
    exports2.mapIncludes = mapIncludes;
  }
});

// ../../node_modules/yaml/dist/compose/resolve-block-map.js
var require_resolve_block_map = __commonJS({
  "../../node_modules/yaml/dist/compose/resolve-block-map.js"(exports2) {
    "use strict";
    var Pair = require_Pair();
    var YAMLMap = require_YAMLMap();
    var resolveProps = require_resolve_props();
    var utilContainsNewline = require_util_contains_newline();
    var utilFlowIndentCheck = require_util_flow_indent_check();
    var utilMapIncludes = require_util_map_includes();
    var startColMsg = "All mapping items must start at the same column";
    function resolveBlockMap({ composeNode, composeEmptyNode }, ctx, bm, onError2, tag) {
      const NodeClass = tag?.nodeClass ?? YAMLMap.YAMLMap;
      const map = new NodeClass(ctx.schema);
      if (ctx.atRoot)
        ctx.atRoot = false;
      let offset = bm.offset;
      let commentEnd = null;
      for (const collItem of bm.items) {
        const { start, key, sep: sep4, value } = collItem;
        const keyProps = resolveProps.resolveProps(start, {
          indicator: "explicit-key-ind",
          next: key ?? sep4?.[0],
          offset,
          onError: onError2,
          parentIndent: bm.indent,
          startOnNewline: true
        });
        const implicitKey = !keyProps.found;
        if (implicitKey) {
          if (key) {
            if (key.type === "block-seq")
              onError2(offset, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key");
            else if ("indent" in key && key.indent !== bm.indent)
              onError2(offset, "BAD_INDENT", startColMsg);
          }
          if (!keyProps.anchor && !keyProps.tag && !sep4) {
            commentEnd = keyProps.end;
            if (keyProps.comment) {
              if (map.comment)
                map.comment += "\n" + keyProps.comment;
              else
                map.comment = keyProps.comment;
            }
            continue;
          }
          if (keyProps.newlineAfterProp || utilContainsNewline.containsNewline(key)) {
            onError2(key ?? start[start.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
          }
        } else if (keyProps.found?.indent !== bm.indent) {
          onError2(offset, "BAD_INDENT", startColMsg);
        }
        ctx.atKey = true;
        const keyStart = keyProps.end;
        const keyNode = key ? composeNode(ctx, key, keyProps, onError2) : composeEmptyNode(ctx, keyStart, start, null, keyProps, onError2);
        if (ctx.schema.compat)
          utilFlowIndentCheck.flowIndentCheck(bm.indent, key, onError2);
        ctx.atKey = false;
        if (utilMapIncludes.mapIncludes(ctx, map.items, keyNode))
          onError2(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
        const valueProps = resolveProps.resolveProps(sep4 ?? [], {
          indicator: "map-value-ind",
          next: value,
          offset: keyNode.range[2],
          onError: onError2,
          parentIndent: bm.indent,
          startOnNewline: !key || key.type === "block-scalar"
        });
        offset = valueProps.end;
        if (valueProps.found) {
          if (implicitKey) {
            if (value?.type === "block-map" && !valueProps.hasNewline)
              onError2(offset, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings");
            if (ctx.options.strict && keyProps.start < valueProps.found.offset - 1024)
              onError2(keyNode.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key");
          }
          const valueNode = value ? composeNode(ctx, value, valueProps, onError2) : composeEmptyNode(ctx, offset, sep4, null, valueProps, onError2);
          if (ctx.schema.compat)
            utilFlowIndentCheck.flowIndentCheck(bm.indent, value, onError2);
          offset = valueNode.range[2];
          const pair = new Pair.Pair(keyNode, valueNode);
          if (ctx.options.keepSourceTokens)
            pair.srcToken = collItem;
          map.items.push(pair);
        } else {
          if (implicitKey)
            onError2(keyNode.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values");
          if (valueProps.comment) {
            if (keyNode.comment)
              keyNode.comment += "\n" + valueProps.comment;
            else
              keyNode.comment = valueProps.comment;
          }
          const pair = new Pair.Pair(keyNode);
          if (ctx.options.keepSourceTokens)
            pair.srcToken = collItem;
          map.items.push(pair);
        }
      }
      if (commentEnd && commentEnd < offset)
        onError2(commentEnd, "IMPOSSIBLE", "Map comment with trailing content");
      map.range = [bm.offset, offset, commentEnd ?? offset];
      return map;
    }
    exports2.resolveBlockMap = resolveBlockMap;
  }
});

// ../../node_modules/yaml/dist/compose/resolve-block-seq.js
var require_resolve_block_seq = __commonJS({
  "../../node_modules/yaml/dist/compose/resolve-block-seq.js"(exports2) {
    "use strict";
    var YAMLSeq = require_YAMLSeq();
    var resolveProps = require_resolve_props();
    var utilFlowIndentCheck = require_util_flow_indent_check();
    function resolveBlockSeq({ composeNode, composeEmptyNode }, ctx, bs, onError2, tag) {
      const NodeClass = tag?.nodeClass ?? YAMLSeq.YAMLSeq;
      const seq = new NodeClass(ctx.schema);
      if (ctx.atRoot)
        ctx.atRoot = false;
      if (ctx.atKey)
        ctx.atKey = false;
      let offset = bs.offset;
      let commentEnd = null;
      for (const { start, value } of bs.items) {
        const props = resolveProps.resolveProps(start, {
          indicator: "seq-item-ind",
          next: value,
          offset,
          onError: onError2,
          parentIndent: bs.indent,
          startOnNewline: true
        });
        if (!props.found) {
          if (props.anchor || props.tag || value) {
            if (value?.type === "block-seq")
              onError2(props.end, "BAD_INDENT", "All sequence items must start at the same column");
            else
              onError2(offset, "MISSING_CHAR", "Sequence item without - indicator");
          } else {
            commentEnd = props.end;
            if (props.comment)
              seq.comment = props.comment;
            continue;
          }
        }
        const node = value ? composeNode(ctx, value, props, onError2) : composeEmptyNode(ctx, props.end, start, null, props, onError2);
        if (ctx.schema.compat)
          utilFlowIndentCheck.flowIndentCheck(bs.indent, value, onError2);
        offset = node.range[2];
        seq.items.push(node);
      }
      seq.range = [bs.offset, offset, commentEnd ?? offset];
      return seq;
    }
    exports2.resolveBlockSeq = resolveBlockSeq;
  }
});

// ../../node_modules/yaml/dist/compose/resolve-end.js
var require_resolve_end = __commonJS({
  "../../node_modules/yaml/dist/compose/resolve-end.js"(exports2) {
    "use strict";
    function resolveEnd(end, offset, reqSpace, onError2) {
      let comment = "";
      if (end) {
        let hasSpace = false;
        let sep4 = "";
        for (const token of end) {
          const { source, type } = token;
          switch (type) {
            case "space":
              hasSpace = true;
              break;
            case "comment": {
              if (reqSpace && !hasSpace)
                onError2(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
              const cb = source.substring(1) || " ";
              if (!comment)
                comment = cb;
              else
                comment += sep4 + cb;
              sep4 = "";
              break;
            }
            case "newline":
              if (comment)
                sep4 += source;
              hasSpace = true;
              break;
            default:
              onError2(token, "UNEXPECTED_TOKEN", `Unexpected ${type} at node end`);
          }
          offset += source.length;
        }
      }
      return { comment, offset };
    }
    exports2.resolveEnd = resolveEnd;
  }
});

// ../../node_modules/yaml/dist/compose/resolve-flow-collection.js
var require_resolve_flow_collection = __commonJS({
  "../../node_modules/yaml/dist/compose/resolve-flow-collection.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var Pair = require_Pair();
    var YAMLMap = require_YAMLMap();
    var YAMLSeq = require_YAMLSeq();
    var resolveEnd = require_resolve_end();
    var resolveProps = require_resolve_props();
    var utilContainsNewline = require_util_contains_newline();
    var utilMapIncludes = require_util_map_includes();
    var blockMsg = "Block collections are not allowed within flow collections";
    var isBlock = (token) => token && (token.type === "block-map" || token.type === "block-seq");
    function resolveFlowCollection({ composeNode, composeEmptyNode }, ctx, fc, onError2, tag) {
      const isMap = fc.start.source === "{";
      const fcName = isMap ? "flow map" : "flow sequence";
      const NodeClass = tag?.nodeClass ?? (isMap ? YAMLMap.YAMLMap : YAMLSeq.YAMLSeq);
      const coll = new NodeClass(ctx.schema);
      coll.flow = true;
      const atRoot = ctx.atRoot;
      if (atRoot)
        ctx.atRoot = false;
      if (ctx.atKey)
        ctx.atKey = false;
      let offset = fc.offset + fc.start.source.length;
      for (let i = 0; i < fc.items.length; ++i) {
        const collItem = fc.items[i];
        const { start, key, sep: sep4, value } = collItem;
        const props = resolveProps.resolveProps(start, {
          flow: fcName,
          indicator: "explicit-key-ind",
          next: key ?? sep4?.[0],
          offset,
          onError: onError2,
          parentIndent: fc.indent,
          startOnNewline: false
        });
        if (!props.found) {
          if (!props.anchor && !props.tag && !sep4 && !value) {
            if (i === 0 && props.comma)
              onError2(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
            else if (i < fc.items.length - 1)
              onError2(props.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${fcName}`);
            if (props.comment) {
              if (coll.comment)
                coll.comment += "\n" + props.comment;
              else
                coll.comment = props.comment;
            }
            offset = props.end;
            continue;
          }
          if (!isMap && ctx.options.strict && utilContainsNewline.containsNewline(key))
            onError2(
              key,
              // checked by containsNewline()
              "MULTILINE_IMPLICIT_KEY",
              "Implicit keys of flow sequence pairs need to be on a single line"
            );
        }
        if (i === 0) {
          if (props.comma)
            onError2(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
        } else {
          if (!props.comma)
            onError2(props.start, "MISSING_CHAR", `Missing , between ${fcName} items`);
          if (props.comment) {
            let prevItemComment = "";
            loop: for (const st of start) {
              switch (st.type) {
                case "comma":
                case "space":
                  break;
                case "comment":
                  prevItemComment = st.source.substring(1);
                  break loop;
                default:
                  break loop;
              }
            }
            if (prevItemComment) {
              let prev = coll.items[coll.items.length - 1];
              if (identity.isPair(prev))
                prev = prev.value ?? prev.key;
              if (prev.comment)
                prev.comment += "\n" + prevItemComment;
              else
                prev.comment = prevItemComment;
              props.comment = props.comment.substring(prevItemComment.length + 1);
            }
          }
        }
        if (!isMap && !sep4 && !props.found) {
          const valueNode = value ? composeNode(ctx, value, props, onError2) : composeEmptyNode(ctx, props.end, sep4, null, props, onError2);
          coll.items.push(valueNode);
          offset = valueNode.range[2];
          if (isBlock(value))
            onError2(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
        } else {
          ctx.atKey = true;
          const keyStart = props.end;
          const keyNode = key ? composeNode(ctx, key, props, onError2) : composeEmptyNode(ctx, keyStart, start, null, props, onError2);
          if (isBlock(key))
            onError2(keyNode.range, "BLOCK_IN_FLOW", blockMsg);
          ctx.atKey = false;
          const valueProps = resolveProps.resolveProps(sep4 ?? [], {
            flow: fcName,
            indicator: "map-value-ind",
            next: value,
            offset: keyNode.range[2],
            onError: onError2,
            parentIndent: fc.indent,
            startOnNewline: false
          });
          if (valueProps.found) {
            if (!isMap && !props.found && ctx.options.strict) {
              if (sep4)
                for (const st of sep4) {
                  if (st === valueProps.found)
                    break;
                  if (st.type === "newline") {
                    onError2(st, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                    break;
                  }
                }
              if (props.start < valueProps.found.offset - 1024)
                onError2(valueProps.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
            }
          } else if (value) {
            if ("source" in value && value.source?.[0] === ":")
              onError2(value, "MISSING_CHAR", `Missing space after : in ${fcName}`);
            else
              onError2(valueProps.start, "MISSING_CHAR", `Missing , or : between ${fcName} items`);
          }
          const valueNode = value ? composeNode(ctx, value, valueProps, onError2) : valueProps.found ? composeEmptyNode(ctx, valueProps.end, sep4, null, valueProps, onError2) : null;
          if (valueNode) {
            if (isBlock(value))
              onError2(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
          } else if (valueProps.comment) {
            if (keyNode.comment)
              keyNode.comment += "\n" + valueProps.comment;
            else
              keyNode.comment = valueProps.comment;
          }
          const pair = new Pair.Pair(keyNode, valueNode);
          if (ctx.options.keepSourceTokens)
            pair.srcToken = collItem;
          if (isMap) {
            const map = coll;
            if (utilMapIncludes.mapIncludes(ctx, map.items, keyNode))
              onError2(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
            map.items.push(pair);
          } else {
            const map = new YAMLMap.YAMLMap(ctx.schema);
            map.flow = true;
            map.items.push(pair);
            const endRange = (valueNode ?? keyNode).range;
            map.range = [keyNode.range[0], endRange[1], endRange[2]];
            coll.items.push(map);
          }
          offset = valueNode ? valueNode.range[2] : valueProps.end;
        }
      }
      const expectedEnd = isMap ? "}" : "]";
      const [ce, ...ee] = fc.end;
      let cePos = offset;
      if (ce?.source === expectedEnd)
        cePos = ce.offset + ce.source.length;
      else {
        const name = fcName[0].toUpperCase() + fcName.substring(1);
        const msg = atRoot ? `${name} must end with a ${expectedEnd}` : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
        onError2(offset, atRoot ? "MISSING_CHAR" : "BAD_INDENT", msg);
        if (ce && ce.source.length !== 1)
          ee.unshift(ce);
      }
      if (ee.length > 0) {
        const end = resolveEnd.resolveEnd(ee, cePos, ctx.options.strict, onError2);
        if (end.comment) {
          if (coll.comment)
            coll.comment += "\n" + end.comment;
          else
            coll.comment = end.comment;
        }
        coll.range = [fc.offset, cePos, end.offset];
      } else {
        coll.range = [fc.offset, cePos, cePos];
      }
      return coll;
    }
    exports2.resolveFlowCollection = resolveFlowCollection;
  }
});

// ../../node_modules/yaml/dist/compose/compose-collection.js
var require_compose_collection = __commonJS({
  "../../node_modules/yaml/dist/compose/compose-collection.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var Scalar = require_Scalar();
    var YAMLMap = require_YAMLMap();
    var YAMLSeq = require_YAMLSeq();
    var resolveBlockMap = require_resolve_block_map();
    var resolveBlockSeq = require_resolve_block_seq();
    var resolveFlowCollection = require_resolve_flow_collection();
    function resolveCollection(CN, ctx, token, onError2, tagName, tag) {
      const coll = token.type === "block-map" ? resolveBlockMap.resolveBlockMap(CN, ctx, token, onError2, tag) : token.type === "block-seq" ? resolveBlockSeq.resolveBlockSeq(CN, ctx, token, onError2, tag) : resolveFlowCollection.resolveFlowCollection(CN, ctx, token, onError2, tag);
      const Coll = coll.constructor;
      if (tagName === "!" || tagName === Coll.tagName) {
        coll.tag = Coll.tagName;
        return coll;
      }
      if (tagName)
        coll.tag = tagName;
      return coll;
    }
    function composeCollection(CN, ctx, token, props, onError2) {
      const tagToken = props.tag;
      const tagName = !tagToken ? null : ctx.directives.tagName(tagToken.source, (msg) => onError2(tagToken, "TAG_RESOLVE_FAILED", msg));
      if (token.type === "block-seq") {
        const { anchor, newlineAfterProp: nl } = props;
        const lastProp = anchor && tagToken ? anchor.offset > tagToken.offset ? anchor : tagToken : anchor ?? tagToken;
        if (lastProp && (!nl || nl.offset < lastProp.offset)) {
          const message = "Missing newline after block sequence props";
          onError2(lastProp, "MISSING_CHAR", message);
        }
      }
      const expType = token.type === "block-map" ? "map" : token.type === "block-seq" ? "seq" : token.start.source === "{" ? "map" : "seq";
      if (!tagToken || !tagName || tagName === "!" || tagName === YAMLMap.YAMLMap.tagName && expType === "map" || tagName === YAMLSeq.YAMLSeq.tagName && expType === "seq") {
        return resolveCollection(CN, ctx, token, onError2, tagName);
      }
      let tag = ctx.schema.tags.find((t) => t.tag === tagName && t.collection === expType);
      if (!tag) {
        const kt = ctx.schema.knownTags[tagName];
        if (kt?.collection === expType) {
          ctx.schema.tags.push(Object.assign({}, kt, { default: false }));
          tag = kt;
        } else {
          if (kt) {
            onError2(tagToken, "BAD_COLLECTION_TYPE", `${kt.tag} used for ${expType} collection, but expects ${kt.collection ?? "scalar"}`, true);
          } else {
            onError2(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, true);
          }
          return resolveCollection(CN, ctx, token, onError2, tagName);
        }
      }
      const coll = resolveCollection(CN, ctx, token, onError2, tagName, tag);
      const res = tag.resolve?.(coll, (msg) => onError2(tagToken, "TAG_RESOLVE_FAILED", msg), ctx.options) ?? coll;
      const node = identity.isNode(res) ? res : new Scalar.Scalar(res);
      node.range = coll.range;
      node.tag = tagName;
      if (tag?.format)
        node.format = tag.format;
      return node;
    }
    exports2.composeCollection = composeCollection;
  }
});

// ../../node_modules/yaml/dist/compose/resolve-block-scalar.js
var require_resolve_block_scalar = __commonJS({
  "../../node_modules/yaml/dist/compose/resolve-block-scalar.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar();
    function resolveBlockScalar(ctx, scalar, onError2) {
      const start = scalar.offset;
      const header = parseBlockScalarHeader(scalar, ctx.options.strict, onError2);
      if (!header)
        return { value: "", type: null, comment: "", range: [start, start, start] };
      const type = header.mode === ">" ? Scalar.Scalar.BLOCK_FOLDED : Scalar.Scalar.BLOCK_LITERAL;
      const lines = scalar.source ? splitLines(scalar.source) : [];
      let chompStart = lines.length;
      for (let i = lines.length - 1; i >= 0; --i) {
        const content = lines[i][1];
        if (content === "" || content === "\r")
          chompStart = i;
        else
          break;
      }
      if (chompStart === 0) {
        const value2 = header.chomp === "+" && lines.length > 0 ? "\n".repeat(Math.max(1, lines.length - 1)) : "";
        let end2 = start + header.length;
        if (scalar.source)
          end2 += scalar.source.length;
        return { value: value2, type, comment: header.comment, range: [start, end2, end2] };
      }
      let trimIndent = scalar.indent + header.indent;
      let offset = scalar.offset + header.length;
      let contentStart = 0;
      for (let i = 0; i < chompStart; ++i) {
        const [indent, content] = lines[i];
        if (content === "" || content === "\r") {
          if (header.indent === 0 && indent.length > trimIndent)
            trimIndent = indent.length;
        } else {
          if (indent.length < trimIndent) {
            const message = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
            onError2(offset + indent.length, "MISSING_CHAR", message);
          }
          if (header.indent === 0)
            trimIndent = indent.length;
          contentStart = i;
          if (trimIndent === 0 && !ctx.atRoot) {
            const message = "Block scalar values in collections must be indented";
            onError2(offset, "BAD_INDENT", message);
          }
          break;
        }
        offset += indent.length + content.length + 1;
      }
      for (let i = lines.length - 1; i >= chompStart; --i) {
        if (lines[i][0].length > trimIndent)
          chompStart = i + 1;
      }
      let value = "";
      let sep4 = "";
      let prevMoreIndented = false;
      for (let i = 0; i < contentStart; ++i)
        value += lines[i][0].slice(trimIndent) + "\n";
      for (let i = contentStart; i < chompStart; ++i) {
        let [indent, content] = lines[i];
        offset += indent.length + content.length + 1;
        const crlf = content[content.length - 1] === "\r";
        if (crlf)
          content = content.slice(0, -1);
        if (content && indent.length < trimIndent) {
          const src = header.indent ? "explicit indentation indicator" : "first line";
          const message = `Block scalar lines must not be less indented than their ${src}`;
          onError2(offset - content.length - (crlf ? 2 : 1), "BAD_INDENT", message);
          indent = "";
        }
        if (type === Scalar.Scalar.BLOCK_LITERAL) {
          value += sep4 + indent.slice(trimIndent) + content;
          sep4 = "\n";
        } else if (indent.length > trimIndent || content[0] === "	") {
          if (sep4 === " ")
            sep4 = "\n";
          else if (!prevMoreIndented && sep4 === "\n")
            sep4 = "\n\n";
          value += sep4 + indent.slice(trimIndent) + content;
          sep4 = "\n";
          prevMoreIndented = true;
        } else if (content === "") {
          if (sep4 === "\n")
            value += "\n";
          else
            sep4 = "\n";
        } else {
          value += sep4 + content;
          sep4 = " ";
          prevMoreIndented = false;
        }
      }
      switch (header.chomp) {
        case "-":
          break;
        case "+":
          for (let i = chompStart; i < lines.length; ++i)
            value += "\n" + lines[i][0].slice(trimIndent);
          if (value[value.length - 1] !== "\n")
            value += "\n";
          break;
        default:
          value += "\n";
      }
      const end = start + header.length + scalar.source.length;
      return { value, type, comment: header.comment, range: [start, end, end] };
    }
    function parseBlockScalarHeader({ offset, props }, strict, onError2) {
      if (props[0].type !== "block-scalar-header") {
        onError2(props[0], "IMPOSSIBLE", "Block scalar header not found");
        return null;
      }
      const { source } = props[0];
      const mode = source[0];
      let indent = 0;
      let chomp = "";
      let error = -1;
      for (let i = 1; i < source.length; ++i) {
        const ch = source[i];
        if (!chomp && (ch === "-" || ch === "+"))
          chomp = ch;
        else {
          const n = Number(ch);
          if (!indent && n)
            indent = n;
          else if (error === -1)
            error = offset + i;
        }
      }
      if (error !== -1)
        onError2(error, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${source}`);
      let hasSpace = false;
      let comment = "";
      let length = source.length;
      for (let i = 1; i < props.length; ++i) {
        const token = props[i];
        switch (token.type) {
          case "space":
            hasSpace = true;
          // fallthrough
          case "newline":
            length += token.source.length;
            break;
          case "comment":
            if (strict && !hasSpace) {
              const message = "Comments must be separated from other tokens by white space characters";
              onError2(token, "MISSING_CHAR", message);
            }
            length += token.source.length;
            comment = token.source.substring(1);
            break;
          case "error":
            onError2(token, "UNEXPECTED_TOKEN", token.message);
            length += token.source.length;
            break;
          /* istanbul ignore next should not happen */
          default: {
            const message = `Unexpected token in block scalar header: ${token.type}`;
            onError2(token, "UNEXPECTED_TOKEN", message);
            const ts = token.source;
            if (ts && typeof ts === "string")
              length += ts.length;
          }
        }
      }
      return { mode, indent, chomp, comment, length };
    }
    function splitLines(source) {
      const split = source.split(/\n( *)/);
      const first2 = split[0];
      const m = first2.match(/^( *)/);
      const line0 = m?.[1] ? [m[1], first2.slice(m[1].length)] : ["", first2];
      const lines = [line0];
      for (let i = 1; i < split.length; i += 2)
        lines.push([split[i], split[i + 1]]);
      return lines;
    }
    exports2.resolveBlockScalar = resolveBlockScalar;
  }
});

// ../../node_modules/yaml/dist/compose/resolve-flow-scalar.js
var require_resolve_flow_scalar = __commonJS({
  "../../node_modules/yaml/dist/compose/resolve-flow-scalar.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar();
    var resolveEnd = require_resolve_end();
    function resolveFlowScalar(scalar, strict, onError2) {
      const { offset, type, source, end } = scalar;
      let _type;
      let value;
      const _onError = (rel, code, msg) => onError2(offset + rel, code, msg);
      switch (type) {
        case "scalar":
          _type = Scalar.Scalar.PLAIN;
          value = plainValue(source, _onError);
          break;
        case "single-quoted-scalar":
          _type = Scalar.Scalar.QUOTE_SINGLE;
          value = singleQuotedValue(source, _onError);
          break;
        case "double-quoted-scalar":
          _type = Scalar.Scalar.QUOTE_DOUBLE;
          value = doubleQuotedValue(source, _onError);
          break;
        /* istanbul ignore next should not happen */
        default:
          onError2(scalar, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${type}`);
          return {
            value: "",
            type: null,
            comment: "",
            range: [offset, offset + source.length, offset + source.length]
          };
      }
      const valueEnd = offset + source.length;
      const re = resolveEnd.resolveEnd(end, valueEnd, strict, onError2);
      return {
        value,
        type: _type,
        comment: re.comment,
        range: [offset, valueEnd, re.offset]
      };
    }
    function plainValue(source, onError2) {
      let badChar = "";
      switch (source[0]) {
        /* istanbul ignore next should not happen */
        case "	":
          badChar = "a tab character";
          break;
        case ",":
          badChar = "flow indicator character ,";
          break;
        case "%":
          badChar = "directive indicator character %";
          break;
        case "|":
        case ">": {
          badChar = `block scalar indicator ${source[0]}`;
          break;
        }
        case "@":
        case "`": {
          badChar = `reserved character ${source[0]}`;
          break;
        }
      }
      if (badChar)
        onError2(0, "BAD_SCALAR_START", `Plain value cannot start with ${badChar}`);
      return foldLines(source);
    }
    function singleQuotedValue(source, onError2) {
      if (source[source.length - 1] !== "'" || source.length === 1)
        onError2(source.length, "MISSING_CHAR", "Missing closing 'quote");
      return foldLines(source.slice(1, -1)).replace(/''/g, "'");
    }
    function foldLines(source) {
      let first2, line;
      try {
        first2 = new RegExp("(.*?)(?<![ 	])[ 	]*\r?\n", "sy");
        line = new RegExp("[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?\n", "sy");
      } catch {
        first2 = /(.*?)[ \t]*\r?\n/sy;
        line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
      }
      let match = first2.exec(source);
      if (!match)
        return source;
      let res = match[1];
      let sep4 = " ";
      let pos = first2.lastIndex;
      line.lastIndex = pos;
      while (match = line.exec(source)) {
        if (match[1] === "") {
          if (sep4 === "\n")
            res += sep4;
          else
            sep4 = "\n";
        } else {
          res += sep4 + match[1];
          sep4 = " ";
        }
        pos = line.lastIndex;
      }
      const last2 = /[ \t]*(.*)/sy;
      last2.lastIndex = pos;
      match = last2.exec(source);
      return res + sep4 + (match?.[1] ?? "");
    }
    function doubleQuotedValue(source, onError2) {
      let res = "";
      for (let i = 1; i < source.length - 1; ++i) {
        const ch = source[i];
        if (ch === "\r" && source[i + 1] === "\n")
          continue;
        if (ch === "\n") {
          const { fold, offset } = foldNewline(source, i);
          res += fold;
          i = offset;
        } else if (ch === "\\") {
          let next = source[++i];
          const cc = escapeCodes[next];
          if (cc)
            res += cc;
          else if (next === "\n") {
            next = source[i + 1];
            while (next === " " || next === "	")
              next = source[++i + 1];
          } else if (next === "\r" && source[i + 1] === "\n") {
            next = source[++i + 1];
            while (next === " " || next === "	")
              next = source[++i + 1];
          } else if (next === "x" || next === "u" || next === "U") {
            const length = { x: 2, u: 4, U: 8 }[next];
            res += parseCharCode(source, i + 1, length, onError2);
            i += length;
          } else {
            const raw = source.substr(i - 1, 2);
            onError2(i - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
            res += raw;
          }
        } else if (ch === " " || ch === "	") {
          const wsStart = i;
          let next = source[i + 1];
          while (next === " " || next === "	")
            next = source[++i + 1];
          if (next !== "\n" && !(next === "\r" && source[i + 2] === "\n"))
            res += i > wsStart ? source.slice(wsStart, i + 1) : ch;
        } else {
          res += ch;
        }
      }
      if (source[source.length - 1] !== '"' || source.length === 1)
        onError2(source.length, "MISSING_CHAR", 'Missing closing "quote');
      return res;
    }
    function foldNewline(source, offset) {
      let fold = "";
      let ch = source[offset + 1];
      while (ch === " " || ch === "	" || ch === "\n" || ch === "\r") {
        if (ch === "\r" && source[offset + 2] !== "\n")
          break;
        if (ch === "\n")
          fold += "\n";
        offset += 1;
        ch = source[offset + 1];
      }
      if (!fold)
        fold = " ";
      return { fold, offset };
    }
    var escapeCodes = {
      "0": "\0",
      // null character
      a: "\x07",
      // bell character
      b: "\b",
      // backspace
      e: "\x1B",
      // escape character
      f: "\f",
      // form feed
      n: "\n",
      // line feed
      r: "\r",
      // carriage return
      t: "	",
      // horizontal tab
      v: "\v",
      // vertical tab
      N: "\x85",
      // Unicode next line
      _: "\xA0",
      // Unicode non-breaking space
      L: "\u2028",
      // Unicode line separator
      P: "\u2029",
      // Unicode paragraph separator
      " ": " ",
      '"': '"',
      "/": "/",
      "\\": "\\",
      "	": "	"
    };
    function parseCharCode(source, offset, length, onError2) {
      const cc = source.substr(offset, length);
      const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
      const code = ok ? parseInt(cc, 16) : NaN;
      if (isNaN(code)) {
        const raw = source.substr(offset - 2, length + 2);
        onError2(offset - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
        return raw;
      }
      return String.fromCodePoint(code);
    }
    exports2.resolveFlowScalar = resolveFlowScalar;
  }
});

// ../../node_modules/yaml/dist/compose/compose-scalar.js
var require_compose_scalar = __commonJS({
  "../../node_modules/yaml/dist/compose/compose-scalar.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var Scalar = require_Scalar();
    var resolveBlockScalar = require_resolve_block_scalar();
    var resolveFlowScalar = require_resolve_flow_scalar();
    function composeScalar(ctx, token, tagToken, onError2) {
      const { value, type, comment, range } = token.type === "block-scalar" ? resolveBlockScalar.resolveBlockScalar(ctx, token, onError2) : resolveFlowScalar.resolveFlowScalar(token, ctx.options.strict, onError2);
      const tagName = tagToken ? ctx.directives.tagName(tagToken.source, (msg) => onError2(tagToken, "TAG_RESOLVE_FAILED", msg)) : null;
      let tag;
      if (ctx.options.stringKeys && ctx.atKey) {
        tag = ctx.schema[identity.SCALAR];
      } else if (tagName)
        tag = findScalarTagByName(ctx.schema, value, tagName, tagToken, onError2);
      else if (token.type === "scalar")
        tag = findScalarTagByTest(ctx, value, token, onError2);
      else
        tag = ctx.schema[identity.SCALAR];
      let scalar;
      try {
        const res = tag.resolve(value, (msg) => onError2(tagToken ?? token, "TAG_RESOLVE_FAILED", msg), ctx.options);
        scalar = identity.isScalar(res) ? res : new Scalar.Scalar(res);
      } catch (error) {
        const msg = error instanceof Error ? error.message : String(error);
        onError2(tagToken ?? token, "TAG_RESOLVE_FAILED", msg);
        scalar = new Scalar.Scalar(value);
      }
      scalar.range = range;
      scalar.source = value;
      if (type)
        scalar.type = type;
      if (tagName)
        scalar.tag = tagName;
      if (tag.format)
        scalar.format = tag.format;
      if (comment)
        scalar.comment = comment;
      return scalar;
    }
    function findScalarTagByName(schema, value, tagName, tagToken, onError2) {
      if (tagName === "!")
        return schema[identity.SCALAR];
      const matchWithTest = [];
      for (const tag of schema.tags) {
        if (!tag.collection && tag.tag === tagName) {
          if (tag.default && tag.test)
            matchWithTest.push(tag);
          else
            return tag;
        }
      }
      for (const tag of matchWithTest)
        if (tag.test?.test(value))
          return tag;
      const kt = schema.knownTags[tagName];
      if (kt && !kt.collection) {
        schema.tags.push(Object.assign({}, kt, { default: false, test: void 0 }));
        return kt;
      }
      onError2(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, tagName !== "tag:yaml.org,2002:str");
      return schema[identity.SCALAR];
    }
    function findScalarTagByTest({ atKey, directives, schema }, value, token, onError2) {
      const tag = schema.tags.find((tag2) => (tag2.default === true || atKey && tag2.default === "key") && tag2.test?.test(value)) || schema[identity.SCALAR];
      if (schema.compat) {
        const compat = schema.compat.find((tag2) => tag2.default && tag2.test?.test(value)) ?? schema[identity.SCALAR];
        if (tag.tag !== compat.tag) {
          const ts = directives.tagString(tag.tag);
          const cs = directives.tagString(compat.tag);
          const msg = `Value may be parsed as either ${ts} or ${cs}`;
          onError2(token, "TAG_RESOLVE_FAILED", msg, true);
        }
      }
      return tag;
    }
    exports2.composeScalar = composeScalar;
  }
});

// ../../node_modules/yaml/dist/compose/util-empty-scalar-position.js
var require_util_empty_scalar_position = __commonJS({
  "../../node_modules/yaml/dist/compose/util-empty-scalar-position.js"(exports2) {
    "use strict";
    function emptyScalarPosition(offset, before, pos) {
      if (before) {
        pos ?? (pos = before.length);
        for (let i = pos - 1; i >= 0; --i) {
          let st = before[i];
          switch (st.type) {
            case "space":
            case "comment":
            case "newline":
              offset -= st.source.length;
              continue;
          }
          st = before[++i];
          while (st?.type === "space") {
            offset += st.source.length;
            st = before[++i];
          }
          break;
        }
      }
      return offset;
    }
    exports2.emptyScalarPosition = emptyScalarPosition;
  }
});

// ../../node_modules/yaml/dist/compose/compose-node.js
var require_compose_node = __commonJS({
  "../../node_modules/yaml/dist/compose/compose-node.js"(exports2) {
    "use strict";
    var Alias = require_Alias();
    var identity = require_identity();
    var composeCollection = require_compose_collection();
    var composeScalar = require_compose_scalar();
    var resolveEnd = require_resolve_end();
    var utilEmptyScalarPosition = require_util_empty_scalar_position();
    var CN = { composeNode, composeEmptyNode };
    function composeNode(ctx, token, props, onError2) {
      const atKey = ctx.atKey;
      const { spaceBefore, comment, anchor, tag } = props;
      let node;
      let isSrcToken = true;
      switch (token.type) {
        case "alias":
          node = composeAlias(ctx, token, onError2);
          if (anchor || tag)
            onError2(token, "ALIAS_PROPS", "An alias node must not specify any properties");
          break;
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
        case "block-scalar":
          node = composeScalar.composeScalar(ctx, token, tag, onError2);
          if (anchor)
            node.anchor = anchor.source.substring(1);
          break;
        case "block-map":
        case "block-seq":
        case "flow-collection":
          node = composeCollection.composeCollection(CN, ctx, token, props, onError2);
          if (anchor)
            node.anchor = anchor.source.substring(1);
          break;
        default: {
          const message = token.type === "error" ? token.message : `Unsupported token (type: ${token.type})`;
          onError2(token, "UNEXPECTED_TOKEN", message);
          node = composeEmptyNode(ctx, token.offset, void 0, null, props, onError2);
          isSrcToken = false;
        }
      }
      if (anchor && node.anchor === "")
        onError2(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
      if (atKey && ctx.options.stringKeys && (!identity.isScalar(node) || typeof node.value !== "string" || node.tag && node.tag !== "tag:yaml.org,2002:str")) {
        const msg = "With stringKeys, all keys must be strings";
        onError2(tag ?? token, "NON_STRING_KEY", msg);
      }
      if (spaceBefore)
        node.spaceBefore = true;
      if (comment) {
        if (token.type === "scalar" && token.source === "")
          node.comment = comment;
        else
          node.commentBefore = comment;
      }
      if (ctx.options.keepSourceTokens && isSrcToken)
        node.srcToken = token;
      return node;
    }
    function composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment, anchor, tag, end }, onError2) {
      const token = {
        type: "scalar",
        offset: utilEmptyScalarPosition.emptyScalarPosition(offset, before, pos),
        indent: -1,
        source: ""
      };
      const node = composeScalar.composeScalar(ctx, token, tag, onError2);
      if (anchor) {
        node.anchor = anchor.source.substring(1);
        if (node.anchor === "")
          onError2(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
      }
      if (spaceBefore)
        node.spaceBefore = true;
      if (comment) {
        node.comment = comment;
        node.range[2] = end;
      }
      return node;
    }
    function composeAlias({ options }, { offset, source, end }, onError2) {
      const alias = new Alias.Alias(source.substring(1));
      if (alias.source === "")
        onError2(offset, "BAD_ALIAS", "Alias cannot be an empty string");
      if (alias.source.endsWith(":"))
        onError2(offset + source.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", true);
      const valueEnd = offset + source.length;
      const re = resolveEnd.resolveEnd(end, valueEnd, options.strict, onError2);
      alias.range = [offset, valueEnd, re.offset];
      if (re.comment)
        alias.comment = re.comment;
      return alias;
    }
    exports2.composeEmptyNode = composeEmptyNode;
    exports2.composeNode = composeNode;
  }
});

// ../../node_modules/yaml/dist/compose/compose-doc.js
var require_compose_doc = __commonJS({
  "../../node_modules/yaml/dist/compose/compose-doc.js"(exports2) {
    "use strict";
    var Document = require_Document();
    var composeNode = require_compose_node();
    var resolveEnd = require_resolve_end();
    var resolveProps = require_resolve_props();
    function composeDoc(options, directives, { offset, start, value, end }, onError2) {
      const opts = Object.assign({ _directives: directives }, options);
      const doc = new Document.Document(void 0, opts);
      const ctx = {
        atKey: false,
        atRoot: true,
        directives: doc.directives,
        options: doc.options,
        schema: doc.schema
      };
      const props = resolveProps.resolveProps(start, {
        indicator: "doc-start",
        next: value ?? end?.[0],
        offset,
        onError: onError2,
        parentIndent: 0,
        startOnNewline: true
      });
      if (props.found) {
        doc.directives.docStart = true;
        if (value && (value.type === "block-map" || value.type === "block-seq") && !props.hasNewline)
          onError2(props.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker");
      }
      doc.contents = value ? composeNode.composeNode(ctx, value, props, onError2) : composeNode.composeEmptyNode(ctx, props.end, start, null, props, onError2);
      const contentEnd = doc.contents.range[2];
      const re = resolveEnd.resolveEnd(end, contentEnd, false, onError2);
      if (re.comment)
        doc.comment = re.comment;
      doc.range = [offset, contentEnd, re.offset];
      return doc;
    }
    exports2.composeDoc = composeDoc;
  }
});

// ../../node_modules/yaml/dist/compose/composer.js
var require_composer = __commonJS({
  "../../node_modules/yaml/dist/compose/composer.js"(exports2) {
    "use strict";
    var node_process = require("process");
    var directives = require_directives();
    var Document = require_Document();
    var errors = require_errors2();
    var identity = require_identity();
    var composeDoc = require_compose_doc();
    var resolveEnd = require_resolve_end();
    function getErrorPos(src) {
      if (typeof src === "number")
        return [src, src + 1];
      if (Array.isArray(src))
        return src.length === 2 ? src : [src[0], src[1]];
      const { offset, source } = src;
      return [offset, offset + (typeof source === "string" ? source.length : 1)];
    }
    function parsePrelude(prelude) {
      let comment = "";
      let atComment = false;
      let afterEmptyLine = false;
      for (let i = 0; i < prelude.length; ++i) {
        const source = prelude[i];
        switch (source[0]) {
          case "#":
            comment += (comment === "" ? "" : afterEmptyLine ? "\n\n" : "\n") + (source.substring(1) || " ");
            atComment = true;
            afterEmptyLine = false;
            break;
          case "%":
            if (prelude[i + 1]?.[0] !== "#")
              i += 1;
            atComment = false;
            break;
          default:
            if (!atComment)
              afterEmptyLine = true;
            atComment = false;
        }
      }
      return { comment, afterEmptyLine };
    }
    var Composer = class {
      constructor(options = {}) {
        this.doc = null;
        this.atDirectives = false;
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
        this.onError = (source, code, message, warning) => {
          const pos = getErrorPos(source);
          if (warning)
            this.warnings.push(new errors.YAMLWarning(pos, code, message));
          else
            this.errors.push(new errors.YAMLParseError(pos, code, message));
        };
        this.directives = new directives.Directives({ version: options.version || "1.2" });
        this.options = options;
      }
      decorate(doc, afterDoc) {
        const { comment, afterEmptyLine } = parsePrelude(this.prelude);
        if (comment) {
          const dc = doc.contents;
          if (afterDoc) {
            doc.comment = doc.comment ? `${doc.comment}
${comment}` : comment;
          } else if (afterEmptyLine || doc.directives.docStart || !dc) {
            doc.commentBefore = comment;
          } else if (identity.isCollection(dc) && !dc.flow && dc.items.length > 0) {
            let it = dc.items[0];
            if (identity.isPair(it))
              it = it.key;
            const cb = it.commentBefore;
            it.commentBefore = cb ? `${comment}
${cb}` : comment;
          } else {
            const cb = dc.commentBefore;
            dc.commentBefore = cb ? `${comment}
${cb}` : comment;
          }
        }
        if (afterDoc) {
          Array.prototype.push.apply(doc.errors, this.errors);
          Array.prototype.push.apply(doc.warnings, this.warnings);
        } else {
          doc.errors = this.errors;
          doc.warnings = this.warnings;
        }
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
      }
      /**
       * Current stream status information.
       *
       * Mostly useful at the end of input for an empty stream.
       */
      streamInfo() {
        return {
          comment: parsePrelude(this.prelude).comment,
          directives: this.directives,
          errors: this.errors,
          warnings: this.warnings
        };
      }
      /**
       * Compose tokens into documents.
       *
       * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
       * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
       */
      *compose(tokens, forceDoc = false, endOffset = -1) {
        for (const token of tokens)
          yield* this.next(token);
        yield* this.end(forceDoc, endOffset);
      }
      /** Advance the composer by one CST token. */
      *next(token) {
        if (node_process.env.LOG_STREAM)
          console.dir(token, { depth: null });
        switch (token.type) {
          case "directive":
            this.directives.add(token.source, (offset, message, warning) => {
              const pos = getErrorPos(token);
              pos[0] += offset;
              this.onError(pos, "BAD_DIRECTIVE", message, warning);
            });
            this.prelude.push(token.source);
            this.atDirectives = true;
            break;
          case "document": {
            const doc = composeDoc.composeDoc(this.options, this.directives, token, this.onError);
            if (this.atDirectives && !doc.directives.docStart)
              this.onError(token, "MISSING_CHAR", "Missing directives-end/doc-start indicator line");
            this.decorate(doc, false);
            if (this.doc)
              yield this.doc;
            this.doc = doc;
            this.atDirectives = false;
            break;
          }
          case "byte-order-mark":
          case "space":
            break;
          case "comment":
          case "newline":
            this.prelude.push(token.source);
            break;
          case "error": {
            const msg = token.source ? `${token.message}: ${JSON.stringify(token.source)}` : token.message;
            const error = new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg);
            if (this.atDirectives || !this.doc)
              this.errors.push(error);
            else
              this.doc.errors.push(error);
            break;
          }
          case "doc-end": {
            if (!this.doc) {
              const msg = "Unexpected doc-end without preceding document";
              this.errors.push(new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg));
              break;
            }
            this.doc.directives.docEnd = true;
            const end = resolveEnd.resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
            this.decorate(this.doc, true);
            if (end.comment) {
              const dc = this.doc.comment;
              this.doc.comment = dc ? `${dc}
${end.comment}` : end.comment;
            }
            this.doc.range[2] = end.offset;
            break;
          }
          default:
            this.errors.push(new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", `Unsupported token ${token.type}`));
        }
      }
      /**
       * Call at end of input to yield any remaining document.
       *
       * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
       * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
       */
      *end(forceDoc = false, endOffset = -1) {
        if (this.doc) {
          this.decorate(this.doc, true);
          yield this.doc;
          this.doc = null;
        } else if (forceDoc) {
          const opts = Object.assign({ _directives: this.directives }, this.options);
          const doc = new Document.Document(void 0, opts);
          if (this.atDirectives)
            this.onError(endOffset, "MISSING_CHAR", "Missing directives-end indicator line");
          doc.range = [0, endOffset, endOffset];
          this.decorate(doc, false);
          yield doc;
        }
      }
    };
    exports2.Composer = Composer;
  }
});

// ../../node_modules/yaml/dist/parse/cst-scalar.js
var require_cst_scalar = __commonJS({
  "../../node_modules/yaml/dist/parse/cst-scalar.js"(exports2) {
    "use strict";
    var resolveBlockScalar = require_resolve_block_scalar();
    var resolveFlowScalar = require_resolve_flow_scalar();
    var errors = require_errors2();
    var stringifyString = require_stringifyString();
    function resolveAsScalar(token, strict = true, onError2) {
      if (token) {
        const _onError = (pos, code, message) => {
          const offset = typeof pos === "number" ? pos : Array.isArray(pos) ? pos[0] : pos.offset;
          if (onError2)
            onError2(offset, code, message);
          else
            throw new errors.YAMLParseError([offset, offset + 1], code, message);
        };
        switch (token.type) {
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar":
            return resolveFlowScalar.resolveFlowScalar(token, strict, _onError);
          case "block-scalar":
            return resolveBlockScalar.resolveBlockScalar({ options: { strict } }, token, _onError);
        }
      }
      return null;
    }
    function createScalarToken(value, context) {
      const { implicitKey = false, indent, inFlow = false, offset = -1, type = "PLAIN" } = context;
      const source = stringifyString.stringifyString({ type, value }, {
        implicitKey,
        indent: indent > 0 ? " ".repeat(indent) : "",
        inFlow,
        options: { blockQuote: true, lineWidth: -1 }
      });
      const end = context.end ?? [
        { type: "newline", offset: -1, indent, source: "\n" }
      ];
      switch (source[0]) {
        case "|":
        case ">": {
          const he = source.indexOf("\n");
          const head = source.substring(0, he);
          const body = source.substring(he + 1) + "\n";
          const props = [
            { type: "block-scalar-header", offset, indent, source: head }
          ];
          if (!addEndtoBlockProps(props, end))
            props.push({ type: "newline", offset: -1, indent, source: "\n" });
          return { type: "block-scalar", offset, indent, props, source: body };
        }
        case '"':
          return { type: "double-quoted-scalar", offset, indent, source, end };
        case "'":
          return { type: "single-quoted-scalar", offset, indent, source, end };
        default:
          return { type: "scalar", offset, indent, source, end };
      }
    }
    function setScalarValue(token, value, context = {}) {
      let { afterKey = false, implicitKey = false, inFlow = false, type } = context;
      let indent = "indent" in token ? token.indent : null;
      if (afterKey && typeof indent === "number")
        indent += 2;
      if (!type)
        switch (token.type) {
          case "single-quoted-scalar":
            type = "QUOTE_SINGLE";
            break;
          case "double-quoted-scalar":
            type = "QUOTE_DOUBLE";
            break;
          case "block-scalar": {
            const header = token.props[0];
            if (header.type !== "block-scalar-header")
              throw new Error("Invalid block scalar header");
            type = header.source[0] === ">" ? "BLOCK_FOLDED" : "BLOCK_LITERAL";
            break;
          }
          default:
            type = "PLAIN";
        }
      const source = stringifyString.stringifyString({ type, value }, {
        implicitKey: implicitKey || indent === null,
        indent: indent !== null && indent > 0 ? " ".repeat(indent) : "",
        inFlow,
        options: { blockQuote: true, lineWidth: -1 }
      });
      switch (source[0]) {
        case "|":
        case ">":
          setBlockScalarValue(token, source);
          break;
        case '"':
          setFlowScalarValue(token, source, "double-quoted-scalar");
          break;
        case "'":
          setFlowScalarValue(token, source, "single-quoted-scalar");
          break;
        default:
          setFlowScalarValue(token, source, "scalar");
      }
    }
    function setBlockScalarValue(token, source) {
      const he = source.indexOf("\n");
      const head = source.substring(0, he);
      const body = source.substring(he + 1) + "\n";
      if (token.type === "block-scalar") {
        const header = token.props[0];
        if (header.type !== "block-scalar-header")
          throw new Error("Invalid block scalar header");
        header.source = head;
        token.source = body;
      } else {
        const { offset } = token;
        const indent = "indent" in token ? token.indent : -1;
        const props = [
          { type: "block-scalar-header", offset, indent, source: head }
        ];
        if (!addEndtoBlockProps(props, "end" in token ? token.end : void 0))
          props.push({ type: "newline", offset: -1, indent, source: "\n" });
        for (const key of Object.keys(token))
          if (key !== "type" && key !== "offset")
            delete token[key];
        Object.assign(token, { type: "block-scalar", indent, props, source: body });
      }
    }
    function addEndtoBlockProps(props, end) {
      if (end)
        for (const st of end)
          switch (st.type) {
            case "space":
            case "comment":
              props.push(st);
              break;
            case "newline":
              props.push(st);
              return true;
          }
      return false;
    }
    function setFlowScalarValue(token, source, type) {
      switch (token.type) {
        case "scalar":
        case "double-quoted-scalar":
        case "single-quoted-scalar":
          token.type = type;
          token.source = source;
          break;
        case "block-scalar": {
          const end = token.props.slice(1);
          let oa = source.length;
          if (token.props[0].type === "block-scalar-header")
            oa -= token.props[0].source.length;
          for (const tok of end)
            tok.offset += oa;
          delete token.props;
          Object.assign(token, { type, source, end });
          break;
        }
        case "block-map":
        case "block-seq": {
          const offset = token.offset + source.length;
          const nl = { type: "newline", offset, indent: token.indent, source: "\n" };
          delete token.items;
          Object.assign(token, { type, source, end: [nl] });
          break;
        }
        default: {
          const indent = "indent" in token ? token.indent : -1;
          const end = "end" in token && Array.isArray(token.end) ? token.end.filter((st) => st.type === "space" || st.type === "comment" || st.type === "newline") : [];
          for (const key of Object.keys(token))
            if (key !== "type" && key !== "offset")
              delete token[key];
          Object.assign(token, { type, indent, source, end });
        }
      }
    }
    exports2.createScalarToken = createScalarToken;
    exports2.resolveAsScalar = resolveAsScalar;
    exports2.setScalarValue = setScalarValue;
  }
});

// ../../node_modules/yaml/dist/parse/cst-stringify.js
var require_cst_stringify = __commonJS({
  "../../node_modules/yaml/dist/parse/cst-stringify.js"(exports2) {
    "use strict";
    var stringify = (cst) => "type" in cst ? stringifyToken(cst) : stringifyItem(cst);
    function stringifyToken(token) {
      switch (token.type) {
        case "block-scalar": {
          let res = "";
          for (const tok of token.props)
            res += stringifyToken(tok);
          return res + token.source;
        }
        case "block-map":
        case "block-seq": {
          let res = "";
          for (const item of token.items)
            res += stringifyItem(item);
          return res;
        }
        case "flow-collection": {
          let res = token.start.source;
          for (const item of token.items)
            res += stringifyItem(item);
          for (const st of token.end)
            res += st.source;
          return res;
        }
        case "document": {
          let res = stringifyItem(token);
          if (token.end)
            for (const st of token.end)
              res += st.source;
          return res;
        }
        default: {
          let res = token.source;
          if ("end" in token && token.end)
            for (const st of token.end)
              res += st.source;
          return res;
        }
      }
    }
    function stringifyItem({ start, key, sep: sep4, value }) {
      let res = "";
      for (const st of start)
        res += st.source;
      if (key)
        res += stringifyToken(key);
      if (sep4)
        for (const st of sep4)
          res += st.source;
      if (value)
        res += stringifyToken(value);
      return res;
    }
    exports2.stringify = stringify;
  }
});

// ../../node_modules/yaml/dist/parse/cst-visit.js
var require_cst_visit = __commonJS({
  "../../node_modules/yaml/dist/parse/cst-visit.js"(exports2) {
    "use strict";
    var BREAK = /* @__PURE__ */ Symbol("break visit");
    var SKIP = /* @__PURE__ */ Symbol("skip children");
    var REMOVE = /* @__PURE__ */ Symbol("remove item");
    function visit(cst, visitor) {
      if ("type" in cst && cst.type === "document")
        cst = { start: cst.start, value: cst.value };
      _visit(Object.freeze([]), cst, visitor);
    }
    visit.BREAK = BREAK;
    visit.SKIP = SKIP;
    visit.REMOVE = REMOVE;
    visit.itemAtPath = (cst, path11) => {
      let item = cst;
      for (const [field, index] of path11) {
        const tok = item?.[field];
        if (tok && "items" in tok) {
          item = tok.items[index];
        } else
          return void 0;
      }
      return item;
    };
    visit.parentCollection = (cst, path11) => {
      const parent = visit.itemAtPath(cst, path11.slice(0, -1));
      const field = path11[path11.length - 1][0];
      const coll = parent?.[field];
      if (coll && "items" in coll)
        return coll;
      throw new Error("Parent collection not found");
    };
    function _visit(path11, item, visitor) {
      let ctrl = visitor(item, path11);
      if (typeof ctrl === "symbol")
        return ctrl;
      for (const field of ["key", "value"]) {
        const token = item[field];
        if (token && "items" in token) {
          for (let i = 0; i < token.items.length; ++i) {
            const ci = _visit(Object.freeze(path11.concat([[field, i]])), token.items[i], visitor);
            if (typeof ci === "number")
              i = ci - 1;
            else if (ci === BREAK)
              return BREAK;
            else if (ci === REMOVE) {
              token.items.splice(i, 1);
              i -= 1;
            }
          }
          if (typeof ctrl === "function" && field === "key")
            ctrl = ctrl(item, path11);
        }
      }
      return typeof ctrl === "function" ? ctrl(item, path11) : ctrl;
    }
    exports2.visit = visit;
  }
});

// ../../node_modules/yaml/dist/parse/cst.js
var require_cst = __commonJS({
  "../../node_modules/yaml/dist/parse/cst.js"(exports2) {
    "use strict";
    var cstScalar = require_cst_scalar();
    var cstStringify = require_cst_stringify();
    var cstVisit = require_cst_visit();
    var BOM = "\uFEFF";
    var DOCUMENT = "";
    var FLOW_END = "";
    var SCALAR = "";
    var isCollection = (token) => !!token && "items" in token;
    var isScalar = (token) => !!token && (token.type === "scalar" || token.type === "single-quoted-scalar" || token.type === "double-quoted-scalar" || token.type === "block-scalar");
    function prettyToken(token) {
      switch (token) {
        case BOM:
          return "<BOM>";
        case DOCUMENT:
          return "<DOC>";
        case FLOW_END:
          return "<FLOW_END>";
        case SCALAR:
          return "<SCALAR>";
        default:
          return JSON.stringify(token);
      }
    }
    function tokenType(source) {
      switch (source) {
        case BOM:
          return "byte-order-mark";
        case DOCUMENT:
          return "doc-mode";
        case FLOW_END:
          return "flow-error-end";
        case SCALAR:
          return "scalar";
        case "---":
          return "doc-start";
        case "...":
          return "doc-end";
        case "":
        case "\n":
        case "\r\n":
          return "newline";
        case "-":
          return "seq-item-ind";
        case "?":
          return "explicit-key-ind";
        case ":":
          return "map-value-ind";
        case "{":
          return "flow-map-start";
        case "}":
          return "flow-map-end";
        case "[":
          return "flow-seq-start";
        case "]":
          return "flow-seq-end";
        case ",":
          return "comma";
      }
      switch (source[0]) {
        case " ":
        case "	":
          return "space";
        case "#":
          return "comment";
        case "%":
          return "directive-line";
        case "*":
          return "alias";
        case "&":
          return "anchor";
        case "!":
          return "tag";
        case "'":
          return "single-quoted-scalar";
        case '"':
          return "double-quoted-scalar";
        case "|":
        case ">":
          return "block-scalar-header";
      }
      return null;
    }
    exports2.createScalarToken = cstScalar.createScalarToken;
    exports2.resolveAsScalar = cstScalar.resolveAsScalar;
    exports2.setScalarValue = cstScalar.setScalarValue;
    exports2.stringify = cstStringify.stringify;
    exports2.visit = cstVisit.visit;
    exports2.BOM = BOM;
    exports2.DOCUMENT = DOCUMENT;
    exports2.FLOW_END = FLOW_END;
    exports2.SCALAR = SCALAR;
    exports2.isCollection = isCollection;
    exports2.isScalar = isScalar;
    exports2.prettyToken = prettyToken;
    exports2.tokenType = tokenType;
  }
});

// ../../node_modules/yaml/dist/parse/lexer.js
var require_lexer = __commonJS({
  "../../node_modules/yaml/dist/parse/lexer.js"(exports2) {
    "use strict";
    var cst = require_cst();
    function isEmpty(ch) {
      switch (ch) {
        case void 0:
        case " ":
        case "\n":
        case "\r":
        case "	":
          return true;
        default:
          return false;
      }
    }
    var hexDigits = new Set("0123456789ABCDEFabcdef");
    var tagChars = new Set("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()");
    var flowIndicatorChars = new Set(",[]{}");
    var invalidAnchorChars = new Set(" ,[]{}\n\r	");
    var isNotAnchorChar = (ch) => !ch || invalidAnchorChars.has(ch);
    var Lexer = class {
      constructor() {
        this.atEnd = false;
        this.blockScalarIndent = -1;
        this.blockScalarKeep = false;
        this.buffer = "";
        this.flowKey = false;
        this.flowLevel = 0;
        this.indentNext = 0;
        this.indentValue = 0;
        this.lineEndPos = null;
        this.next = null;
        this.pos = 0;
      }
      /**
       * Generate YAML tokens from the `source` string. If `incomplete`,
       * a part of the last line may be left as a buffer for the next call.
       *
       * @returns A generator of lexical tokens
       */
      *lex(source, incomplete = false) {
        if (source) {
          if (typeof source !== "string")
            throw TypeError("source is not a string");
          this.buffer = this.buffer ? this.buffer + source : source;
          this.lineEndPos = null;
        }
        this.atEnd = !incomplete;
        let next = this.next ?? "stream";
        while (next && (incomplete || this.hasChars(1)))
          next = yield* this.parseNext(next);
      }
      atLineEnd() {
        let i = this.pos;
        let ch = this.buffer[i];
        while (ch === " " || ch === "	")
          ch = this.buffer[++i];
        if (!ch || ch === "#" || ch === "\n")
          return true;
        if (ch === "\r")
          return this.buffer[i + 1] === "\n";
        return false;
      }
      charAt(n) {
        return this.buffer[this.pos + n];
      }
      continueScalar(offset) {
        let ch = this.buffer[offset];
        if (this.indentNext > 0) {
          let indent = 0;
          while (ch === " ")
            ch = this.buffer[++indent + offset];
          if (ch === "\r") {
            const next = this.buffer[indent + offset + 1];
            if (next === "\n" || !next && !this.atEnd)
              return offset + indent + 1;
          }
          return ch === "\n" || indent >= this.indentNext || !ch && !this.atEnd ? offset + indent : -1;
        }
        if (ch === "-" || ch === ".") {
          const dt = this.buffer.substr(offset, 3);
          if ((dt === "---" || dt === "...") && isEmpty(this.buffer[offset + 3]))
            return -1;
        }
        return offset;
      }
      getLine() {
        let end = this.lineEndPos;
        if (typeof end !== "number" || end !== -1 && end < this.pos) {
          end = this.buffer.indexOf("\n", this.pos);
          this.lineEndPos = end;
        }
        if (end === -1)
          return this.atEnd ? this.buffer.substring(this.pos) : null;
        if (this.buffer[end - 1] === "\r")
          end -= 1;
        return this.buffer.substring(this.pos, end);
      }
      hasChars(n) {
        return this.pos + n <= this.buffer.length;
      }
      setNext(state) {
        this.buffer = this.buffer.substring(this.pos);
        this.pos = 0;
        this.lineEndPos = null;
        this.next = state;
        return null;
      }
      peek(n) {
        return this.buffer.substr(this.pos, n);
      }
      *parseNext(next) {
        switch (next) {
          case "stream":
            return yield* this.parseStream();
          case "line-start":
            return yield* this.parseLineStart();
          case "block-start":
            return yield* this.parseBlockStart();
          case "doc":
            return yield* this.parseDocument();
          case "flow":
            return yield* this.parseFlowCollection();
          case "quoted-scalar":
            return yield* this.parseQuotedScalar();
          case "block-scalar":
            return yield* this.parseBlockScalar();
          case "plain-scalar":
            return yield* this.parsePlainScalar();
        }
      }
      *parseStream() {
        let line = this.getLine();
        if (line === null)
          return this.setNext("stream");
        if (line[0] === cst.BOM) {
          yield* this.pushCount(1);
          line = line.substring(1);
        }
        if (line[0] === "%") {
          let dirEnd = line.length;
          let cs = line.indexOf("#");
          while (cs !== -1) {
            const ch = line[cs - 1];
            if (ch === " " || ch === "	") {
              dirEnd = cs - 1;
              break;
            } else {
              cs = line.indexOf("#", cs + 1);
            }
          }
          while (true) {
            const ch = line[dirEnd - 1];
            if (ch === " " || ch === "	")
              dirEnd -= 1;
            else
              break;
          }
          const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
          yield* this.pushCount(line.length - n);
          this.pushNewline();
          return "stream";
        }
        if (this.atLineEnd()) {
          const sp = yield* this.pushSpaces(true);
          yield* this.pushCount(line.length - sp);
          yield* this.pushNewline();
          return "stream";
        }
        yield cst.DOCUMENT;
        return yield* this.parseLineStart();
      }
      *parseLineStart() {
        const ch = this.charAt(0);
        if (!ch && !this.atEnd)
          return this.setNext("line-start");
        if (ch === "-" || ch === ".") {
          if (!this.atEnd && !this.hasChars(4))
            return this.setNext("line-start");
          const s = this.peek(3);
          if ((s === "---" || s === "...") && isEmpty(this.charAt(3))) {
            yield* this.pushCount(3);
            this.indentValue = 0;
            this.indentNext = 0;
            return s === "---" ? "doc" : "stream";
          }
        }
        this.indentValue = yield* this.pushSpaces(false);
        if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1)))
          this.indentNext = this.indentValue;
        return yield* this.parseBlockStart();
      }
      *parseBlockStart() {
        const [ch0, ch1] = this.peek(2);
        if (!ch1 && !this.atEnd)
          return this.setNext("block-start");
        if ((ch0 === "-" || ch0 === "?" || ch0 === ":") && isEmpty(ch1)) {
          const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
          this.indentNext = this.indentValue + 1;
          this.indentValue += n;
          return yield* this.parseBlockStart();
        }
        return "doc";
      }
      *parseDocument() {
        yield* this.pushSpaces(true);
        const line = this.getLine();
        if (line === null)
          return this.setNext("doc");
        let n = yield* this.pushIndicators();
        switch (line[n]) {
          case "#":
            yield* this.pushCount(line.length - n);
          // fallthrough
          case void 0:
            yield* this.pushNewline();
            return yield* this.parseLineStart();
          case "{":
          case "[":
            yield* this.pushCount(1);
            this.flowKey = false;
            this.flowLevel = 1;
            return "flow";
          case "}":
          case "]":
            yield* this.pushCount(1);
            return "doc";
          case "*":
            yield* this.pushUntil(isNotAnchorChar);
            return "doc";
          case '"':
          case "'":
            return yield* this.parseQuotedScalar();
          case "|":
          case ">":
            n += yield* this.parseBlockScalarHeader();
            n += yield* this.pushSpaces(true);
            yield* this.pushCount(line.length - n);
            yield* this.pushNewline();
            return yield* this.parseBlockScalar();
          default:
            return yield* this.parsePlainScalar();
        }
      }
      *parseFlowCollection() {
        let nl, sp;
        let indent = -1;
        do {
          nl = yield* this.pushNewline();
          if (nl > 0) {
            sp = yield* this.pushSpaces(false);
            this.indentValue = indent = sp;
          } else {
            sp = 0;
          }
          sp += yield* this.pushSpaces(true);
        } while (nl + sp > 0);
        const line = this.getLine();
        if (line === null)
          return this.setNext("flow");
        if (indent !== -1 && indent < this.indentNext && line[0] !== "#" || indent === 0 && (line.startsWith("---") || line.startsWith("...")) && isEmpty(line[3])) {
          const atFlowEndMarker = indent === this.indentNext - 1 && this.flowLevel === 1 && (line[0] === "]" || line[0] === "}");
          if (!atFlowEndMarker) {
            this.flowLevel = 0;
            yield cst.FLOW_END;
            return yield* this.parseLineStart();
          }
        }
        let n = 0;
        while (line[n] === ",") {
          n += yield* this.pushCount(1);
          n += yield* this.pushSpaces(true);
          this.flowKey = false;
        }
        n += yield* this.pushIndicators();
        switch (line[n]) {
          case void 0:
            return "flow";
          case "#":
            yield* this.pushCount(line.length - n);
            return "flow";
          case "{":
          case "[":
            yield* this.pushCount(1);
            this.flowKey = false;
            this.flowLevel += 1;
            return "flow";
          case "}":
          case "]":
            yield* this.pushCount(1);
            this.flowKey = true;
            this.flowLevel -= 1;
            return this.flowLevel ? "flow" : "doc";
          case "*":
            yield* this.pushUntil(isNotAnchorChar);
            return "flow";
          case '"':
          case "'":
            this.flowKey = true;
            return yield* this.parseQuotedScalar();
          case ":": {
            const next = this.charAt(1);
            if (this.flowKey || isEmpty(next) || next === ",") {
              this.flowKey = false;
              yield* this.pushCount(1);
              yield* this.pushSpaces(true);
              return "flow";
            }
          }
          // fallthrough
          default:
            this.flowKey = false;
            return yield* this.parsePlainScalar();
        }
      }
      *parseQuotedScalar() {
        const quote = this.charAt(0);
        let end = this.buffer.indexOf(quote, this.pos + 1);
        if (quote === "'") {
          while (end !== -1 && this.buffer[end + 1] === "'")
            end = this.buffer.indexOf("'", end + 2);
        } else {
          while (end !== -1) {
            let n = 0;
            while (this.buffer[end - 1 - n] === "\\")
              n += 1;
            if (n % 2 === 0)
              break;
            end = this.buffer.indexOf('"', end + 1);
          }
        }
        const qb = this.buffer.substring(0, end);
        let nl = qb.indexOf("\n", this.pos);
        if (nl !== -1) {
          while (nl !== -1) {
            const cs = this.continueScalar(nl + 1);
            if (cs === -1)
              break;
            nl = qb.indexOf("\n", cs);
          }
          if (nl !== -1) {
            end = nl - (qb[nl - 1] === "\r" ? 2 : 1);
          }
        }
        if (end === -1) {
          if (!this.atEnd)
            return this.setNext("quoted-scalar");
          end = this.buffer.length;
        }
        yield* this.pushToIndex(end + 1, false);
        return this.flowLevel ? "flow" : "doc";
      }
      *parseBlockScalarHeader() {
        this.blockScalarIndent = -1;
        this.blockScalarKeep = false;
        let i = this.pos;
        while (true) {
          const ch = this.buffer[++i];
          if (ch === "+")
            this.blockScalarKeep = true;
          else if (ch > "0" && ch <= "9")
            this.blockScalarIndent = Number(ch) - 1;
          else if (ch !== "-")
            break;
        }
        return yield* this.pushUntil((ch) => isEmpty(ch) || ch === "#");
      }
      *parseBlockScalar() {
        let nl = this.pos - 1;
        let indent = 0;
        let ch;
        loop: for (let i2 = this.pos; ch = this.buffer[i2]; ++i2) {
          switch (ch) {
            case " ":
              indent += 1;
              break;
            case "\n":
              nl = i2;
              indent = 0;
              break;
            case "\r": {
              const next = this.buffer[i2 + 1];
              if (!next && !this.atEnd)
                return this.setNext("block-scalar");
              if (next === "\n")
                break;
            }
            // fallthrough
            default:
              break loop;
          }
        }
        if (!ch && !this.atEnd)
          return this.setNext("block-scalar");
        if (indent >= this.indentNext) {
          if (this.blockScalarIndent === -1)
            this.indentNext = indent;
          else {
            this.indentNext = this.blockScalarIndent + (this.indentNext === 0 ? 1 : this.indentNext);
          }
          do {
            const cs = this.continueScalar(nl + 1);
            if (cs === -1)
              break;
            nl = this.buffer.indexOf("\n", cs);
          } while (nl !== -1);
          if (nl === -1) {
            if (!this.atEnd)
              return this.setNext("block-scalar");
            nl = this.buffer.length;
          }
        }
        let i = nl + 1;
        ch = this.buffer[i];
        while (ch === " ")
          ch = this.buffer[++i];
        if (ch === "	") {
          while (ch === "	" || ch === " " || ch === "\r" || ch === "\n")
            ch = this.buffer[++i];
          nl = i - 1;
        } else if (!this.blockScalarKeep) {
          do {
            let i2 = nl - 1;
            let ch2 = this.buffer[i2];
            if (ch2 === "\r")
              ch2 = this.buffer[--i2];
            const lastChar = i2;
            while (ch2 === " ")
              ch2 = this.buffer[--i2];
            if (ch2 === "\n" && i2 >= this.pos && i2 + 1 + indent > lastChar)
              nl = i2;
            else
              break;
          } while (true);
        }
        yield cst.SCALAR;
        yield* this.pushToIndex(nl + 1, true);
        return yield* this.parseLineStart();
      }
      *parsePlainScalar() {
        const inFlow = this.flowLevel > 0;
        let end = this.pos - 1;
        let i = this.pos - 1;
        let ch;
        while (ch = this.buffer[++i]) {
          if (ch === ":") {
            const next = this.buffer[i + 1];
            if (isEmpty(next) || inFlow && flowIndicatorChars.has(next))
              break;
            end = i;
          } else if (isEmpty(ch)) {
            let next = this.buffer[i + 1];
            if (ch === "\r") {
              if (next === "\n") {
                i += 1;
                ch = "\n";
                next = this.buffer[i + 1];
              } else
                end = i;
            }
            if (next === "#" || inFlow && flowIndicatorChars.has(next))
              break;
            if (ch === "\n") {
              const cs = this.continueScalar(i + 1);
              if (cs === -1)
                break;
              i = Math.max(i, cs - 2);
            }
          } else {
            if (inFlow && flowIndicatorChars.has(ch))
              break;
            end = i;
          }
        }
        if (!ch && !this.atEnd)
          return this.setNext("plain-scalar");
        yield cst.SCALAR;
        yield* this.pushToIndex(end + 1, true);
        return inFlow ? "flow" : "doc";
      }
      *pushCount(n) {
        if (n > 0) {
          yield this.buffer.substr(this.pos, n);
          this.pos += n;
          return n;
        }
        return 0;
      }
      *pushToIndex(i, allowEmpty) {
        const s = this.buffer.slice(this.pos, i);
        if (s) {
          yield s;
          this.pos += s.length;
          return s.length;
        } else if (allowEmpty)
          yield "";
        return 0;
      }
      *pushIndicators() {
        switch (this.charAt(0)) {
          case "!":
            return (yield* this.pushTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
          case "&":
            return (yield* this.pushUntil(isNotAnchorChar)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
          case "-":
          // this is an error
          case "?":
          // this is an error outside flow collections
          case ":": {
            const inFlow = this.flowLevel > 0;
            const ch1 = this.charAt(1);
            if (isEmpty(ch1) || inFlow && flowIndicatorChars.has(ch1)) {
              if (!inFlow)
                this.indentNext = this.indentValue + 1;
              else if (this.flowKey)
                this.flowKey = false;
              return (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
            }
          }
        }
        return 0;
      }
      *pushTag() {
        if (this.charAt(1) === "<") {
          let i = this.pos + 2;
          let ch = this.buffer[i];
          while (!isEmpty(ch) && ch !== ">")
            ch = this.buffer[++i];
          return yield* this.pushToIndex(ch === ">" ? i + 1 : i, false);
        } else {
          let i = this.pos + 1;
          let ch = this.buffer[i];
          while (ch) {
            if (tagChars.has(ch))
              ch = this.buffer[++i];
            else if (ch === "%" && hexDigits.has(this.buffer[i + 1]) && hexDigits.has(this.buffer[i + 2])) {
              ch = this.buffer[i += 3];
            } else
              break;
          }
          return yield* this.pushToIndex(i, false);
        }
      }
      *pushNewline() {
        const ch = this.buffer[this.pos];
        if (ch === "\n")
          return yield* this.pushCount(1);
        else if (ch === "\r" && this.charAt(1) === "\n")
          return yield* this.pushCount(2);
        else
          return 0;
      }
      *pushSpaces(allowTabs) {
        let i = this.pos - 1;
        let ch;
        do {
          ch = this.buffer[++i];
        } while (ch === " " || allowTabs && ch === "	");
        const n = i - this.pos;
        if (n > 0) {
          yield this.buffer.substr(this.pos, n);
          this.pos = i;
        }
        return n;
      }
      *pushUntil(test) {
        let i = this.pos;
        let ch = this.buffer[i];
        while (!test(ch))
          ch = this.buffer[++i];
        return yield* this.pushToIndex(i, false);
      }
    };
    exports2.Lexer = Lexer;
  }
});

// ../../node_modules/yaml/dist/parse/line-counter.js
var require_line_counter = __commonJS({
  "../../node_modules/yaml/dist/parse/line-counter.js"(exports2) {
    "use strict";
    var LineCounter = class {
      constructor() {
        this.lineStarts = [];
        this.addNewLine = (offset) => this.lineStarts.push(offset);
        this.linePos = (offset) => {
          let low = 0;
          let high = this.lineStarts.length;
          while (low < high) {
            const mid = low + high >> 1;
            if (this.lineStarts[mid] < offset)
              low = mid + 1;
            else
              high = mid;
          }
          if (this.lineStarts[low] === offset)
            return { line: low + 1, col: 1 };
          if (low === 0)
            return { line: 0, col: offset };
          const start = this.lineStarts[low - 1];
          return { line: low, col: offset - start + 1 };
        };
      }
    };
    exports2.LineCounter = LineCounter;
  }
});

// ../../node_modules/yaml/dist/parse/parser.js
var require_parser = __commonJS({
  "../../node_modules/yaml/dist/parse/parser.js"(exports2) {
    "use strict";
    var node_process = require("process");
    var cst = require_cst();
    var lexer = require_lexer();
    function includesToken(list, type) {
      for (let i = 0; i < list.length; ++i)
        if (list[i].type === type)
          return true;
      return false;
    }
    function findNonEmptyIndex(list) {
      for (let i = 0; i < list.length; ++i) {
        switch (list[i].type) {
          case "space":
          case "comment":
          case "newline":
            break;
          default:
            return i;
        }
      }
      return -1;
    }
    function isFlowToken(token) {
      switch (token?.type) {
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
        case "flow-collection":
          return true;
        default:
          return false;
      }
    }
    function getPrevProps(parent) {
      switch (parent.type) {
        case "document":
          return parent.start;
        case "block-map": {
          const it = parent.items[parent.items.length - 1];
          return it.sep ?? it.start;
        }
        case "block-seq":
          return parent.items[parent.items.length - 1].start;
        /* istanbul ignore next should not happen */
        default:
          return [];
      }
    }
    function getFirstKeyStartProps(prev) {
      if (prev.length === 0)
        return [];
      let i = prev.length;
      loop: while (--i >= 0) {
        switch (prev[i].type) {
          case "doc-start":
          case "explicit-key-ind":
          case "map-value-ind":
          case "seq-item-ind":
          case "newline":
            break loop;
        }
      }
      while (prev[++i]?.type === "space") {
      }
      return prev.splice(i, prev.length);
    }
    function fixFlowSeqItems(fc) {
      if (fc.start.type === "flow-seq-start") {
        for (const it of fc.items) {
          if (it.sep && !it.value && !includesToken(it.start, "explicit-key-ind") && !includesToken(it.sep, "map-value-ind")) {
            if (it.key)
              it.value = it.key;
            delete it.key;
            if (isFlowToken(it.value)) {
              if (it.value.end)
                Array.prototype.push.apply(it.value.end, it.sep);
              else
                it.value.end = it.sep;
            } else
              Array.prototype.push.apply(it.start, it.sep);
            delete it.sep;
          }
        }
      }
    }
    var Parser = class {
      /**
       * @param onNewLine - If defined, called separately with the start position of
       *   each new line (in `parse()`, including the start of input).
       */
      constructor(onNewLine) {
        this.atNewLine = true;
        this.atScalar = false;
        this.indent = 0;
        this.offset = 0;
        this.onKeyLine = false;
        this.stack = [];
        this.source = "";
        this.type = "";
        this.lexer = new lexer.Lexer();
        this.onNewLine = onNewLine;
      }
      /**
       * Parse `source` as a YAML stream.
       * If `incomplete`, a part of the last line may be left as a buffer for the next call.
       *
       * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
       *
       * @returns A generator of tokens representing each directive, document, and other structure.
       */
      *parse(source, incomplete = false) {
        if (this.onNewLine && this.offset === 0)
          this.onNewLine(0);
        for (const lexeme of this.lexer.lex(source, incomplete))
          yield* this.next(lexeme);
        if (!incomplete)
          yield* this.end();
      }
      /**
       * Advance the parser by the `source` of one lexical token.
       */
      *next(source) {
        this.source = source;
        if (node_process.env.LOG_TOKENS)
          console.log("|", cst.prettyToken(source));
        if (this.atScalar) {
          this.atScalar = false;
          yield* this.step();
          this.offset += source.length;
          return;
        }
        const type = cst.tokenType(source);
        if (!type) {
          const message = `Not a YAML token: ${source}`;
          yield* this.pop({ type: "error", offset: this.offset, message, source });
          this.offset += source.length;
        } else if (type === "scalar") {
          this.atNewLine = false;
          this.atScalar = true;
          this.type = "scalar";
        } else {
          this.type = type;
          yield* this.step();
          switch (type) {
            case "newline":
              this.atNewLine = true;
              this.indent = 0;
              if (this.onNewLine)
                this.onNewLine(this.offset + source.length);
              break;
            case "space":
              if (this.atNewLine && source[0] === " ")
                this.indent += source.length;
              break;
            case "explicit-key-ind":
            case "map-value-ind":
            case "seq-item-ind":
              if (this.atNewLine)
                this.indent += source.length;
              break;
            case "doc-mode":
            case "flow-error-end":
              return;
            default:
              this.atNewLine = false;
          }
          this.offset += source.length;
        }
      }
      /** Call at end of input to push out any remaining constructions */
      *end() {
        while (this.stack.length > 0)
          yield* this.pop();
      }
      get sourceToken() {
        const st = {
          type: this.type,
          offset: this.offset,
          indent: this.indent,
          source: this.source
        };
        return st;
      }
      *step() {
        const top = this.peek(1);
        if (this.type === "doc-end" && top?.type !== "doc-end") {
          while (this.stack.length > 0)
            yield* this.pop();
          this.stack.push({
            type: "doc-end",
            offset: this.offset,
            source: this.source
          });
          return;
        }
        if (!top)
          return yield* this.stream();
        switch (top.type) {
          case "document":
            return yield* this.document(top);
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar":
            return yield* this.scalar(top);
          case "block-scalar":
            return yield* this.blockScalar(top);
          case "block-map":
            return yield* this.blockMap(top);
          case "block-seq":
            return yield* this.blockSequence(top);
          case "flow-collection":
            return yield* this.flowCollection(top);
          case "doc-end":
            return yield* this.documentEnd(top);
        }
        yield* this.pop();
      }
      peek(n) {
        return this.stack[this.stack.length - n];
      }
      *pop(error) {
        const token = error ?? this.stack.pop();
        if (!token) {
          const message = "Tried to pop an empty stack";
          yield { type: "error", offset: this.offset, source: "", message };
        } else if (this.stack.length === 0) {
          yield token;
        } else {
          const top = this.peek(1);
          if (token.type === "block-scalar") {
            token.indent = "indent" in top ? top.indent : 0;
          } else if (token.type === "flow-collection" && top.type === "document") {
            token.indent = 0;
          }
          if (token.type === "flow-collection")
            fixFlowSeqItems(token);
          switch (top.type) {
            case "document":
              top.value = token;
              break;
            case "block-scalar":
              top.props.push(token);
              break;
            case "block-map": {
              const it = top.items[top.items.length - 1];
              if (it.value) {
                top.items.push({ start: [], key: token, sep: [] });
                this.onKeyLine = true;
                return;
              } else if (it.sep) {
                it.value = token;
              } else {
                Object.assign(it, { key: token, sep: [] });
                this.onKeyLine = !it.explicitKey;
                return;
              }
              break;
            }
            case "block-seq": {
              const it = top.items[top.items.length - 1];
              if (it.value)
                top.items.push({ start: [], value: token });
              else
                it.value = token;
              break;
            }
            case "flow-collection": {
              const it = top.items[top.items.length - 1];
              if (!it || it.value)
                top.items.push({ start: [], key: token, sep: [] });
              else if (it.sep)
                it.value = token;
              else
                Object.assign(it, { key: token, sep: [] });
              return;
            }
            /* istanbul ignore next should not happen */
            default:
              yield* this.pop();
              yield* this.pop(token);
          }
          if ((top.type === "document" || top.type === "block-map" || top.type === "block-seq") && (token.type === "block-map" || token.type === "block-seq")) {
            const last2 = token.items[token.items.length - 1];
            if (last2 && !last2.sep && !last2.value && last2.start.length > 0 && findNonEmptyIndex(last2.start) === -1 && (token.indent === 0 || last2.start.every((st) => st.type !== "comment" || st.indent < token.indent))) {
              if (top.type === "document")
                top.end = last2.start;
              else
                top.items.push({ start: last2.start });
              token.items.splice(-1, 1);
            }
          }
        }
      }
      *stream() {
        switch (this.type) {
          case "directive-line":
            yield { type: "directive", offset: this.offset, source: this.source };
            return;
          case "byte-order-mark":
          case "space":
          case "comment":
          case "newline":
            yield this.sourceToken;
            return;
          case "doc-mode":
          case "doc-start": {
            const doc = {
              type: "document",
              offset: this.offset,
              start: []
            };
            if (this.type === "doc-start")
              doc.start.push(this.sourceToken);
            this.stack.push(doc);
            return;
          }
        }
        yield {
          type: "error",
          offset: this.offset,
          message: `Unexpected ${this.type} token in YAML stream`,
          source: this.source
        };
      }
      *document(doc) {
        if (doc.value)
          return yield* this.lineEnd(doc);
        switch (this.type) {
          case "doc-start": {
            if (findNonEmptyIndex(doc.start) !== -1) {
              yield* this.pop();
              yield* this.step();
            } else
              doc.start.push(this.sourceToken);
            return;
          }
          case "anchor":
          case "tag":
          case "space":
          case "comment":
          case "newline":
            doc.start.push(this.sourceToken);
            return;
        }
        const bv = this.startBlockValue(doc);
        if (bv)
          this.stack.push(bv);
        else {
          yield {
            type: "error",
            offset: this.offset,
            message: `Unexpected ${this.type} token in YAML document`,
            source: this.source
          };
        }
      }
      *scalar(scalar) {
        if (this.type === "map-value-ind") {
          const prev = getPrevProps(this.peek(2));
          const start = getFirstKeyStartProps(prev);
          let sep4;
          if (scalar.end) {
            sep4 = scalar.end;
            sep4.push(this.sourceToken);
            delete scalar.end;
          } else
            sep4 = [this.sourceToken];
          const map = {
            type: "block-map",
            offset: scalar.offset,
            indent: scalar.indent,
            items: [{ start, key: scalar, sep: sep4 }]
          };
          this.onKeyLine = true;
          this.stack[this.stack.length - 1] = map;
        } else
          yield* this.lineEnd(scalar);
      }
      *blockScalar(scalar) {
        switch (this.type) {
          case "space":
          case "comment":
          case "newline":
            scalar.props.push(this.sourceToken);
            return;
          case "scalar":
            scalar.source = this.source;
            this.atNewLine = true;
            this.indent = 0;
            if (this.onNewLine) {
              let nl = this.source.indexOf("\n") + 1;
              while (nl !== 0) {
                this.onNewLine(this.offset + nl);
                nl = this.source.indexOf("\n", nl) + 1;
              }
            }
            yield* this.pop();
            break;
          /* istanbul ignore next should not happen */
          default:
            yield* this.pop();
            yield* this.step();
        }
      }
      *blockMap(map) {
        const it = map.items[map.items.length - 1];
        switch (this.type) {
          case "newline":
            this.onKeyLine = false;
            if (it.value) {
              const end = "end" in it.value ? it.value.end : void 0;
              const last2 = Array.isArray(end) ? end[end.length - 1] : void 0;
              if (last2?.type === "comment")
                end?.push(this.sourceToken);
              else
                map.items.push({ start: [this.sourceToken] });
            } else if (it.sep) {
              it.sep.push(this.sourceToken);
            } else {
              it.start.push(this.sourceToken);
            }
            return;
          case "space":
          case "comment":
            if (it.value) {
              map.items.push({ start: [this.sourceToken] });
            } else if (it.sep) {
              it.sep.push(this.sourceToken);
            } else {
              if (this.atIndentedComment(it.start, map.indent)) {
                const prev = map.items[map.items.length - 2];
                const end = prev?.value?.end;
                if (Array.isArray(end)) {
                  Array.prototype.push.apply(end, it.start);
                  end.push(this.sourceToken);
                  map.items.pop();
                  return;
                }
              }
              it.start.push(this.sourceToken);
            }
            return;
        }
        if (this.indent >= map.indent) {
          const atMapIndent = !this.onKeyLine && this.indent === map.indent;
          const atNextItem = atMapIndent && (it.sep || it.explicitKey) && this.type !== "seq-item-ind";
          let start = [];
          if (atNextItem && it.sep && !it.value) {
            const nl = [];
            for (let i = 0; i < it.sep.length; ++i) {
              const st = it.sep[i];
              switch (st.type) {
                case "newline":
                  nl.push(i);
                  break;
                case "space":
                  break;
                case "comment":
                  if (st.indent > map.indent)
                    nl.length = 0;
                  break;
                default:
                  nl.length = 0;
              }
            }
            if (nl.length >= 2)
              start = it.sep.splice(nl[1]);
          }
          switch (this.type) {
            case "anchor":
            case "tag":
              if (atNextItem || it.value) {
                start.push(this.sourceToken);
                map.items.push({ start });
                this.onKeyLine = true;
              } else if (it.sep) {
                it.sep.push(this.sourceToken);
              } else {
                it.start.push(this.sourceToken);
              }
              return;
            case "explicit-key-ind":
              if (!it.sep && !it.explicitKey) {
                it.start.push(this.sourceToken);
                it.explicitKey = true;
              } else if (atNextItem || it.value) {
                start.push(this.sourceToken);
                map.items.push({ start, explicitKey: true });
              } else {
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: [this.sourceToken], explicitKey: true }]
                });
              }
              this.onKeyLine = true;
              return;
            case "map-value-ind":
              if (it.explicitKey) {
                if (!it.sep) {
                  if (includesToken(it.start, "newline")) {
                    Object.assign(it, { key: null, sep: [this.sourceToken] });
                  } else {
                    const start2 = getFirstKeyStartProps(it.start);
                    this.stack.push({
                      type: "block-map",
                      offset: this.offset,
                      indent: this.indent,
                      items: [{ start: start2, key: null, sep: [this.sourceToken] }]
                    });
                  }
                } else if (it.value) {
                  map.items.push({ start: [], key: null, sep: [this.sourceToken] });
                } else if (includesToken(it.sep, "map-value-ind")) {
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start, key: null, sep: [this.sourceToken] }]
                  });
                } else if (isFlowToken(it.key) && !includesToken(it.sep, "newline")) {
                  const start2 = getFirstKeyStartProps(it.start);
                  const key = it.key;
                  const sep4 = it.sep;
                  sep4.push(this.sourceToken);
                  delete it.key;
                  delete it.sep;
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start: start2, key, sep: sep4 }]
                  });
                } else if (start.length > 0) {
                  it.sep = it.sep.concat(start, this.sourceToken);
                } else {
                  it.sep.push(this.sourceToken);
                }
              } else {
                if (!it.sep) {
                  Object.assign(it, { key: null, sep: [this.sourceToken] });
                } else if (it.value || atNextItem) {
                  map.items.push({ start, key: null, sep: [this.sourceToken] });
                } else if (includesToken(it.sep, "map-value-ind")) {
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start: [], key: null, sep: [this.sourceToken] }]
                  });
                } else {
                  it.sep.push(this.sourceToken);
                }
              }
              this.onKeyLine = true;
              return;
            case "alias":
            case "scalar":
            case "single-quoted-scalar":
            case "double-quoted-scalar": {
              const fs10 = this.flowScalar(this.type);
              if (atNextItem || it.value) {
                map.items.push({ start, key: fs10, sep: [] });
                this.onKeyLine = true;
              } else if (it.sep) {
                this.stack.push(fs10);
              } else {
                Object.assign(it, { key: fs10, sep: [] });
                this.onKeyLine = true;
              }
              return;
            }
            default: {
              const bv = this.startBlockValue(map);
              if (bv) {
                if (bv.type === "block-seq") {
                  if (!it.explicitKey && it.sep && !includesToken(it.sep, "newline")) {
                    yield* this.pop({
                      type: "error",
                      offset: this.offset,
                      message: "Unexpected block-seq-ind on same line with key",
                      source: this.source
                    });
                    return;
                  }
                } else if (atMapIndent) {
                  map.items.push({ start });
                }
                this.stack.push(bv);
                return;
              }
            }
          }
        }
        yield* this.pop();
        yield* this.step();
      }
      *blockSequence(seq) {
        const it = seq.items[seq.items.length - 1];
        switch (this.type) {
          case "newline":
            if (it.value) {
              const end = "end" in it.value ? it.value.end : void 0;
              const last2 = Array.isArray(end) ? end[end.length - 1] : void 0;
              if (last2?.type === "comment")
                end?.push(this.sourceToken);
              else
                seq.items.push({ start: [this.sourceToken] });
            } else
              it.start.push(this.sourceToken);
            return;
          case "space":
          case "comment":
            if (it.value)
              seq.items.push({ start: [this.sourceToken] });
            else {
              if (this.atIndentedComment(it.start, seq.indent)) {
                const prev = seq.items[seq.items.length - 2];
                const end = prev?.value?.end;
                if (Array.isArray(end)) {
                  Array.prototype.push.apply(end, it.start);
                  end.push(this.sourceToken);
                  seq.items.pop();
                  return;
                }
              }
              it.start.push(this.sourceToken);
            }
            return;
          case "anchor":
          case "tag":
            if (it.value || this.indent <= seq.indent)
              break;
            it.start.push(this.sourceToken);
            return;
          case "seq-item-ind":
            if (this.indent !== seq.indent)
              break;
            if (it.value || includesToken(it.start, "seq-item-ind"))
              seq.items.push({ start: [this.sourceToken] });
            else
              it.start.push(this.sourceToken);
            return;
        }
        if (this.indent > seq.indent) {
          const bv = this.startBlockValue(seq);
          if (bv) {
            this.stack.push(bv);
            return;
          }
        }
        yield* this.pop();
        yield* this.step();
      }
      *flowCollection(fc) {
        const it = fc.items[fc.items.length - 1];
        if (this.type === "flow-error-end") {
          let top;
          do {
            yield* this.pop();
            top = this.peek(1);
          } while (top?.type === "flow-collection");
        } else if (fc.end.length === 0) {
          switch (this.type) {
            case "comma":
            case "explicit-key-ind":
              if (!it || it.sep)
                fc.items.push({ start: [this.sourceToken] });
              else
                it.start.push(this.sourceToken);
              return;
            case "map-value-ind":
              if (!it || it.value)
                fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
              else if (it.sep)
                it.sep.push(this.sourceToken);
              else
                Object.assign(it, { key: null, sep: [this.sourceToken] });
              return;
            case "space":
            case "comment":
            case "newline":
            case "anchor":
            case "tag":
              if (!it || it.value)
                fc.items.push({ start: [this.sourceToken] });
              else if (it.sep)
                it.sep.push(this.sourceToken);
              else
                it.start.push(this.sourceToken);
              return;
            case "alias":
            case "scalar":
            case "single-quoted-scalar":
            case "double-quoted-scalar": {
              const fs10 = this.flowScalar(this.type);
              if (!it || it.value)
                fc.items.push({ start: [], key: fs10, sep: [] });
              else if (it.sep)
                this.stack.push(fs10);
              else
                Object.assign(it, { key: fs10, sep: [] });
              return;
            }
            case "flow-map-end":
            case "flow-seq-end":
              fc.end.push(this.sourceToken);
              return;
          }
          const bv = this.startBlockValue(fc);
          if (bv)
            this.stack.push(bv);
          else {
            yield* this.pop();
            yield* this.step();
          }
        } else {
          const parent = this.peek(2);
          if (parent.type === "block-map" && (this.type === "map-value-ind" && parent.indent === fc.indent || this.type === "newline" && !parent.items[parent.items.length - 1].sep)) {
            yield* this.pop();
            yield* this.step();
          } else if (this.type === "map-value-ind" && parent.type !== "flow-collection") {
            const prev = getPrevProps(parent);
            const start = getFirstKeyStartProps(prev);
            fixFlowSeqItems(fc);
            const sep4 = fc.end.splice(1, fc.end.length);
            sep4.push(this.sourceToken);
            const map = {
              type: "block-map",
              offset: fc.offset,
              indent: fc.indent,
              items: [{ start, key: fc, sep: sep4 }]
            };
            this.onKeyLine = true;
            this.stack[this.stack.length - 1] = map;
          } else {
            yield* this.lineEnd(fc);
          }
        }
      }
      flowScalar(type) {
        if (this.onNewLine) {
          let nl = this.source.indexOf("\n") + 1;
          while (nl !== 0) {
            this.onNewLine(this.offset + nl);
            nl = this.source.indexOf("\n", nl) + 1;
          }
        }
        return {
          type,
          offset: this.offset,
          indent: this.indent,
          source: this.source
        };
      }
      startBlockValue(parent) {
        switch (this.type) {
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar":
            return this.flowScalar(this.type);
          case "block-scalar-header":
            return {
              type: "block-scalar",
              offset: this.offset,
              indent: this.indent,
              props: [this.sourceToken],
              source: ""
            };
          case "flow-map-start":
          case "flow-seq-start":
            return {
              type: "flow-collection",
              offset: this.offset,
              indent: this.indent,
              start: this.sourceToken,
              items: [],
              end: []
            };
          case "seq-item-ind":
            return {
              type: "block-seq",
              offset: this.offset,
              indent: this.indent,
              items: [{ start: [this.sourceToken] }]
            };
          case "explicit-key-ind": {
            this.onKeyLine = true;
            const prev = getPrevProps(parent);
            const start = getFirstKeyStartProps(prev);
            start.push(this.sourceToken);
            return {
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start, explicitKey: true }]
            };
          }
          case "map-value-ind": {
            this.onKeyLine = true;
            const prev = getPrevProps(parent);
            const start = getFirstKeyStartProps(prev);
            return {
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start, key: null, sep: [this.sourceToken] }]
            };
          }
        }
        return null;
      }
      atIndentedComment(start, indent) {
        if (this.type !== "comment")
          return false;
        if (this.indent <= indent)
          return false;
        return start.every((st) => st.type === "newline" || st.type === "space");
      }
      *documentEnd(docEnd) {
        if (this.type !== "doc-mode") {
          if (docEnd.end)
            docEnd.end.push(this.sourceToken);
          else
            docEnd.end = [this.sourceToken];
          if (this.type === "newline")
            yield* this.pop();
        }
      }
      *lineEnd(token) {
        switch (this.type) {
          case "comma":
          case "doc-start":
          case "doc-end":
          case "flow-seq-end":
          case "flow-map-end":
          case "map-value-ind":
            yield* this.pop();
            yield* this.step();
            break;
          case "newline":
            this.onKeyLine = false;
          // fallthrough
          case "space":
          case "comment":
          default:
            if (token.end)
              token.end.push(this.sourceToken);
            else
              token.end = [this.sourceToken];
            if (this.type === "newline")
              yield* this.pop();
        }
      }
    };
    exports2.Parser = Parser;
  }
});

// ../../node_modules/yaml/dist/public-api.js
var require_public_api = __commonJS({
  "../../node_modules/yaml/dist/public-api.js"(exports2) {
    "use strict";
    var composer = require_composer();
    var Document = require_Document();
    var errors = require_errors2();
    var log = require_log();
    var identity = require_identity();
    var lineCounter = require_line_counter();
    var parser4 = require_parser();
    function parseOptions(options) {
      const prettyErrors = options.prettyErrors !== false;
      const lineCounter$1 = options.lineCounter || prettyErrors && new lineCounter.LineCounter() || null;
      return { lineCounter: lineCounter$1, prettyErrors };
    }
    function parseAllDocuments(source, options = {}) {
      const { lineCounter: lineCounter2, prettyErrors } = parseOptions(options);
      const parser$1 = new parser4.Parser(lineCounter2?.addNewLine);
      const composer$1 = new composer.Composer(options);
      const docs = Array.from(composer$1.compose(parser$1.parse(source)));
      if (prettyErrors && lineCounter2)
        for (const doc of docs) {
          doc.errors.forEach(errors.prettifyError(source, lineCounter2));
          doc.warnings.forEach(errors.prettifyError(source, lineCounter2));
        }
      if (docs.length > 0)
        return docs;
      return Object.assign([], { empty: true }, composer$1.streamInfo());
    }
    function parseDocument(source, options = {}) {
      const { lineCounter: lineCounter2, prettyErrors } = parseOptions(options);
      const parser$1 = new parser4.Parser(lineCounter2?.addNewLine);
      const composer$1 = new composer.Composer(options);
      let doc = null;
      for (const _doc of composer$1.compose(parser$1.parse(source), true, source.length)) {
        if (!doc)
          doc = _doc;
        else if (doc.options.logLevel !== "silent") {
          doc.errors.push(new errors.YAMLParseError(_doc.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
          break;
        }
      }
      if (prettyErrors && lineCounter2) {
        doc.errors.forEach(errors.prettifyError(source, lineCounter2));
        doc.warnings.forEach(errors.prettifyError(source, lineCounter2));
      }
      return doc;
    }
    function parse2(src, reviver, options) {
      let _reviver = void 0;
      if (typeof reviver === "function") {
        _reviver = reviver;
      } else if (options === void 0 && reviver && typeof reviver === "object") {
        options = reviver;
      }
      const doc = parseDocument(src, options);
      if (!doc)
        return null;
      doc.warnings.forEach((warning) => log.warn(doc.options.logLevel, warning));
      if (doc.errors.length > 0) {
        if (doc.options.logLevel !== "silent")
          throw doc.errors[0];
        else
          doc.errors = [];
      }
      return doc.toJS(Object.assign({ reviver: _reviver }, options));
    }
    function stringify(value, replacer, options) {
      let _replacer = null;
      if (typeof replacer === "function" || Array.isArray(replacer)) {
        _replacer = replacer;
      } else if (options === void 0 && replacer) {
        options = replacer;
      }
      if (typeof options === "string")
        options = options.length;
      if (typeof options === "number") {
        const indent = Math.round(options);
        options = indent < 1 ? void 0 : indent > 8 ? { indent: 8 } : { indent };
      }
      if (value === void 0) {
        const { keepUndefined } = options ?? replacer ?? {};
        if (!keepUndefined)
          return void 0;
      }
      if (identity.isDocument(value) && !_replacer)
        return value.toString(options);
      return new Document.Document(value, _replacer, options).toString(options);
    }
    exports2.parse = parse2;
    exports2.parseAllDocuments = parseAllDocuments;
    exports2.parseDocument = parseDocument;
    exports2.stringify = stringify;
  }
});

// ../../node_modules/yaml/dist/index.js
var require_dist3 = __commonJS({
  "../../node_modules/yaml/dist/index.js"(exports2) {
    "use strict";
    var composer = require_composer();
    var Document = require_Document();
    var Schema = require_Schema();
    var errors = require_errors2();
    var Alias = require_Alias();
    var identity = require_identity();
    var Pair = require_Pair();
    var Scalar = require_Scalar();
    var YAMLMap = require_YAMLMap();
    var YAMLSeq = require_YAMLSeq();
    var cst = require_cst();
    var lexer = require_lexer();
    var lineCounter = require_line_counter();
    var parser4 = require_parser();
    var publicApi = require_public_api();
    var visit = require_visit();
    exports2.Composer = composer.Composer;
    exports2.Document = Document.Document;
    exports2.Schema = Schema.Schema;
    exports2.YAMLError = errors.YAMLError;
    exports2.YAMLParseError = errors.YAMLParseError;
    exports2.YAMLWarning = errors.YAMLWarning;
    exports2.Alias = Alias.Alias;
    exports2.isAlias = identity.isAlias;
    exports2.isCollection = identity.isCollection;
    exports2.isDocument = identity.isDocument;
    exports2.isMap = identity.isMap;
    exports2.isNode = identity.isNode;
    exports2.isPair = identity.isPair;
    exports2.isScalar = identity.isScalar;
    exports2.isSeq = identity.isSeq;
    exports2.Pair = Pair.Pair;
    exports2.Scalar = Scalar.Scalar;
    exports2.YAMLMap = YAMLMap.YAMLMap;
    exports2.YAMLSeq = YAMLSeq.YAMLSeq;
    exports2.CST = cst;
    exports2.Lexer = lexer.Lexer;
    exports2.LineCounter = lineCounter.LineCounter;
    exports2.Parser = parser4.Parser;
    exports2.parse = publicApi.parse;
    exports2.parseAllDocuments = publicApi.parseAllDocuments;
    exports2.parseDocument = publicApi.parseDocument;
    exports2.stringify = publicApi.stringify;
    exports2.visit = visit.visit;
    exports2.visitAsync = visit.visitAsync;
  }
});

// node_modules/commander/esm.mjs
var import_index = __toESM(require_commander(), 1);
var {
  program,
  createCommand,
  createArgument,
  createOption,
  CommanderError,
  InvalidArgumentError,
  InvalidOptionArgumentError,
  // deprecated old name
  Command,
  Argument,
  Option,
  Help
} = import_index.default;

// src/sdk-proxy.ts
var import_dev_tunnels_management2 = __toESM(require_dev_tunnels_management(), 1);

// src/tunnel-adapter.ts
var dns = __toESM(require("dns"), 1);
var net = __toESM(require("net"), 1);
var os2 = __toESM(require("os"), 1);
var import_dev_tunnels_connections = __toESM(require_dev_tunnels_connections(), 1);
var import_dev_tunnels_contracts = __toESM(require_dev_tunnels_contracts(), 1);
var import_dev_tunnels_management = __toESM(require_dev_tunnels_management(), 1);

// src/token-storage.ts
var import_keytar = __toESM(require("keytar"), 1);
var SERVICE_NAME = "agent-tunnels";
var ACCOUNT_NAME = "github-token-data";
async function loadTokenData() {
  try {
    const data = await import_keytar.default.getPassword(SERVICE_NAME, ACCOUNT_NAME);
    if (!data) return null;
    return JSON.parse(data);
  } catch (error) {
    console.warn("Failed to load token data from keychain:", error);
    return null;
  }
}
async function saveTokenData(tokenData) {
  try {
    await import_keytar.default.setPassword(SERVICE_NAME, ACCOUNT_NAME, JSON.stringify(tokenData));
  } catch (error) {
    console.warn("Failed to save token data to keychain:", error);
    throw error;
  }
}
async function clearTokenData() {
  try {
    await import_keytar.default.deletePassword(SERVICE_NAME, ACCOUNT_NAME);
  } catch (error) {
    console.warn("Failed to clear token data from keychain:", error);
  }
}

// src/tunnel-config.ts
var fs = __toESM(require("fs/promises"), 1);
var path = __toESM(require("path"), 1);
var os = __toESM(require("os"), 1);
function getConfigDir() {
  return path.join(os.homedir(), ".copilot", "agent-tunnels");
}
function getConfigPath() {
  return path.join(getConfigDir(), "host-config.json");
}
async function loadTunnelConfig() {
  try {
    const configPath = getConfigPath();
    const data = await fs.readFile(configPath, "utf-8");
    return JSON.parse(data);
  } catch {
    return null;
  }
}
async function saveTunnelConfig(config) {
  const configDir = getConfigDir();
  const configPath = getConfigPath();
  await fs.mkdir(configDir, { recursive: true });
  await fs.writeFile(configPath, JSON.stringify(config, null, 2), "utf-8");
}
async function clearTunnelConfig() {
  try {
    const configPath = getConfigPath();
    await fs.unlink(configPath);
  } catch {
  }
}

// src/tunnel-adapter.ts
var DEFAULT_KEEP_ALIVE_INTERVAL_SECONDS = 5;
var DEFAULT_CONNECTION_TIMEOUT_MS = 3e4;
var NETWORK_CHECK_INTERVAL_MS = 5e3;
var MIN_RETRY_DELAY_MS = 1e3;
var DNS_TIMEOUT_MS = 5e3;
var SLEEP_WAKE_THRESHOLD_MS = 3e4;
var TUNNEL_LABEL = "copilot-tunnel-session";
var GITHUB_CLIENT_ID = "Iv1.e7b89e013f801f03";
var GITHUB_SCOPES = "read:user,read:org";
var GITHUB_DEVICE_CODE_URL = "https://github.com/login/device/code";
var GITHUB_TOKEN_URL = "https://github.com/login/oauth/access_token";
var DEVICE_CODE_POLL_INTERVAL_MS = 5e3;
var DevTunnelHostAdapter = class {
  config;
  server = null;
  tunnel = null;
  host = null;
  managementClient = null;
  clientHandlers = [];
  disconnectHandlers = [];
  clientCounter = 0;
  clients = /* @__PURE__ */ new Map();
  disconnectedClients = /* @__PURE__ */ new Set();
  // Track already-disconnected clients to avoid duplicate notifications
  isDisposed = false;
  username;
  currentToken = null;
  hasEverConnected = false;
  // Track initial connection for logging
  // Disconnect tracking for reconnection context
  lastDisconnectReason;
  disconnectedAt;
  // Network monitoring state (runs when disconnected)
  lastNetworkInterfaces = "";
  networkCheckTimer = null;
  lastNetworkCheckTime = 0;
  // For sleep/wake detection
  isNetworkAvailable = true;
  retryCount = 0;
  // Sleep detection state (runs always to detect system wake)
  sleepDetectionTimer = null;
  lastSleepCheckTime = 0;
  // Log level filtering
  logLevel;
  constructor(config) {
    this.config = config;
    this.logLevel = config.logLevel ?? "info";
  }
  log(level, message) {
    if (level === "debug" && this.logLevel !== "debug") {
      return;
    }
    this.config.onLog?.(level, message);
  }
  // ===========================================================================
  // Network Monitoring & Reconnection
  // ===========================================================================
  /**
   * Get a fingerprint of current network interfaces.
   * Changes indicate network state changed (e.g., wifi reconnected).
   */
  getNetworkFingerprint() {
    const interfaces = os2.networkInterfaces();
    const addresses = [];
    for (const [name, addrs] of Object.entries(interfaces)) {
      if (!addrs) continue;
      for (const addr of addrs) {
        if (!addr.internal && addr.family === "IPv4") {
          addresses.push(`${name}:${addr.address}`);
        }
      }
    }
    return addresses.sort().join(",");
  }
  /**
   * Check if network is available by attempting DNS resolution with timeout.
   */
  async checkNetworkAvailable() {
    return new Promise((resolve8) => {
      const timeout = setTimeout(() => resolve8(false), DNS_TIMEOUT_MS);
      dns.resolve("github.com", (err) => {
        clearTimeout(timeout);
        resolve8(!err);
      });
    });
  }
  /**
   * Start monitoring network for changes and system sleep/wake events.
   * When network is restored or system wakes from sleep, resets retryCount
   * so the next SDK retry will happen faster.
   */
  startNetworkMonitoring() {
    if (this.networkCheckTimer) return;
    this.lastNetworkInterfaces = this.getNetworkFingerprint();
    this.lastNetworkCheckTime = Date.now();
    this.log("debug", "Started network monitoring");
    this.networkCheckTimer = setInterval(async () => {
      if (this.isDisposed) {
        this.stopNetworkMonitoring();
        return;
      }
      const now = Date.now();
      const elapsed = now - this.lastNetworkCheckTime;
      this.lastNetworkCheckTime = now;
      if (elapsed > SLEEP_WAKE_THRESHOLD_MS) {
        this.log("debug", `System wake detected (${Math.round(elapsed / 1e3)}s since last check)`);
        await this.handleSystemWake();
        return;
      }
      const currentFingerprint = this.getNetworkFingerprint();
      if (currentFingerprint !== this.lastNetworkInterfaces) {
        this.lastNetworkInterfaces = currentFingerprint;
        await this.handleNetworkChange();
      }
    }, NETWORK_CHECK_INTERVAL_MS);
  }
  /**
   * Handle detected network interface change.
   */
  async handleNetworkChange() {
    this.log("debug", "Network interfaces changed");
    const available = await this.checkNetworkAvailable();
    if (available && !this.isNetworkAvailable) {
      this.log("debug", "Network connectivity restored - next retry will be faster");
      this.isNetworkAvailable = true;
      this.retryCount = 0;
    }
    this.isNetworkAvailable = available;
  }
  /**
   * Handle system wake from sleep.
   * Forces a reconnection attempt by resetting retry state, regardless of
   * whether network interfaces changed (they often don't when waking to same WiFi).
   */
  async handleSystemWake() {
    this.lastNetworkInterfaces = this.getNetworkFingerprint();
    const available = await this.checkNetworkAvailable();
    if (available) {
      this.log("debug", "Network available after wake - triggering reconnection");
      this.isNetworkAvailable = true;
      this.retryCount = 0;
    } else {
      this.log("debug", "Network not yet available after wake");
      this.isNetworkAvailable = false;
    }
  }
  /**
   * Stop network monitoring.
   */
  stopNetworkMonitoring() {
    if (this.networkCheckTimer) {
      clearInterval(this.networkCheckTimer);
      this.networkCheckTimer = null;
      this.log("debug", "Stopped network monitoring");
    }
  }
  /**
   * Start always-on sleep detection.
   * This runs even when connected to detect system wake events that may have
   * left the connection in a stale state.
   */
  startSleepDetection() {
    if (this.sleepDetectionTimer) return;
    this.lastSleepCheckTime = Date.now();
    this.log("debug", "Started sleep detection");
    this.sleepDetectionTimer = setInterval(() => {
      if (this.isDisposed) {
        this.stopSleepDetection();
        return;
      }
      const now = Date.now();
      const elapsed = now - this.lastSleepCheckTime;
      this.lastSleepCheckTime = now;
      if (elapsed > SLEEP_WAKE_THRESHOLD_MS) {
        this.log("debug", `System wake detected (${Math.round(elapsed / 1e3)}s since last check)`);
        this.handleConnectedWake();
      }
    }, NETWORK_CHECK_INTERVAL_MS);
  }
  /**
   * Stop sleep detection.
   */
  stopSleepDetection() {
    if (this.sleepDetectionTimer) {
      clearInterval(this.sleepDetectionTimer);
      this.sleepDetectionTimer = null;
      this.log("debug", "Stopped sleep detection");
    }
  }
  /**
   * Handle system wake while tunnel is connected.
   * The underlying connection may be stale after sleep, so we trigger
   * a keepAlive to verify and potentially force reconnection.
   */
  handleConnectedWake() {
    const host = this.host;
    if (host?.sshSession?.sendKeepAlive) {
      this.log("debug", "Triggering keepAlive check after wake");
      try {
        host.sshSession.sendKeepAlive();
      } catch (err) {
        this.log("warn", `KeepAlive after wake failed: ${err}`);
      }
    }
  }
  /**
   * Handle connection status change from SDK.
   */
  handleConnectionStatusChange(status, reason) {
    if (status === "disconnected") {
      this.log("info", "Tunnel disconnected" + (reason ? ` (${reason})` : ""));
      this.log("info", "Reconnecting...");
      this.lastDisconnectReason = reason;
      this.disconnectedAt = Date.now();
      this.stopSleepDetection();
      this.startNetworkMonitoring();
      if (this.clients.size > 0) {
        this.log("debug", `Closing ${this.clients.size} orphaned client connection(s)`);
        for (const [clientId, socket] of this.clients) {
          this.disconnectedClients.add(clientId);
          socket.destroy();
        }
      }
    } else if (status === "connected") {
      if (this.hasEverConnected) {
        const parts = ["Tunnel reconnected"];
        if (this.disconnectedAt) {
          const downtime = Math.round((Date.now() - this.disconnectedAt) / 1e3);
          parts.push(`after ${downtime}s`);
        }
        const contextParts = [];
        if (this.lastDisconnectReason) {
          contextParts.push(this.lastDisconnectReason);
        }
        if (this.retryCount > 0) {
          contextParts.push(`${this.retryCount} ${this.retryCount === 1 ? "retry" : "retries"}`);
        }
        if (contextParts.length > 0) {
          parts.push(`(${contextParts.join(", ")})`);
        }
        this.log("info", parts.join(" "));
        this.lastDisconnectReason = void 0;
        this.disconnectedAt = void 0;
      } else {
        this.hasEverConnected = true;
      }
      this.stopNetworkMonitoring();
      this.startSleepDetection();
      this.retryCount = 0;
      this.isNetworkAvailable = true;
    } else {
      this.log("debug", `Tunnel status: ${status}`);
    }
    this.config.onStatusChange?.(status, reason);
  }
  /**
   * Handle SDK retry event - speed up the first retry after network restoration.
   */
  handleRetryEvent(e) {
    this.retryCount++;
    this.log("debug", `Retry #${this.retryCount} in ${e.delayMs}ms (${e.error.message})`);
    if (this.isNetworkAvailable && this.retryCount === 1) {
      const reducedDelay = Math.min(e.delayMs, MIN_RETRY_DELAY_MS);
      if (reducedDelay < e.delayMs) {
        this.log("debug", `Network available, reducing delay to ${reducedDelay}ms`);
        e.delayMs = reducedDelay;
      }
    }
  }
  /**
   * Check if an error indicates the tunnel doesn't exist (404).
   */
  isTunnelNotFoundError(error) {
    if (error instanceof Error) {
      const message = error.message.toLowerCase();
      return message.includes("404") || message.includes("not found") || message.includes("does not exist");
    }
    return false;
  }
  /**
   * Connect to the tunnel relay and set up event handlers.
   */
  async connectToTunnel(rpcPort) {
    if (!this.managementClient || !this.tunnel) {
      throw new Error("Management client or tunnel not initialized");
    }
    this.log("debug", "Connecting to tunnel relay...");
    this.host = new import_dev_tunnels_connections.TunnelRelayTunnelHost(this.managementClient);
    this.host.connectionStatusChanged((e) => {
      const reason = e.disconnectReason;
      this.handleConnectionStatusChange(e.status, reason);
    });
    this.host.refreshingTunnelAccessToken((e) => {
      this.log("debug", `Token refresh requested (scope: ${e.tunnelAccessScope})`);
    });
    this.host.retryingTunnelConnection((e) => {
      this.handleRetryEvent(e);
    });
    const connectionOptions = {
      keepAliveIntervalInSeconds: DEFAULT_KEEP_ALIVE_INTERVAL_SECONDS,
      enableRetry: true,
      enableReconnect: true
    };
    await this.connectWithTimeout(connectionOptions, DEFAULT_CONNECTION_TIMEOUT_MS);
    this.setupHostKeepAlive();
  }
  /**
   * Workaround for Dev Tunnels SDK bug: manually configure keepAlive on the host's SSH session.
   * The SDK only configures keepAlive for clienthost sessions, not hostrelay sessions.
   */
  setupHostKeepAlive() {
    const sshSession = this.host?.sshSession;
    if (!sshSession?.config || !sshSession.startKeepAliveTimer) {
      this.log("warn", "Unable to configure host keepAlive - sshSession not accessible");
      return;
    }
    sshSession.config.keepAliveTimeoutInSeconds = DEFAULT_KEEP_ALIVE_INTERVAL_SECONDS;
    sshSession.onKeepAliveSucceeded?.(() => {
      this.log("debug", `KeepAlive success (count: ${sshSession.keepAliveSuccessCount})`);
    });
    sshSession.onKeepAliveFailed?.(() => {
      const failureCount = sshSession.keepAliveFailureCount ?? 0;
      this.log("debug", `KeepAlive failed (count: ${failureCount})`);
      if (failureCount === 3) {
        this.log("debug", "Multiple keepAlive failures - connection stale");
        if (this.clients.size > 0) {
          this.log("debug", `Closing ${this.clients.size} client connection(s) due to stale tunnel`);
          for (const [clientId, socket] of this.clients) {
            if (!this.disconnectedClients.has(clientId)) {
              this.disconnectedClients.add(clientId);
              socket.destroy();
            }
          }
        }
      }
    });
    sshSession.startKeepAliveTimer();
    this.log("debug", `Host keepAlive configured (interval: ${DEFAULT_KEEP_ALIVE_INTERVAL_SECONDS}s)`);
  }
  // ===========================================================================
  // Auth Retry Infrastructure
  // ===========================================================================
  /**
   * Create (or recreate) the tunnel management client.
   * The token callback reads from this.currentToken so it always uses
   * the latest token without closure issues.
   */
  createManagementClient() {
    this.log("debug", "Creating tunnel management client...");
    this.managementClient = new import_dev_tunnels_management.TunnelManagementHttpClient(
      "RemoteSdkBridge/1.0",
      import_dev_tunnels_management.ManagementApiVersions.Version20230927preview,
      () => Promise.resolve(this.currentToken ? `github ${this.currentToken}` : null)
    );
  }
  /**
   * Check if an error indicates a 401 Unauthorized response from the tunnel service.
   */
  isUnauthorizedError(error) {
    if (error instanceof Error) {
      const axiosError = error;
      if (axiosError.isAxiosError && axiosError.response?.status === 401) {
        return true;
      }
      const message = error.message.toLowerCase();
      if (message.includes("401") || message.includes("unauthorized")) {
        return true;
      }
    }
    return false;
  }
  /**
   * Execute a management client operation with automatic 401 retry.
   *
   * If the operation fails with 401:
   * 1. Try refreshing the access token using the stored refresh token
   * 2. If refresh succeeds, save new tokens, recreate management client, retry
   * 3. If refresh fails or no refresh token, clear tokens, run device flow, retry
   *
   * Only retries ONCE to prevent infinite loops.
   */
  async withAuthRetry(operation) {
    try {
      return await operation();
    } catch (error) {
      if (!this.isUnauthorizedError(error)) {
        throw error;
      }
      this.log("info", "Received 401 from tunnel service, attempting token refresh...");
      const tokenData = await loadTokenData();
      if (tokenData?.refreshToken) {
        const now = Date.now();
        const refreshExpired = tokenData.refreshExpiresAt < now + 5 * 60 * 1e3;
        if (!refreshExpired) {
          try {
            const oldUsername = tokenData.username;
            const newTokenData2 = await this.refreshAccessToken(tokenData.refreshToken);
            newTokenData2.username = oldUsername;
            await saveTokenData(newTokenData2);
            this.currentToken = newTokenData2.accessToken;
            this.username = oldUsername;
            this.createManagementClient();
            this.log("info", "Token refreshed successfully, retrying operation...");
            return await operation();
          } catch (refreshErr) {
            this.log("warn", `Token refresh failed: ${refreshErr}`);
          }
        } else {
          this.log("debug", "Refresh token is expired, skipping refresh attempt");
        }
      }
      this.log("info", "Clearing credentials and starting device flow...");
      await clearTokenData();
      const newTokenData = await this.authenticateWithDeviceFlow();
      this.username = await this.fetchGitHubUsername(newTokenData.accessToken);
      newTokenData.username = this.username;
      await saveTokenData(newTokenData);
      this.currentToken = newTokenData.accessToken;
      this.createManagementClient();
      this.log("info", `Re-authenticated as: ${this.username ?? "unknown"}, retrying operation...`);
      return await operation();
    }
  }
  async start() {
    if (this.server) {
      throw new Error("Tunnel adapter already started");
    }
    this.log("debug", "Creating local TCP server...");
    this.server = await this.createServer();
    const rpcPort = this.server.address().port;
    this.log("debug", `Local JSON-RPC server listening on port ${rpcPort}`);
    this.currentToken = await this.getStoredOrNewToken();
    this.createManagementClient();
    const storedConfig = await loadTunnelConfig();
    if (storedConfig) {
      this.log("info", `Found stored tunnel: ${storedConfig.tunnelId}`);
      try {
        const tunnelRequest = {
          tunnelId: storedConfig.tunnelId,
          clusterId: storedConfig.clusterId
        };
        this.tunnel = await this.withAuthRetry(
          () => this.managementClient.getTunnel(tunnelRequest, {
            tokenScopes: [import_dev_tunnels_contracts.TunnelAccessScopes.Host, import_dev_tunnels_contracts.TunnelAccessScopes.Connect],
            includePorts: true
          })
        );
        if (this.tunnel) {
          if (this.tunnel.ports && this.tunnel.ports.length > 0) {
            for (const port of this.tunnel.ports) {
              if (port.portNumber) {
                this.log("debug", `Removing old port ${port.portNumber} from tunnel`);
                try {
                  await this.withAuthRetry(
                    () => this.managementClient.deleteTunnelPort(this.tunnel, port.portNumber)
                  );
                } catch {
                }
              }
            }
          }
          this.log("debug", `Adding port ${rpcPort} to tunnel`);
          await this.withAuthRetry(
            () => this.managementClient.createTunnelPort(this.tunnel, {
              portNumber: rpcPort,
              protocol: "auto"
            })
          );
          this.tunnel = await this.withAuthRetry(
            () => this.managementClient.getTunnel(this.tunnel, {
              tokenScopes: [import_dev_tunnels_contracts.TunnelAccessScopes.Host, import_dev_tunnels_contracts.TunnelAccessScopes.Connect],
              includePorts: true
            })
          );
          this.log("debug", "Connecting to existing tunnel...");
          await this.connectToTunnel(rpcPort);
          this.log("info", "Connected to existing tunnel");
          return {
            tunnelId: this.tunnel.tunnelId,
            clusterId: this.tunnel.clusterId,
            port: rpcPort,
            username: this.username
          };
        }
      } catch (error) {
        if (this.isTunnelNotFoundError(error)) {
          this.log("info", "Stored tunnel no longer exists");
          await clearTunnelConfig();
        } else {
          throw error;
        }
      }
    }
    this.log("info", "Searching for existing tunnel by label...");
    const labeledTunnels = await this.withAuthRetry(
      () => this.managementClient.listTunnels(
        void 0,
        // global search (no cluster filter)
        void 0,
        // default domain
        { labels: [TUNNEL_LABEL] }
      )
    );
    if (labeledTunnels.length > 0) {
      labeledTunnels.sort(
        (a, b) => new Date(b.created ?? 0).getTime() - new Date(a.created ?? 0).getTime()
      );
      const foundTunnel = labeledTunnels[0];
      this.log("info", `Found existing tunnel via label: ${foundTunnel.tunnelId}`);
      this.tunnel = await this.withAuthRetry(
        () => this.managementClient.getTunnel(
          { tunnelId: foundTunnel.tunnelId, clusterId: foundTunnel.clusterId },
          { tokenScopes: [import_dev_tunnels_contracts.TunnelAccessScopes.Host, import_dev_tunnels_contracts.TunnelAccessScopes.Connect], includePorts: true }
        )
      );
      if (!this.tunnel) {
        throw new Error("Failed to fetch tunnel details");
      }
      if (this.tunnel.ports && this.tunnel.ports.length > 0) {
        for (const port of this.tunnel.ports) {
          if (port.portNumber) {
            this.log("debug", `Removing old port ${port.portNumber} from tunnel`);
            try {
              await this.withAuthRetry(
                () => this.managementClient.deleteTunnelPort(this.tunnel, port.portNumber)
              );
            } catch {
            }
          }
        }
      }
      this.log("debug", `Adding port ${rpcPort} to tunnel`);
      await this.withAuthRetry(
        () => this.managementClient.createTunnelPort(this.tunnel, {
          portNumber: rpcPort,
          protocol: "auto"
        })
      );
      this.tunnel = await this.withAuthRetry(
        () => this.managementClient.getTunnel(this.tunnel, {
          tokenScopes: [import_dev_tunnels_contracts.TunnelAccessScopes.Host, import_dev_tunnels_contracts.TunnelAccessScopes.Connect],
          includePorts: true
        })
      );
      if (!this.tunnel) {
        throw new Error("Failed to refresh tunnel details");
      }
      await saveTunnelConfig({
        tunnelId: this.tunnel.tunnelId,
        clusterId: this.tunnel.clusterId,
        createdAt: (/* @__PURE__ */ new Date()).toISOString()
      });
      this.log("debug", "Tunnel config saved");
      this.log("debug", "Connecting to existing tunnel...");
      await this.connectToTunnel(rpcPort);
      this.log("info", "Connected to existing tunnel");
      return {
        tunnelId: this.tunnel.tunnelId,
        clusterId: this.tunnel.clusterId,
        port: rpcPort,
        username: this.username
      };
    }
    this.log("info", "Creating new tunnel...");
    const tunnelConfig = {
      labels: [TUNNEL_LABEL],
      ports: [
        { portNumber: rpcPort, protocol: "auto" }
      ]
    };
    this.tunnel = await this.withAuthRetry(
      () => this.managementClient.createTunnel(tunnelConfig, {
        tokenScopes: [import_dev_tunnels_contracts.TunnelAccessScopes.Host, import_dev_tunnels_contracts.TunnelAccessScopes.Connect],
        includePorts: true
      })
    );
    this.log("info", `Tunnel created: ${this.tunnel.tunnelId} (cluster: ${this.tunnel.clusterId})`);
    await saveTunnelConfig({
      tunnelId: this.tunnel.tunnelId,
      clusterId: this.tunnel.clusterId,
      createdAt: (/* @__PURE__ */ new Date()).toISOString()
    });
    this.log("debug", "Tunnel config saved");
    await this.connectToTunnel(rpcPort);
    this.log("info", "Tunnel connected");
    return {
      tunnelId: this.tunnel.tunnelId,
      clusterId: this.tunnel.clusterId,
      port: rpcPort,
      username: this.username
    };
  }
  async stop() {
    this.isDisposed = true;
    this.stopNetworkMonitoring();
    this.stopSleepDetection();
    for (const [clientId, socket] of this.clients) {
      if (!this.disconnectedClients.has(clientId)) {
        this.disconnectedClients.add(clientId);
        socket.destroy();
        this.disconnectHandlers.forEach((h) => h(clientId));
      }
    }
    this.clients.clear();
    if (this.host) {
      await this.host.dispose();
      this.host = null;
    }
    this.tunnel = null;
    this.managementClient = null;
    if (this.server) {
      await new Promise((resolve8) => {
        this.server.close(() => resolve8());
      });
      this.server = null;
    }
    this.disconnectedClients.clear();
  }
  onClientConnected(handler) {
    this.clientHandlers.push(handler);
    return () => {
      const index = this.clientHandlers.indexOf(handler);
      if (index !== -1) {
        this.clientHandlers.splice(index, 1);
      }
    };
  }
  onClientDisconnected(handler) {
    this.disconnectHandlers.push(handler);
    return () => {
      const index = this.disconnectHandlers.indexOf(handler);
      if (index !== -1) {
        this.disconnectHandlers.splice(index, 1);
      }
    };
  }
  createServer() {
    return new Promise((resolve8, reject) => {
      const server = net.createServer((socket) => {
        if (this.isDisposed) {
          socket.destroy();
          return;
        }
        const clientId = `client-${++this.clientCounter}`;
        this.clients.set(clientId, socket);
        this.log("debug", `Client ${clientId} connected (total clients: ${this.clients.size})`);
        const SOCKET_TIMEOUT_MS = 6e4;
        socket.setTimeout(SOCKET_TIMEOUT_MS);
        socket.on("timeout", () => {
          this.log("info", `Client ${clientId} socket timeout (no data in ${SOCKET_TIMEOUT_MS / 1e3}s)`);
          socket.destroy();
        });
        this.clientHandlers.forEach((h) => h(socket, clientId));
        socket.on("close", (hadError) => {
          if (this.disconnectedClients.has(clientId)) {
            this.log("debug", `Client ${clientId} already notified, skipping duplicate close event`);
            this.clients.delete(clientId);
            return;
          }
          this.disconnectedClients.add(clientId);
          const reason = hadError ? "connection_error" : "remote_closed";
          this.log("debug", `Client ${clientId} disconnected (${reason})`);
          this.clients.delete(clientId);
          this.disconnectHandlers.forEach((h) => h(clientId));
        });
        socket.on("error", (err) => {
          if (this.disconnectedClients.has(clientId)) {
            this.log("debug", `Client ${clientId} already notified, skipping duplicate error event`);
            return;
          }
          this.disconnectedClients.add(clientId);
          this.log("warn", `Client ${clientId} socket error: ${err.message}`);
          this.clients.delete(clientId);
          this.disconnectHandlers.forEach((h) => h(clientId));
        });
      });
      server.on("error", reject);
      server.listen(this.config.port || 0, () => {
        resolve8(server);
      });
    });
  }
  async connectWithTimeout(options, timeoutMs) {
    if (!this.host || !this.tunnel) {
      throw new Error("Host or tunnel not initialized");
    }
    const timeoutPromise = new Promise((_, reject) => {
      setTimeout(() => reject(new Error(`Connection timeout after ${timeoutMs}ms`)), timeoutMs);
    });
    await Promise.race([this.host.connect(this.tunnel, options), timeoutPromise]);
  }
  /**
   * Get a GitHub token for tunnel management.
   * Returns the stored access token if one exists (no expiry check  if it's
   * invalid, withAuthRetry() will handle the 401 and refresh/re-auth).
   * If no stored token exists, runs device flow to authenticate.
   * Also sets this.username for display purposes.
   */
  async getStoredOrNewToken() {
    this.log("debug", "Checking for cached GitHub token...");
    const tokenData = await loadTokenData();
    if (tokenData?.accessToken) {
      if (tokenData.username) {
        this.username = tokenData.username;
      } else {
        this.log("debug", "Fetching username for stored token...");
        this.username = await this.fetchGitHubUsername(tokenData.accessToken);
        if (this.username) {
          tokenData.username = this.username;
          await saveTokenData(tokenData);
        }
      }
      this.log("debug", "Using stored access token");
      return tokenData.accessToken;
    }
    this.log("info", "No stored credentials found");
    const newTokenData = await this.authenticateWithDeviceFlow();
    this.username = await this.fetchGitHubUsername(newTokenData.accessToken);
    newTokenData.username = this.username;
    this.log("debug", "Saving token data to secure storage...");
    await saveTokenData(newTokenData);
    this.log("info", `Authenticated as: ${this.username ?? "unknown"}`);
    return newTokenData.accessToken;
  }
  /**
   * Refresh an access token using a refresh token.
   */
  async refreshAccessToken(refreshToken) {
    const response = await fetch(GITHUB_TOKEN_URL, {
      method: "POST",
      headers: {
        Accept: "application/json",
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        client_id: GITHUB_CLIENT_ID,
        refresh_token: refreshToken,
        grant_type: "refresh_token"
      })
    });
    if (!response.ok) {
      throw new Error(`Failed to refresh token: ${response.statusText}`);
    }
    const token = await response.json();
    if (token.error) {
      throw new Error(`Token refresh error: ${token.error_description || token.error}`);
    }
    if (!token.access_token) {
      throw new Error("Token refresh failed: no access token in response");
    }
    const now = Date.now();
    return {
      accessToken: token.access_token,
      refreshToken: token.refresh_token || refreshToken,
      // May or may not return new refresh token
      expiresAt: now + (token.expires_in || 28800) * 1e3,
      refreshExpiresAt: now + (token.refresh_token_expires_in || 15638400) * 1e3
    };
  }
  /**
   * Fetch the GitHub username for the given token.
   * Returns undefined if the fetch fails.
   */
  async fetchGitHubUsername(token) {
    try {
      const response = await fetch("https://api.github.com/user", {
        headers: {
          Authorization: `Bearer ${token}`,
          Accept: "application/vnd.github.v3+json",
          "User-Agent": "AgentTunnels/1.0"
        }
      });
      if (response.ok) {
        const user = await response.json();
        return user.login;
      }
      return void 0;
    } catch {
      return void 0;
    }
  }
  /**
   * Clear the stored token. Call this when the server reports an auth error.
   */
  async clearStoredToken() {
    this.log("info", "Clearing stored token due to auth error");
    await clearTokenData();
  }
  /**
   * Authenticate using GitHub device code flow.
   * This allows users to authenticate without providing a token upfront.
   */
  async authenticateWithDeviceFlow() {
    this.log("debug", "Requesting device code from GitHub...");
    const deviceCodeResponse = await fetch(GITHUB_DEVICE_CODE_URL, {
      method: "POST",
      headers: {
        Accept: "application/json",
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        client_id: GITHUB_CLIENT_ID,
        scope: GITHUB_SCOPES
      })
    });
    if (!deviceCodeResponse.ok) {
      throw new Error(`Failed to get device code: ${deviceCodeResponse.statusText}`);
    }
    const deviceCode = await deviceCodeResponse.json();
    this.log("debug", `Device code received, user code: ${deviceCode.user_code}`);
    this.config.onAuth?.(
      "GitHub authentication required",
      deviceCode.verification_uri,
      deviceCode.user_code
    );
    this.log("debug", "Waiting for user to complete authentication...");
    const pollInterval = Math.max(deviceCode.interval * 1e3, DEVICE_CODE_POLL_INTERVAL_MS);
    const pollExpiresAt = Date.now() + deviceCode.expires_in * 1e3;
    while (Date.now() < pollExpiresAt) {
      await this.sleep(pollInterval);
      const tokenResponse = await fetch(GITHUB_TOKEN_URL, {
        method: "POST",
        headers: {
          Accept: "application/json",
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          client_id: GITHUB_CLIENT_ID,
          device_code: deviceCode.device_code,
          grant_type: "urn:ietf:params:oauth:grant-type:device_code"
        })
      });
      if (!tokenResponse.ok) {
        throw new Error(`Failed to poll for token: ${tokenResponse.statusText}`);
      }
      const token = await tokenResponse.json();
      if (token.access_token) {
        this.log("debug", "GitHub authentication completed successfully");
        const now = Date.now();
        return {
          accessToken: token.access_token,
          refreshToken: token.refresh_token || "",
          expiresAt: now + (token.expires_in || 28800) * 1e3,
          refreshExpiresAt: now + (token.refresh_token_expires_in || 15638400) * 1e3
        };
      }
      if (token.error === "authorization_pending") {
        this.log("debug", "Authorization pending, continuing to poll...");
        continue;
      }
      if (token.error === "slow_down") {
        this.log("debug", "Rate limited, slowing down polling...");
        await this.sleep(5e3);
        continue;
      }
      if (token.error === "expired_token") {
        throw new Error("Device code expired. Please try again.");
      }
      if (token.error === "access_denied") {
        throw new Error("Authentication was denied.");
      }
      if (token.error) {
        throw new Error(`Authentication error: ${token.error_description || token.error}`);
      }
    }
    throw new Error("Device code expired before authentication completed.");
  }
  sleep(ms) {
    return new Promise((resolve8) => setTimeout(resolve8, ms));
  }
};
function createTunnelHostAdapter(config) {
  return new DevTunnelHostAdapter(config);
}

// ../remote-sdk-protocol/dist/index.js
function isRequest(message) {
  return "method" in message && "id" in message && !("result" in message) && !("error" in message);
}
function isResponse(message) {
  return "id" in message && ("result" in message || "error" in message);
}
function isNotification(message) {
  return !("id" in message) && "method" in message;
}
var CONTENT_LENGTH_HEADER = "Content-Length: ";
var HEADER_DELIMITER = "\r\n\r\n";
function encodeJsonRpcMessageToBuffer(message) {
  const json = JSON.stringify(message);
  const header = `${CONTENT_LENGTH_HEADER}${Buffer.byteLength(json, "utf-8")}${HEADER_DELIMITER}`;
  return Buffer.from(header + json, "utf-8");
}
var JsonRpcDecoder = class {
  buffer = new Uint8Array(0);
  expectedLength = null;
  /**
   * Feed data into the decoder and return any complete messages.
   */
  decode(data) {
    const inputData = data instanceof Uint8Array ? data : new Uint8Array(data);
    const newBuffer = new Uint8Array(this.buffer.length + inputData.length);
    newBuffer.set(this.buffer, 0);
    newBuffer.set(inputData, this.buffer.length);
    this.buffer = newBuffer;
    const messages = [];
    const decoder = new TextDecoder();
    const headerDelimiterBytes = new TextEncoder().encode(HEADER_DELIMITER);
    while (true) {
      if (this.expectedLength === null) {
        const headerEndIndex = this.findSequence(this.buffer, headerDelimiterBytes);
        if (headerEndIndex === -1) {
          break;
        }
        const headerSection = decoder.decode(this.buffer.slice(0, headerEndIndex));
        const contentLengthMatch = headerSection.match(/Content-Length:\s*(\d+)/i);
        if (!contentLengthMatch) {
          this.buffer = this.buffer.slice(headerEndIndex + headerDelimiterBytes.length);
          continue;
        }
        this.expectedLength = parseInt(contentLengthMatch[1], 10);
        this.buffer = this.buffer.slice(headerEndIndex + headerDelimiterBytes.length);
      }
      if (this.buffer.length < this.expectedLength) {
        break;
      }
      const bodyBytes = this.buffer.slice(0, this.expectedLength);
      this.buffer = this.buffer.slice(this.expectedLength);
      this.expectedLength = null;
      try {
        const body = decoder.decode(bodyBytes);
        const message = JSON.parse(body);
        messages.push(message);
      } catch (err) {
        console.error("Failed to parse JSON-RPC message:", err);
      }
    }
    return messages;
  }
  /**
   * Find the index of a byte sequence in a buffer.
   */
  findSequence(buffer, sequence) {
    outer: for (let i = 0; i <= buffer.length - sequence.length; i++) {
      for (let j = 0; j < sequence.length; j++) {
        if (buffer[i + j] !== sequence[j]) {
          continue outer;
        }
      }
      return i;
    }
    return -1;
  }
  /**
   * Reset the decoder state.
   */
  reset() {
    this.buffer = new Uint8Array(0);
    this.expectedLength = null;
  }
};
var SUPPORTED_MODELS = [
  { id: "claude-sonnet-4.5", label: "Claude Sonnet 4.5", multiplier: 1, isAvailable: true },
  { id: "claude-haiku-4.5", label: "Claude Haiku 4.5", multiplier: 0.33, isAvailable: true },
  { id: "claude-opus-4.5", label: "Claude Opus 4.5", multiplier: 1, isAvailable: true },
  { id: "claude-sonnet-4", label: "Claude Sonnet 4", multiplier: 1, isAvailable: true },
  { id: "gpt-5", label: "GPT-5", multiplier: 1, isAvailable: true },
  { id: "gpt-5.1", label: "GPT-5.1", multiplier: 1, isAvailable: true },
  { id: "gpt-5.1-codex", label: "GPT-5.1 Codex", multiplier: 1, isAvailable: true },
  { id: "gpt-5.1-codex-mini", label: "GPT-5.1 Codex Mini", multiplier: 0.33, isAvailable: true },
  { id: "gpt-5-mini", label: "GPT-5 Mini", multiplier: 0, isAvailable: true },
  { id: "gpt-4.1", label: "GPT-4.1", multiplier: 0, isAvailable: true },
  { id: "gemini-3-pro-preview", label: "Gemini 3 Pro Preview", multiplier: 1, isAvailable: true }
];
var DEFAULT_MODEL = "claude-sonnet-4.5";

// src/cli-process.ts
var import_node_child_process = require("child_process");
var import_node_events = require("events");
var import_node_os = require("os");
var import_node_path = require("path");
var import_node_fs = require("fs");
var activeChildProcesses = /* @__PURE__ */ new Set();
process.on("exit", () => {
  for (const child of activeChildProcesses) {
    try {
      child.kill("SIGTERM");
    } catch {
    }
  }
});
function getCopilotExecutableNames() {
  if (process.platform === "win32") {
    return ["copilot.exe", "copilot.cmd", "copilot.bat"];
  }
  return ["copilot"];
}
function findCopilotInDir(dir) {
  if (!dir) return void 0;
  for (const name of getCopilotExecutableNames()) {
    const candidate = (0, import_node_path.join)(dir, name);
    if ((0, import_node_fs.existsSync)(candidate)) {
      return candidate;
    }
  }
  return void 0;
}
function collectSearchPaths() {
  const paths = [];
  const pathEnv = process.env.PATH || "";
  paths.push(...pathEnv.split(process.platform === "win32" ? ";" : ":"));
  const home = (0, import_node_os.homedir)();
  paths.push((0, import_node_path.join)(home, ".local", "bin"));
  paths.push((0, import_node_path.join)(home, ".npm-global", "bin"));
  paths.push((0, import_node_path.join)(home, ".yarn", "bin"));
  paths.push((0, import_node_path.join)(home, ".volta", "bin"));
  paths.push((0, import_node_path.join)(home, ".asdf", "shims"));
  paths.push((0, import_node_path.join)(home, "bin"));
  if (process.platform === "darwin") {
    paths.push("/opt/homebrew/bin");
    paths.push("/usr/local/bin");
    paths.push("/usr/bin");
    paths.push("/bin");
    paths.push("/usr/sbin");
    paths.push("/sbin");
  } else if (process.platform === "linux") {
    paths.push("/usr/local/bin");
    paths.push("/usr/bin");
    paths.push("/bin");
    paths.push("/snap/bin");
  } else if (process.platform === "win32") {
    const appdata = process.env.APPDATA;
    const localAppdata = process.env.LOCALAPPDATA;
    if (appdata) paths.push((0, import_node_path.join)(appdata, "npm"));
    if (localAppdata) paths.push((0, import_node_path.join)(localAppdata, "Programs"));
  }
  const unique = [];
  const seen = /* @__PURE__ */ new Set();
  for (const p of paths) {
    if (p && !seen.has(p)) {
      seen.add(p);
      unique.push(p);
    }
  }
  return unique;
}
function resolveCopilotBinary(explicitPath) {
  if (explicitPath) {
    if ((0, import_node_fs.existsSync)(explicitPath)) {
      return explicitPath;
    }
    const found = findCopilotInDir(explicitPath);
    if (found) return found;
  }
  const envPath = process.env.COPILOT_CLI_PATH;
  if (envPath) {
    if ((0, import_node_fs.existsSync)(envPath)) {
      return envPath;
    }
    const found = findCopilotInDir(envPath);
    if (found) return found;
  }
  for (const dir of collectSearchPaths()) {
    const found = findCopilotInDir(dir);
    if (found) return found;
  }
  throw new Error(
    "Copilot CLI not found. Ensure `copilot` is installed and on PATH, or set COPILOT_CLI_PATH."
  );
}
var CliProcess = class extends import_node_events.EventEmitter {
  constructor(options) {
    super();
    this.options = options;
    this.cwd = options.cwd;
    this.log = options.log ?? ((level, message) => {
      if (level === "error") {
        console.error(message);
      } else if (level === "warn") {
        console.warn(message);
      } else {
        console.log(message);
      }
    });
  }
  child = null;
  decoder = new JsonRpcDecoder();
  requestId = 0;
  pendingRequests = /* @__PURE__ */ new Map();
  _isAlive = false;
  log;
  cwd;
  /**
   * Spawn the copilot CLI process.
   */
  async spawn() {
    const cliPath = resolveCopilotBinary(this.options.cliPath);
    this.log("debug", `[CliProcess] Spawning CLI for: ${this.cwd}`);
    const args = ["--server", "--stdio", "--log-level", this.options.logLevel ?? "info"];
    this.child = (0, import_node_child_process.spawn)(cliPath, args, {
      cwd: this.cwd,
      env: {
        ...process.env,
        ...this.options.env,
        // Enable background agents + unified task tool for sub-agent orchestration
        COPILOT_SWE_AGENT_UNIFIED_TASK_TOOL: "true",
        COPILOT_SWE_AGENT_BACKGROUND_AGENTS: "true"
      },
      stdio: ["pipe", "pipe", "pipe"]
    });
    if (!this.child.stdin || !this.child.stdout) {
      throw new Error("Failed to capture stdin/stdout");
    }
    activeChildProcesses.add(this.child);
    this.child.stdout.on("data", (data) => {
      this.handleStdout(data);
    });
    this.child.stderr?.on("data", (data) => {
      const lines = data.toString().split("\n").filter(Boolean);
      for (const line of lines) {
        console.debug(`[CLI stderr] ${line}`);
      }
    });
    this.child.on("exit", (code) => {
      console.log(`[CliProcess] Process exited with code ${code}`);
      activeChildProcesses.delete(this.child);
      this._isAlive = false;
      this.rejectAllPending(new Error(`CLI process exited with code ${code}`));
      this.emit("exit", code);
    });
    this.child.on("error", (err) => {
      console.error(`[CliProcess] Process error:`, err);
      activeChildProcesses.delete(this.child);
      this._isAlive = false;
      this.rejectAllPending(err);
      this.emit("error", err);
    });
    this._isAlive = true;
  }
  /**
   * Check if the CLI process is alive.
   */
  get isAlive() {
    return this._isAlive;
  }
  /**
   * Send a JSON-RPC request and wait for response.
   * @param method - The JSON-RPC method name
   * @param params - Optional parameters for the method
   * @param timeoutMs - Request timeout in milliseconds (default: 30000, use 0 for no timeout)
   */
  async sendRequest(method, params, timeoutMs = 3e4) {
    if (!this.child?.stdin || !this._isAlive) {
      throw new Error("CLI process not running");
    }
    const id = ++this.requestId;
    const request = {
      jsonrpc: "2.0",
      id,
      method,
      params
    };
    return new Promise((resolve8, reject) => {
      let timeoutId;
      const cleanup = () => {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        this.pendingRequests.delete(id);
      };
      if (timeoutMs > 0) {
        timeoutId = setTimeout(() => {
          cleanup();
          reject(new Error(`Request timeout after ${timeoutMs}ms: ${method} (id: ${id})`));
        }, timeoutMs);
      }
      this.pendingRequests.set(id, {
        resolve: (response) => {
          cleanup();
          if (response.error) {
            reject(new Error(response.error.message));
          } else {
            resolve8(response.result);
          }
        },
        reject: (err) => {
          cleanup();
          reject(err);
        }
      });
      this.writeMessage(request);
    });
  }
  /**
   * Send a JSON-RPC response (for incoming requests like tool.call).
   */
  async sendResponse(id, result, error) {
    if (!this.child?.stdin || !this._isAlive) {
      throw new Error("CLI process not running");
    }
    const response = {
      jsonrpc: "2.0",
      id,
      ...error ? { error } : { result }
    };
    this.writeMessage(response);
  }
  /**
   * Ping the CLI to check if it's responsive.
   */
  async ping() {
    try {
      await this.sendRequest("ping", {});
      return true;
    } catch {
      return false;
    }
  }
  /**
   * Kill the CLI process.
   */
  async kill() {
    if (this.child) {
      console.log(`[CliProcess] Killing CLI process for: ${this.cwd}`);
      activeChildProcesses.delete(this.child);
      this.child.kill();
      this.child = null;
      this._isAlive = false;
    }
  }
  /**
   * Write a JSON-RPC message to stdin with LSP framing.
   */
  writeMessage(message) {
    if (!this.child?.stdin) return;
    const buffer = encodeJsonRpcMessageToBuffer(message);
    this.child.stdin.write(buffer);
  }
  /**
   * Handle data from stdout - decode and route messages.
   */
  handleStdout(data) {
    const messages = this.decoder.decode(data);
    for (const message of messages) {
      this.routeMessage(message);
    }
  }
  /**
   * Route a decoded message to the appropriate handler.
   */
  routeMessage(message) {
    if (isResponse(message)) {
      const pending = this.pendingRequests.get(message.id);
      if (pending) {
        this.pendingRequests.delete(message.id);
        pending.resolve(message);
      } else {
        console.warn(`[CliProcess] Received response for unknown request id: ${message.id}`);
      }
    } else if (isNotification(message)) {
      this.emit("notification", message);
    } else if (isRequest(message)) {
      this.emit("request", message);
    }
  }
  /**
   * Reject all pending requests (on process exit/error).
   */
  rejectAllPending(error) {
    const entries = [...this.pendingRequests.entries()];
    this.pendingRequests.clear();
    for (const [, pending] of entries) {
      pending.reject(error);
    }
  }
};

// src/file-search-service.ts
var import_promises = require("fs/promises");
var import_node_path2 = require("path");

// ../../node_modules/fdir/dist/index.mjs
var import_module = require("module");
var import_path = require("path");
var nativeFs = __toESM(require("fs"), 1);
var __require = /* @__PURE__ */ (0, import_module.createRequire)(__bundled_import_meta_url);
function cleanPath(path11) {
  let normalized = (0, import_path.normalize)(path11);
  if (normalized.length > 1 && normalized[normalized.length - 1] === import_path.sep) normalized = normalized.substring(0, normalized.length - 1);
  return normalized;
}
var SLASHES_REGEX = /[\\/]/g;
function convertSlashes(path11, separator) {
  return path11.replace(SLASHES_REGEX, separator);
}
var WINDOWS_ROOT_DIR_REGEX = /^[a-z]:[\\/]$/i;
function isRootDirectory(path11) {
  return path11 === "/" || WINDOWS_ROOT_DIR_REGEX.test(path11);
}
function normalizePath(path11, options) {
  const { resolvePaths, normalizePath: normalizePath$1, pathSeparator } = options;
  const pathNeedsCleaning = process.platform === "win32" && path11.includes("/") || path11.startsWith(".");
  if (resolvePaths) path11 = (0, import_path.resolve)(path11);
  if (normalizePath$1 || pathNeedsCleaning) path11 = cleanPath(path11);
  if (path11 === ".") return "";
  const needsSeperator = path11[path11.length - 1] !== pathSeparator;
  return convertSlashes(needsSeperator ? path11 + pathSeparator : path11, pathSeparator);
}
function joinPathWithBasePath(filename, directoryPath) {
  return directoryPath + filename;
}
function joinPathWithRelativePath(root, options) {
  return function(filename, directoryPath) {
    const sameRoot = directoryPath.startsWith(root);
    if (sameRoot) return directoryPath.slice(root.length) + filename;
    else return convertSlashes((0, import_path.relative)(root, directoryPath), options.pathSeparator) + options.pathSeparator + filename;
  };
}
function joinPath(filename) {
  return filename;
}
function joinDirectoryPath(filename, directoryPath, separator) {
  return directoryPath + filename + separator;
}
function build$7(root, options) {
  const { relativePaths, includeBasePath } = options;
  return relativePaths && root ? joinPathWithRelativePath(root, options) : includeBasePath ? joinPathWithBasePath : joinPath;
}
function pushDirectoryWithRelativePath(root) {
  return function(directoryPath, paths) {
    paths.push(directoryPath.substring(root.length) || ".");
  };
}
function pushDirectoryFilterWithRelativePath(root) {
  return function(directoryPath, paths, filters) {
    const relativePath = directoryPath.substring(root.length) || ".";
    if (filters.every((filter) => filter(relativePath, true))) paths.push(relativePath);
  };
}
var pushDirectory = (directoryPath, paths) => {
  paths.push(directoryPath || ".");
};
var pushDirectoryFilter = (directoryPath, paths, filters) => {
  const path11 = directoryPath || ".";
  if (filters.every((filter) => filter(path11, true))) paths.push(path11);
};
var empty$2 = () => {
};
function build$6(root, options) {
  const { includeDirs, filters, relativePaths } = options;
  if (!includeDirs) return empty$2;
  if (relativePaths) return filters && filters.length ? pushDirectoryFilterWithRelativePath(root) : pushDirectoryWithRelativePath(root);
  return filters && filters.length ? pushDirectoryFilter : pushDirectory;
}
var pushFileFilterAndCount = (filename, _paths, counts, filters) => {
  if (filters.every((filter) => filter(filename, false))) counts.files++;
};
var pushFileFilter = (filename, paths, _counts, filters) => {
  if (filters.every((filter) => filter(filename, false))) paths.push(filename);
};
var pushFileCount = (_filename, _paths, counts, _filters) => {
  counts.files++;
};
var pushFile = (filename, paths) => {
  paths.push(filename);
};
var empty$1 = () => {
};
function build$5(options) {
  const { excludeFiles, filters, onlyCounts } = options;
  if (excludeFiles) return empty$1;
  if (filters && filters.length) return onlyCounts ? pushFileFilterAndCount : pushFileFilter;
  else if (onlyCounts) return pushFileCount;
  else return pushFile;
}
var getArray = (paths) => {
  return paths;
};
var getArrayGroup = () => {
  return [""].slice(0, 0);
};
function build$4(options) {
  return options.group ? getArrayGroup : getArray;
}
var groupFiles = (groups, directory, files) => {
  groups.push({
    directory,
    files,
    dir: directory
  });
};
var empty = () => {
};
function build$3(options) {
  return options.group ? groupFiles : empty;
}
var resolveSymlinksAsync = function(path11, state, callback$1) {
  const { queue, fs: fs10, options: { suppressErrors } } = state;
  queue.enqueue();
  fs10.realpath(path11, (error, resolvedPath) => {
    if (error) return queue.dequeue(suppressErrors ? null : error, state);
    fs10.stat(resolvedPath, (error$1, stat3) => {
      if (error$1) return queue.dequeue(suppressErrors ? null : error$1, state);
      if (stat3.isDirectory() && isRecursive(path11, resolvedPath, state)) return queue.dequeue(null, state);
      callback$1(stat3, resolvedPath);
      queue.dequeue(null, state);
    });
  });
};
var resolveSymlinks = function(path11, state, callback$1) {
  const { queue, fs: fs10, options: { suppressErrors } } = state;
  queue.enqueue();
  try {
    const resolvedPath = fs10.realpathSync(path11);
    const stat3 = fs10.statSync(resolvedPath);
    if (stat3.isDirectory() && isRecursive(path11, resolvedPath, state)) return;
    callback$1(stat3, resolvedPath);
  } catch (e) {
    if (!suppressErrors) throw e;
  }
};
function build$2(options, isSynchronous) {
  if (!options.resolveSymlinks || options.excludeSymlinks) return null;
  return isSynchronous ? resolveSymlinks : resolveSymlinksAsync;
}
function isRecursive(path11, resolved, state) {
  if (state.options.useRealPaths) return isRecursiveUsingRealPaths(resolved, state);
  let parent = (0, import_path.dirname)(path11);
  let depth = 1;
  while (parent !== state.root && depth < 2) {
    const resolvedPath = state.symlinks.get(parent);
    const isSameRoot = !!resolvedPath && (resolvedPath === resolved || resolvedPath.startsWith(resolved) || resolved.startsWith(resolvedPath));
    if (isSameRoot) depth++;
    else parent = (0, import_path.dirname)(parent);
  }
  state.symlinks.set(path11, resolved);
  return depth > 1;
}
function isRecursiveUsingRealPaths(resolved, state) {
  return state.visited.includes(resolved + state.options.pathSeparator);
}
var onlyCountsSync = (state) => {
  return state.counts;
};
var groupsSync = (state) => {
  return state.groups;
};
var defaultSync = (state) => {
  return state.paths;
};
var limitFilesSync = (state) => {
  return state.paths.slice(0, state.options.maxFiles);
};
var onlyCountsAsync = (state, error, callback$1) => {
  report(error, callback$1, state.counts, state.options.suppressErrors);
  return null;
};
var defaultAsync = (state, error, callback$1) => {
  report(error, callback$1, state.paths, state.options.suppressErrors);
  return null;
};
var limitFilesAsync = (state, error, callback$1) => {
  report(error, callback$1, state.paths.slice(0, state.options.maxFiles), state.options.suppressErrors);
  return null;
};
var groupsAsync = (state, error, callback$1) => {
  report(error, callback$1, state.groups, state.options.suppressErrors);
  return null;
};
function report(error, callback$1, output, suppressErrors) {
  if (error && !suppressErrors) callback$1(error, output);
  else callback$1(null, output);
}
function build$1(options, isSynchronous) {
  const { onlyCounts, group, maxFiles } = options;
  if (onlyCounts) return isSynchronous ? onlyCountsSync : onlyCountsAsync;
  else if (group) return isSynchronous ? groupsSync : groupsAsync;
  else if (maxFiles) return isSynchronous ? limitFilesSync : limitFilesAsync;
  else return isSynchronous ? defaultSync : defaultAsync;
}
var readdirOpts = { withFileTypes: true };
var walkAsync = (state, crawlPath, directoryPath, currentDepth, callback$1) => {
  state.queue.enqueue();
  if (currentDepth < 0) return state.queue.dequeue(null, state);
  const { fs: fs10 } = state;
  state.visited.push(crawlPath);
  state.counts.directories++;
  fs10.readdir(crawlPath || ".", readdirOpts, (error, entries = []) => {
    callback$1(entries, directoryPath, currentDepth);
    state.queue.dequeue(state.options.suppressErrors ? null : error, state);
  });
};
var walkSync = (state, crawlPath, directoryPath, currentDepth, callback$1) => {
  const { fs: fs10 } = state;
  if (currentDepth < 0) return;
  state.visited.push(crawlPath);
  state.counts.directories++;
  let entries = [];
  try {
    entries = fs10.readdirSync(crawlPath || ".", readdirOpts);
  } catch (e) {
    if (!state.options.suppressErrors) throw e;
  }
  callback$1(entries, directoryPath, currentDepth);
};
function build(isSynchronous) {
  return isSynchronous ? walkSync : walkAsync;
}
var Queue = class {
  count = 0;
  constructor(onQueueEmpty) {
    this.onQueueEmpty = onQueueEmpty;
  }
  enqueue() {
    this.count++;
    return this.count;
  }
  dequeue(error, output) {
    if (this.onQueueEmpty && (--this.count <= 0 || error)) {
      this.onQueueEmpty(error, output);
      if (error) {
        output.controller.abort();
        this.onQueueEmpty = void 0;
      }
    }
  }
};
var Counter = class {
  _files = 0;
  _directories = 0;
  set files(num) {
    this._files = num;
  }
  get files() {
    return this._files;
  }
  set directories(num) {
    this._directories = num;
  }
  get directories() {
    return this._directories;
  }
  /**
  * @deprecated use `directories` instead
  */
  /* c8 ignore next 3 */
  get dirs() {
    return this._directories;
  }
};
var Aborter = class {
  aborted = false;
  abort() {
    this.aborted = true;
  }
};
var Walker = class {
  root;
  isSynchronous;
  state;
  joinPath;
  pushDirectory;
  pushFile;
  getArray;
  groupFiles;
  resolveSymlink;
  walkDirectory;
  callbackInvoker;
  constructor(root, options, callback$1) {
    this.isSynchronous = !callback$1;
    this.callbackInvoker = build$1(options, this.isSynchronous);
    this.root = normalizePath(root, options);
    this.state = {
      root: isRootDirectory(this.root) ? this.root : this.root.slice(0, -1),
      paths: [""].slice(0, 0),
      groups: [],
      counts: new Counter(),
      options,
      queue: new Queue((error, state) => this.callbackInvoker(state, error, callback$1)),
      symlinks: /* @__PURE__ */ new Map(),
      visited: [""].slice(0, 0),
      controller: new Aborter(),
      fs: options.fs || nativeFs
    };
    this.joinPath = build$7(this.root, options);
    this.pushDirectory = build$6(this.root, options);
    this.pushFile = build$5(options);
    this.getArray = build$4(options);
    this.groupFiles = build$3(options);
    this.resolveSymlink = build$2(options, this.isSynchronous);
    this.walkDirectory = build(this.isSynchronous);
  }
  start() {
    this.pushDirectory(this.root, this.state.paths, this.state.options.filters);
    this.walkDirectory(this.state, this.root, this.root, this.state.options.maxDepth, this.walk);
    return this.isSynchronous ? this.callbackInvoker(this.state, null) : null;
  }
  walk = (entries, directoryPath, depth) => {
    const { paths, options: { filters, resolveSymlinks: resolveSymlinks$1, excludeSymlinks, exclude, maxFiles, signal, useRealPaths, pathSeparator }, controller } = this.state;
    if (controller.aborted || signal && signal.aborted || maxFiles && paths.length > maxFiles) return;
    const files = this.getArray(this.state.paths);
    for (let i = 0; i < entries.length; ++i) {
      const entry = entries[i];
      if (entry.isFile() || entry.isSymbolicLink() && !resolveSymlinks$1 && !excludeSymlinks) {
        const filename = this.joinPath(entry.name, directoryPath);
        this.pushFile(filename, files, this.state.counts, filters);
      } else if (entry.isDirectory()) {
        let path11 = joinDirectoryPath(entry.name, directoryPath, this.state.options.pathSeparator);
        if (exclude && exclude(entry.name, path11)) continue;
        this.pushDirectory(path11, paths, filters);
        this.walkDirectory(this.state, path11, path11, depth - 1, this.walk);
      } else if (this.resolveSymlink && entry.isSymbolicLink()) {
        let path11 = joinPathWithBasePath(entry.name, directoryPath);
        this.resolveSymlink(path11, this.state, (stat3, resolvedPath) => {
          if (stat3.isDirectory()) {
            resolvedPath = normalizePath(resolvedPath, this.state.options);
            if (exclude && exclude(entry.name, useRealPaths ? resolvedPath : path11 + pathSeparator)) return;
            this.walkDirectory(this.state, resolvedPath, useRealPaths ? resolvedPath : path11 + pathSeparator, depth - 1, this.walk);
          } else {
            resolvedPath = useRealPaths ? resolvedPath : path11;
            const filename = (0, import_path.basename)(resolvedPath);
            const directoryPath$1 = normalizePath((0, import_path.dirname)(resolvedPath), this.state.options);
            resolvedPath = this.joinPath(filename, directoryPath$1);
            this.pushFile(resolvedPath, files, this.state.counts, filters);
          }
        });
      }
    }
    this.groupFiles(this.state.groups, directoryPath, files);
  };
};
function promise(root, options) {
  return new Promise((resolve$1, reject) => {
    callback(root, options, (err, output) => {
      if (err) return reject(err);
      resolve$1(output);
    });
  });
}
function callback(root, options, callback$1) {
  let walker = new Walker(root, options, callback$1);
  walker.start();
}
function sync(root, options) {
  const walker = new Walker(root, options);
  return walker.start();
}
var APIBuilder = class {
  constructor(root, options) {
    this.root = root;
    this.options = options;
  }
  withPromise() {
    return promise(this.root, this.options);
  }
  withCallback(cb) {
    callback(this.root, this.options, cb);
  }
  sync() {
    return sync(this.root, this.options);
  }
};
var pm = null;
try {
  __require.resolve("picomatch");
  pm = __require("picomatch");
} catch {
}
var Builder = class {
  globCache = {};
  options = {
    maxDepth: Infinity,
    suppressErrors: true,
    pathSeparator: import_path.sep,
    filters: []
  };
  globFunction;
  constructor(options) {
    this.options = {
      ...this.options,
      ...options
    };
    this.globFunction = this.options.globFunction;
  }
  group() {
    this.options.group = true;
    return this;
  }
  withPathSeparator(separator) {
    this.options.pathSeparator = separator;
    return this;
  }
  withBasePath() {
    this.options.includeBasePath = true;
    return this;
  }
  withRelativePaths() {
    this.options.relativePaths = true;
    return this;
  }
  withDirs() {
    this.options.includeDirs = true;
    return this;
  }
  withMaxDepth(depth) {
    this.options.maxDepth = depth;
    return this;
  }
  withMaxFiles(limit) {
    this.options.maxFiles = limit;
    return this;
  }
  withFullPaths() {
    this.options.resolvePaths = true;
    this.options.includeBasePath = true;
    return this;
  }
  withErrors() {
    this.options.suppressErrors = false;
    return this;
  }
  withSymlinks({ resolvePaths = true } = {}) {
    this.options.resolveSymlinks = true;
    this.options.useRealPaths = resolvePaths;
    return this.withFullPaths();
  }
  withAbortSignal(signal) {
    this.options.signal = signal;
    return this;
  }
  normalize() {
    this.options.normalizePath = true;
    return this;
  }
  filter(predicate) {
    this.options.filters.push(predicate);
    return this;
  }
  onlyDirs() {
    this.options.excludeFiles = true;
    this.options.includeDirs = true;
    return this;
  }
  exclude(predicate) {
    this.options.exclude = predicate;
    return this;
  }
  onlyCounts() {
    this.options.onlyCounts = true;
    return this;
  }
  crawl(root) {
    return new APIBuilder(root || ".", this.options);
  }
  withGlobFunction(fn) {
    this.globFunction = fn;
    return this;
  }
  /**
  * @deprecated Pass options using the constructor instead:
  * ```ts
  * new fdir(options).crawl("/path/to/root");
  * ```
  * This method will be removed in v7.0
  */
  /* c8 ignore next 4 */
  crawlWithOptions(root, options) {
    this.options = {
      ...this.options,
      ...options
    };
    return new APIBuilder(root || ".", this.options);
  }
  glob(...patterns) {
    if (this.globFunction) return this.globWithOptions(patterns);
    return this.globWithOptions(patterns, ...[{ dot: true }]);
  }
  globWithOptions(patterns, ...options) {
    const globFn = this.globFunction || pm;
    if (!globFn) throw new Error("Please specify a glob function to use glob matching.");
    var isMatch = this.globCache[patterns.join("\0")];
    if (!isMatch) {
      isMatch = globFn(patterns, ...options);
      this.globCache[patterns.join("\0")] = isMatch;
    }
    this.options.filters.push((path11) => isMatch(path11));
    return this;
  }
};

// src/file-search-service.ts
var import_picomatch = __toESM(require_picomatch2(), 1);
var ALWAYS_IGNORED_DIRS = [
  "node_modules",
  ".git",
  "dist",
  "build",
  ".next",
  "coverage",
  "__pycache__",
  ".cache",
  ".turbo",
  ".parcel-cache",
  "out",
  ".svn",
  ".hg",
  "vendor",
  ".venv",
  "venv",
  ".tox"
];
var ALWAYS_IGNORED_PATTERNS = [
  "*.pyc",
  "*.pyo",
  "*.class",
  "*.o",
  "*.obj",
  "*.swp",
  "*.swo",
  "*~",
  ".DS_Store",
  "Thumbs.db",
  "*.log",
  "*.tmp",
  "*.lock",
  "package-lock.json",
  "yarn.lock",
  "pnpm-lock.yaml"
];
function fuzzyMatch(query, target) {
  const lowerQuery = query.toLowerCase();
  const lowerTarget = target.toLowerCase();
  let queryIdx = 0;
  let score = 0;
  let consecutiveMatches = 0;
  let lastMatchIdx = -1;
  for (let i = 0; i < lowerTarget.length && queryIdx < lowerQuery.length; i++) {
    if (lowerTarget[i] === lowerQuery[queryIdx]) {
      if (lastMatchIdx === i - 1) {
        consecutiveMatches++;
        score += consecutiveMatches * 2;
      } else {
        consecutiveMatches = 1;
        score += 1;
      }
      if (i === 0 || lowerTarget[i - 1] === "/" || lowerTarget[i - 1] === "-" || lowerTarget[i - 1] === "_" || lowerTarget[i - 1] === ".") {
        score += 5;
      }
      lastMatchIdx = i;
      queryIdx++;
    }
  }
  return {
    match: queryIdx === lowerQuery.length,
    score
  };
}
var FileSearchService = class {
  indexes = /* @__PURE__ */ new Map();
  cacheTtl;
  constructor(options = {}) {
    this.cacheTtl = options.cacheTtl ?? 5 * 60 * 1e3;
  }
  /**
   * Search for files matching a query.
   */
  async search(request) {
    const { query, cwd, maxResults = 50, includeDirs = false } = request;
    const { files, freshIndex } = await this.getIndex(cwd, includeDirs);
    const results = await this.performSearch(files, query, maxResults);
    return {
      results,
      totalIndexed: files.length,
      freshIndex
    };
  }
  /**
   * Force refresh index for a working directory.
   */
  invalidate(cwd) {
    for (const key of this.indexes.keys()) {
      if (key.startsWith(cwd)) {
        this.indexes.delete(key);
      }
    }
  }
  // ===========================================================================
  // Private Methods
  // ===========================================================================
  async getIndex(cwd, includeDirs) {
    const key = `${cwd}:${includeDirs}`;
    const cached = this.indexes.get(key);
    if (cached && Date.now() - cached.createdAt < this.cacheTtl) {
      return { files: cached.files, freshIndex: false };
    }
    const files = await this.buildIndex(cwd, includeDirs);
    this.indexes.set(key, { files, createdAt: Date.now() });
    return { files, freshIndex: true };
  }
  async buildIndex(cwd, includeDirs) {
    const ignorePatterns = await this.loadIgnorePatterns(cwd);
    const allIgnorePatterns = [...ALWAYS_IGNORED_PATTERNS, ...ignorePatterns];
    const isIgnoredFile = (0, import_picomatch.default)(allIgnorePatterns, { dot: true });
    const ignoredDirSet = new Set(ALWAYS_IGNORED_DIRS);
    const crawler = new Builder().withRelativePaths().exclude((dirName) => {
      return ignoredDirSet.has(dirName);
    });
    if (includeDirs) {
      crawler.withDirs();
    }
    const allPaths = await crawler.crawl(cwd).withPromise();
    const filteredFiles = allPaths.filter((filePath) => {
      const fileName = (0, import_node_path2.basename)(filePath);
      return !isIgnoredFile(fileName);
    });
    return filteredFiles;
  }
  async loadIgnorePatterns(cwd) {
    const patterns = [];
    try {
      const gitignorePath = (0, import_node_path2.join)(cwd, ".gitignore");
      const content = await (0, import_promises.readFile)(gitignorePath, "utf-8");
      const lines = content.split("\n").map((line) => line.trim()).filter((line) => line && !line.startsWith("#"));
      patterns.push(...lines);
    } catch {
    }
    return patterns;
  }
  async performSearch(files, query, maxResults) {
    if (!query) {
      return files.slice().sort((a, b) => a.length - b.length).slice(0, maxResults).map((path11) => ({
        path: path11,
        type: this.getType(path11),
        score: 0
      }));
    }
    if (query.includes("*") || query.includes("?")) {
      const matcher = (0, import_picomatch.default)(query, { nocase: true, dot: true });
      return files.filter((f) => matcher(f)).slice(0, maxResults).map((path11) => ({
        path: path11,
        type: this.getType(path11),
        score: 1
      }));
    }
    const results = [];
    for (const filePath of files) {
      const { match, score: fuzzyScore } = fuzzyMatch(query, filePath);
      if (match) {
        const totalScore = this.calculateScore(filePath, query, fuzzyScore);
        results.push({ path: filePath, score: totalScore });
      }
    }
    return results.sort((a, b) => b.score - a.score).slice(0, maxResults).map(({ path: path11, score }) => ({
      path: path11,
      type: this.getType(path11),
      score
    }));
  }
  calculateScore(filePath, query, fuzzyScore) {
    const lowerPath = filePath.toLowerCase();
    const lowerQuery = query.toLowerCase();
    const filename = (0, import_node_path2.basename)(filePath).toLowerCase();
    if (lowerPath === lowerQuery) {
      return 1e3 + fuzzyScore;
    }
    if (filename === lowerQuery) {
      return 800 + fuzzyScore;
    }
    if (filename.startsWith(lowerQuery)) {
      return 600 + fuzzyScore;
    }
    if (lowerPath.includes("/" + lowerQuery) || lowerPath.includes(lowerQuery + "/")) {
      return 500 + fuzzyScore;
    }
    if (lowerPath.includes(lowerQuery)) {
      return 400 + fuzzyScore;
    }
    return fuzzyScore;
  }
  getType(filePath) {
    return filePath.endsWith("/") ? "directory" : "file";
  }
};

// src/fs/disk-fs-provider.ts
var fs4 = __toESM(require("fs/promises"), 1);
var nodePath = __toESM(require("path"), 1);

// src/shared/event-emitter.ts
var EventEmitter2 = class {
  /**
   * Set of registered listeners.
   *
   * Using a Set ensures:
   * - O(1) add/remove operations
   * - No duplicate listeners
   * - Iteration order matches insertion order
   */
  listeners = /* @__PURE__ */ new Set();
  /**
   * Whether this emitter has been disposed.
   *
   * Once disposed, no new listeners can be added and fire() is a no-op.
   */
  disposed = false;
  /**
   * The public event property for subscribing.
   *
   * This is a function that takes a listener and returns a disposable.
   * Consumers use this to subscribe to events.
   *
   * @example
   * ```typescript
   * const subscription = emitter.event((data) => {
   *   console.log('Received:', data);
   * });
   * ```
   */
  event = (listener) => {
    if (this.disposed) {
      return { dispose: () => {
      } };
    }
    this.listeners.add(listener);
    return {
      dispose: () => {
        this.listeners.delete(listener);
      }
    };
  };
  /**
   * Fire the event, notifying all listeners.
   *
   * Listeners are called synchronously in insertion order.
   * Errors in listeners are caught and logged to prevent one
   * bad listener from breaking others.
   *
   * @param data - The event data to pass to listeners
   */
  fire(data) {
    if (this.disposed) {
      return;
    }
    const listenersSnapshot = [...this.listeners];
    for (const listener of listenersSnapshot) {
      try {
        listener(data);
      } catch (error) {
        console.error("[EventEmitter] Listener threw an error:", error);
      }
    }
  }
  /**
   * Check if there are any registered listeners.
   *
   * Useful for optimization - skip work if no one is listening.
   */
  hasListeners() {
    return this.listeners.size > 0;
  }
  /**
   * Get the number of registered listeners.
   *
   * Useful for debugging and testing.
   */
  get listenerCount() {
    return this.listeners.size;
  }
  /**
   * Dispose the emitter, clearing all listeners.
   *
   * After disposal:
   * - All existing listeners are removed
   * - New subscriptions return no-op disposables
   * - fire() becomes a no-op
   *
   * This should be called when the owning object is disposed
   * to prevent memory leaks.
   */
  dispose() {
    this.disposed = true;
    this.listeners.clear();
  }
};

// src/fs/path-utils.ts
var path2 = __toESM(require("path"), 1);
var isCaseInsensitiveFS = process.platform === "darwin" || process.platform === "win32";
function normalizePathForComparison(filePath) {
  return isCaseInsensitiveFS ? filePath.toLowerCase() : filePath;
}
function pathStartsWith(filePath, prefix) {
  const normalizedPath = normalizePathForComparison(filePath);
  const normalizedPrefix = normalizePathForComparison(prefix);
  if (normalizedPath === normalizedPrefix) {
    return true;
  }
  return normalizedPath.startsWith(normalizedPrefix + path2.sep);
}
function safeRelativePath(from, to) {
  const normalizedFrom = normalizePathForComparison(from);
  const normalizedTo = normalizePathForComparison(to);
  return path2.relative(normalizedFrom, normalizedTo);
}
function isPathOutside(relativePath) {
  return relativePath.startsWith("..");
}

// src/fs/directory-cache.ts
var DirectoryCacheImpl = class {
  /**
   * The main cache storage.
   * Key: normalized absolute path
   * Value: CacheEntry with entries, version, and timestamp
   */
  cache = /* @__PURE__ */ new Map();
  /**
   * Listeners for cache changes.
   * Key: path pattern (or '*' for all)
   * Value: Set of listener callbacks
   */
  listeners = /* @__PURE__ */ new Map();
  /**
   * Tracks access order for LRU eviction.
   * Most recently accessed paths are at the end.
   */
  accessOrder = [];
  /**
   * Maximum number of entries before LRU eviction kicks in.
   * Can be configured via setMaxSize() for testing.
   */
  maxSize = 500;
  // -------------------------------------------------------------------------
  // Core Operations
  // -------------------------------------------------------------------------
  /**
   * Get a cached directory entry.
   *
   * Updates access order for LRU tracking (this path becomes most-recently-used).
   *
   * @param dirPath - Absolute path to the directory
   * @returns CacheEntry if found, undefined if not cached
   */
  get(dirPath) {
    const normalizedPath = this.normalizePath(dirPath);
    const entry = this.cache.get(normalizedPath);
    if (entry) {
      this.updateAccessOrder(normalizedPath);
    }
    return entry;
  }
  /**
   * Cache a directory listing.
   *
   * If an entry already exists, its version is incremented.
   * If the cache is full, the least-recently-used entry is evicted.
   *
   * @param dirPath - Absolute path to the directory
   * @param entries - Directory entries to cache
   */
  set(dirPath, entries) {
    const normalizedPath = this.normalizePath(dirPath);
    const existing = this.cache.get(normalizedPath);
    if (!existing && this.cache.size >= this.maxSize) {
      this.evictLRU();
    }
    const newEntry = {
      entries,
      version: (existing?.version ?? 0) + 1,
      timestamp: Date.now()
    };
    this.cache.set(normalizedPath, newEntry);
    this.updateAccessOrder(normalizedPath);
    this.notifyListeners(normalizedPath, newEntry);
  }
  /**
   * Check if a directory is cached.
   *
   * Does NOT update access order (peek operation).
   *
   * @param dirPath - Absolute path to the directory
   * @returns true if the directory is in the cache
   */
  has(dirPath) {
    const normalizedPath = this.normalizePath(dirPath);
    return this.cache.has(normalizedPath);
  }
  /**
   * Get the version number of a cached entry.
   *
   * Useful for comparing if data has changed since last read.
   *
   * @param dirPath - Absolute path to the directory
   * @returns Version number, or 0 if not cached
   */
  getVersion(dirPath) {
    const normalizedPath = this.normalizePath(dirPath);
    return this.cache.get(normalizedPath)?.version ?? 0;
  }
  // -------------------------------------------------------------------------
  // In-Place Updates
  // -------------------------------------------------------------------------
  /**
   * Add a single entry to a cached directory listing.
   *
   * If the directory is not cached, this is a no-op.
   * If an entry with the same name already exists, it is replaced.
   *
   * @param dirPath - Absolute path to the directory
   * @param entry - The entry to add
   */
  addEntry(dirPath, entry) {
    const normalizedPath = this.normalizePath(dirPath);
    const cached = this.cache.get(normalizedPath);
    if (!cached) {
      return;
    }
    const entries = cached.entries.filter(
      (e) => !this.entryNamesMatch(e.name, entry.name)
    );
    entries.push(entry);
    entries.sort((a, b) => {
      if (a.type !== b.type) {
        return a.type === "directory" ? -1 : 1;
      }
      return a.name.localeCompare(b.name);
    });
    cached.entries = entries;
    cached.version++;
    cached.timestamp = Date.now();
    this.notifyListeners(normalizedPath, cached);
  }
  /**
   * Remove a single entry from a cached directory listing.
   *
   * If the directory is not cached or the entry doesn't exist, this is a no-op.
   *
   * @param dirPath - Absolute path to the directory
   * @param entryName - Name of the entry to remove
   */
  removeEntry(dirPath, entryName) {
    const normalizedPath = this.normalizePath(dirPath);
    const cached = this.cache.get(normalizedPath);
    if (!cached) {
      return;
    }
    const originalLength = cached.entries.length;
    cached.entries = cached.entries.filter(
      (e) => !this.entryNamesMatch(e.name, entryName)
    );
    if (cached.entries.length !== originalLength) {
      cached.version++;
      cached.timestamp = Date.now();
      this.notifyListeners(normalizedPath, cached);
    }
  }
  // -------------------------------------------------------------------------
  // Invalidation
  // -------------------------------------------------------------------------
  /**
   * Invalidate a cached entry without removing it.
   *
   * This increments the version number, signaling that the data may be stale.
   * The entry remains in cache so stale data can be returned immediately
   * while fresh data is fetched in the background.
   *
   * @param dirPath - Absolute path to the directory
   */
  invalidate(dirPath) {
    const normalizedPath = this.normalizePath(dirPath);
    const entry = this.cache.get(normalizedPath);
    if (entry) {
      entry.version++;
      entry.timestamp = Date.now();
      this.notifyListeners(normalizedPath, entry);
    }
  }
  /**
   * Remove a cached entry completely.
   *
   * Use this when a directory is deleted or you want to force a fresh read.
   * For normal invalidation (file changed), prefer `invalidate()`.
   *
   * @param dirPath - Absolute path to the directory
   */
  delete(dirPath) {
    const normalizedPath = this.normalizePath(dirPath);
    if (this.cache.delete(normalizedPath)) {
      const index = this.accessOrder.indexOf(normalizedPath);
      if (index !== -1) {
        this.accessOrder.splice(index, 1);
      }
      this.notifyListeners(normalizedPath, null);
    }
  }
  /**
   * Clear the entire cache.
   *
   * Use sparingly - typically only needed for testing or major CWD changes.
   */
  clear() {
    const paths = [...this.cache.keys()];
    this.cache.clear();
    this.accessOrder = [];
    for (const path11 of paths) {
      this.notifyListeners(path11, null);
    }
  }
  // -------------------------------------------------------------------------
  // Subscription
  // -------------------------------------------------------------------------
  /**
   * Subscribe to cache changes for a specific path.
   *
   * @param dirPath - Path to watch, or '*' for all changes
   * @param listener - Callback when cache changes
   * @returns Disposable to unsubscribe
   */
  subscribe(dirPath, listener) {
    const normalizedPath = dirPath === "*" ? "*" : this.normalizePath(dirPath);
    let pathListeners = this.listeners.get(normalizedPath);
    if (!pathListeners) {
      pathListeners = /* @__PURE__ */ new Set();
      this.listeners.set(normalizedPath, pathListeners);
    }
    pathListeners.add(listener);
    return {
      dispose: () => {
        const listeners = this.listeners.get(normalizedPath);
        if (listeners) {
          listeners.delete(listener);
          if (listeners.size === 0) {
            this.listeners.delete(normalizedPath);
          }
        }
      }
    };
  }
  // -------------------------------------------------------------------------
  // Configuration
  // -------------------------------------------------------------------------
  /**
   * Set the maximum cache size.
   *
   * If the new size is smaller than current cache size,
   * LRU entries will be evicted immediately.
   *
   * @param size - Maximum number of entries
   */
  setMaxSize(size) {
    this.maxSize = size;
    while (this.cache.size > this.maxSize) {
      this.evictLRU();
    }
  }
  /**
   * Get the current cache size (number of entries).
   */
  get size() {
    return this.cache.size;
  }
  /**
   * Get all cached directory paths under a given prefix.
   *
   * Used for bulk operations like refreshing gitignore status.
   * Does NOT update access order (peek operation).
   *
   * @param prefix - Path prefix to filter by (e.g., git root)
   * @returns Array of cached paths that start with the prefix
   */
  getPathsUnder(prefix) {
    const normalizedPrefix = this.normalizePath(prefix);
    const paths = [];
    const prefixToMatch = normalizePathForComparison(normalizedPrefix);
    for (const cachedPath of this.cache.keys()) {
      const pathToMatch = normalizePathForComparison(cachedPath);
      if (pathToMatch === prefixToMatch || pathStartsWith(cachedPath, normalizedPrefix)) {
        paths.push(cachedPath);
      }
    }
    return paths;
  }
  // -------------------------------------------------------------------------
  // Internal Helpers
  // -------------------------------------------------------------------------
  /**
   * Normalize a path for consistent cache keys.
   *
   * - Removes trailing slashes (except for root '/')
   * - Lowercases on case-insensitive filesystems (macOS/Windows)
   * - Ensures consistent format
   */
  normalizePath(dirPath) {
    let normalized = dirPath;
    if (normalized.length > 1 && normalized.endsWith("/")) {
      normalized = normalized.slice(0, -1);
    }
    return normalizePathForComparison(normalized);
  }
  /**
   * Check if two entry names match, handling case sensitivity correctly.
   *
   * On case-insensitive filesystems (macOS/Windows), comparison is case-insensitive.
   * This ensures that when a watcher reports a file with different casing than
   * what's in the cache, we still match correctly.
   */
  entryNamesMatch(name1, name2) {
    if (isCaseInsensitiveFS) {
      return name1.toLowerCase() === name2.toLowerCase();
    }
    return name1 === name2;
  }
  /**
   * Update access order for LRU tracking.
   *
   * Moves the path to the end of accessOrder (most recently used).
   */
  updateAccessOrder(normalizedPath) {
    const index = this.accessOrder.indexOf(normalizedPath);
    if (index !== -1) {
      this.accessOrder.splice(index, 1);
    }
    this.accessOrder.push(normalizedPath);
  }
  /**
   * Evict the least-recently-used entry.
   */
  evictLRU() {
    if (this.accessOrder.length === 0) {
      return;
    }
    const lruPath = this.accessOrder.shift();
    if (lruPath) {
      this.cache.delete(lruPath);
      this.notifyListeners(lruPath, null);
    }
  }
  /**
   * Notify listeners about a cache change.
   */
  notifyListeners(path11, entry) {
    const pathListeners = this.listeners.get(path11);
    if (pathListeners) {
      for (const listener of pathListeners) {
        try {
          listener(path11, entry);
        } catch (error) {
          console.error("[DirectoryCache] Listener threw an error:", error);
        }
      }
    }
    const wildcardListeners = this.listeners.get("*");
    if (wildcardListeners) {
      for (const listener of wildcardListeners) {
        try {
          listener(path11, entry);
        } catch (error) {
          console.error("[DirectoryCache] Listener threw an error:", error);
        }
      }
    }
  }
};
var DirectoryCache = new DirectoryCacheImpl();

// src/fs/gitignore-cache.ts
var import_ignore = __toESM(require_ignore(), 1);
var import_node_child_process2 = require("child_process");
var fs2 = __toESM(require("fs"), 1);
var path3 = __toESM(require("path"), 1);
var GitIgnoreCacheImpl = class {
  /**
   * Cache of directory path -> git root path (or null if not in a repo).
   * This rarely changes, so we cache indefinitely.
   */
  gitRootCache = /* @__PURE__ */ new Map();
  /**
   * Cache of git root -> ignore matcher instance.
   * The matcher contains all rules from .gitignore files in that repo.
   */
  matcherCache = /* @__PURE__ */ new Map();
  /**
   * Tracks which .gitignore files have been loaded for each git root.
   * Key: gitRoot, Value: Set of .gitignore file paths that have been loaded.
   */
  loadedGitignoreFiles = /* @__PURE__ */ new Map();
  // -------------------------------------------------------------------------
  // Git Root Lookup
  // -------------------------------------------------------------------------
  /**
   * Normalize a path for cache key (case-insensitive on macOS/Windows).
   */
  normalizeCacheKey(filePath) {
    return normalizePathForComparison(path3.resolve(filePath));
  }
  /**
   * Find the git root for a directory, with caching.
   */
  async getGitRoot(dirPath) {
    const cacheKey = this.normalizeCacheKey(dirPath);
    if (this.gitRootCache.has(cacheKey)) {
      return this.gitRootCache.get(cacheKey) ?? null;
    }
    const resolved = path3.resolve(dirPath);
    const gitRoot = await this.findGitRoot(resolved);
    this.gitRootCache.set(cacheKey, gitRoot);
    if (gitRoot) {
      let current = path3.dirname(resolved);
      while (current.length >= gitRoot.length) {
        this.gitRootCache.set(this.normalizeCacheKey(current), gitRoot);
        const parent = path3.dirname(current);
        if (parent === current) break;
        current = parent;
      }
    }
    return gitRoot;
  }
  findGitRoot(dirPath) {
    return new Promise((resolve8) => {
      try {
        const child = (0, import_node_child_process2.spawn)("git", ["rev-parse", "--show-toplevel"], {
          cwd: dirPath,
          stdio: ["ignore", "pipe", "ignore"]
        });
        let output = "";
        child.stdout.on("data", (chunk) => {
          output += chunk.toString();
        });
        child.once("error", () => {
          resolve8(null);
        });
        child.once("close", (code) => {
          if (code === 0 && output.trim()) {
            resolve8(output.trim());
          } else {
            resolve8(null);
          }
        });
      } catch {
        resolve8(null);
      }
    });
  }
  // -------------------------------------------------------------------------
  // Ignore Matcher Management
  // -------------------------------------------------------------------------
  /**
   * Get or create the ignore matcher for a git root.
   * Automatically loads the root .gitignore if not already loaded.
   */
  getOrCreateMatcher(gitRoot) {
    const normalizedRoot = normalizePathForComparison(gitRoot);
    let matcher = this.matcherCache.get(normalizedRoot);
    if (!matcher) {
      matcher = (0, import_ignore.default)();
      this.matcherCache.set(normalizedRoot, matcher);
      this.loadedGitignoreFiles.set(normalizedRoot, /* @__PURE__ */ new Set());
      this.loadGitignoreFile(
        normalizedRoot,
        gitRoot,
        path3.join(gitRoot, ".gitignore")
      );
    }
    return matcher;
  }
  /**
   * Load a .gitignore file and add its rules to the matcher.
   * Rules are prefixed with the relative directory path to handle nested .gitignore files.
   *
   * @param normalizedRoot - Normalized cache key for lookups (case-insensitive on macOS/Windows)
   * @param originalGitRoot - Original git root path for filesystem operations
   * @param gitignorePath - Path to the .gitignore file to load
   */
  loadGitignoreFile(normalizedRoot, originalGitRoot, gitignorePath) {
    const loadedFiles = this.loadedGitignoreFiles.get(normalizedRoot);
    if (!loadedFiles || loadedFiles.has(gitignorePath)) {
      return;
    }
    if (!fs2.existsSync(gitignorePath)) {
      return;
    }
    try {
      const content = fs2.readFileSync(gitignorePath, "utf-8");
      const matcher = this.matcherCache.get(normalizedRoot);
      if (!matcher) return;
      const gitignoreDir = path3.dirname(gitignorePath);
      const relativeDir = path3.relative(originalGitRoot, gitignoreDir);
      const rules = content.split("\n").map((line) => line.trim()).filter((line) => line && !line.startsWith("#"));
      if (relativeDir) {
        const prefixedRules = rules.map((rule) => {
          if (rule.startsWith("!")) {
            const pattern = rule.slice(1);
            return `!${relativeDir}/${pattern}`;
          }
          return `${relativeDir}/${rule}`;
        });
        matcher.add(prefixedRules);
      } else {
        matcher.add(rules);
      }
      loadedFiles.add(gitignorePath);
    } catch {
    }
  }
  // -------------------------------------------------------------------------
  // Gitignore Checking
  // -------------------------------------------------------------------------
  /**
   * Check if entries are gitignored using the ignore package (no git spawning).
   * Returns a Set of entry names that are ignored.
   *
   * @param dirPath - Directory containing the entries
   * @param entries - Entries to check, with name and whether they're directories
   * @param gitRoot - Optional pre-resolved git root (avoids lookup if provided)
   */
  async getIgnoredEntries(dirPath, entries, gitRoot) {
    const resolvedGitRoot = gitRoot !== void 0 ? gitRoot : await this.getGitRoot(dirPath);
    if (!resolvedGitRoot) {
      return /* @__PURE__ */ new Set();
    }
    const relativeDir = safeRelativePath(resolvedGitRoot, dirPath);
    if (isPathOutside(relativeDir)) {
      return /* @__PURE__ */ new Set();
    }
    const matcher = this.getOrCreateMatcher(resolvedGitRoot);
    const normalizedRoot = normalizePathForComparison(resolvedGitRoot);
    const localGitignore = path3.join(dirPath, ".gitignore");
    this.loadGitignoreFile(normalizedRoot, resolvedGitRoot, localGitignore);
    const ignored = /* @__PURE__ */ new Set();
    for (const { name, isDirectory } of entries) {
      const relativePath = relativeDir ? `${relativeDir}/${name}` : name;
      const pathToCheck = isDirectory ? `${relativePath}/` : relativePath;
      if (matcher.ignores(pathToCheck)) {
        ignored.add(name);
      }
    }
    return ignored;
  }
  /**
   * Check if a single path is ignored (synchronous, for watcher filtering).
   * Requires git root to be pre-resolved.
   *
   * Note: This uses only the currently loaded .gitignore rules. If the file
   * is in a directory that hasn't been traversed yet, nested .gitignore files
   * for that directory won't be loaded. This is acceptable for watcher filtering
   * since we err on the side of not filtering (showing events for potentially
   * ignored files is better than missing events for non-ignored files).
   *
   * @param gitRoot - The git root directory
   * @param filePath - Absolute path to check
   * @returns true if the path is ignored
   */
  isIgnored(gitRoot, filePath) {
    const relativePath = safeRelativePath(gitRoot, filePath);
    if (isPathOutside(relativePath)) {
      return false;
    }
    const matcher = this.getOrCreateMatcher(gitRoot);
    return matcher.ignores(relativePath);
  }
  // -------------------------------------------------------------------------
  // Cache Invalidation
  // -------------------------------------------------------------------------
  /**
   * Invalidate gitignore cache when .gitignore changes (created/modified/deleted).
   * Rebuilds the matcher for the affected git root.
   *
   * @param gitignorePath - Path to the .gitignore file that changed
   */
  invalidateForGitignore(gitignorePath) {
    const gitignoreDir = path3.dirname(gitignorePath);
    const cacheKey = this.normalizeCacheKey(gitignoreDir);
    const gitRoot = this.gitRootCache.get(cacheKey);
    if (gitRoot) {
      const normalizedGitRoot = normalizePathForComparison(gitRoot);
      this.matcherCache.delete(normalizedGitRoot);
      this.loadedGitignoreFiles.delete(normalizedGitRoot);
    } else {
      this.matcherCache.clear();
      this.loadedGitignoreFiles.clear();
    }
  }
  /**
   * Clear all caches.
   */
  clear() {
    this.gitRootCache.clear();
    this.matcherCache.clear();
    this.loadedGitignoreFiles.clear();
  }
  /**
   * Get cache statistics for debugging.
   */
  getStats() {
    let totalLoadedFiles = 0;
    for (const files of this.loadedGitignoreFiles.values()) {
      totalLoadedFiles += files.size;
    }
    return {
      gitRootEntries: this.gitRootCache.size,
      matcherCount: this.matcherCache.size,
      loadedGitignoreFiles: totalLoadedFiles
    };
  }
};
var GitIgnoreCache = new GitIgnoreCacheImpl();

// src/fs/parcel-file-watcher.ts
var import_watcher = __toESM(require("@parcel/watcher"), 1);
var import_node_fs2 = __toESM(require("fs"), 1);
var import_node_path3 = __toESM(require("path"), 1);
var DEFAULT_IGNORED_PATTERNS = [
  "**/node_modules/**",
  "**/.git/**",
  "**/dist/**",
  "**/build/**",
  "**/.next/**",
  "**/.cache/**",
  "**/coverage/**",
  "**/*.log",
  "**/.DS_Store"
];
var RenameDetector = class {
  /** Pending DELETE events: normalized path  { originalPath, timestamp } */
  pendingDeletes = /* @__PURE__ */ new Map();
  /** Pending CREATE events: normalized path  { originalPath, timestamp } */
  pendingCreates = /* @__PURE__ */ new Map();
  /** Time window for correlating events (ms) */
  correlationWindow = 500;
  /**
   * Normalize a path for case-insensitive comparison on macOS/Windows.
   */
  normalizePath(filePath) {
    return normalizePathForComparison(filePath);
  }
  /**
   * Record a DELETE event for potential rename detection.
   */
  recordDelete(filePath) {
    const normalized = this.normalizePath(filePath);
    this.pendingDeletes.set(normalized, {
      originalPath: filePath,
      timestamp: Date.now()
    });
    setTimeout(() => {
      this.pendingDeletes.delete(normalized);
    }, this.correlationWindow);
  }
  /**
   * Record a CREATE event for potential rename detection.
   */
  recordCreate(filePath) {
    const normalized = this.normalizePath(filePath);
    this.pendingCreates.set(normalized, {
      originalPath: filePath,
      timestamp: Date.now()
    });
    setTimeout(() => {
      this.pendingCreates.delete(normalized);
    }, this.correlationWindow);
  }
  /**
   * Check if a CREATE event is actually a rename (DELETE came first).
   *
   * @param newPath - The path of the created file
   * @returns The old path if this is a rename, null otherwise
   */
  matchCreateWithDelete(newPath) {
    const newDirNormalized = this.normalizePath(import_node_path3.default.dirname(newPath));
    const newPathNormalized = this.normalizePath(newPath);
    const now = Date.now();
    for (const [oldPathNormalized, entry] of this.pendingDeletes.entries()) {
      if (now - entry.timestamp > this.correlationWindow) {
        continue;
      }
      const oldDirNormalized = this.normalizePath(
        import_node_path3.default.dirname(entry.originalPath)
      );
      if (oldDirNormalized !== newDirNormalized) {
        continue;
      }
      if (oldPathNormalized === newPathNormalized) {
        continue;
      }
      this.pendingDeletes.delete(oldPathNormalized);
      return entry.originalPath;
    }
    return null;
  }
  /**
   * Check if a DELETE event is actually a rename (CREATE came first).
   *
   * @param oldPath - The path of the deleted file
   * @returns The new path if this is a rename, null otherwise
   */
  matchDeleteWithCreate(oldPath) {
    const oldDirNormalized = this.normalizePath(import_node_path3.default.dirname(oldPath));
    const oldPathNormalized = this.normalizePath(oldPath);
    const now = Date.now();
    for (const [newPathNormalized, entry] of this.pendingCreates.entries()) {
      if (now - entry.timestamp > this.correlationWindow) {
        continue;
      }
      const newDirNormalized = this.normalizePath(
        import_node_path3.default.dirname(entry.originalPath)
      );
      if (newDirNormalized !== oldDirNormalized) {
        continue;
      }
      if (oldPathNormalized === newPathNormalized) {
        continue;
      }
      this.pendingCreates.delete(newPathNormalized);
      return entry.originalPath;
    }
    return null;
  }
  /**
   * Clear all pending events.
   */
  clear() {
    this.pendingDeletes.clear();
    this.pendingCreates.clear();
  }
};
var ParcelFileWatcher = class {
  /** The directory being watched */
  path;
  /** Resolved real path (handles symlinks) */
  realPath;
  /** Ignore patterns */
  ignored;
  /** The @parcel/watcher subscription */
  subscription = null;
  /** Whether currently watching */
  watching = false;
  /** Rename detection helper */
  renameDetector = new RenameDetector();
  /** Debounce timers */
  debounceTimers = /* @__PURE__ */ new Map();
  // -------------------------------------------------------------------------
  // Event Emitters
  // -------------------------------------------------------------------------
  _onCreated = new EventEmitter2();
  _onModified = new EventEmitter2();
  _onDeleted = new EventEmitter2();
  _onRenamed = new EventEmitter2();
  /** Fired when a file or directory is created */
  onCreated = this._onCreated.event;
  /** Fired when a file's content is modified */
  onModified = this._onModified.event;
  /** Fired when a file or directory is deleted */
  onDeleted = this._onDeleted.event;
  /** Fired when a file or directory is renamed */
  onRenamed = this._onRenamed.event;
  // -------------------------------------------------------------------------
  // Constructor
  // -------------------------------------------------------------------------
  /**
   * Create a new file watcher.
   *
   * @param watchPath - Directory to watch
   * @param options - Watcher configuration
   */
  constructor(watchPath, options = {}) {
    this.path = watchPath;
    this.ignored = options.ignored ?? DEFAULT_IGNORED_PATTERNS;
    try {
      this.realPath = import_node_fs2.default.realpathSync(watchPath);
    } catch {
      this.realPath = import_node_path3.default.resolve(watchPath);
    }
  }
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  /**
   * Start watching for file changes.
   *
   * @throws If watching fails to start
   */
  async watch() {
    if (this.watching) {
      return;
    }
    const backend = this.getBackend();
    this.subscription = await import_watcher.default.subscribe(
      this.path,
      (err, events) => {
        if (err) {
          console.error("[ParcelFileWatcher] Error:", err);
          return;
        }
        this.handleEvents(events);
      },
      {
        backend,
        ignore: this.ignored
      }
    );
    this.watching = true;
  }
  /**
   * Stop watching for file changes.
   */
  async unwatch() {
    if (!this.watching || !this.subscription) {
      return;
    }
    await this.subscription.unsubscribe();
    this.subscription = null;
    this.watching = false;
    this.clearDebounceTimers();
    this.renameDetector.clear();
  }
  /**
   * Check if currently watching.
   */
  isWatching() {
    return this.watching;
  }
  /**
   * Clean up all resources.
   *
   * Stops watching and disposes all event emitters.
   */
  async dispose() {
    await this.unwatch();
    this._onCreated.dispose();
    this._onModified.dispose();
    this._onDeleted.dispose();
    this._onRenamed.dispose();
  }
  // -------------------------------------------------------------------------
  // Private Methods
  // -------------------------------------------------------------------------
  /**
   * Get the appropriate watcher backend for the current platform.
   */
  getBackend() {
    switch (process.platform) {
      case "darwin":
        return "fs-events";
      case "linux":
        return "inotify";
      default:
        return "windows";
    }
  }
  /**
   * Handle a batch of events from @parcel/watcher.
   */
  handleEvents(events) {
    for (const event of events) {
      if (this.shouldIgnore(event.path)) {
        continue;
      }
      switch (event.type) {
        case "create":
          this.handleCreate(event.path);
          break;
        case "update":
          this.handleUpdate(event.path);
          break;
        case "delete":
          this.handleDelete(event.path);
          break;
      }
    }
  }
  /**
   * Check if a path matches any ignore pattern.
   *
   * Uses simple pattern matching for common glob patterns.
   */
  shouldIgnore(filePath) {
    const normalizedPath = filePath.replace(/\\/g, "/");
    for (const pattern of this.ignored) {
      if (this.matchPattern(normalizedPath, pattern)) {
        return true;
      }
    }
    return false;
  }
  /**
   * Match a path against a glob-like pattern.
   *
   * Supports common patterns:
   * - Double-star/name/double-star: contains /name/ anywhere
   * - Double-star/*.ext: ends with .ext
   * - Double-star/name: ends with /name or equals name
   *
   * On case-insensitive filesystems (macOS/Windows), matching is case-insensitive.
   */
  matchPattern(filePath, pattern) {
    const normalizedPath = isCaseInsensitiveFS ? filePath.toLowerCase() : filePath;
    const normalizedPattern = isCaseInsensitiveFS ? pattern.toLowerCase() : pattern;
    const dirMatch = normalizedPattern.match(/^\*\*\/(.+)\/\*\*$/);
    if (dirMatch) {
      const dirName = dirMatch[1];
      return normalizedPath.includes(`/${dirName}/`) || normalizedPath.startsWith(`${dirName}/`) || normalizedPath.endsWith(`/${dirName}`);
    }
    const extMatch = normalizedPattern.match(/^\*\*\/\*(\.[^/]+)$/);
    if (extMatch) {
      return normalizedPath.endsWith(extMatch[1]);
    }
    const nameMatch = normalizedPattern.match(/^\*\*\/(.+)$/);
    if (nameMatch) {
      const name = nameMatch[1];
      return normalizedPath.endsWith(`/${name}`) || normalizedPath === name;
    }
    return normalizedPath.includes(normalizedPattern);
  }
  /**
   * Handle a CREATE event.
   */
  handleCreate(filePath) {
    const oldPath = this.renameDetector.matchCreateWithDelete(filePath);
    if (oldPath) {
      this.cancelDebounce(`delete:${oldPath}`);
      this.emitRename(oldPath, filePath);
    } else {
      this.renameDetector.recordCreate(filePath);
      this.debounce(`create:${filePath}`, 200, () => {
        const matchedOldPath = this.renameDetector.matchCreateWithDelete(filePath);
        if (matchedOldPath) {
          this.cancelDebounce(`delete:${matchedOldPath}`);
          this.emitRename(matchedOldPath, filePath);
        } else {
          const isDirectory = this.isDirectory(filePath);
          this._onCreated.fire({ path: filePath, isDirectory });
        }
      });
    }
  }
  /**
   * Handle an UPDATE event.
   */
  handleUpdate(filePath) {
    this.debounce(`update:${filePath}`, 50, () => {
      this._onModified.fire({ path: filePath });
    });
  }
  /**
   * Handle a DELETE event.
   */
  handleDelete(filePath) {
    const newPath = this.renameDetector.matchDeleteWithCreate(filePath);
    if (newPath) {
      this.cancelDebounce(`create:${newPath}`);
      this.emitRename(filePath, newPath);
    } else {
      this.renameDetector.recordDelete(filePath);
      this.debounce(`delete:${filePath}`, 200, () => {
        const matchedNewPath = this.renameDetector.matchDeleteWithCreate(filePath);
        if (matchedNewPath) {
          this.cancelDebounce(`create:${matchedNewPath}`);
          this.emitRename(filePath, matchedNewPath);
        } else {
          this._onDeleted.fire({
            path: filePath,
            isDirectory: false
            // Can't determine for deleted files
          });
        }
      });
    }
  }
  /**
   * Emit a rename event.
   */
  emitRename(oldPath, newPath) {
    const isDirectory = this.isDirectory(newPath);
    this._onRenamed.fire({ oldPath, newPath, isDirectory });
  }
  /**
   * Check if a path is a directory.
   */
  isDirectory(filePath) {
    try {
      return import_node_fs2.default.statSync(filePath).isDirectory();
    } catch {
      return false;
    }
  }
  /**
   * Debounce a callback with the given key and delay.
   */
  debounce(key, delay2, callback2) {
    const existingTimer = this.debounceTimers.get(key);
    if (existingTimer) {
      clearTimeout(existingTimer);
    }
    const timer = setTimeout(() => {
      this.debounceTimers.delete(key);
      callback2();
    }, delay2);
    this.debounceTimers.set(key, timer);
  }
  /**
   * Cancel a pending debounced callback.
   */
  cancelDebounce(key) {
    const timer = this.debounceTimers.get(key);
    if (timer) {
      clearTimeout(timer);
      this.debounceTimers.delete(key);
    }
  }
  /**
   * Clear all debounce timers.
   */
  clearDebounceTimers() {
    for (const timer of this.debounceTimers.values()) {
      clearTimeout(timer);
    }
    this.debounceTimers.clear();
  }
};

// src/fs/types.ts
var ALWAYS_HIDDEN = /* @__PURE__ */ new Set([".git", "node_modules"]);

// src/fs/disk-fs-provider.ts
var REFRESH_DEBOUNCE_MS = 50;
var MAX_CONCURRENT_PREFETCH = 10;
var VERIFY_CACHE_COOLDOWN_MS = 2e3;
var DiskFileSystemProvider = class {
  cwd;
  // -------------------------------------------------------------------------
  // Internal Components
  // -------------------------------------------------------------------------
  watcher;
  disposed = false;
  /** Pending directory refresh timers (debouncing) */
  refreshTimers = /* @__PURE__ */ new Map();
  /** Currently running prefetch operations */
  activePrefetches = /* @__PURE__ */ new Set();
  /** Last verification time per directory (for cooldown) */
  lastVerifyTime = /* @__PURE__ */ new Map();
  /** Cached git root for this cwd (null if not in repo, undefined if not yet checked) */
  gitRoot = void 0;
  // -------------------------------------------------------------------------
  // Event Emitters
  // -------------------------------------------------------------------------
  _onDirectoryListingChanged = new EventEmitter2();
  _onFileContentChanged = new EventEmitter2();
  _onFileRenamed = new EventEmitter2();
  _onFileDeleted = new EventEmitter2();
  onDirectoryListingChanged = this._onDirectoryListingChanged.event;
  onFileContentChanged = this._onFileContentChanged.event;
  onFileRenamed = this._onFileRenamed.event;
  onFileDeleted = this._onFileDeleted.event;
  // -------------------------------------------------------------------------
  // Constructor
  // -------------------------------------------------------------------------
  /**
   * Create a new disk filesystem provider.
   *
   * @param cwd - The working directory to scope this provider to
   * @param watcherOptions - Optional configuration for the file watcher
   */
  constructor(cwd, watcherOptions) {
    this.cwd = nodePath.resolve(cwd);
    this.watcher = new ParcelFileWatcher(this.cwd, watcherOptions);
    this.setupWatcherEvents();
    this.initializeGitRoot();
  }
  /**
   * Initialize git root asynchronously.
   * Called from constructor to ensure gitRoot is available for watcher filtering.
   */
  initializeGitRoot() {
    GitIgnoreCache.getGitRoot(this.cwd).then((root) => {
      this.gitRoot = root;
    });
  }
  // -------------------------------------------------------------------------
  // File Operations
  // -------------------------------------------------------------------------
  /**
   * Get metadata for a file or directory.
   */
  async stat(path11) {
    const stats = await fs4.stat(path11);
    return {
      type: stats.isDirectory() ? "directory" : "file",
      size: stats.size,
      mtime: stats.mtimeMs,
      ctime: stats.ctimeMs,
      readonly: this.isReadonly(stats)
    };
  }
  /**
   * List contents of a directory.
   *
   * Uses cache-first strategy:
   * 1. Return cached entries immediately if available
   * 2. Fetch from disk in background and update cache
   * 3. Emit event if entries changed
   */
  async readDirectory(dirPath) {
    const normalizedPath = nodePath.resolve(dirPath);
    const cached = DirectoryCache.get(normalizedPath);
    if (cached) {
      this.scheduleVerifyCache(normalizedPath);
      return cached.entries;
    }
    const entries = await this.readDirectoryFromDisk(normalizedPath);
    DirectoryCache.set(normalizedPath, entries);
    this.prefetchChildren(normalizedPath, entries);
    return entries;
  }
  /**
   * Read complete file contents as binary.
   */
  async readFile(filePath) {
    const buffer = await fs4.readFile(filePath);
    return new Uint8Array(buffer);
  }
  /**
   * Read complete file contents as text (UTF-8).
   *
   * Convenience method that returns a string directly, avoiding the need
   * for TextDecoder on the caller side.
   *
   * Note: Binary files will have invalid UTF-8 bytes replaced with U+FFFD.
   */
  async readTextFile(filePath) {
    return fs4.readFile(filePath, "utf-8");
  }
  /**
   * Write content to a file.
   *
   * Creates parent directories if they don't exist.
   * Updates the directory cache in-place for immediate consistency.
   */
  async writeFile(filePath, content) {
    const parentDir = nodePath.dirname(filePath);
    await fs4.mkdir(parentDir, { recursive: true });
    await fs4.writeFile(filePath, content);
    const fileName = nodePath.basename(filePath);
    DirectoryCache.addEntry(
      parentDir,
      this.buildCacheEntry(fileName, "file", filePath)
    );
  }
  /**
   * Delete a file or directory.
   *
   * Updates the directory cache in-place for immediate consistency.
   */
  async delete(path11, options) {
    let isDirectory = false;
    try {
      const stats = await fs4.stat(path11);
      isDirectory = stats.isDirectory();
    } catch {
    }
    await fs4.rm(path11, {
      recursive: options?.recursive ?? false,
      force: false
    });
    const parentDir = nodePath.dirname(path11);
    const fileName = nodePath.basename(path11);
    DirectoryCache.removeEntry(parentDir, fileName);
    if (isDirectory) {
      DirectoryCache.delete(path11);
    }
  }
  /**
   * Rename or move a file/directory.
   *
   * Updates the directory cache in-place for immediate consistency.
   */
  async rename(oldPath, newPath) {
    const stats = await fs4.lstat(oldPath);
    const entryType = stats.isDirectory() ? "directory" : "file";
    const isSymlink = stats.isSymbolicLink();
    const newParentDir = nodePath.dirname(newPath);
    await fs4.mkdir(newParentDir, { recursive: true });
    await fs4.rename(oldPath, newPath);
    const oldParentDir = nodePath.dirname(oldPath);
    const oldName = nodePath.basename(oldPath);
    const newName = nodePath.basename(newPath);
    DirectoryCache.removeEntry(oldParentDir, oldName);
    DirectoryCache.addEntry(
      newParentDir,
      this.buildCacheEntry(newName, entryType, newPath, isSymlink)
    );
    if (entryType === "directory") {
      const oldCache = DirectoryCache.get(oldPath);
      if (oldCache) {
        DirectoryCache.set(newPath, oldCache.entries);
        DirectoryCache.delete(oldPath);
      }
    }
  }
  /**
   * Create a directory.
   *
   * Creates parent directories if they don't exist (like `mkdir -p`).
   * Updates the directory cache in-place for immediate consistency.
   */
  async createDirectory(dirPath) {
    await fs4.mkdir(dirPath, { recursive: true });
    const parentDir = nodePath.dirname(dirPath);
    const dirName = nodePath.basename(dirPath);
    DirectoryCache.addEntry(
      parentDir,
      this.buildCacheEntry(dirName, "directory", dirPath)
    );
    DirectoryCache.set(dirPath, []);
  }
  /**
   * Check if a path exists.
   */
  async exists(path11) {
    try {
      await fs4.access(path11);
      return true;
    } catch {
      return false;
    }
  }
  // -------------------------------------------------------------------------
  // Lifecycle
  // -------------------------------------------------------------------------
  /**
   * Start watching for file changes.
   *
   * Call this after setting up event listeners.
   */
  async startWatching() {
    if (!this.disposed) {
      await this.watcher.watch();
    }
  }
  /**
   * Check if currently watching for changes.
   */
  isWatching() {
    return this.watcher.isWatching();
  }
  /**
   * Clean up all resources.
   */
  async dispose() {
    if (this.disposed) {
      return;
    }
    this.disposed = true;
    for (const timer of this.refreshTimers.values()) {
      clearTimeout(timer);
    }
    this.refreshTimers.clear();
    await this.watcher.dispose();
    this._onDirectoryListingChanged.dispose();
    this._onFileContentChanged.dispose();
    this._onFileRenamed.dispose();
    this._onFileDeleted.dispose();
  }
  // -------------------------------------------------------------------------
  // Internal: Watcher Event Handling
  // -------------------------------------------------------------------------
  /**
   * Check if a path should be ignored (gitignored).
   * Returns false if git root is not yet known (conservative - don't filter).
   */
  isPathIgnored(filePath) {
    if (nodePath.basename(filePath) === ".gitignore") {
      return false;
    }
    if (!this.gitRoot) {
      return false;
    }
    return GitIgnoreCache.isIgnored(this.gitRoot, filePath);
  }
  /**
   * Build a DirectoryEntry for cache updates.
   *
   * Uses cached git root (if available) to set isGitignored synchronously.
   * If git root isn't cached yet, isGitignored is omitted and will be set
   * correctly when the watcher triggers a full directory refresh.
   */
  buildCacheEntry(name, type, fullPath, isSymlink = false) {
    const entry = { name, type, isSymlink };
    if (this.gitRoot) {
      entry.isGitignored = GitIgnoreCache.isIgnored(this.gitRoot, fullPath);
    }
    return entry;
  }
  /**
   * Refresh isGitignored status for all cached directories under the git root.
   *
   * Called when .gitignore changes. This is efficient because:
   * 1. Only processes directories already in cache (no disk I/O)
   * 2. Only fires events for directories where status actually changed
   * 3. Recalculates in-place without re-reading directory contents
   */
  async refreshGitignoreAffectedDirectories() {
    const gitRoot = await this.getGitRoot();
    if (!gitRoot) {
      return;
    }
    const cachedPaths = DirectoryCache.getPathsUnder(gitRoot);
    if (cachedPaths.length === 0) {
      return;
    }
    for (const dirPath of cachedPaths) {
      const cached = DirectoryCache.get(dirPath);
      if (!cached || cached.entries.length === 0) {
        continue;
      }
      const gitIgnored = await GitIgnoreCache.getIgnoredEntries(
        dirPath,
        cached.entries.map((e) => ({
          name: e.name,
          isDirectory: e.type === "directory"
        })),
        gitRoot
      );
      let hasChanges = false;
      const updatedEntries = cached.entries.map((entry) => {
        const newIsGitignored = gitIgnored.has(entry.name);
        if (entry.isGitignored !== newIsGitignored) {
          hasChanges = true;
          return { ...entry, isGitignored: newIsGitignored };
        }
        return entry;
      });
      if (hasChanges) {
        DirectoryCache.set(dirPath, updatedEntries);
        this._onDirectoryListingChanged.fire({
          path: dirPath,
          entries: updatedEntries
        });
      }
    }
  }
  /**
   * Wire up watcher events to provider events.
   */
  setupWatcherEvents() {
    this.watcher.onCreated((event) => {
      if (nodePath.basename(event.path) === ".gitignore") {
        GitIgnoreCache.invalidateForGitignore(event.path);
        this.refreshGitignoreAffectedDirectories();
      }
      const parentDir = nodePath.dirname(event.path);
      this.scheduleRefresh(parentDir);
      if (!event.isDirectory) {
        this._onFileContentChanged.fire({ path: event.path });
      }
    });
    this.watcher.onModified((event) => {
      if (nodePath.basename(event.path) === ".gitignore") {
        GitIgnoreCache.invalidateForGitignore(event.path);
        this.refreshGitignoreAffectedDirectories();
      }
      this._onFileContentChanged.fire({ path: event.path });
    });
    this.watcher.onDeleted((event) => {
      if (nodePath.basename(event.path) === ".gitignore") {
        GitIgnoreCache.invalidateForGitignore(event.path);
        this.refreshGitignoreAffectedDirectories();
      }
      const parentDir = nodePath.dirname(event.path);
      this.scheduleRefresh(parentDir);
      this._onFileDeleted.fire(event);
      DirectoryCache.delete(event.path);
      this._onFileContentChanged.fire({ path: event.path });
    });
    this.watcher.onRenamed((event) => {
      const oldParentDir = nodePath.dirname(event.oldPath);
      const newParentDir = nodePath.dirname(event.newPath);
      this.scheduleRefresh(oldParentDir);
      if (oldParentDir !== newParentDir) {
        this.scheduleRefresh(newParentDir);
      }
      this._onFileRenamed.fire(event);
      if (event.isDirectory) {
        DirectoryCache.delete(event.oldPath);
      }
      this._onFileContentChanged.fire({ path: event.newPath });
    });
  }
  // -------------------------------------------------------------------------
  // Internal: Directory Reading
  // -------------------------------------------------------------------------
  /**
   * Get the git root for this provider's cwd (lazy initialization).
   * Cached after first lookup - only one git process spawn per provider lifetime.
   */
  async getGitRoot() {
    if (this.gitRoot === void 0) {
      this.gitRoot = await GitIgnoreCache.getGitRoot(this.cwd);
    }
    return this.gitRoot;
  }
  /**
   * Read directory contents from disk.
   *
   * Filters out:
   * - Always-hidden entries (.git, node_modules)
   *
   * Marks with isGitignored:
   * - Gitignored files (via .gitignore)
   */
  async readDirectoryFromDisk(dirPath) {
    const dirents = await fs4.readdir(dirPath, { withFileTypes: true });
    let entries = dirents.filter((dirent) => !ALWAYS_HIDDEN.has(dirent.name)).map((dirent) => ({
      name: dirent.name,
      type: dirent.isDirectory() ? "directory" : "file",
      isSymlink: dirent.isSymbolicLink()
    }));
    const gitRoot = await this.getGitRoot();
    const gitIgnored = await GitIgnoreCache.getIgnoredEntries(
      dirPath,
      entries.map((e) => ({
        name: e.name,
        isDirectory: e.type === "directory"
      })),
      gitRoot
    );
    if (gitIgnored.size > 0) {
      entries = entries.map((e) => ({
        ...e,
        isGitignored: gitIgnored.has(e.name)
      }));
    }
    return this.sortEntries(entries);
  }
  /**
   * Sort directory entries: directories first, then files, alphabetically.
   */
  sortEntries(entries) {
    return entries.sort((a, b) => {
      if (a.type !== b.type) {
        return a.type === "directory" ? -1 : 1;
      }
      return a.name.localeCompare(b.name, void 0, { sensitivity: "base" });
    });
  }
  // -------------------------------------------------------------------------
  // Internal: Refresh Scheduling
  // -------------------------------------------------------------------------
  /**
   * Schedule a directory refresh with debouncing.
   *
   * Multiple changes to the same directory within REFRESH_DEBOUNCE_MS
   * are coalesced into a single refresh.
   */
  scheduleRefresh(dirPath) {
    if (this.disposed) {
      return;
    }
    const existingTimer = this.refreshTimers.get(dirPath);
    if (existingTimer) {
      clearTimeout(existingTimer);
    }
    const timer = setTimeout(() => {
      this.refreshTimers.delete(dirPath);
      this.refreshDirectory(dirPath);
    }, REFRESH_DEBOUNCE_MS);
    this.refreshTimers.set(dirPath, timer);
  }
  /**
   * Actually refresh a directory and emit event if changed.
   */
  async refreshDirectory(dirPath) {
    if (this.disposed) {
      return;
    }
    const normalizedPath = nodePath.resolve(dirPath);
    try {
      const exists2 = await this.exists(normalizedPath);
      if (!exists2) {
        DirectoryCache.delete(normalizedPath);
        return;
      }
      const entries = await this.readDirectoryFromDisk(normalizedPath);
      DirectoryCache.set(normalizedPath, entries);
      this._onDirectoryListingChanged.fire({
        path: normalizedPath,
        entries
      });
    } catch (error) {
      const code = error.code;
      if (code === "EPERM" || code === "EACCES") {
        return;
      }
      console.error(
        `[DiskFileSystemProvider] Failed to refresh directory ${normalizedPath}:`,
        error
      );
    }
  }
  // -------------------------------------------------------------------------
  // Internal: Cache Verification
  // -------------------------------------------------------------------------
  /**
   * Schedule cache verification with cooldown.
   *
   * This ensures we don't hammer the disk when rapidly reading
   * the same directory.
   */
  scheduleVerifyCache(dirPath) {
    const now = Date.now();
    const lastVerify = this.lastVerifyTime.get(dirPath) ?? 0;
    if (now - lastVerify < VERIFY_CACHE_COOLDOWN_MS) {
      return;
    }
    this.lastVerifyTime.set(dirPath, now);
    this.verifyCache(dirPath).catch((error) => {
      const code = error.code;
      if (code === "EPERM" || code === "EACCES") {
        return;
      }
      console.error(
        `[DiskFileSystemProvider] Cache verification failed for ${dirPath}:`,
        error
      );
    });
  }
  /**
   * Verify cache matches disk and update if stale.
   */
  async verifyCache(dirPath) {
    if (this.disposed) {
      return;
    }
    try {
      const cached = DirectoryCache.get(dirPath);
      if (!cached) {
        return;
      }
      const freshEntries = await this.readDirectoryFromDisk(dirPath);
      const hasChanged = cached.entries.length !== freshEntries.length || cached.entries.some(
        (entry, i) => entry.name !== freshEntries[i].name || entry.type !== freshEntries[i].type
      );
      if (hasChanged) {
        DirectoryCache.set(dirPath, freshEntries);
        this._onDirectoryListingChanged.fire({
          path: dirPath,
          entries: freshEntries
        });
      }
    } catch {
      DirectoryCache.delete(dirPath);
    }
  }
  // -------------------------------------------------------------------------
  // Internal: Prefetching
  // -------------------------------------------------------------------------
  /**
   * Prefetch child directories in the background.
   *
   * This makes expanding folders in the UI instant because
   * the data is already cached.
   */
  prefetchChildren(parentPath, entries) {
    if (this.disposed) {
      return;
    }
    const directories = entries.filter((e) => e.type === "directory").map((e) => nodePath.join(parentPath, e.name)).filter((p) => !DirectoryCache.has(p));
    const available = MAX_CONCURRENT_PREFETCH - this.activePrefetches.size;
    const toPrefetch = directories.slice(0, available);
    for (const dirPath of toPrefetch) {
      this.prefetchDirectory(dirPath);
    }
  }
  /**
   * Prefetch a single directory.
   */
  async prefetchDirectory(dirPath) {
    if (this.disposed || this.activePrefetches.has(dirPath)) {
      return;
    }
    this.activePrefetches.add(dirPath);
    try {
      const entries = await this.readDirectoryFromDisk(dirPath);
      DirectoryCache.set(dirPath, entries);
    } catch {
    } finally {
      this.activePrefetches.delete(dirPath);
    }
  }
  // -------------------------------------------------------------------------
  // Internal: Helpers
  // -------------------------------------------------------------------------
  /**
   * Check if a file is readonly based on its stats.
   */
  isReadonly(stats) {
    return (stats.mode & 128) === 0;
  }
};

// src/fs/fs-provider-service.ts
var fs7 = __toESM(require("fs"), 1);
var path7 = __toESM(require("path"), 1);

// src/git/git-provider-service.ts
var fs6 = __toESM(require("fs"), 1);
var path6 = __toESM(require("path"), 1);

// ../../node_modules/simple-git/dist/esm/index.js
var import_node_buffer = require("buffer");
var import_file_exists = __toESM(require_dist(), 1);
var import_debug = __toESM(require_src(), 1);
var import_child_process = require("child_process");
var import_promise_deferred = __toESM(require_dist2(), 1);
var import_node_path4 = require("path");
var import_promise_deferred2 = __toESM(require_dist2(), 1);
var import_node_events2 = require("events");
var __defProp2 = Object.defineProperty;
var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames2 = Object.getOwnPropertyNames;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames2(fn)[0]])(fn = 0)), res;
};
var __commonJS2 = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames2(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export2 = (target, all) => {
  for (var name in all)
    __defProp2(target, name, { get: all[name], enumerable: true });
};
var __copyProps2 = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames2(from))
      if (!__hasOwnProp2.call(to, key) && key !== except)
        __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
function pathspec(...paths) {
  const key = new String(paths);
  cache.set(key, paths);
  return key;
}
function isPathSpec(path11) {
  return path11 instanceof String && cache.has(path11);
}
function toPaths(pathSpec) {
  return cache.get(pathSpec) || [];
}
var cache;
var init_pathspec = __esm({
  "src/lib/args/pathspec.ts"() {
    "use strict";
    cache = /* @__PURE__ */ new WeakMap();
  }
});
var GitError;
var init_git_error = __esm({
  "src/lib/errors/git-error.ts"() {
    "use strict";
    GitError = class extends Error {
      constructor(task, message) {
        super(message);
        this.task = task;
        Object.setPrototypeOf(this, new.target.prototype);
      }
    };
  }
});
var GitResponseError;
var init_git_response_error = __esm({
  "src/lib/errors/git-response-error.ts"() {
    "use strict";
    init_git_error();
    GitResponseError = class extends GitError {
      constructor(git, message) {
        super(void 0, message || String(git));
        this.git = git;
      }
    };
  }
});
var TaskConfigurationError;
var init_task_configuration_error = __esm({
  "src/lib/errors/task-configuration-error.ts"() {
    "use strict";
    init_git_error();
    TaskConfigurationError = class extends GitError {
      constructor(message) {
        super(void 0, message);
      }
    };
  }
});
function asFunction(source) {
  if (typeof source !== "function") {
    return NOOP;
  }
  return source;
}
function isUserFunction(source) {
  return typeof source === "function" && source !== NOOP;
}
function splitOn(input, char) {
  const index = input.indexOf(char);
  if (index <= 0) {
    return [input, ""];
  }
  return [input.substr(0, index), input.substr(index + 1)];
}
function first(input, offset = 0) {
  return isArrayLike(input) && input.length > offset ? input[offset] : void 0;
}
function last(input, offset = 0) {
  if (isArrayLike(input) && input.length > offset) {
    return input[input.length - 1 - offset];
  }
}
function isArrayLike(input) {
  return filterHasLength(input);
}
function toLinesWithContent(input = "", trimmed2 = true, separator = "\n") {
  return input.split(separator).reduce((output, line) => {
    const lineContent = trimmed2 ? line.trim() : line;
    if (lineContent) {
      output.push(lineContent);
    }
    return output;
  }, []);
}
function forEachLineWithContent(input, callback2) {
  return toLinesWithContent(input, true).map((line) => callback2(line));
}
function folderExists(path11) {
  return (0, import_file_exists.exists)(path11, import_file_exists.FOLDER);
}
function append(target, item) {
  if (Array.isArray(target)) {
    if (!target.includes(item)) {
      target.push(item);
    }
  } else {
    target.add(item);
  }
  return item;
}
function including(target, item) {
  if (Array.isArray(target) && !target.includes(item)) {
    target.push(item);
  }
  return target;
}
function remove(target, item) {
  if (Array.isArray(target)) {
    const index = target.indexOf(item);
    if (index >= 0) {
      target.splice(index, 1);
    }
  } else {
    target.delete(item);
  }
  return item;
}
function asArray(source) {
  return Array.isArray(source) ? source : [source];
}
function asCamelCase(str) {
  return str.replace(/[\s-]+(.)/g, (_all, chr) => {
    return chr.toUpperCase();
  });
}
function asStringArray(source) {
  return asArray(source).map((item) => {
    return item instanceof String ? item : String(item);
  });
}
function asNumber(source, onNaN = 0) {
  if (source == null) {
    return onNaN;
  }
  const num = parseInt(source, 10);
  return Number.isNaN(num) ? onNaN : num;
}
function prefixedArray(input, prefix) {
  const output = [];
  for (let i = 0, max = input.length; i < max; i++) {
    output.push(prefix, input[i]);
  }
  return output;
}
function bufferToString(input) {
  return (Array.isArray(input) ? import_node_buffer.Buffer.concat(input) : input).toString("utf-8");
}
function pick(source, properties) {
  const out = {};
  properties.forEach((key) => {
    if (source[key] !== void 0) {
      out[key] = source[key];
    }
  });
  return out;
}
function delay(duration = 0) {
  return new Promise((done) => setTimeout(done, duration));
}
function orVoid(input) {
  if (input === false) {
    return void 0;
  }
  return input;
}
var NULL;
var NOOP;
var objectToString;
var init_util = __esm({
  "src/lib/utils/util.ts"() {
    "use strict";
    init_argument_filters();
    NULL = "\0";
    NOOP = () => {
    };
    objectToString = Object.prototype.toString.call.bind(Object.prototype.toString);
  }
});
function filterType(input, filter, def) {
  if (filter(input)) {
    return input;
  }
  return arguments.length > 2 ? def : void 0;
}
function filterPrimitives(input, omit) {
  const type = isPathSpec(input) ? "string" : typeof input;
  return /number|string|boolean/.test(type) && (!omit || !omit.includes(type));
}
function filterPlainObject(input) {
  return !!input && objectToString(input) === "[object Object]";
}
function filterFunction(input) {
  return typeof input === "function";
}
var filterArray;
var filterNumber;
var filterString;
var filterStringOrStringArray;
var filterHasLength;
var init_argument_filters = __esm({
  "src/lib/utils/argument-filters.ts"() {
    "use strict";
    init_pathspec();
    init_util();
    filterArray = (input) => {
      return Array.isArray(input);
    };
    filterNumber = (input) => {
      return typeof input === "number";
    };
    filterString = (input) => {
      return typeof input === "string";
    };
    filterStringOrStringArray = (input) => {
      return filterString(input) || Array.isArray(input) && input.every(filterString);
    };
    filterHasLength = (input) => {
      if (input == null || "number|boolean|function".includes(typeof input)) {
        return false;
      }
      return typeof input.length === "number";
    };
  }
});
var ExitCodes;
var init_exit_codes = __esm({
  "src/lib/utils/exit-codes.ts"() {
    "use strict";
    ExitCodes = /* @__PURE__ */ ((ExitCodes2) => {
      ExitCodes2[ExitCodes2["SUCCESS"] = 0] = "SUCCESS";
      ExitCodes2[ExitCodes2["ERROR"] = 1] = "ERROR";
      ExitCodes2[ExitCodes2["NOT_FOUND"] = -2] = "NOT_FOUND";
      ExitCodes2[ExitCodes2["UNCLEAN"] = 128] = "UNCLEAN";
      return ExitCodes2;
    })(ExitCodes || {});
  }
});
var GitOutputStreams;
var init_git_output_streams = __esm({
  "src/lib/utils/git-output-streams.ts"() {
    "use strict";
    GitOutputStreams = class _GitOutputStreams {
      constructor(stdOut, stdErr) {
        this.stdOut = stdOut;
        this.stdErr = stdErr;
      }
      asStrings() {
        return new _GitOutputStreams(this.stdOut.toString("utf8"), this.stdErr.toString("utf8"));
      }
    };
  }
});
function useMatchesDefault() {
  throw new Error(`LineParser:useMatches not implemented`);
}
var LineParser;
var RemoteLineParser;
var init_line_parser = __esm({
  "src/lib/utils/line-parser.ts"() {
    "use strict";
    LineParser = class {
      constructor(regExp, useMatches) {
        this.matches = [];
        this.useMatches = useMatchesDefault;
        this.parse = (line, target) => {
          this.resetMatches();
          if (!this._regExp.every((reg, index) => this.addMatch(reg, index, line(index)))) {
            return false;
          }
          return this.useMatches(target, this.prepareMatches()) !== false;
        };
        this._regExp = Array.isArray(regExp) ? regExp : [regExp];
        if (useMatches) {
          this.useMatches = useMatches;
        }
      }
      resetMatches() {
        this.matches.length = 0;
      }
      prepareMatches() {
        return this.matches;
      }
      addMatch(reg, index, line) {
        const matched = line && reg.exec(line);
        if (matched) {
          this.pushMatch(index, matched);
        }
        return !!matched;
      }
      pushMatch(_index, matched) {
        this.matches.push(...matched.slice(1));
      }
    };
    RemoteLineParser = class extends LineParser {
      addMatch(reg, index, line) {
        return /^remote:\s/.test(String(line)) && super.addMatch(reg, index, line);
      }
      pushMatch(index, matched) {
        if (index > 0 || matched.length > 1) {
          super.pushMatch(index, matched);
        }
      }
    };
  }
});
function createInstanceConfig(...options) {
  const baseDir = process.cwd();
  const config = Object.assign(
    { baseDir, ...defaultOptions },
    ...options.filter((o) => typeof o === "object" && o)
  );
  config.baseDir = config.baseDir || baseDir;
  config.trimmed = config.trimmed === true;
  return config;
}
var defaultOptions;
var init_simple_git_options = __esm({
  "src/lib/utils/simple-git-options.ts"() {
    "use strict";
    defaultOptions = {
      binary: "git",
      maxConcurrentProcesses: 5,
      config: [],
      trimmed: false
    };
  }
});
function appendTaskOptions(options, commands = []) {
  if (!filterPlainObject(options)) {
    return commands;
  }
  return Object.keys(options).reduce((commands2, key) => {
    const value = options[key];
    if (isPathSpec(value)) {
      commands2.push(value);
    } else if (filterPrimitives(value, ["boolean"])) {
      commands2.push(key + "=" + value);
    } else if (Array.isArray(value)) {
      for (const v of value) {
        if (!filterPrimitives(v, ["string", "number"])) {
          commands2.push(key + "=" + v);
        }
      }
    } else {
      commands2.push(key);
    }
    return commands2;
  }, commands);
}
function getTrailingOptions(args, initialPrimitive = 0, objectOnly = false) {
  const command = [];
  for (let i = 0, max = initialPrimitive < 0 ? args.length : initialPrimitive; i < max; i++) {
    if ("string|number".includes(typeof args[i])) {
      command.push(String(args[i]));
    }
  }
  appendTaskOptions(trailingOptionsArgument(args), command);
  if (!objectOnly) {
    command.push(...trailingArrayArgument(args));
  }
  return command;
}
function trailingArrayArgument(args) {
  const hasTrailingCallback = typeof last(args) === "function";
  return asStringArray(filterType(last(args, hasTrailingCallback ? 1 : 0), filterArray, []));
}
function trailingOptionsArgument(args) {
  const hasTrailingCallback = filterFunction(last(args));
  return filterType(last(args, hasTrailingCallback ? 1 : 0), filterPlainObject);
}
function trailingFunctionArgument(args, includeNoop = true) {
  const callback2 = asFunction(last(args));
  return includeNoop || isUserFunction(callback2) ? callback2 : void 0;
}
var init_task_options = __esm({
  "src/lib/utils/task-options.ts"() {
    "use strict";
    init_argument_filters();
    init_util();
    init_pathspec();
  }
});
function callTaskParser(parser4, streams) {
  return parser4(streams.stdOut, streams.stdErr);
}
function parseStringResponse(result, parsers12, texts, trim = true) {
  asArray(texts).forEach((text) => {
    for (let lines = toLinesWithContent(text, trim), i = 0, max = lines.length; i < max; i++) {
      const line = (offset = 0) => {
        if (i + offset >= max) {
          return;
        }
        return lines[i + offset];
      };
      parsers12.some(({ parse: parse2 }) => parse2(line, result));
    }
  });
  return result;
}
var init_task_parser = __esm({
  "src/lib/utils/task-parser.ts"() {
    "use strict";
    init_util();
  }
});
var utils_exports = {};
__export2(utils_exports, {
  ExitCodes: () => ExitCodes,
  GitOutputStreams: () => GitOutputStreams,
  LineParser: () => LineParser,
  NOOP: () => NOOP,
  NULL: () => NULL,
  RemoteLineParser: () => RemoteLineParser,
  append: () => append,
  appendTaskOptions: () => appendTaskOptions,
  asArray: () => asArray,
  asCamelCase: () => asCamelCase,
  asFunction: () => asFunction,
  asNumber: () => asNumber,
  asStringArray: () => asStringArray,
  bufferToString: () => bufferToString,
  callTaskParser: () => callTaskParser,
  createInstanceConfig: () => createInstanceConfig,
  delay: () => delay,
  filterArray: () => filterArray,
  filterFunction: () => filterFunction,
  filterHasLength: () => filterHasLength,
  filterNumber: () => filterNumber,
  filterPlainObject: () => filterPlainObject,
  filterPrimitives: () => filterPrimitives,
  filterString: () => filterString,
  filterStringOrStringArray: () => filterStringOrStringArray,
  filterType: () => filterType,
  first: () => first,
  folderExists: () => folderExists,
  forEachLineWithContent: () => forEachLineWithContent,
  getTrailingOptions: () => getTrailingOptions,
  including: () => including,
  isUserFunction: () => isUserFunction,
  last: () => last,
  objectToString: () => objectToString,
  orVoid: () => orVoid,
  parseStringResponse: () => parseStringResponse,
  pick: () => pick,
  prefixedArray: () => prefixedArray,
  remove: () => remove,
  splitOn: () => splitOn,
  toLinesWithContent: () => toLinesWithContent,
  trailingFunctionArgument: () => trailingFunctionArgument,
  trailingOptionsArgument: () => trailingOptionsArgument
});
var init_utils = __esm({
  "src/lib/utils/index.ts"() {
    "use strict";
    init_argument_filters();
    init_exit_codes();
    init_git_output_streams();
    init_line_parser();
    init_simple_git_options();
    init_task_options();
    init_task_parser();
    init_util();
  }
});
var check_is_repo_exports = {};
__export2(check_is_repo_exports, {
  CheckRepoActions: () => CheckRepoActions,
  checkIsBareRepoTask: () => checkIsBareRepoTask,
  checkIsRepoRootTask: () => checkIsRepoRootTask,
  checkIsRepoTask: () => checkIsRepoTask
});
function checkIsRepoTask(action) {
  switch (action) {
    case "bare":
      return checkIsBareRepoTask();
    case "root":
      return checkIsRepoRootTask();
  }
  const commands = ["rev-parse", "--is-inside-work-tree"];
  return {
    commands,
    format: "utf-8",
    onError,
    parser
  };
}
function checkIsRepoRootTask() {
  const commands = ["rev-parse", "--git-dir"];
  return {
    commands,
    format: "utf-8",
    onError,
    parser(path11) {
      return /^\.(git)?$/.test(path11.trim());
    }
  };
}
function checkIsBareRepoTask() {
  const commands = ["rev-parse", "--is-bare-repository"];
  return {
    commands,
    format: "utf-8",
    onError,
    parser
  };
}
function isNotRepoMessage(error) {
  return /(Not a git repository|Kein Git-Repository)/i.test(String(error));
}
var CheckRepoActions;
var onError;
var parser;
var init_check_is_repo = __esm({
  "src/lib/tasks/check-is-repo.ts"() {
    "use strict";
    init_utils();
    CheckRepoActions = /* @__PURE__ */ ((CheckRepoActions2) => {
      CheckRepoActions2["BARE"] = "bare";
      CheckRepoActions2["IN_TREE"] = "tree";
      CheckRepoActions2["IS_REPO_ROOT"] = "root";
      return CheckRepoActions2;
    })(CheckRepoActions || {});
    onError = ({ exitCode }, error, done, fail) => {
      if (exitCode === 128 && isNotRepoMessage(error)) {
        return done(Buffer.from("false"));
      }
      fail(error);
    };
    parser = (text) => {
      return text.trim() === "true";
    };
  }
});
function cleanSummaryParser(dryRun, text) {
  const summary = new CleanResponse(dryRun);
  const regexp = dryRun ? dryRunRemovalRegexp : removalRegexp;
  toLinesWithContent(text).forEach((line) => {
    const removed = line.replace(regexp, "");
    summary.paths.push(removed);
    (isFolderRegexp.test(removed) ? summary.folders : summary.files).push(removed);
  });
  return summary;
}
var CleanResponse;
var removalRegexp;
var dryRunRemovalRegexp;
var isFolderRegexp;
var init_CleanSummary = __esm({
  "src/lib/responses/CleanSummary.ts"() {
    "use strict";
    init_utils();
    CleanResponse = class {
      constructor(dryRun) {
        this.dryRun = dryRun;
        this.paths = [];
        this.files = [];
        this.folders = [];
      }
    };
    removalRegexp = /^[a-z]+\s*/i;
    dryRunRemovalRegexp = /^[a-z]+\s+[a-z]+\s*/i;
    isFolderRegexp = /\/$/;
  }
});
var task_exports = {};
__export2(task_exports, {
  EMPTY_COMMANDS: () => EMPTY_COMMANDS,
  adhocExecTask: () => adhocExecTask,
  configurationErrorTask: () => configurationErrorTask,
  isBufferTask: () => isBufferTask,
  isEmptyTask: () => isEmptyTask,
  straightThroughBufferTask: () => straightThroughBufferTask,
  straightThroughStringTask: () => straightThroughStringTask
});
function adhocExecTask(parser4) {
  return {
    commands: EMPTY_COMMANDS,
    format: "empty",
    parser: parser4
  };
}
function configurationErrorTask(error) {
  return {
    commands: EMPTY_COMMANDS,
    format: "empty",
    parser() {
      throw typeof error === "string" ? new TaskConfigurationError(error) : error;
    }
  };
}
function straightThroughStringTask(commands, trimmed2 = false) {
  return {
    commands,
    format: "utf-8",
    parser(text) {
      return trimmed2 ? String(text).trim() : text;
    }
  };
}
function straightThroughBufferTask(commands) {
  return {
    commands,
    format: "buffer",
    parser(buffer) {
      return buffer;
    }
  };
}
function isBufferTask(task) {
  return task.format === "buffer";
}
function isEmptyTask(task) {
  return task.format === "empty" || !task.commands.length;
}
var EMPTY_COMMANDS;
var init_task = __esm({
  "src/lib/tasks/task.ts"() {
    "use strict";
    init_task_configuration_error();
    EMPTY_COMMANDS = [];
  }
});
var clean_exports = {};
__export2(clean_exports, {
  CONFIG_ERROR_INTERACTIVE_MODE: () => CONFIG_ERROR_INTERACTIVE_MODE,
  CONFIG_ERROR_MODE_REQUIRED: () => CONFIG_ERROR_MODE_REQUIRED,
  CONFIG_ERROR_UNKNOWN_OPTION: () => CONFIG_ERROR_UNKNOWN_OPTION,
  CleanOptions: () => CleanOptions,
  cleanTask: () => cleanTask,
  cleanWithOptionsTask: () => cleanWithOptionsTask,
  isCleanOptionsArray: () => isCleanOptionsArray
});
function cleanWithOptionsTask(mode, customArgs) {
  const { cleanMode, options, valid } = getCleanOptions(mode);
  if (!cleanMode) {
    return configurationErrorTask(CONFIG_ERROR_MODE_REQUIRED);
  }
  if (!valid.options) {
    return configurationErrorTask(CONFIG_ERROR_UNKNOWN_OPTION + JSON.stringify(mode));
  }
  options.push(...customArgs);
  if (options.some(isInteractiveMode)) {
    return configurationErrorTask(CONFIG_ERROR_INTERACTIVE_MODE);
  }
  return cleanTask(cleanMode, options);
}
function cleanTask(mode, customArgs) {
  const commands = ["clean", `-${mode}`, ...customArgs];
  return {
    commands,
    format: "utf-8",
    parser(text) {
      return cleanSummaryParser(mode === "n", text);
    }
  };
}
function isCleanOptionsArray(input) {
  return Array.isArray(input) && input.every((test) => CleanOptionValues.has(test));
}
function getCleanOptions(input) {
  let cleanMode;
  let options = [];
  let valid = { cleanMode: false, options: true };
  input.replace(/[^a-z]i/g, "").split("").forEach((char) => {
    if (isCleanMode(char)) {
      cleanMode = char;
      valid.cleanMode = true;
    } else {
      valid.options = valid.options && isKnownOption(options[options.length] = `-${char}`);
    }
  });
  return {
    cleanMode,
    options,
    valid
  };
}
function isCleanMode(cleanMode) {
  return cleanMode === "f" || cleanMode === "n";
}
function isKnownOption(option) {
  return /^-[a-z]$/i.test(option) && CleanOptionValues.has(option.charAt(1));
}
function isInteractiveMode(option) {
  if (/^-[^\-]/.test(option)) {
    return option.indexOf("i") > 0;
  }
  return option === "--interactive";
}
var CONFIG_ERROR_INTERACTIVE_MODE;
var CONFIG_ERROR_MODE_REQUIRED;
var CONFIG_ERROR_UNKNOWN_OPTION;
var CleanOptions;
var CleanOptionValues;
var init_clean = __esm({
  "src/lib/tasks/clean.ts"() {
    "use strict";
    init_CleanSummary();
    init_utils();
    init_task();
    CONFIG_ERROR_INTERACTIVE_MODE = "Git clean interactive mode is not supported";
    CONFIG_ERROR_MODE_REQUIRED = 'Git clean mode parameter ("n" or "f") is required';
    CONFIG_ERROR_UNKNOWN_OPTION = "Git clean unknown option found in: ";
    CleanOptions = /* @__PURE__ */ ((CleanOptions2) => {
      CleanOptions2["DRY_RUN"] = "n";
      CleanOptions2["FORCE"] = "f";
      CleanOptions2["IGNORED_INCLUDED"] = "x";
      CleanOptions2["IGNORED_ONLY"] = "X";
      CleanOptions2["EXCLUDING"] = "e";
      CleanOptions2["QUIET"] = "q";
      CleanOptions2["RECURSIVE"] = "d";
      return CleanOptions2;
    })(CleanOptions || {});
    CleanOptionValues = /* @__PURE__ */ new Set([
      "i",
      ...asStringArray(Object.values(CleanOptions))
    ]);
  }
});
function configListParser(text) {
  const config = new ConfigList();
  for (const item of configParser(text)) {
    config.addValue(item.file, String(item.key), item.value);
  }
  return config;
}
function configGetParser(text, key) {
  let value = null;
  const values = [];
  const scopes = /* @__PURE__ */ new Map();
  for (const item of configParser(text, key)) {
    if (item.key !== key) {
      continue;
    }
    values.push(value = item.value);
    if (!scopes.has(item.file)) {
      scopes.set(item.file, []);
    }
    scopes.get(item.file).push(value);
  }
  return {
    key,
    paths: Array.from(scopes.keys()),
    scopes,
    value,
    values
  };
}
function configFilePath(filePath) {
  return filePath.replace(/^(file):/, "");
}
function* configParser(text, requestedKey = null) {
  const lines = text.split("\0");
  for (let i = 0, max = lines.length - 1; i < max; ) {
    const file = configFilePath(lines[i++]);
    let value = lines[i++];
    let key = requestedKey;
    if (value.includes("\n")) {
      const line = splitOn(value, "\n");
      key = line[0];
      value = line[1];
    }
    yield { file, key, value };
  }
}
var ConfigList;
var init_ConfigList = __esm({
  "src/lib/responses/ConfigList.ts"() {
    "use strict";
    init_utils();
    ConfigList = class {
      constructor() {
        this.files = [];
        this.values = /* @__PURE__ */ Object.create(null);
      }
      get all() {
        if (!this._all) {
          this._all = this.files.reduce((all, file) => {
            return Object.assign(all, this.values[file]);
          }, {});
        }
        return this._all;
      }
      addFile(file) {
        if (!(file in this.values)) {
          const latest = last(this.files);
          this.values[file] = latest ? Object.create(this.values[latest]) : {};
          this.files.push(file);
        }
        return this.values[file];
      }
      addValue(file, key, value) {
        const values = this.addFile(file);
        if (!Object.hasOwn(values, key)) {
          values[key] = value;
        } else if (Array.isArray(values[key])) {
          values[key].push(value);
        } else {
          values[key] = [values[key], value];
        }
        this._all = void 0;
      }
    };
  }
});
function asConfigScope(scope, fallback) {
  if (typeof scope === "string" && Object.hasOwn(GitConfigScope, scope)) {
    return scope;
  }
  return fallback;
}
function addConfigTask(key, value, append2, scope) {
  const commands = ["config", `--${scope}`];
  if (append2) {
    commands.push("--add");
  }
  commands.push(key, value);
  return {
    commands,
    format: "utf-8",
    parser(text) {
      return text;
    }
  };
}
function getConfigTask(key, scope) {
  const commands = ["config", "--null", "--show-origin", "--get-all", key];
  if (scope) {
    commands.splice(1, 0, `--${scope}`);
  }
  return {
    commands,
    format: "utf-8",
    parser(text) {
      return configGetParser(text, key);
    }
  };
}
function listConfigTask(scope) {
  const commands = ["config", "--list", "--show-origin", "--null"];
  if (scope) {
    commands.push(`--${scope}`);
  }
  return {
    commands,
    format: "utf-8",
    parser(text) {
      return configListParser(text);
    }
  };
}
function config_default() {
  return {
    addConfig(key, value, ...rest) {
      return this._runTask(
        addConfigTask(
          key,
          value,
          rest[0] === true,
          asConfigScope(
            rest[1],
            "local"
            /* local */
          )
        ),
        trailingFunctionArgument(arguments)
      );
    },
    getConfig(key, scope) {
      return this._runTask(
        getConfigTask(key, asConfigScope(scope, void 0)),
        trailingFunctionArgument(arguments)
      );
    },
    listConfig(...rest) {
      return this._runTask(
        listConfigTask(asConfigScope(rest[0], void 0)),
        trailingFunctionArgument(arguments)
      );
    }
  };
}
var GitConfigScope;
var init_config = __esm({
  "src/lib/tasks/config.ts"() {
    "use strict";
    init_ConfigList();
    init_utils();
    GitConfigScope = /* @__PURE__ */ ((GitConfigScope2) => {
      GitConfigScope2["system"] = "system";
      GitConfigScope2["global"] = "global";
      GitConfigScope2["local"] = "local";
      GitConfigScope2["worktree"] = "worktree";
      return GitConfigScope2;
    })(GitConfigScope || {});
  }
});
function isDiffNameStatus(input) {
  return diffNameStatus.has(input);
}
var DiffNameStatus;
var diffNameStatus;
var init_diff_name_status = __esm({
  "src/lib/tasks/diff-name-status.ts"() {
    "use strict";
    DiffNameStatus = /* @__PURE__ */ ((DiffNameStatus2) => {
      DiffNameStatus2["ADDED"] = "A";
      DiffNameStatus2["COPIED"] = "C";
      DiffNameStatus2["DELETED"] = "D";
      DiffNameStatus2["MODIFIED"] = "M";
      DiffNameStatus2["RENAMED"] = "R";
      DiffNameStatus2["CHANGED"] = "T";
      DiffNameStatus2["UNMERGED"] = "U";
      DiffNameStatus2["UNKNOWN"] = "X";
      DiffNameStatus2["BROKEN"] = "B";
      return DiffNameStatus2;
    })(DiffNameStatus || {});
    diffNameStatus = new Set(Object.values(DiffNameStatus));
  }
});
function grepQueryBuilder(...params) {
  return new GrepQuery().param(...params);
}
function parseGrep(grep) {
  const paths = /* @__PURE__ */ new Set();
  const results = {};
  forEachLineWithContent(grep, (input) => {
    const [path11, line, preview] = input.split(NULL);
    paths.add(path11);
    (results[path11] = results[path11] || []).push({
      line: asNumber(line),
      path: path11,
      preview
    });
  });
  return {
    paths,
    results
  };
}
function grep_default() {
  return {
    grep(searchTerm) {
      const then = trailingFunctionArgument(arguments);
      const options = getTrailingOptions(arguments);
      for (const option of disallowedOptions) {
        if (options.includes(option)) {
          return this._runTask(
            configurationErrorTask(`git.grep: use of "${option}" is not supported.`),
            then
          );
        }
      }
      if (typeof searchTerm === "string") {
        searchTerm = grepQueryBuilder().param(searchTerm);
      }
      const commands = ["grep", "--null", "-n", "--full-name", ...options, ...searchTerm];
      return this._runTask(
        {
          commands,
          format: "utf-8",
          parser(stdOut) {
            return parseGrep(stdOut);
          }
        },
        then
      );
    }
  };
}
var disallowedOptions;
var Query;
var _a;
var GrepQuery;
var init_grep = __esm({
  "src/lib/tasks/grep.ts"() {
    "use strict";
    init_utils();
    init_task();
    disallowedOptions = ["-h"];
    Query = /* @__PURE__ */ Symbol("grepQuery");
    GrepQuery = class {
      constructor() {
        this[_a] = [];
      }
      *[(_a = Query, Symbol.iterator)]() {
        for (const query of this[Query]) {
          yield query;
        }
      }
      and(...and) {
        and.length && this[Query].push("--and", "(", ...prefixedArray(and, "-e"), ")");
        return this;
      }
      param(...param) {
        this[Query].push(...prefixedArray(param, "-e"));
        return this;
      }
    };
  }
});
var reset_exports = {};
__export2(reset_exports, {
  ResetMode: () => ResetMode,
  getResetMode: () => getResetMode,
  resetTask: () => resetTask
});
function resetTask(mode, customArgs) {
  const commands = ["reset"];
  if (isValidResetMode(mode)) {
    commands.push(`--${mode}`);
  }
  commands.push(...customArgs);
  return straightThroughStringTask(commands);
}
function getResetMode(mode) {
  if (isValidResetMode(mode)) {
    return mode;
  }
  switch (typeof mode) {
    case "string":
    case "undefined":
      return "soft";
  }
  return;
}
function isValidResetMode(mode) {
  return typeof mode === "string" && validResetModes.includes(mode);
}
var ResetMode;
var validResetModes;
var init_reset = __esm({
  "src/lib/tasks/reset.ts"() {
    "use strict";
    init_utils();
    init_task();
    ResetMode = /* @__PURE__ */ ((ResetMode2) => {
      ResetMode2["MIXED"] = "mixed";
      ResetMode2["SOFT"] = "soft";
      ResetMode2["HARD"] = "hard";
      ResetMode2["MERGE"] = "merge";
      ResetMode2["KEEP"] = "keep";
      return ResetMode2;
    })(ResetMode || {});
    validResetModes = asStringArray(Object.values(ResetMode));
  }
});
function createLog() {
  return (0, import_debug.default)("simple-git");
}
function prefixedLogger(to, prefix, forward) {
  if (!prefix || !String(prefix).replace(/\s*/, "")) {
    return !forward ? to : (message, ...args) => {
      to(message, ...args);
      forward(message, ...args);
    };
  }
  return (message, ...args) => {
    to(`%s ${message}`, prefix, ...args);
    if (forward) {
      forward(message, ...args);
    }
  };
}
function childLoggerName(name, childDebugger, { namespace: parentNamespace }) {
  if (typeof name === "string") {
    return name;
  }
  const childNamespace = childDebugger && childDebugger.namespace || "";
  if (childNamespace.startsWith(parentNamespace)) {
    return childNamespace.substr(parentNamespace.length + 1);
  }
  return childNamespace || parentNamespace;
}
function createLogger(label, verbose, initialStep, infoDebugger = createLog()) {
  const labelPrefix = label && `[${label}]` || "";
  const spawned = [];
  const debugDebugger = typeof verbose === "string" ? infoDebugger.extend(verbose) : verbose;
  const key = childLoggerName(filterType(verbose, filterString), debugDebugger, infoDebugger);
  return step(initialStep);
  function sibling(name, initial) {
    return append(
      spawned,
      createLogger(label, key.replace(/^[^:]+/, name), initial, infoDebugger)
    );
  }
  function step(phase) {
    const stepPrefix = phase && `[${phase}]` || "";
    const debug2 = debugDebugger && prefixedLogger(debugDebugger, stepPrefix) || NOOP;
    const info = prefixedLogger(infoDebugger, `${labelPrefix} ${stepPrefix}`, debug2);
    return Object.assign(debugDebugger ? debug2 : info, {
      label,
      sibling,
      info,
      step
    });
  }
}
var init_git_logger = __esm({
  "src/lib/git-logger.ts"() {
    "use strict";
    init_utils();
    import_debug.default.formatters.L = (value) => String(filterHasLength(value) ? value.length : "-");
    import_debug.default.formatters.B = (value) => {
      if (Buffer.isBuffer(value)) {
        return value.toString("utf8");
      }
      return objectToString(value);
    };
  }
});
var TasksPendingQueue;
var init_tasks_pending_queue = __esm({
  "src/lib/runners/tasks-pending-queue.ts"() {
    "use strict";
    init_git_error();
    init_git_logger();
    TasksPendingQueue = class _TasksPendingQueue {
      constructor(logLabel = "GitExecutor") {
        this.logLabel = logLabel;
        this._queue = /* @__PURE__ */ new Map();
      }
      withProgress(task) {
        return this._queue.get(task);
      }
      createProgress(task) {
        const name = _TasksPendingQueue.getName(task.commands[0]);
        const logger = createLogger(this.logLabel, name);
        return {
          task,
          logger,
          name
        };
      }
      push(task) {
        const progress = this.createProgress(task);
        progress.logger("Adding task to the queue, commands = %o", task.commands);
        this._queue.set(task, progress);
        return progress;
      }
      fatal(err) {
        for (const [task, { logger }] of Array.from(this._queue.entries())) {
          if (task === err.task) {
            logger.info(`Failed %o`, err);
            logger(
              `Fatal exception, any as-yet un-started tasks run through this executor will not be attempted`
            );
          } else {
            logger.info(
              `A fatal exception occurred in a previous task, the queue has been purged: %o`,
              err.message
            );
          }
          this.complete(task);
        }
        if (this._queue.size !== 0) {
          throw new Error(`Queue size should be zero after fatal: ${this._queue.size}`);
        }
      }
      complete(task) {
        const progress = this.withProgress(task);
        if (progress) {
          this._queue.delete(task);
        }
      }
      attempt(task) {
        const progress = this.withProgress(task);
        if (!progress) {
          throw new GitError(void 0, "TasksPendingQueue: attempt called for an unknown task");
        }
        progress.logger("Starting task");
        return progress;
      }
      static getName(name = "empty") {
        return `task:${name}:${++_TasksPendingQueue.counter}`;
      }
      static {
        this.counter = 0;
      }
    };
  }
});
function pluginContext(task, commands) {
  return {
    method: first(task.commands) || "",
    commands
  };
}
function onErrorReceived(target, logger) {
  return (err) => {
    logger(`[ERROR] child process exception %o`, err);
    target.push(Buffer.from(String(err.stack), "ascii"));
  };
}
function onDataReceived(target, name, logger, output) {
  return (buffer) => {
    logger(`%s received %L bytes`, name, buffer);
    output(`%B`, buffer);
    target.push(buffer);
  };
}
var GitExecutorChain;
var init_git_executor_chain = __esm({
  "src/lib/runners/git-executor-chain.ts"() {
    "use strict";
    init_git_error();
    init_task();
    init_utils();
    init_tasks_pending_queue();
    GitExecutorChain = class {
      constructor(_executor, _scheduler, _plugins) {
        this._executor = _executor;
        this._scheduler = _scheduler;
        this._plugins = _plugins;
        this._chain = Promise.resolve();
        this._queue = new TasksPendingQueue();
      }
      get cwd() {
        return this._cwd || this._executor.cwd;
      }
      set cwd(cwd) {
        this._cwd = cwd;
      }
      get env() {
        return this._executor.env;
      }
      get outputHandler() {
        return this._executor.outputHandler;
      }
      chain() {
        return this;
      }
      push(task) {
        this._queue.push(task);
        return this._chain = this._chain.then(() => this.attemptTask(task));
      }
      async attemptTask(task) {
        const onScheduleComplete = await this._scheduler.next();
        const onQueueComplete = () => this._queue.complete(task);
        try {
          const { logger } = this._queue.attempt(task);
          return await (isEmptyTask(task) ? this.attemptEmptyTask(task, logger) : this.attemptRemoteTask(task, logger));
        } catch (e) {
          throw this.onFatalException(task, e);
        } finally {
          onQueueComplete();
          onScheduleComplete();
        }
      }
      onFatalException(task, e) {
        const gitError = e instanceof GitError ? Object.assign(e, { task }) : new GitError(task, e && String(e));
        this._chain = Promise.resolve();
        this._queue.fatal(gitError);
        return gitError;
      }
      async attemptRemoteTask(task, logger) {
        const binary = this._plugins.exec("spawn.binary", "", pluginContext(task, task.commands));
        const args = this._plugins.exec(
          "spawn.args",
          [...task.commands],
          pluginContext(task, task.commands)
        );
        const raw = await this.gitResponse(
          task,
          binary,
          args,
          this.outputHandler,
          logger.step("SPAWN")
        );
        const outputStreams = await this.handleTaskData(task, args, raw, logger.step("HANDLE"));
        logger(`passing response to task's parser as a %s`, task.format);
        if (isBufferTask(task)) {
          return callTaskParser(task.parser, outputStreams);
        }
        return callTaskParser(task.parser, outputStreams.asStrings());
      }
      async attemptEmptyTask(task, logger) {
        logger(`empty task bypassing child process to call to task's parser`);
        return task.parser(this);
      }
      handleTaskData(task, args, result, logger) {
        const { exitCode, rejection, stdOut, stdErr } = result;
        return new Promise((done, fail) => {
          logger(`Preparing to handle process response exitCode=%d stdOut=`, exitCode);
          const { error } = this._plugins.exec(
            "task.error",
            { error: rejection },
            {
              ...pluginContext(task, args),
              ...result
            }
          );
          if (error && task.onError) {
            logger.info(`exitCode=%s handling with custom error handler`);
            return task.onError(
              result,
              error,
              (newStdOut) => {
                logger.info(`custom error handler treated as success`);
                logger(`custom error returned a %s`, objectToString(newStdOut));
                done(
                  new GitOutputStreams(
                    Array.isArray(newStdOut) ? Buffer.concat(newStdOut) : newStdOut,
                    Buffer.concat(stdErr)
                  )
                );
              },
              fail
            );
          }
          if (error) {
            logger.info(
              `handling as error: exitCode=%s stdErr=%s rejection=%o`,
              exitCode,
              stdErr.length,
              rejection
            );
            return fail(error);
          }
          logger.info(`retrieving task output complete`);
          done(new GitOutputStreams(Buffer.concat(stdOut), Buffer.concat(stdErr)));
        });
      }
      async gitResponse(task, command, args, outputHandler, logger) {
        const outputLogger = logger.sibling("output");
        const spawnOptions = this._plugins.exec(
          "spawn.options",
          {
            cwd: this.cwd,
            env: this.env,
            windowsHide: true
          },
          pluginContext(task, task.commands)
        );
        return new Promise((done) => {
          const stdOut = [];
          const stdErr = [];
          logger.info(`%s %o`, command, args);
          logger("%O", spawnOptions);
          let rejection = this._beforeSpawn(task, args);
          if (rejection) {
            return done({
              stdOut,
              stdErr,
              exitCode: 9901,
              rejection
            });
          }
          this._plugins.exec("spawn.before", void 0, {
            ...pluginContext(task, args),
            kill(reason) {
              rejection = reason || rejection;
            }
          });
          const spawned = (0, import_child_process.spawn)(command, args, spawnOptions);
          spawned.stdout.on(
            "data",
            onDataReceived(stdOut, "stdOut", logger, outputLogger.step("stdOut"))
          );
          spawned.stderr.on(
            "data",
            onDataReceived(stdErr, "stdErr", logger, outputLogger.step("stdErr"))
          );
          spawned.on("error", onErrorReceived(stdErr, logger));
          if (outputHandler) {
            logger(`Passing child process stdOut/stdErr to custom outputHandler`);
            outputHandler(command, spawned.stdout, spawned.stderr, [...args]);
          }
          this._plugins.exec("spawn.after", void 0, {
            ...pluginContext(task, args),
            spawned,
            close(exitCode, reason) {
              done({
                stdOut,
                stdErr,
                exitCode,
                rejection: rejection || reason
              });
            },
            kill(reason) {
              if (spawned.killed) {
                return;
              }
              rejection = reason;
              spawned.kill("SIGINT");
            }
          });
        });
      }
      _beforeSpawn(task, args) {
        let rejection;
        this._plugins.exec("spawn.before", void 0, {
          ...pluginContext(task, args),
          kill(reason) {
            rejection = reason || rejection;
          }
        });
        return rejection;
      }
    };
  }
});
var git_executor_exports = {};
__export2(git_executor_exports, {
  GitExecutor: () => GitExecutor
});
var GitExecutor;
var init_git_executor = __esm({
  "src/lib/runners/git-executor.ts"() {
    "use strict";
    init_git_executor_chain();
    GitExecutor = class {
      constructor(cwd, _scheduler, _plugins) {
        this.cwd = cwd;
        this._scheduler = _scheduler;
        this._plugins = _plugins;
        this._chain = new GitExecutorChain(this, this._scheduler, this._plugins);
      }
      chain() {
        return new GitExecutorChain(this, this._scheduler, this._plugins);
      }
      push(task) {
        return this._chain.push(task);
      }
    };
  }
});
function taskCallback(task, response, callback2 = NOOP) {
  const onSuccess = (data) => {
    callback2(null, data);
  };
  const onError2 = (err) => {
    if (err?.task === task) {
      callback2(
        err instanceof GitResponseError ? addDeprecationNoticeToError(err) : err,
        void 0
      );
    }
  };
  response.then(onSuccess, onError2);
}
function addDeprecationNoticeToError(err) {
  let log = (name) => {
    console.warn(
      `simple-git deprecation notice: accessing GitResponseError.${name} should be GitResponseError.git.${name}, this will no longer be available in version 3`
    );
    log = NOOP;
  };
  return Object.create(err, Object.getOwnPropertyNames(err.git).reduce(descriptorReducer, {}));
  function descriptorReducer(all, name) {
    if (name in err) {
      return all;
    }
    all[name] = {
      enumerable: false,
      configurable: false,
      get() {
        log(name);
        return err.git[name];
      }
    };
    return all;
  }
}
var init_task_callback = __esm({
  "src/lib/task-callback.ts"() {
    "use strict";
    init_git_response_error();
    init_utils();
  }
});
function changeWorkingDirectoryTask(directory, root) {
  return adhocExecTask((instance) => {
    if (!folderExists(directory)) {
      throw new Error(`Git.cwd: cannot change to non-directory "${directory}"`);
    }
    return (root || instance).cwd = directory;
  });
}
var init_change_working_directory = __esm({
  "src/lib/tasks/change-working-directory.ts"() {
    "use strict";
    init_utils();
    init_task();
  }
});
function checkoutTask(args) {
  const commands = ["checkout", ...args];
  if (commands[1] === "-b" && commands.includes("-B")) {
    commands[1] = remove(commands, "-B");
  }
  return straightThroughStringTask(commands);
}
function checkout_default() {
  return {
    checkout() {
      return this._runTask(
        checkoutTask(getTrailingOptions(arguments, 1)),
        trailingFunctionArgument(arguments)
      );
    },
    checkoutBranch(branchName, startPoint) {
      return this._runTask(
        checkoutTask(["-b", branchName, startPoint, ...getTrailingOptions(arguments)]),
        trailingFunctionArgument(arguments)
      );
    },
    checkoutLocalBranch(branchName) {
      return this._runTask(
        checkoutTask(["-b", branchName, ...getTrailingOptions(arguments)]),
        trailingFunctionArgument(arguments)
      );
    }
  };
}
var init_checkout = __esm({
  "src/lib/tasks/checkout.ts"() {
    "use strict";
    init_utils();
    init_task();
  }
});
function countObjectsResponse() {
  return {
    count: 0,
    garbage: 0,
    inPack: 0,
    packs: 0,
    prunePackable: 0,
    size: 0,
    sizeGarbage: 0,
    sizePack: 0
  };
}
function count_objects_default() {
  return {
    countObjects() {
      return this._runTask({
        commands: ["count-objects", "--verbose"],
        format: "utf-8",
        parser(stdOut) {
          return parseStringResponse(countObjectsResponse(), [parser2], stdOut);
        }
      });
    }
  };
}
var parser2;
var init_count_objects = __esm({
  "src/lib/tasks/count-objects.ts"() {
    "use strict";
    init_utils();
    parser2 = new LineParser(
      /([a-z-]+): (\d+)$/,
      (result, [key, value]) => {
        const property = asCamelCase(key);
        if (Object.hasOwn(result, property)) {
          result[property] = asNumber(value);
        }
      }
    );
  }
});
function parseCommitResult(stdOut) {
  const result = {
    author: null,
    branch: "",
    commit: "",
    root: false,
    summary: {
      changes: 0,
      insertions: 0,
      deletions: 0
    }
  };
  return parseStringResponse(result, parsers, stdOut);
}
var parsers;
var init_parse_commit = __esm({
  "src/lib/parsers/parse-commit.ts"() {
    "use strict";
    init_utils();
    parsers = [
      new LineParser(/^\[([^\s]+)( \([^)]+\))? ([^\]]+)/, (result, [branch, root, commit]) => {
        result.branch = branch;
        result.commit = commit;
        result.root = !!root;
      }),
      new LineParser(/\s*Author:\s(.+)/i, (result, [author]) => {
        const parts = author.split("<");
        const email = parts.pop();
        if (!email || !email.includes("@")) {
          return;
        }
        result.author = {
          email: email.substr(0, email.length - 1),
          name: parts.join("<").trim()
        };
      }),
      new LineParser(
        /(\d+)[^,]*(?:,\s*(\d+)[^,]*)(?:,\s*(\d+))/g,
        (result, [changes, insertions, deletions]) => {
          result.summary.changes = parseInt(changes, 10) || 0;
          result.summary.insertions = parseInt(insertions, 10) || 0;
          result.summary.deletions = parseInt(deletions, 10) || 0;
        }
      ),
      new LineParser(
        /^(\d+)[^,]*(?:,\s*(\d+)[^(]+\(([+-]))?/,
        (result, [changes, lines, direction]) => {
          result.summary.changes = parseInt(changes, 10) || 0;
          const count = parseInt(lines, 10) || 0;
          if (direction === "-") {
            result.summary.deletions = count;
          } else if (direction === "+") {
            result.summary.insertions = count;
          }
        }
      )
    ];
  }
});
function commitTask(message, files, customArgs) {
  const commands = [
    "-c",
    "core.abbrev=40",
    "commit",
    ...prefixedArray(message, "-m"),
    ...files,
    ...customArgs
  ];
  return {
    commands,
    format: "utf-8",
    parser: parseCommitResult
  };
}
function commit_default() {
  return {
    commit(message, ...rest) {
      const next = trailingFunctionArgument(arguments);
      const task = rejectDeprecatedSignatures(message) || commitTask(
        asArray(message),
        asArray(filterType(rest[0], filterStringOrStringArray, [])),
        [
          ...asStringArray(filterType(rest[1], filterArray, [])),
          ...getTrailingOptions(arguments, 0, true)
        ]
      );
      return this._runTask(task, next);
    }
  };
  function rejectDeprecatedSignatures(message) {
    return !filterStringOrStringArray(message) && configurationErrorTask(
      `git.commit: requires the commit message to be supplied as a string/string[]`
    );
  }
}
var init_commit = __esm({
  "src/lib/tasks/commit.ts"() {
    "use strict";
    init_parse_commit();
    init_utils();
    init_task();
  }
});
function first_commit_default() {
  return {
    firstCommit() {
      return this._runTask(
        straightThroughStringTask(["rev-list", "--max-parents=0", "HEAD"], true),
        trailingFunctionArgument(arguments)
      );
    }
  };
}
var init_first_commit = __esm({
  "src/lib/tasks/first-commit.ts"() {
    "use strict";
    init_utils();
    init_task();
  }
});
function hashObjectTask(filePath, write) {
  const commands = ["hash-object", filePath];
  if (write) {
    commands.push("-w");
  }
  return straightThroughStringTask(commands, true);
}
var init_hash_object = __esm({
  "src/lib/tasks/hash-object.ts"() {
    "use strict";
    init_task();
  }
});
function parseInit(bare, path11, text) {
  const response = String(text).trim();
  let result;
  if (result = initResponseRegex.exec(response)) {
    return new InitSummary(bare, path11, false, result[1]);
  }
  if (result = reInitResponseRegex.exec(response)) {
    return new InitSummary(bare, path11, true, result[1]);
  }
  let gitDir = "";
  const tokens = response.split(" ");
  while (tokens.length) {
    const token = tokens.shift();
    if (token === "in") {
      gitDir = tokens.join(" ");
      break;
    }
  }
  return new InitSummary(bare, path11, /^re/i.test(response), gitDir);
}
var InitSummary;
var initResponseRegex;
var reInitResponseRegex;
var init_InitSummary = __esm({
  "src/lib/responses/InitSummary.ts"() {
    "use strict";
    InitSummary = class {
      constructor(bare, path11, existing, gitDir) {
        this.bare = bare;
        this.path = path11;
        this.existing = existing;
        this.gitDir = gitDir;
      }
    };
    initResponseRegex = /^Init.+ repository in (.+)$/;
    reInitResponseRegex = /^Rein.+ in (.+)$/;
  }
});
function hasBareCommand(command) {
  return command.includes(bareCommand);
}
function initTask(bare = false, path11, customArgs) {
  const commands = ["init", ...customArgs];
  if (bare && !hasBareCommand(commands)) {
    commands.splice(1, 0, bareCommand);
  }
  return {
    commands,
    format: "utf-8",
    parser(text) {
      return parseInit(commands.includes("--bare"), path11, text);
    }
  };
}
var bareCommand;
var init_init = __esm({
  "src/lib/tasks/init.ts"() {
    "use strict";
    init_InitSummary();
    bareCommand = "--bare";
  }
});
function logFormatFromCommand(customArgs) {
  for (let i = 0; i < customArgs.length; i++) {
    const format = logFormatRegex.exec(customArgs[i]);
    if (format) {
      return `--${format[1]}`;
    }
  }
  return "";
}
function isLogFormat(customArg) {
  return logFormatRegex.test(customArg);
}
var logFormatRegex;
var init_log_format = __esm({
  "src/lib/args/log-format.ts"() {
    "use strict";
    logFormatRegex = /^--(stat|numstat|name-only|name-status)(=|$)/;
  }
});
var DiffSummary;
var init_DiffSummary = __esm({
  "src/lib/responses/DiffSummary.ts"() {
    "use strict";
    DiffSummary = class {
      constructor() {
        this.changed = 0;
        this.deletions = 0;
        this.insertions = 0;
        this.files = [];
      }
    };
  }
});
function getDiffParser(format = "") {
  const parser4 = diffSummaryParsers[format];
  return (stdOut) => parseStringResponse(new DiffSummary(), parser4, stdOut, false);
}
var statParser;
var numStatParser;
var nameOnlyParser;
var nameStatusParser;
var diffSummaryParsers;
var init_parse_diff_summary = __esm({
  "src/lib/parsers/parse-diff-summary.ts"() {
    "use strict";
    init_log_format();
    init_DiffSummary();
    init_diff_name_status();
    init_utils();
    statParser = [
      new LineParser(
        /^(.+)\s+\|\s+(\d+)(\s+[+\-]+)?$/,
        (result, [file, changes, alterations = ""]) => {
          result.files.push({
            file: file.trim(),
            changes: asNumber(changes),
            insertions: alterations.replace(/[^+]/g, "").length,
            deletions: alterations.replace(/[^-]/g, "").length,
            binary: false
          });
        }
      ),
      new LineParser(
        /^(.+) \|\s+Bin ([0-9.]+) -> ([0-9.]+) ([a-z]+)/,
        (result, [file, before, after]) => {
          result.files.push({
            file: file.trim(),
            before: asNumber(before),
            after: asNumber(after),
            binary: true
          });
        }
      ),
      new LineParser(
        /(\d+) files? changed\s*((?:, \d+ [^,]+){0,2})/,
        (result, [changed, summary]) => {
          const inserted = /(\d+) i/.exec(summary);
          const deleted = /(\d+) d/.exec(summary);
          result.changed = asNumber(changed);
          result.insertions = asNumber(inserted?.[1]);
          result.deletions = asNumber(deleted?.[1]);
        }
      )
    ];
    numStatParser = [
      new LineParser(
        /(\d+)\t(\d+)\t(.+)$/,
        (result, [changesInsert, changesDelete, file]) => {
          const insertions = asNumber(changesInsert);
          const deletions = asNumber(changesDelete);
          result.changed++;
          result.insertions += insertions;
          result.deletions += deletions;
          result.files.push({
            file,
            changes: insertions + deletions,
            insertions,
            deletions,
            binary: false
          });
        }
      ),
      new LineParser(/-\t-\t(.+)$/, (result, [file]) => {
        result.changed++;
        result.files.push({
          file,
          after: 0,
          before: 0,
          binary: true
        });
      })
    ];
    nameOnlyParser = [
      new LineParser(/(.+)$/, (result, [file]) => {
        result.changed++;
        result.files.push({
          file,
          changes: 0,
          insertions: 0,
          deletions: 0,
          binary: false
        });
      })
    ];
    nameStatusParser = [
      new LineParser(
        /([ACDMRTUXB])([0-9]{0,3})\t(.[^\t]*)(\t(.[^\t]*))?$/,
        (result, [status, similarity, from, _to, to]) => {
          result.changed++;
          result.files.push({
            file: to ?? from,
            changes: 0,
            insertions: 0,
            deletions: 0,
            binary: false,
            status: orVoid(isDiffNameStatus(status) && status),
            from: orVoid(!!to && from !== to && from),
            similarity: asNumber(similarity)
          });
        }
      )
    ];
    diffSummaryParsers = {
      [
        ""
        /* NONE */
      ]: statParser,
      [
        "--stat"
        /* STAT */
      ]: statParser,
      [
        "--numstat"
        /* NUM_STAT */
      ]: numStatParser,
      [
        "--name-status"
        /* NAME_STATUS */
      ]: nameStatusParser,
      [
        "--name-only"
        /* NAME_ONLY */
      ]: nameOnlyParser
    };
  }
});
function lineBuilder(tokens, fields) {
  return fields.reduce(
    (line, field, index) => {
      line[field] = tokens[index] || "";
      return line;
    },
    /* @__PURE__ */ Object.create({ diff: null })
  );
}
function createListLogSummaryParser(splitter = SPLITTER, fields = defaultFieldNames, logFormat = "") {
  const parseDiffResult = getDiffParser(logFormat);
  return function(stdOut) {
    const all = toLinesWithContent(
      stdOut.trim(),
      false,
      START_BOUNDARY
    ).map(function(item) {
      const lineDetail = item.split(COMMIT_BOUNDARY);
      const listLogLine = lineBuilder(lineDetail[0].split(splitter), fields);
      if (lineDetail.length > 1 && !!lineDetail[1].trim()) {
        listLogLine.diff = parseDiffResult(lineDetail[1]);
      }
      return listLogLine;
    });
    return {
      all,
      latest: all.length && all[0] || null,
      total: all.length
    };
  };
}
var START_BOUNDARY;
var COMMIT_BOUNDARY;
var SPLITTER;
var defaultFieldNames;
var init_parse_list_log_summary = __esm({
  "src/lib/parsers/parse-list-log-summary.ts"() {
    "use strict";
    init_utils();
    init_parse_diff_summary();
    init_log_format();
    START_BOUNDARY = "\xF2\xF2\xF2\xF2\xF2\xF2 ";
    COMMIT_BOUNDARY = " \xF2\xF2";
    SPLITTER = " \xF2 ";
    defaultFieldNames = ["hash", "date", "message", "refs", "author_name", "author_email"];
  }
});
var diff_exports = {};
__export2(diff_exports, {
  diffSummaryTask: () => diffSummaryTask,
  validateLogFormatConfig: () => validateLogFormatConfig
});
function diffSummaryTask(customArgs) {
  let logFormat = logFormatFromCommand(customArgs);
  const commands = ["diff"];
  if (logFormat === "") {
    logFormat = "--stat";
    commands.push("--stat=4096");
  }
  commands.push(...customArgs);
  return validateLogFormatConfig(commands) || {
    commands,
    format: "utf-8",
    parser: getDiffParser(logFormat)
  };
}
function validateLogFormatConfig(customArgs) {
  const flags = customArgs.filter(isLogFormat);
  if (flags.length > 1) {
    return configurationErrorTask(
      `Summary flags are mutually exclusive - pick one of ${flags.join(",")}`
    );
  }
  if (flags.length && customArgs.includes("-z")) {
    return configurationErrorTask(
      `Summary flag ${flags} parsing is not compatible with null termination option '-z'`
    );
  }
}
var init_diff = __esm({
  "src/lib/tasks/diff.ts"() {
    "use strict";
    init_log_format();
    init_parse_diff_summary();
    init_task();
  }
});
function prettyFormat(format, splitter) {
  const fields = [];
  const formatStr = [];
  Object.keys(format).forEach((field) => {
    fields.push(field);
    formatStr.push(String(format[field]));
  });
  return [fields, formatStr.join(splitter)];
}
function userOptions(input) {
  return Object.keys(input).reduce((out, key) => {
    if (!(key in excludeOptions)) {
      out[key] = input[key];
    }
    return out;
  }, {});
}
function parseLogOptions(opt = {}, customArgs = []) {
  const splitter = filterType(opt.splitter, filterString, SPLITTER);
  const format = filterPlainObject(opt.format) ? opt.format : {
    hash: "%H",
    date: opt.strictDate === false ? "%ai" : "%aI",
    message: "%s",
    refs: "%D",
    body: opt.multiLine ? "%B" : "%b",
    author_name: opt.mailMap !== false ? "%aN" : "%an",
    author_email: opt.mailMap !== false ? "%aE" : "%ae"
  };
  const [fields, formatStr] = prettyFormat(format, splitter);
  const suffix = [];
  const command = [
    `--pretty=format:${START_BOUNDARY}${formatStr}${COMMIT_BOUNDARY}`,
    ...customArgs
  ];
  const maxCount = opt.n || opt["max-count"] || opt.maxCount;
  if (maxCount) {
    command.push(`--max-count=${maxCount}`);
  }
  if (opt.from || opt.to) {
    const rangeOperator = opt.symmetric !== false ? "..." : "..";
    suffix.push(`${opt.from || ""}${rangeOperator}${opt.to || ""}`);
  }
  if (filterString(opt.file)) {
    command.push("--follow", pathspec(opt.file));
  }
  appendTaskOptions(userOptions(opt), command);
  return {
    fields,
    splitter,
    commands: [...command, ...suffix]
  };
}
function logTask(splitter, fields, customArgs) {
  const parser4 = createListLogSummaryParser(splitter, fields, logFormatFromCommand(customArgs));
  return {
    commands: ["log", ...customArgs],
    format: "utf-8",
    parser: parser4
  };
}
function log_default() {
  return {
    log(...rest) {
      const next = trailingFunctionArgument(arguments);
      const options = parseLogOptions(
        trailingOptionsArgument(arguments),
        asStringArray(filterType(arguments[0], filterArray, []))
      );
      const task = rejectDeprecatedSignatures(...rest) || validateLogFormatConfig(options.commands) || createLogTask(options);
      return this._runTask(task, next);
    }
  };
  function createLogTask(options) {
    return logTask(options.splitter, options.fields, options.commands);
  }
  function rejectDeprecatedSignatures(from, to) {
    return filterString(from) && filterString(to) && configurationErrorTask(
      `git.log(string, string) should be replaced with git.log({ from: string, to: string })`
    );
  }
}
var excludeOptions;
var init_log = __esm({
  "src/lib/tasks/log.ts"() {
    "use strict";
    init_log_format();
    init_pathspec();
    init_parse_list_log_summary();
    init_utils();
    init_task();
    init_diff();
    excludeOptions = /* @__PURE__ */ ((excludeOptions2) => {
      excludeOptions2[excludeOptions2["--pretty"] = 0] = "--pretty";
      excludeOptions2[excludeOptions2["max-count"] = 1] = "max-count";
      excludeOptions2[excludeOptions2["maxCount"] = 2] = "maxCount";
      excludeOptions2[excludeOptions2["n"] = 3] = "n";
      excludeOptions2[excludeOptions2["file"] = 4] = "file";
      excludeOptions2[excludeOptions2["format"] = 5] = "format";
      excludeOptions2[excludeOptions2["from"] = 6] = "from";
      excludeOptions2[excludeOptions2["to"] = 7] = "to";
      excludeOptions2[excludeOptions2["splitter"] = 8] = "splitter";
      excludeOptions2[excludeOptions2["symmetric"] = 9] = "symmetric";
      excludeOptions2[excludeOptions2["mailMap"] = 10] = "mailMap";
      excludeOptions2[excludeOptions2["multiLine"] = 11] = "multiLine";
      excludeOptions2[excludeOptions2["strictDate"] = 12] = "strictDate";
      return excludeOptions2;
    })(excludeOptions || {});
  }
});
var MergeSummaryConflict;
var MergeSummaryDetail;
var init_MergeSummary = __esm({
  "src/lib/responses/MergeSummary.ts"() {
    "use strict";
    MergeSummaryConflict = class {
      constructor(reason, file = null, meta) {
        this.reason = reason;
        this.file = file;
        this.meta = meta;
      }
      toString() {
        return `${this.file}:${this.reason}`;
      }
    };
    MergeSummaryDetail = class {
      constructor() {
        this.conflicts = [];
        this.merges = [];
        this.result = "success";
      }
      get failed() {
        return this.conflicts.length > 0;
      }
      get reason() {
        return this.result;
      }
      toString() {
        if (this.conflicts.length) {
          return `CONFLICTS: ${this.conflicts.join(", ")}`;
        }
        return "OK";
      }
    };
  }
});
var PullSummary;
var PullFailedSummary;
var init_PullSummary = __esm({
  "src/lib/responses/PullSummary.ts"() {
    "use strict";
    PullSummary = class {
      constructor() {
        this.remoteMessages = {
          all: []
        };
        this.created = [];
        this.deleted = [];
        this.files = [];
        this.deletions = {};
        this.insertions = {};
        this.summary = {
          changes: 0,
          deletions: 0,
          insertions: 0
        };
      }
    };
    PullFailedSummary = class {
      constructor() {
        this.remote = "";
        this.hash = {
          local: "",
          remote: ""
        };
        this.branch = {
          local: "",
          remote: ""
        };
        this.message = "";
      }
      toString() {
        return this.message;
      }
    };
  }
});
function objectEnumerationResult(remoteMessages) {
  return remoteMessages.objects = remoteMessages.objects || {
    compressing: 0,
    counting: 0,
    enumerating: 0,
    packReused: 0,
    reused: { count: 0, delta: 0 },
    total: { count: 0, delta: 0 }
  };
}
function asObjectCount(source) {
  const count = /^\s*(\d+)/.exec(source);
  const delta = /delta (\d+)/i.exec(source);
  return {
    count: asNumber(count && count[1] || "0"),
    delta: asNumber(delta && delta[1] || "0")
  };
}
var remoteMessagesObjectParsers;
var init_parse_remote_objects = __esm({
  "src/lib/parsers/parse-remote-objects.ts"() {
    "use strict";
    init_utils();
    remoteMessagesObjectParsers = [
      new RemoteLineParser(
        /^remote:\s*(enumerating|counting|compressing) objects: (\d+),/i,
        (result, [action, count]) => {
          const key = action.toLowerCase();
          const enumeration = objectEnumerationResult(result.remoteMessages);
          Object.assign(enumeration, { [key]: asNumber(count) });
        }
      ),
      new RemoteLineParser(
        /^remote:\s*(enumerating|counting|compressing) objects: \d+% \(\d+\/(\d+)\),/i,
        (result, [action, count]) => {
          const key = action.toLowerCase();
          const enumeration = objectEnumerationResult(result.remoteMessages);
          Object.assign(enumeration, { [key]: asNumber(count) });
        }
      ),
      new RemoteLineParser(
        /total ([^,]+), reused ([^,]+), pack-reused (\d+)/i,
        (result, [total, reused, packReused]) => {
          const objects = objectEnumerationResult(result.remoteMessages);
          objects.total = asObjectCount(total);
          objects.reused = asObjectCount(reused);
          objects.packReused = asNumber(packReused);
        }
      )
    ];
  }
});
function parseRemoteMessages(_stdOut, stdErr) {
  return parseStringResponse({ remoteMessages: new RemoteMessageSummary() }, parsers2, stdErr);
}
var parsers2;
var RemoteMessageSummary;
var init_parse_remote_messages = __esm({
  "src/lib/parsers/parse-remote-messages.ts"() {
    "use strict";
    init_utils();
    init_parse_remote_objects();
    parsers2 = [
      new RemoteLineParser(/^remote:\s*(.+)$/, (result, [text]) => {
        result.remoteMessages.all.push(text.trim());
        return false;
      }),
      ...remoteMessagesObjectParsers,
      new RemoteLineParser(
        [/create a (?:pull|merge) request/i, /\s(https?:\/\/\S+)$/],
        (result, [pullRequestUrl]) => {
          result.remoteMessages.pullRequestUrl = pullRequestUrl;
        }
      ),
      new RemoteLineParser(
        [/found (\d+) vulnerabilities.+\(([^)]+)\)/i, /\s(https?:\/\/\S+)$/],
        (result, [count, summary, url]) => {
          result.remoteMessages.vulnerabilities = {
            count: asNumber(count),
            summary,
            url
          };
        }
      )
    ];
    RemoteMessageSummary = class {
      constructor() {
        this.all = [];
      }
    };
  }
});
function parsePullErrorResult(stdOut, stdErr) {
  const pullError = parseStringResponse(new PullFailedSummary(), errorParsers, [stdOut, stdErr]);
  return pullError.message && pullError;
}
var FILE_UPDATE_REGEX;
var SUMMARY_REGEX;
var ACTION_REGEX;
var parsers3;
var errorParsers;
var parsePullDetail;
var parsePullResult;
var init_parse_pull = __esm({
  "src/lib/parsers/parse-pull.ts"() {
    "use strict";
    init_PullSummary();
    init_utils();
    init_parse_remote_messages();
    FILE_UPDATE_REGEX = /^\s*(.+?)\s+\|\s+\d+\s*(\+*)(-*)/;
    SUMMARY_REGEX = /(\d+)\D+((\d+)\D+\(\+\))?(\D+(\d+)\D+\(-\))?/;
    ACTION_REGEX = /^(create|delete) mode \d+ (.+)/;
    parsers3 = [
      new LineParser(FILE_UPDATE_REGEX, (result, [file, insertions, deletions]) => {
        result.files.push(file);
        if (insertions) {
          result.insertions[file] = insertions.length;
        }
        if (deletions) {
          result.deletions[file] = deletions.length;
        }
      }),
      new LineParser(SUMMARY_REGEX, (result, [changes, , insertions, , deletions]) => {
        if (insertions !== void 0 || deletions !== void 0) {
          result.summary.changes = +changes || 0;
          result.summary.insertions = +insertions || 0;
          result.summary.deletions = +deletions || 0;
          return true;
        }
        return false;
      }),
      new LineParser(ACTION_REGEX, (result, [action, file]) => {
        append(result.files, file);
        append(action === "create" ? result.created : result.deleted, file);
      })
    ];
    errorParsers = [
      new LineParser(/^from\s(.+)$/i, (result, [remote]) => void (result.remote = remote)),
      new LineParser(/^fatal:\s(.+)$/, (result, [message]) => void (result.message = message)),
      new LineParser(
        /([a-z0-9]+)\.\.([a-z0-9]+)\s+(\S+)\s+->\s+(\S+)$/,
        (result, [hashLocal, hashRemote, branchLocal, branchRemote]) => {
          result.branch.local = branchLocal;
          result.hash.local = hashLocal;
          result.branch.remote = branchRemote;
          result.hash.remote = hashRemote;
        }
      )
    ];
    parsePullDetail = (stdOut, stdErr) => {
      return parseStringResponse(new PullSummary(), parsers3, [stdOut, stdErr]);
    };
    parsePullResult = (stdOut, stdErr) => {
      return Object.assign(
        new PullSummary(),
        parsePullDetail(stdOut, stdErr),
        parseRemoteMessages(stdOut, stdErr)
      );
    };
  }
});
var parsers4;
var parseMergeResult;
var parseMergeDetail;
var init_parse_merge = __esm({
  "src/lib/parsers/parse-merge.ts"() {
    "use strict";
    init_MergeSummary();
    init_utils();
    init_parse_pull();
    parsers4 = [
      new LineParser(/^Auto-merging\s+(.+)$/, (summary, [autoMerge]) => {
        summary.merges.push(autoMerge);
      }),
      new LineParser(/^CONFLICT\s+\((.+)\): Merge conflict in (.+)$/, (summary, [reason, file]) => {
        summary.conflicts.push(new MergeSummaryConflict(reason, file));
      }),
      new LineParser(
        /^CONFLICT\s+\((.+\/delete)\): (.+) deleted in (.+) and/,
        (summary, [reason, file, deleteRef]) => {
          summary.conflicts.push(new MergeSummaryConflict(reason, file, { deleteRef }));
        }
      ),
      new LineParser(/^CONFLICT\s+\((.+)\):/, (summary, [reason]) => {
        summary.conflicts.push(new MergeSummaryConflict(reason, null));
      }),
      new LineParser(/^Automatic merge failed;\s+(.+)$/, (summary, [result]) => {
        summary.result = result;
      })
    ];
    parseMergeResult = (stdOut, stdErr) => {
      return Object.assign(parseMergeDetail(stdOut, stdErr), parsePullResult(stdOut, stdErr));
    };
    parseMergeDetail = (stdOut) => {
      return parseStringResponse(new MergeSummaryDetail(), parsers4, stdOut);
    };
  }
});
function mergeTask(customArgs) {
  if (!customArgs.length) {
    return configurationErrorTask("Git.merge requires at least one option");
  }
  return {
    commands: ["merge", ...customArgs],
    format: "utf-8",
    parser(stdOut, stdErr) {
      const merge = parseMergeResult(stdOut, stdErr);
      if (merge.failed) {
        throw new GitResponseError(merge);
      }
      return merge;
    }
  };
}
var init_merge = __esm({
  "src/lib/tasks/merge.ts"() {
    "use strict";
    init_git_response_error();
    init_parse_merge();
    init_task();
  }
});
function pushResultPushedItem(local, remote, status) {
  const deleted = status.includes("deleted");
  const tag = status.includes("tag") || /^refs\/tags/.test(local);
  const alreadyUpdated = !status.includes("new");
  return {
    deleted,
    tag,
    branch: !tag,
    new: !alreadyUpdated,
    alreadyUpdated,
    local,
    remote
  };
}
var parsers5;
var parsePushResult;
var parsePushDetail;
var init_parse_push = __esm({
  "src/lib/parsers/parse-push.ts"() {
    "use strict";
    init_utils();
    init_parse_remote_messages();
    parsers5 = [
      new LineParser(/^Pushing to (.+)$/, (result, [repo]) => {
        result.repo = repo;
      }),
      new LineParser(/^updating local tracking ref '(.+)'/, (result, [local]) => {
        result.ref = {
          ...result.ref || {},
          local
        };
      }),
      new LineParser(/^[=*-]\s+([^:]+):(\S+)\s+\[(.+)]$/, (result, [local, remote, type]) => {
        result.pushed.push(pushResultPushedItem(local, remote, type));
      }),
      new LineParser(
        /^Branch '([^']+)' set up to track remote branch '([^']+)' from '([^']+)'/,
        (result, [local, remote, remoteName]) => {
          result.branch = {
            ...result.branch || {},
            local,
            remote,
            remoteName
          };
        }
      ),
      new LineParser(
        /^([^:]+):(\S+)\s+([a-z0-9]+)\.\.([a-z0-9]+)$/,
        (result, [local, remote, from, to]) => {
          result.update = {
            head: {
              local,
              remote
            },
            hash: {
              from,
              to
            }
          };
        }
      )
    ];
    parsePushResult = (stdOut, stdErr) => {
      const pushDetail = parsePushDetail(stdOut, stdErr);
      const responseDetail = parseRemoteMessages(stdOut, stdErr);
      return {
        ...pushDetail,
        ...responseDetail
      };
    };
    parsePushDetail = (stdOut, stdErr) => {
      return parseStringResponse({ pushed: [] }, parsers5, [stdOut, stdErr]);
    };
  }
});
var push_exports = {};
__export2(push_exports, {
  pushTagsTask: () => pushTagsTask,
  pushTask: () => pushTask
});
function pushTagsTask(ref = {}, customArgs) {
  append(customArgs, "--tags");
  return pushTask(ref, customArgs);
}
function pushTask(ref = {}, customArgs) {
  const commands = ["push", ...customArgs];
  if (ref.branch) {
    commands.splice(1, 0, ref.branch);
  }
  if (ref.remote) {
    commands.splice(1, 0, ref.remote);
  }
  remove(commands, "-v");
  append(commands, "--verbose");
  append(commands, "--porcelain");
  return {
    commands,
    format: "utf-8",
    parser: parsePushResult
  };
}
var init_push = __esm({
  "src/lib/tasks/push.ts"() {
    "use strict";
    init_parse_push();
    init_utils();
  }
});
function show_default() {
  return {
    showBuffer() {
      const commands = ["show", ...getTrailingOptions(arguments, 1)];
      if (!commands.includes("--binary")) {
        commands.splice(1, 0, "--binary");
      }
      return this._runTask(
        straightThroughBufferTask(commands),
        trailingFunctionArgument(arguments)
      );
    },
    show() {
      const commands = ["show", ...getTrailingOptions(arguments, 1)];
      return this._runTask(
        straightThroughStringTask(commands),
        trailingFunctionArgument(arguments)
      );
    }
  };
}
var init_show = __esm({
  "src/lib/tasks/show.ts"() {
    "use strict";
    init_utils();
    init_task();
  }
});
var fromPathRegex;
var FileStatusSummary;
var init_FileStatusSummary = __esm({
  "src/lib/responses/FileStatusSummary.ts"() {
    "use strict";
    fromPathRegex = /^(.+)\0(.+)$/;
    FileStatusSummary = class {
      constructor(path11, index, working_dir) {
        this.path = path11;
        this.index = index;
        this.working_dir = working_dir;
        if (index === "R" || working_dir === "R") {
          const detail = fromPathRegex.exec(path11) || [null, path11, path11];
          this.from = detail[2] || "";
          this.path = detail[1] || "";
        }
      }
    };
  }
});
function renamedFile(line) {
  const [to, from] = line.split(NULL);
  return {
    from: from || to,
    to
  };
}
function parser3(indexX, indexY, handler) {
  return [`${indexX}${indexY}`, handler];
}
function conflicts(indexX, ...indexY) {
  return indexY.map((y) => parser3(indexX, y, (result, file) => append(result.conflicted, file)));
}
function splitLine(result, lineStr) {
  const trimmed2 = lineStr.trim();
  switch (" ") {
    case trimmed2.charAt(2):
      return data(trimmed2.charAt(0), trimmed2.charAt(1), trimmed2.substr(3));
    case trimmed2.charAt(1):
      return data(" ", trimmed2.charAt(0), trimmed2.substr(2));
    default:
      return;
  }
  function data(index, workingDir, path11) {
    const raw = `${index}${workingDir}`;
    const handler = parsers6.get(raw);
    if (handler) {
      handler(result, path11);
    }
    if (raw !== "##" && raw !== "!!") {
      result.files.push(new FileStatusSummary(path11, index, workingDir));
    }
  }
}
var StatusSummary;
var parsers6;
var parseStatusSummary;
var init_StatusSummary = __esm({
  "src/lib/responses/StatusSummary.ts"() {
    "use strict";
    init_utils();
    init_FileStatusSummary();
    StatusSummary = class {
      constructor() {
        this.not_added = [];
        this.conflicted = [];
        this.created = [];
        this.deleted = [];
        this.ignored = void 0;
        this.modified = [];
        this.renamed = [];
        this.files = [];
        this.staged = [];
        this.ahead = 0;
        this.behind = 0;
        this.current = null;
        this.tracking = null;
        this.detached = false;
        this.isClean = () => {
          return !this.files.length;
        };
      }
    };
    parsers6 = new Map([
      parser3(
        " ",
        "A",
        (result, file) => append(result.created, file)
      ),
      parser3(
        " ",
        "D",
        (result, file) => append(result.deleted, file)
      ),
      parser3(
        " ",
        "M",
        (result, file) => append(result.modified, file)
      ),
      parser3(
        "A",
        " ",
        (result, file) => append(result.created, file) && append(result.staged, file)
      ),
      parser3(
        "A",
        "M",
        (result, file) => append(result.created, file) && append(result.staged, file) && append(result.modified, file)
      ),
      parser3(
        "D",
        " ",
        (result, file) => append(result.deleted, file) && append(result.staged, file)
      ),
      parser3(
        "M",
        " ",
        (result, file) => append(result.modified, file) && append(result.staged, file)
      ),
      parser3(
        "M",
        "M",
        (result, file) => append(result.modified, file) && append(result.staged, file)
      ),
      parser3("R", " ", (result, file) => {
        append(result.renamed, renamedFile(file));
      }),
      parser3("R", "M", (result, file) => {
        const renamed = renamedFile(file);
        append(result.renamed, renamed);
        append(result.modified, renamed.to);
      }),
      parser3("!", "!", (_result, _file) => {
        append(_result.ignored = _result.ignored || [], _file);
      }),
      parser3(
        "?",
        "?",
        (result, file) => append(result.not_added, file)
      ),
      ...conflicts(
        "A",
        "A",
        "U"
        /* UNMERGED */
      ),
      ...conflicts(
        "D",
        "D",
        "U"
        /* UNMERGED */
      ),
      ...conflicts(
        "U",
        "A",
        "D",
        "U"
        /* UNMERGED */
      ),
      [
        "##",
        (result, line) => {
          const aheadReg = /ahead (\d+)/;
          const behindReg = /behind (\d+)/;
          const currentReg = /^(.+?(?=(?:\.{3}|\s|$)))/;
          const trackingReg = /\.{3}(\S*)/;
          const onEmptyBranchReg = /\son\s(\S+?)(?=\.{3}|$)/;
          let regexResult = aheadReg.exec(line);
          result.ahead = regexResult && +regexResult[1] || 0;
          regexResult = behindReg.exec(line);
          result.behind = regexResult && +regexResult[1] || 0;
          regexResult = currentReg.exec(line);
          result.current = filterType(regexResult?.[1], filterString, null);
          regexResult = trackingReg.exec(line);
          result.tracking = filterType(regexResult?.[1], filterString, null);
          regexResult = onEmptyBranchReg.exec(line);
          if (regexResult) {
            result.current = filterType(regexResult?.[1], filterString, result.current);
          }
          result.detached = /\(no branch\)/.test(line);
        }
      ]
    ]);
    parseStatusSummary = function(text) {
      const lines = text.split(NULL);
      const status = new StatusSummary();
      for (let i = 0, l = lines.length; i < l; ) {
        let line = lines[i++].trim();
        if (!line) {
          continue;
        }
        if (line.charAt(0) === "R") {
          line += NULL + (lines[i++] || "");
        }
        splitLine(status, line);
      }
      return status;
    };
  }
});
function statusTask(customArgs) {
  const commands = [
    "status",
    "--porcelain",
    "-b",
    "-u",
    "--null",
    ...customArgs.filter((arg) => !ignoredOptions.includes(arg))
  ];
  return {
    format: "utf-8",
    commands,
    parser(text) {
      return parseStatusSummary(text);
    }
  };
}
var ignoredOptions;
var init_status = __esm({
  "src/lib/tasks/status.ts"() {
    "use strict";
    init_StatusSummary();
    ignoredOptions = ["--null", "-z"];
  }
});
function versionResponse(major = 0, minor = 0, patch = 0, agent = "", installed = true) {
  return Object.defineProperty(
    {
      major,
      minor,
      patch,
      agent,
      installed
    },
    "toString",
    {
      value() {
        return `${this.major}.${this.minor}.${this.patch}`;
      },
      configurable: false,
      enumerable: false
    }
  );
}
function notInstalledResponse() {
  return versionResponse(0, 0, 0, "", false);
}
function version_default() {
  return {
    version() {
      return this._runTask({
        commands: ["--version"],
        format: "utf-8",
        parser: versionParser,
        onError(result, error, done, fail) {
          if (result.exitCode === -2) {
            return done(Buffer.from(NOT_INSTALLED));
          }
          fail(error);
        }
      });
    }
  };
}
function versionParser(stdOut) {
  if (stdOut === NOT_INSTALLED) {
    return notInstalledResponse();
  }
  return parseStringResponse(versionResponse(0, 0, 0, stdOut), parsers7, stdOut);
}
var NOT_INSTALLED;
var parsers7;
var init_version = __esm({
  "src/lib/tasks/version.ts"() {
    "use strict";
    init_utils();
    NOT_INSTALLED = "installed=false";
    parsers7 = [
      new LineParser(
        /version (\d+)\.(\d+)\.(\d+)(?:\s*\((.+)\))?/,
        (result, [major, minor, patch, agent = ""]) => {
          Object.assign(
            result,
            versionResponse(asNumber(major), asNumber(minor), asNumber(patch), agent)
          );
        }
      ),
      new LineParser(
        /version (\d+)\.(\d+)\.(\D+)(.+)?$/,
        (result, [major, minor, patch, agent = ""]) => {
          Object.assign(result, versionResponse(asNumber(major), asNumber(minor), patch, agent));
        }
      )
    ];
  }
});
var simple_git_api_exports = {};
__export2(simple_git_api_exports, {
  SimpleGitApi: () => SimpleGitApi
});
var SimpleGitApi;
var init_simple_git_api = __esm({
  "src/lib/simple-git-api.ts"() {
    "use strict";
    init_task_callback();
    init_change_working_directory();
    init_checkout();
    init_count_objects();
    init_commit();
    init_config();
    init_first_commit();
    init_grep();
    init_hash_object();
    init_init();
    init_log();
    init_merge();
    init_push();
    init_show();
    init_status();
    init_task();
    init_version();
    init_utils();
    SimpleGitApi = class {
      constructor(_executor) {
        this._executor = _executor;
      }
      _runTask(task, then) {
        const chain = this._executor.chain();
        const promise2 = chain.push(task);
        if (then) {
          taskCallback(task, promise2, then);
        }
        return Object.create(this, {
          then: { value: promise2.then.bind(promise2) },
          catch: { value: promise2.catch.bind(promise2) },
          _executor: { value: chain }
        });
      }
      add(files) {
        return this._runTask(
          straightThroughStringTask(["add", ...asArray(files)]),
          trailingFunctionArgument(arguments)
        );
      }
      cwd(directory) {
        const next = trailingFunctionArgument(arguments);
        if (typeof directory === "string") {
          return this._runTask(changeWorkingDirectoryTask(directory, this._executor), next);
        }
        if (typeof directory?.path === "string") {
          return this._runTask(
            changeWorkingDirectoryTask(
              directory.path,
              directory.root && this._executor || void 0
            ),
            next
          );
        }
        return this._runTask(
          configurationErrorTask("Git.cwd: workingDirectory must be supplied as a string"),
          next
        );
      }
      hashObject(path11, write) {
        return this._runTask(
          hashObjectTask(path11, write === true),
          trailingFunctionArgument(arguments)
        );
      }
      init(bare) {
        return this._runTask(
          initTask(bare === true, this._executor.cwd, getTrailingOptions(arguments)),
          trailingFunctionArgument(arguments)
        );
      }
      merge() {
        return this._runTask(
          mergeTask(getTrailingOptions(arguments)),
          trailingFunctionArgument(arguments)
        );
      }
      mergeFromTo(remote, branch) {
        if (!(filterString(remote) && filterString(branch))) {
          return this._runTask(
            configurationErrorTask(
              `Git.mergeFromTo requires that the 'remote' and 'branch' arguments are supplied as strings`
            )
          );
        }
        return this._runTask(
          mergeTask([remote, branch, ...getTrailingOptions(arguments)]),
          trailingFunctionArgument(arguments, false)
        );
      }
      outputHandler(handler) {
        this._executor.outputHandler = handler;
        return this;
      }
      push() {
        const task = pushTask(
          {
            remote: filterType(arguments[0], filterString),
            branch: filterType(arguments[1], filterString)
          },
          getTrailingOptions(arguments)
        );
        return this._runTask(task, trailingFunctionArgument(arguments));
      }
      stash() {
        return this._runTask(
          straightThroughStringTask(["stash", ...getTrailingOptions(arguments)]),
          trailingFunctionArgument(arguments)
        );
      }
      status() {
        return this._runTask(
          statusTask(getTrailingOptions(arguments)),
          trailingFunctionArgument(arguments)
        );
      }
    };
    Object.assign(
      SimpleGitApi.prototype,
      checkout_default(),
      commit_default(),
      config_default(),
      count_objects_default(),
      first_commit_default(),
      grep_default(),
      log_default(),
      show_default(),
      version_default()
    );
  }
});
var scheduler_exports = {};
__export2(scheduler_exports, {
  Scheduler: () => Scheduler
});
var createScheduledTask;
var Scheduler;
var init_scheduler = __esm({
  "src/lib/runners/scheduler.ts"() {
    "use strict";
    init_utils();
    init_git_logger();
    createScheduledTask = /* @__PURE__ */ (() => {
      let id = 0;
      return () => {
        id++;
        const { promise: promise2, done } = (0, import_promise_deferred.createDeferred)();
        return {
          promise: promise2,
          done,
          id
        };
      };
    })();
    Scheduler = class {
      constructor(concurrency = 2) {
        this.concurrency = concurrency;
        this.logger = createLogger("", "scheduler");
        this.pending = [];
        this.running = [];
        this.logger(`Constructed, concurrency=%s`, concurrency);
      }
      schedule() {
        if (!this.pending.length || this.running.length >= this.concurrency) {
          this.logger(
            `Schedule attempt ignored, pending=%s running=%s concurrency=%s`,
            this.pending.length,
            this.running.length,
            this.concurrency
          );
          return;
        }
        const task = append(this.running, this.pending.shift());
        this.logger(`Attempting id=%s`, task.id);
        task.done(() => {
          this.logger(`Completing id=`, task.id);
          remove(this.running, task);
          this.schedule();
        });
      }
      next() {
        const { promise: promise2, id } = append(this.pending, createScheduledTask());
        this.logger(`Scheduling id=%s`, id);
        this.schedule();
        return promise2;
      }
    };
  }
});
var apply_patch_exports = {};
__export2(apply_patch_exports, {
  applyPatchTask: () => applyPatchTask
});
function applyPatchTask(patches, customArgs) {
  return straightThroughStringTask(["apply", ...customArgs, ...patches]);
}
var init_apply_patch = __esm({
  "src/lib/tasks/apply-patch.ts"() {
    "use strict";
    init_task();
  }
});
function branchDeletionSuccess(branch, hash) {
  return {
    branch,
    hash,
    success: true
  };
}
function branchDeletionFailure(branch) {
  return {
    branch,
    hash: null,
    success: false
  };
}
var BranchDeletionBatch;
var init_BranchDeleteSummary = __esm({
  "src/lib/responses/BranchDeleteSummary.ts"() {
    "use strict";
    BranchDeletionBatch = class {
      constructor() {
        this.all = [];
        this.branches = {};
        this.errors = [];
      }
      get success() {
        return !this.errors.length;
      }
    };
  }
});
function hasBranchDeletionError(data, processExitCode) {
  return processExitCode === 1 && deleteErrorRegex.test(data);
}
var deleteSuccessRegex;
var deleteErrorRegex;
var parsers8;
var parseBranchDeletions;
var init_parse_branch_delete = __esm({
  "src/lib/parsers/parse-branch-delete.ts"() {
    "use strict";
    init_BranchDeleteSummary();
    init_utils();
    deleteSuccessRegex = /(\S+)\s+\(\S+\s([^)]+)\)/;
    deleteErrorRegex = /^error[^']+'([^']+)'/m;
    parsers8 = [
      new LineParser(deleteSuccessRegex, (result, [branch, hash]) => {
        const deletion = branchDeletionSuccess(branch, hash);
        result.all.push(deletion);
        result.branches[branch] = deletion;
      }),
      new LineParser(deleteErrorRegex, (result, [branch]) => {
        const deletion = branchDeletionFailure(branch);
        result.errors.push(deletion);
        result.all.push(deletion);
        result.branches[branch] = deletion;
      })
    ];
    parseBranchDeletions = (stdOut, stdErr) => {
      return parseStringResponse(new BranchDeletionBatch(), parsers8, [stdOut, stdErr]);
    };
  }
});
var BranchSummaryResult;
var init_BranchSummary = __esm({
  "src/lib/responses/BranchSummary.ts"() {
    "use strict";
    BranchSummaryResult = class {
      constructor() {
        this.all = [];
        this.branches = {};
        this.current = "";
        this.detached = false;
      }
      push(status, detached, name, commit, label) {
        if (status === "*") {
          this.detached = detached;
          this.current = name;
        }
        this.all.push(name);
        this.branches[name] = {
          current: status === "*",
          linkedWorkTree: status === "+",
          name,
          commit,
          label
        };
      }
    };
  }
});
function branchStatus(input) {
  return input ? input.charAt(0) : "";
}
function parseBranchSummary(stdOut, currentOnly = false) {
  return parseStringResponse(
    new BranchSummaryResult(),
    currentOnly ? [currentBranchParser] : parsers9,
    stdOut
  );
}
var parsers9;
var currentBranchParser;
var init_parse_branch = __esm({
  "src/lib/parsers/parse-branch.ts"() {
    "use strict";
    init_BranchSummary();
    init_utils();
    parsers9 = [
      new LineParser(
        /^([*+]\s)?\((?:HEAD )?detached (?:from|at) (\S+)\)\s+([a-z0-9]+)\s(.*)$/,
        (result, [current, name, commit, label]) => {
          result.push(branchStatus(current), true, name, commit, label);
        }
      ),
      new LineParser(
        /^([*+]\s)?(\S+)\s+([a-z0-9]+)\s?(.*)$/s,
        (result, [current, name, commit, label]) => {
          result.push(branchStatus(current), false, name, commit, label);
        }
      )
    ];
    currentBranchParser = new LineParser(/^(\S+)$/s, (result, [name]) => {
      result.push("*", false, name, "", "");
    });
  }
});
var branch_exports = {};
__export2(branch_exports, {
  branchLocalTask: () => branchLocalTask,
  branchTask: () => branchTask,
  containsDeleteBranchCommand: () => containsDeleteBranchCommand,
  deleteBranchTask: () => deleteBranchTask,
  deleteBranchesTask: () => deleteBranchesTask
});
function containsDeleteBranchCommand(commands) {
  const deleteCommands = ["-d", "-D", "--delete"];
  return commands.some((command) => deleteCommands.includes(command));
}
function branchTask(customArgs) {
  const isDelete = containsDeleteBranchCommand(customArgs);
  const isCurrentOnly = customArgs.includes("--show-current");
  const commands = ["branch", ...customArgs];
  if (commands.length === 1) {
    commands.push("-a");
  }
  if (!commands.includes("-v")) {
    commands.splice(1, 0, "-v");
  }
  return {
    format: "utf-8",
    commands,
    parser(stdOut, stdErr) {
      if (isDelete) {
        return parseBranchDeletions(stdOut, stdErr).all[0];
      }
      return parseBranchSummary(stdOut, isCurrentOnly);
    }
  };
}
function branchLocalTask() {
  return {
    format: "utf-8",
    commands: ["branch", "-v"],
    parser(stdOut) {
      return parseBranchSummary(stdOut);
    }
  };
}
function deleteBranchesTask(branches, forceDelete = false) {
  return {
    format: "utf-8",
    commands: ["branch", "-v", forceDelete ? "-D" : "-d", ...branches],
    parser(stdOut, stdErr) {
      return parseBranchDeletions(stdOut, stdErr);
    },
    onError({ exitCode, stdOut }, error, done, fail) {
      if (!hasBranchDeletionError(String(error), exitCode)) {
        return fail(error);
      }
      done(stdOut);
    }
  };
}
function deleteBranchTask(branch, forceDelete = false) {
  const task = {
    format: "utf-8",
    commands: ["branch", "-v", forceDelete ? "-D" : "-d", branch],
    parser(stdOut, stdErr) {
      return parseBranchDeletions(stdOut, stdErr).branches[branch];
    },
    onError({ exitCode, stdErr, stdOut }, error, _, fail) {
      if (!hasBranchDeletionError(String(error), exitCode)) {
        return fail(error);
      }
      throw new GitResponseError(
        task.parser(bufferToString(stdOut), bufferToString(stdErr)),
        String(error)
      );
    }
  };
  return task;
}
var init_branch = __esm({
  "src/lib/tasks/branch.ts"() {
    "use strict";
    init_git_response_error();
    init_parse_branch_delete();
    init_parse_branch();
    init_utils();
  }
});
function toPath(input) {
  const path11 = input.trim().replace(/^["']|["']$/g, "");
  return path11 && (0, import_node_path4.normalize)(path11);
}
var parseCheckIgnore;
var init_CheckIgnore = __esm({
  "src/lib/responses/CheckIgnore.ts"() {
    "use strict";
    parseCheckIgnore = (text) => {
      return text.split(/\n/g).map(toPath).filter(Boolean);
    };
  }
});
var check_ignore_exports = {};
__export2(check_ignore_exports, {
  checkIgnoreTask: () => checkIgnoreTask
});
function checkIgnoreTask(paths) {
  return {
    commands: ["check-ignore", ...paths],
    format: "utf-8",
    parser: parseCheckIgnore
  };
}
var init_check_ignore = __esm({
  "src/lib/tasks/check-ignore.ts"() {
    "use strict";
    init_CheckIgnore();
  }
});
var clone_exports = {};
__export2(clone_exports, {
  cloneMirrorTask: () => cloneMirrorTask,
  cloneTask: () => cloneTask
});
function disallowedCommand(command) {
  return /^--upload-pack(=|$)/.test(command);
}
function cloneTask(repo, directory, customArgs) {
  const commands = ["clone", ...customArgs];
  filterString(repo) && commands.push(repo);
  filterString(directory) && commands.push(directory);
  const banned = commands.find(disallowedCommand);
  if (banned) {
    return configurationErrorTask(`git.fetch: potential exploit argument blocked.`);
  }
  return straightThroughStringTask(commands);
}
function cloneMirrorTask(repo, directory, customArgs) {
  append(customArgs, "--mirror");
  return cloneTask(repo, directory, customArgs);
}
var init_clone = __esm({
  "src/lib/tasks/clone.ts"() {
    "use strict";
    init_task();
    init_utils();
  }
});
function parseFetchResult(stdOut, stdErr) {
  const result = {
    raw: stdOut,
    remote: null,
    branches: [],
    tags: [],
    updated: [],
    deleted: []
  };
  return parseStringResponse(result, parsers10, [stdOut, stdErr]);
}
var parsers10;
var init_parse_fetch = __esm({
  "src/lib/parsers/parse-fetch.ts"() {
    "use strict";
    init_utils();
    parsers10 = [
      new LineParser(/From (.+)$/, (result, [remote]) => {
        result.remote = remote;
      }),
      new LineParser(/\* \[new branch]\s+(\S+)\s*-> (.+)$/, (result, [name, tracking]) => {
        result.branches.push({
          name,
          tracking
        });
      }),
      new LineParser(/\* \[new tag]\s+(\S+)\s*-> (.+)$/, (result, [name, tracking]) => {
        result.tags.push({
          name,
          tracking
        });
      }),
      new LineParser(/- \[deleted]\s+\S+\s*-> (.+)$/, (result, [tracking]) => {
        result.deleted.push({
          tracking
        });
      }),
      new LineParser(
        /\s*([^.]+)\.\.(\S+)\s+(\S+)\s*-> (.+)$/,
        (result, [from, to, name, tracking]) => {
          result.updated.push({
            name,
            tracking,
            to,
            from
          });
        }
      )
    ];
  }
});
var fetch_exports = {};
__export2(fetch_exports, {
  fetchTask: () => fetchTask
});
function disallowedCommand2(command) {
  return /^--upload-pack(=|$)/.test(command);
}
function fetchTask(remote, branch, customArgs) {
  const commands = ["fetch", ...customArgs];
  if (remote && branch) {
    commands.push(remote, branch);
  }
  const banned = commands.find(disallowedCommand2);
  if (banned) {
    return configurationErrorTask(`git.fetch: potential exploit argument blocked.`);
  }
  return {
    commands,
    format: "utf-8",
    parser: parseFetchResult
  };
}
var init_fetch = __esm({
  "src/lib/tasks/fetch.ts"() {
    "use strict";
    init_parse_fetch();
    init_task();
  }
});
function parseMoveResult(stdOut) {
  return parseStringResponse({ moves: [] }, parsers11, stdOut);
}
var parsers11;
var init_parse_move = __esm({
  "src/lib/parsers/parse-move.ts"() {
    "use strict";
    init_utils();
    parsers11 = [
      new LineParser(/^Renaming (.+) to (.+)$/, (result, [from, to]) => {
        result.moves.push({ from, to });
      })
    ];
  }
});
var move_exports = {};
__export2(move_exports, {
  moveTask: () => moveTask
});
function moveTask(from, to) {
  return {
    commands: ["mv", "-v", ...asArray(from), to],
    format: "utf-8",
    parser: parseMoveResult
  };
}
var init_move = __esm({
  "src/lib/tasks/move.ts"() {
    "use strict";
    init_parse_move();
    init_utils();
  }
});
var pull_exports = {};
__export2(pull_exports, {
  pullTask: () => pullTask
});
function pullTask(remote, branch, customArgs) {
  const commands = ["pull", ...customArgs];
  if (remote && branch) {
    commands.splice(1, 0, remote, branch);
  }
  return {
    commands,
    format: "utf-8",
    parser(stdOut, stdErr) {
      return parsePullResult(stdOut, stdErr);
    },
    onError(result, _error, _done, fail) {
      const pullError = parsePullErrorResult(
        bufferToString(result.stdOut),
        bufferToString(result.stdErr)
      );
      if (pullError) {
        return fail(new GitResponseError(pullError));
      }
      fail(_error);
    }
  };
}
var init_pull = __esm({
  "src/lib/tasks/pull.ts"() {
    "use strict";
    init_git_response_error();
    init_parse_pull();
    init_utils();
  }
});
function parseGetRemotes(text) {
  const remotes = {};
  forEach(text, ([name]) => remotes[name] = { name });
  return Object.values(remotes);
}
function parseGetRemotesVerbose(text) {
  const remotes = {};
  forEach(text, ([name, url, purpose]) => {
    if (!Object.hasOwn(remotes, name)) {
      remotes[name] = {
        name,
        refs: { fetch: "", push: "" }
      };
    }
    if (purpose && url) {
      remotes[name].refs[purpose.replace(/[^a-z]/g, "")] = url;
    }
  });
  return Object.values(remotes);
}
function forEach(text, handler) {
  forEachLineWithContent(text, (line) => handler(line.split(/\s+/)));
}
var init_GetRemoteSummary = __esm({
  "src/lib/responses/GetRemoteSummary.ts"() {
    "use strict";
    init_utils();
  }
});
var remote_exports = {};
__export2(remote_exports, {
  addRemoteTask: () => addRemoteTask,
  getRemotesTask: () => getRemotesTask,
  listRemotesTask: () => listRemotesTask,
  remoteTask: () => remoteTask,
  removeRemoteTask: () => removeRemoteTask
});
function addRemoteTask(remoteName, remoteRepo, customArgs) {
  return straightThroughStringTask(["remote", "add", ...customArgs, remoteName, remoteRepo]);
}
function getRemotesTask(verbose) {
  const commands = ["remote"];
  if (verbose) {
    commands.push("-v");
  }
  return {
    commands,
    format: "utf-8",
    parser: verbose ? parseGetRemotesVerbose : parseGetRemotes
  };
}
function listRemotesTask(customArgs) {
  const commands = [...customArgs];
  if (commands[0] !== "ls-remote") {
    commands.unshift("ls-remote");
  }
  return straightThroughStringTask(commands);
}
function remoteTask(customArgs) {
  const commands = [...customArgs];
  if (commands[0] !== "remote") {
    commands.unshift("remote");
  }
  return straightThroughStringTask(commands);
}
function removeRemoteTask(remoteName) {
  return straightThroughStringTask(["remote", "remove", remoteName]);
}
var init_remote = __esm({
  "src/lib/tasks/remote.ts"() {
    "use strict";
    init_GetRemoteSummary();
    init_task();
  }
});
var stash_list_exports = {};
__export2(stash_list_exports, {
  stashListTask: () => stashListTask
});
function stashListTask(opt = {}, customArgs) {
  const options = parseLogOptions(opt);
  const commands = ["stash", "list", ...options.commands, ...customArgs];
  const parser4 = createListLogSummaryParser(
    options.splitter,
    options.fields,
    logFormatFromCommand(commands)
  );
  return validateLogFormatConfig(commands) || {
    commands,
    format: "utf-8",
    parser: parser4
  };
}
var init_stash_list = __esm({
  "src/lib/tasks/stash-list.ts"() {
    "use strict";
    init_log_format();
    init_parse_list_log_summary();
    init_diff();
    init_log();
  }
});
var sub_module_exports = {};
__export2(sub_module_exports, {
  addSubModuleTask: () => addSubModuleTask,
  initSubModuleTask: () => initSubModuleTask,
  subModuleTask: () => subModuleTask,
  updateSubModuleTask: () => updateSubModuleTask
});
function addSubModuleTask(repo, path11) {
  return subModuleTask(["add", repo, path11]);
}
function initSubModuleTask(customArgs) {
  return subModuleTask(["init", ...customArgs]);
}
function subModuleTask(customArgs) {
  const commands = [...customArgs];
  if (commands[0] !== "submodule") {
    commands.unshift("submodule");
  }
  return straightThroughStringTask(commands);
}
function updateSubModuleTask(customArgs) {
  return subModuleTask(["update", ...customArgs]);
}
var init_sub_module = __esm({
  "src/lib/tasks/sub-module.ts"() {
    "use strict";
    init_task();
  }
});
function singleSorted(a, b) {
  const aIsNum = Number.isNaN(a);
  const bIsNum = Number.isNaN(b);
  if (aIsNum !== bIsNum) {
    return aIsNum ? 1 : -1;
  }
  return aIsNum ? sorted(a, b) : 0;
}
function sorted(a, b) {
  return a === b ? 0 : a > b ? 1 : -1;
}
function trimmed(input) {
  return input.trim();
}
function toNumber(input) {
  if (typeof input === "string") {
    return parseInt(input.replace(/^\D+/g, ""), 10) || 0;
  }
  return 0;
}
var TagList;
var parseTagList;
var init_TagList = __esm({
  "src/lib/responses/TagList.ts"() {
    "use strict";
    TagList = class {
      constructor(all, latest) {
        this.all = all;
        this.latest = latest;
      }
    };
    parseTagList = function(data, customSort = false) {
      const tags = data.split("\n").map(trimmed).filter(Boolean);
      if (!customSort) {
        tags.sort(function(tagA, tagB) {
          const partsA = tagA.split(".");
          const partsB = tagB.split(".");
          if (partsA.length === 1 || partsB.length === 1) {
            return singleSorted(toNumber(partsA[0]), toNumber(partsB[0]));
          }
          for (let i = 0, l = Math.max(partsA.length, partsB.length); i < l; i++) {
            const diff = sorted(toNumber(partsA[i]), toNumber(partsB[i]));
            if (diff) {
              return diff;
            }
          }
          return 0;
        });
      }
      const latest = customSort ? tags[0] : [...tags].reverse().find((tag) => tag.indexOf(".") >= 0);
      return new TagList(tags, latest);
    };
  }
});
var tag_exports = {};
__export2(tag_exports, {
  addAnnotatedTagTask: () => addAnnotatedTagTask,
  addTagTask: () => addTagTask,
  tagListTask: () => tagListTask
});
function tagListTask(customArgs = []) {
  const hasCustomSort = customArgs.some((option) => /^--sort=/.test(option));
  return {
    format: "utf-8",
    commands: ["tag", "-l", ...customArgs],
    parser(text) {
      return parseTagList(text, hasCustomSort);
    }
  };
}
function addTagTask(name) {
  return {
    format: "utf-8",
    commands: ["tag", name],
    parser() {
      return { name };
    }
  };
}
function addAnnotatedTagTask(name, tagMessage) {
  return {
    format: "utf-8",
    commands: ["tag", "-a", "-m", tagMessage, name],
    parser() {
      return { name };
    }
  };
}
var init_tag = __esm({
  "src/lib/tasks/tag.ts"() {
    "use strict";
    init_TagList();
  }
});
var require_git = __commonJS2({
  "src/git.js"(exports2, module2) {
    "use strict";
    var { GitExecutor: GitExecutor2 } = (init_git_executor(), __toCommonJS(git_executor_exports));
    var { SimpleGitApi: SimpleGitApi2 } = (init_simple_git_api(), __toCommonJS(simple_git_api_exports));
    var { Scheduler: Scheduler2 } = (init_scheduler(), __toCommonJS(scheduler_exports));
    var { configurationErrorTask: configurationErrorTask2 } = (init_task(), __toCommonJS(task_exports));
    var {
      asArray: asArray2,
      filterArray: filterArray2,
      filterPrimitives: filterPrimitives2,
      filterString: filterString2,
      filterStringOrStringArray: filterStringOrStringArray2,
      filterType: filterType2,
      getTrailingOptions: getTrailingOptions2,
      trailingFunctionArgument: trailingFunctionArgument2,
      trailingOptionsArgument: trailingOptionsArgument2
    } = (init_utils(), __toCommonJS(utils_exports));
    var { applyPatchTask: applyPatchTask2 } = (init_apply_patch(), __toCommonJS(apply_patch_exports));
    var {
      branchTask: branchTask2,
      branchLocalTask: branchLocalTask2,
      deleteBranchesTask: deleteBranchesTask2,
      deleteBranchTask: deleteBranchTask2
    } = (init_branch(), __toCommonJS(branch_exports));
    var { checkIgnoreTask: checkIgnoreTask2 } = (init_check_ignore(), __toCommonJS(check_ignore_exports));
    var { checkIsRepoTask: checkIsRepoTask2 } = (init_check_is_repo(), __toCommonJS(check_is_repo_exports));
    var { cloneTask: cloneTask2, cloneMirrorTask: cloneMirrorTask2 } = (init_clone(), __toCommonJS(clone_exports));
    var { cleanWithOptionsTask: cleanWithOptionsTask2, isCleanOptionsArray: isCleanOptionsArray2 } = (init_clean(), __toCommonJS(clean_exports));
    var { diffSummaryTask: diffSummaryTask2 } = (init_diff(), __toCommonJS(diff_exports));
    var { fetchTask: fetchTask2 } = (init_fetch(), __toCommonJS(fetch_exports));
    var { moveTask: moveTask2 } = (init_move(), __toCommonJS(move_exports));
    var { pullTask: pullTask2 } = (init_pull(), __toCommonJS(pull_exports));
    var { pushTagsTask: pushTagsTask2 } = (init_push(), __toCommonJS(push_exports));
    var {
      addRemoteTask: addRemoteTask2,
      getRemotesTask: getRemotesTask2,
      listRemotesTask: listRemotesTask2,
      remoteTask: remoteTask2,
      removeRemoteTask: removeRemoteTask2
    } = (init_remote(), __toCommonJS(remote_exports));
    var { getResetMode: getResetMode2, resetTask: resetTask2 } = (init_reset(), __toCommonJS(reset_exports));
    var { stashListTask: stashListTask2 } = (init_stash_list(), __toCommonJS(stash_list_exports));
    var {
      addSubModuleTask: addSubModuleTask2,
      initSubModuleTask: initSubModuleTask2,
      subModuleTask: subModuleTask2,
      updateSubModuleTask: updateSubModuleTask2
    } = (init_sub_module(), __toCommonJS(sub_module_exports));
    var { addAnnotatedTagTask: addAnnotatedTagTask2, addTagTask: addTagTask2, tagListTask: tagListTask2 } = (init_tag(), __toCommonJS(tag_exports));
    var { straightThroughBufferTask: straightThroughBufferTask2, straightThroughStringTask: straightThroughStringTask2 } = (init_task(), __toCommonJS(task_exports));
    function Git2(options, plugins) {
      this._plugins = plugins;
      this._executor = new GitExecutor2(
        options.baseDir,
        new Scheduler2(options.maxConcurrentProcesses),
        plugins
      );
      this._trimmed = options.trimmed;
    }
    (Git2.prototype = Object.create(SimpleGitApi2.prototype)).constructor = Git2;
    Git2.prototype.customBinary = function(command) {
      this._plugins.reconfigure("binary", command);
      return this;
    };
    Git2.prototype.env = function(name, value) {
      if (arguments.length === 1 && typeof name === "object") {
        this._executor.env = name;
      } else {
        (this._executor.env = this._executor.env || {})[name] = value;
      }
      return this;
    };
    Git2.prototype.stashList = function(options) {
      return this._runTask(
        stashListTask2(
          trailingOptionsArgument2(arguments) || {},
          filterArray2(options) && options || []
        ),
        trailingFunctionArgument2(arguments)
      );
    };
    function createCloneTask(api, task, repoPath, localPath) {
      if (typeof repoPath !== "string") {
        return configurationErrorTask2(`git.${api}() requires a string 'repoPath'`);
      }
      return task(repoPath, filterType2(localPath, filterString2), getTrailingOptions2(arguments));
    }
    Git2.prototype.clone = function() {
      return this._runTask(
        createCloneTask("clone", cloneTask2, ...arguments),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.mirror = function() {
      return this._runTask(
        createCloneTask("mirror", cloneMirrorTask2, ...arguments),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.mv = function(from, to) {
      return this._runTask(moveTask2(from, to), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.checkoutLatestTag = function(then) {
      var git = this;
      return this.pull(function() {
        git.tags(function(err, tags) {
          git.checkout(tags.latest, then);
        });
      });
    };
    Git2.prototype.pull = function(remote, branch, options, then) {
      return this._runTask(
        pullTask2(
          filterType2(remote, filterString2),
          filterType2(branch, filterString2),
          getTrailingOptions2(arguments)
        ),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.fetch = function(remote, branch) {
      return this._runTask(
        fetchTask2(
          filterType2(remote, filterString2),
          filterType2(branch, filterString2),
          getTrailingOptions2(arguments)
        ),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.silent = function(silence) {
      console.warn(
        "simple-git deprecation notice: git.silent: logging should be configured using the `debug` library / `DEBUG` environment variable, this will be an error in version 3"
      );
      return this;
    };
    Git2.prototype.tags = function(options, then) {
      return this._runTask(
        tagListTask2(getTrailingOptions2(arguments)),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.rebase = function() {
      return this._runTask(
        straightThroughStringTask2(["rebase", ...getTrailingOptions2(arguments)]),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.reset = function(mode) {
      return this._runTask(
        resetTask2(getResetMode2(mode), getTrailingOptions2(arguments)),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.revert = function(commit) {
      const next = trailingFunctionArgument2(arguments);
      if (typeof commit !== "string") {
        return this._runTask(configurationErrorTask2("Commit must be a string"), next);
      }
      return this._runTask(
        straightThroughStringTask2(["revert", ...getTrailingOptions2(arguments, 0, true), commit]),
        next
      );
    };
    Git2.prototype.addTag = function(name) {
      const task = typeof name === "string" ? addTagTask2(name) : configurationErrorTask2("Git.addTag requires a tag name");
      return this._runTask(task, trailingFunctionArgument2(arguments));
    };
    Git2.prototype.addAnnotatedTag = function(tagName, tagMessage) {
      return this._runTask(
        addAnnotatedTagTask2(tagName, tagMessage),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.deleteLocalBranch = function(branchName, forceDelete, then) {
      return this._runTask(
        deleteBranchTask2(branchName, typeof forceDelete === "boolean" ? forceDelete : false),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.deleteLocalBranches = function(branchNames, forceDelete, then) {
      return this._runTask(
        deleteBranchesTask2(branchNames, typeof forceDelete === "boolean" ? forceDelete : false),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.branch = function(options, then) {
      return this._runTask(
        branchTask2(getTrailingOptions2(arguments)),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.branchLocal = function(then) {
      return this._runTask(branchLocalTask2(), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.raw = function(commands) {
      const createRestCommands = !Array.isArray(commands);
      const command = [].slice.call(createRestCommands ? arguments : commands, 0);
      for (let i = 0; i < command.length && createRestCommands; i++) {
        if (!filterPrimitives2(command[i])) {
          command.splice(i, command.length - i);
          break;
        }
      }
      command.push(...getTrailingOptions2(arguments, 0, true));
      var next = trailingFunctionArgument2(arguments);
      if (!command.length) {
        return this._runTask(
          configurationErrorTask2("Raw: must supply one or more command to execute"),
          next
        );
      }
      return this._runTask(straightThroughStringTask2(command, this._trimmed), next);
    };
    Git2.prototype.submoduleAdd = function(repo, path11, then) {
      return this._runTask(addSubModuleTask2(repo, path11), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.submoduleUpdate = function(args, then) {
      return this._runTask(
        updateSubModuleTask2(getTrailingOptions2(arguments, true)),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.submoduleInit = function(args, then) {
      return this._runTask(
        initSubModuleTask2(getTrailingOptions2(arguments, true)),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.subModule = function(options, then) {
      return this._runTask(
        subModuleTask2(getTrailingOptions2(arguments)),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.listRemote = function() {
      return this._runTask(
        listRemotesTask2(getTrailingOptions2(arguments)),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.addRemote = function(remoteName, remoteRepo, then) {
      return this._runTask(
        addRemoteTask2(remoteName, remoteRepo, getTrailingOptions2(arguments)),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.removeRemote = function(remoteName, then) {
      return this._runTask(removeRemoteTask2(remoteName), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.getRemotes = function(verbose, then) {
      return this._runTask(getRemotesTask2(verbose === true), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.remote = function(options, then) {
      return this._runTask(
        remoteTask2(getTrailingOptions2(arguments)),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.tag = function(options, then) {
      const command = getTrailingOptions2(arguments);
      if (command[0] !== "tag") {
        command.unshift("tag");
      }
      return this._runTask(straightThroughStringTask2(command), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.updateServerInfo = function(then) {
      return this._runTask(
        straightThroughStringTask2(["update-server-info"]),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.pushTags = function(remote, then) {
      const task = pushTagsTask2(
        { remote: filterType2(remote, filterString2) },
        getTrailingOptions2(arguments)
      );
      return this._runTask(task, trailingFunctionArgument2(arguments));
    };
    Git2.prototype.rm = function(files) {
      return this._runTask(
        straightThroughStringTask2(["rm", "-f", ...asArray2(files)]),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.rmKeepLocal = function(files) {
      return this._runTask(
        straightThroughStringTask2(["rm", "--cached", ...asArray2(files)]),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.catFile = function(options, then) {
      return this._catFile("utf-8", arguments);
    };
    Git2.prototype.binaryCatFile = function() {
      return this._catFile("buffer", arguments);
    };
    Git2.prototype._catFile = function(format, args) {
      var handler = trailingFunctionArgument2(args);
      var command = ["cat-file"];
      var options = args[0];
      if (typeof options === "string") {
        return this._runTask(
          configurationErrorTask2("Git.catFile: options must be supplied as an array of strings"),
          handler
        );
      }
      if (Array.isArray(options)) {
        command.push.apply(command, options);
      }
      const task = format === "buffer" ? straightThroughBufferTask2(command) : straightThroughStringTask2(command);
      return this._runTask(task, handler);
    };
    Git2.prototype.diff = function(options, then) {
      const task = filterString2(options) ? configurationErrorTask2(
        "git.diff: supplying options as a single string is no longer supported, switch to an array of strings"
      ) : straightThroughStringTask2(["diff", ...getTrailingOptions2(arguments)]);
      return this._runTask(task, trailingFunctionArgument2(arguments));
    };
    Git2.prototype.diffSummary = function() {
      return this._runTask(
        diffSummaryTask2(getTrailingOptions2(arguments, 1)),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.applyPatch = function(patches) {
      const task = !filterStringOrStringArray2(patches) ? configurationErrorTask2(
        `git.applyPatch requires one or more string patches as the first argument`
      ) : applyPatchTask2(asArray2(patches), getTrailingOptions2([].slice.call(arguments, 1)));
      return this._runTask(task, trailingFunctionArgument2(arguments));
    };
    Git2.prototype.revparse = function() {
      const commands = ["rev-parse", ...getTrailingOptions2(arguments, true)];
      return this._runTask(
        straightThroughStringTask2(commands, true),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.clean = function(mode, options, then) {
      const usingCleanOptionsArray = isCleanOptionsArray2(mode);
      const cleanMode = usingCleanOptionsArray && mode.join("") || filterType2(mode, filterString2) || "";
      const customArgs = getTrailingOptions2([].slice.call(arguments, usingCleanOptionsArray ? 1 : 0));
      return this._runTask(
        cleanWithOptionsTask2(cleanMode, customArgs),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.exec = function(then) {
      const task = {
        commands: [],
        format: "utf-8",
        parser() {
          if (typeof then === "function") {
            then();
          }
        }
      };
      return this._runTask(task);
    };
    Git2.prototype.clearQueue = function() {
      return this;
    };
    Git2.prototype.checkIgnore = function(pathnames, then) {
      return this._runTask(
        checkIgnoreTask2(asArray2(filterType2(pathnames, filterStringOrStringArray2, []))),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.checkIsRepo = function(checkType, then) {
      return this._runTask(
        checkIsRepoTask2(filterType2(checkType, filterString2)),
        trailingFunctionArgument2(arguments)
      );
    };
    module2.exports = Git2;
  }
});
init_pathspec();
init_git_error();
var GitConstructError = class extends GitError {
  constructor(config, message) {
    super(void 0, message);
    this.config = config;
  }
};
init_git_error();
init_git_error();
var GitPluginError = class extends GitError {
  constructor(task, plugin, message) {
    super(task, message);
    this.task = task;
    this.plugin = plugin;
    Object.setPrototypeOf(this, new.target.prototype);
  }
};
init_git_response_error();
init_task_configuration_error();
init_check_is_repo();
init_clean();
init_config();
init_diff_name_status();
init_grep();
init_reset();
function abortPlugin(signal) {
  if (!signal) {
    return;
  }
  const onSpawnAfter = {
    type: "spawn.after",
    action(_data, context) {
      function kill() {
        context.kill(new GitPluginError(void 0, "abort", "Abort signal received"));
      }
      signal.addEventListener("abort", kill);
      context.spawned.on("close", () => signal.removeEventListener("abort", kill));
    }
  };
  const onSpawnBefore = {
    type: "spawn.before",
    action(_data, context) {
      if (signal.aborted) {
        context.kill(new GitPluginError(void 0, "abort", "Abort already signaled"));
      }
    }
  };
  return [onSpawnBefore, onSpawnAfter];
}
function isConfigSwitch(arg) {
  return typeof arg === "string" && arg.trim().toLowerCase() === "-c";
}
function preventProtocolOverride(arg, next) {
  if (!isConfigSwitch(arg)) {
    return;
  }
  if (!/^\s*protocol(.[a-z]+)?.allow/.test(next)) {
    return;
  }
  throw new GitPluginError(
    void 0,
    "unsafe",
    "Configuring protocol.allow is not permitted without enabling allowUnsafeExtProtocol"
  );
}
function preventUploadPack(arg, method) {
  if (/^\s*--(upload|receive)-pack/.test(arg)) {
    throw new GitPluginError(
      void 0,
      "unsafe",
      `Use of --upload-pack or --receive-pack is not permitted without enabling allowUnsafePack`
    );
  }
  if (method === "clone" && /^\s*-u\b/.test(arg)) {
    throw new GitPluginError(
      void 0,
      "unsafe",
      `Use of clone with option -u is not permitted without enabling allowUnsafePack`
    );
  }
  if (method === "push" && /^\s*--exec\b/.test(arg)) {
    throw new GitPluginError(
      void 0,
      "unsafe",
      `Use of push with option --exec is not permitted without enabling allowUnsafePack`
    );
  }
}
function blockUnsafeOperationsPlugin({
  allowUnsafeProtocolOverride = false,
  allowUnsafePack = false
} = {}) {
  return {
    type: "spawn.args",
    action(args, context) {
      args.forEach((current, index) => {
        const next = index < args.length ? args[index + 1] : "";
        allowUnsafeProtocolOverride || preventProtocolOverride(current, next);
        allowUnsafePack || preventUploadPack(current, context.method);
      });
      return args;
    }
  };
}
init_utils();
function commandConfigPrefixingPlugin(configuration) {
  const prefix = prefixedArray(configuration, "-c");
  return {
    type: "spawn.args",
    action(data) {
      return [...prefix, ...data];
    }
  };
}
init_utils();
var never = (0, import_promise_deferred2.deferred)().promise;
function completionDetectionPlugin({
  onClose = true,
  onExit = 50
} = {}) {
  function createEvents() {
    let exitCode = -1;
    const events = {
      close: (0, import_promise_deferred2.deferred)(),
      closeTimeout: (0, import_promise_deferred2.deferred)(),
      exit: (0, import_promise_deferred2.deferred)(),
      exitTimeout: (0, import_promise_deferred2.deferred)()
    };
    const result = Promise.race([
      onClose === false ? never : events.closeTimeout.promise,
      onExit === false ? never : events.exitTimeout.promise
    ]);
    configureTimeout(onClose, events.close, events.closeTimeout);
    configureTimeout(onExit, events.exit, events.exitTimeout);
    return {
      close(code) {
        exitCode = code;
        events.close.done();
      },
      exit(code) {
        exitCode = code;
        events.exit.done();
      },
      get exitCode() {
        return exitCode;
      },
      result
    };
  }
  function configureTimeout(flag, event, timeout) {
    if (flag === false) {
      return;
    }
    (flag === true ? event.promise : event.promise.then(() => delay(flag))).then(timeout.done);
  }
  return {
    type: "spawn.after",
    async action(_data, { spawned, close }) {
      const events = createEvents();
      let deferClose = true;
      let quickClose = () => void (deferClose = false);
      spawned.stdout?.on("data", quickClose);
      spawned.stderr?.on("data", quickClose);
      spawned.on("error", quickClose);
      spawned.on("close", (code) => events.close(code));
      spawned.on("exit", (code) => events.exit(code));
      try {
        await events.result;
        if (deferClose) {
          await delay(50);
        }
        close(events.exitCode);
      } catch (err) {
        close(events.exitCode, err);
      }
    }
  };
}
init_utils();
var WRONG_NUMBER_ERR = `Invalid value supplied for custom binary, requires a single string or an array containing either one or two strings`;
var WRONG_CHARS_ERR = `Invalid value supplied for custom binary, restricted characters must be removed or supply the unsafe.allowUnsafeCustomBinary option`;
function isBadArgument(arg) {
  return !arg || !/^([a-z]:)?([a-z0-9/.\\_-]+)$/i.test(arg);
}
function toBinaryConfig(input, allowUnsafe) {
  if (input.length < 1 || input.length > 2) {
    throw new GitPluginError(void 0, "binary", WRONG_NUMBER_ERR);
  }
  const isBad = input.some(isBadArgument);
  if (isBad) {
    if (allowUnsafe) {
      console.warn(WRONG_CHARS_ERR);
    } else {
      throw new GitPluginError(void 0, "binary", WRONG_CHARS_ERR);
    }
  }
  const [binary, prefix] = input;
  return {
    binary,
    prefix
  };
}
function customBinaryPlugin(plugins, input = ["git"], allowUnsafe = false) {
  let config = toBinaryConfig(asArray(input), allowUnsafe);
  plugins.on("binary", (input2) => {
    config = toBinaryConfig(asArray(input2), allowUnsafe);
  });
  plugins.append("spawn.binary", () => {
    return config.binary;
  });
  plugins.append("spawn.args", (data) => {
    return config.prefix ? [config.prefix, ...data] : data;
  });
}
init_git_error();
function isTaskError(result) {
  return !!(result.exitCode && result.stdErr.length);
}
function getErrorMessage(result) {
  return Buffer.concat([...result.stdOut, ...result.stdErr]);
}
function errorDetectionHandler(overwrite = false, isError = isTaskError, errorMessage = getErrorMessage) {
  return (error, result) => {
    if (!overwrite && error || !isError(result)) {
      return error;
    }
    return errorMessage(result);
  };
}
function errorDetectionPlugin(config) {
  return {
    type: "task.error",
    action(data, context) {
      const error = config(data.error, {
        stdErr: context.stdErr,
        stdOut: context.stdOut,
        exitCode: context.exitCode
      });
      if (Buffer.isBuffer(error)) {
        return { error: new GitError(void 0, error.toString("utf-8")) };
      }
      return {
        error
      };
    }
  };
}
init_utils();
var PluginStore = class {
  constructor() {
    this.plugins = /* @__PURE__ */ new Set();
    this.events = new import_node_events2.EventEmitter();
  }
  on(type, listener) {
    this.events.on(type, listener);
  }
  reconfigure(type, data) {
    this.events.emit(type, data);
  }
  append(type, action) {
    const plugin = append(this.plugins, { type, action });
    return () => this.plugins.delete(plugin);
  }
  add(plugin) {
    const plugins = [];
    asArray(plugin).forEach((plugin2) => plugin2 && this.plugins.add(append(plugins, plugin2)));
    return () => {
      plugins.forEach((plugin2) => this.plugins.delete(plugin2));
    };
  }
  exec(type, data, context) {
    let output = data;
    const contextual = Object.freeze(Object.create(context));
    for (const plugin of this.plugins) {
      if (plugin.type === type) {
        output = plugin.action(output, contextual);
      }
    }
    return output;
  }
};
init_utils();
function progressMonitorPlugin(progress) {
  const progressCommand = "--progress";
  const progressMethods = ["checkout", "clone", "fetch", "pull", "push"];
  const onProgress = {
    type: "spawn.after",
    action(_data, context) {
      if (!context.commands.includes(progressCommand)) {
        return;
      }
      context.spawned.stderr?.on("data", (chunk) => {
        const message = /^([\s\S]+?):\s*(\d+)% \((\d+)\/(\d+)\)/.exec(chunk.toString("utf8"));
        if (!message) {
          return;
        }
        progress({
          method: context.method,
          stage: progressEventStage(message[1]),
          progress: asNumber(message[2]),
          processed: asNumber(message[3]),
          total: asNumber(message[4])
        });
      });
    }
  };
  const onArgs = {
    type: "spawn.args",
    action(args, context) {
      if (!progressMethods.includes(context.method)) {
        return args;
      }
      return including(args, progressCommand);
    }
  };
  return [onArgs, onProgress];
}
function progressEventStage(input) {
  return String(input.toLowerCase().split(" ", 1)) || "unknown";
}
init_utils();
function spawnOptionsPlugin(spawnOptions) {
  const options = pick(spawnOptions, ["uid", "gid"]);
  return {
    type: "spawn.options",
    action(data) {
      return { ...options, ...data };
    }
  };
}
function timeoutPlugin({
  block,
  stdErr = true,
  stdOut = true
}) {
  if (block > 0) {
    return {
      type: "spawn.after",
      action(_data, context) {
        let timeout;
        function wait() {
          timeout && clearTimeout(timeout);
          timeout = setTimeout(kill, block);
        }
        function stop() {
          context.spawned.stdout?.off("data", wait);
          context.spawned.stderr?.off("data", wait);
          context.spawned.off("exit", stop);
          context.spawned.off("close", stop);
          timeout && clearTimeout(timeout);
        }
        function kill() {
          stop();
          context.kill(new GitPluginError(void 0, "timeout", `block timeout reached`));
        }
        stdOut && context.spawned.stdout?.on("data", wait);
        stdErr && context.spawned.stderr?.on("data", wait);
        context.spawned.on("exit", stop);
        context.spawned.on("close", stop);
        wait();
      }
    };
  }
}
init_pathspec();
function suffixPathsPlugin() {
  return {
    type: "spawn.args",
    action(data) {
      const prefix = [];
      let suffix;
      function append2(args) {
        (suffix = suffix || []).push(...args);
      }
      for (let i = 0; i < data.length; i++) {
        const param = data[i];
        if (isPathSpec(param)) {
          append2(toPaths(param));
          continue;
        }
        if (param === "--") {
          append2(
            data.slice(i + 1).flatMap((item) => isPathSpec(item) && toPaths(item) || item)
          );
          break;
        }
        prefix.push(param);
      }
      return !suffix ? prefix : [...prefix, "--", ...suffix.map(String)];
    }
  };
}
init_utils();
var Git = require_git();
function gitInstanceFactory(baseDir, options) {
  const plugins = new PluginStore();
  const config = createInstanceConfig(
    baseDir && (typeof baseDir === "string" ? { baseDir } : baseDir) || {},
    options
  );
  if (!folderExists(config.baseDir)) {
    throw new GitConstructError(
      config,
      `Cannot use simple-git on a directory that does not exist`
    );
  }
  if (Array.isArray(config.config)) {
    plugins.add(commandConfigPrefixingPlugin(config.config));
  }
  plugins.add(blockUnsafeOperationsPlugin(config.unsafe));
  plugins.add(suffixPathsPlugin());
  plugins.add(completionDetectionPlugin(config.completion));
  config.abort && plugins.add(abortPlugin(config.abort));
  config.progress && plugins.add(progressMonitorPlugin(config.progress));
  config.timeout && plugins.add(timeoutPlugin(config.timeout));
  config.spawnOptions && plugins.add(spawnOptionsPlugin(config.spawnOptions));
  plugins.add(errorDetectionPlugin(errorDetectionHandler(true)));
  config.errors && plugins.add(errorDetectionPlugin(config.errors));
  customBinaryPlugin(plugins, config.binary, config.unsafe?.allowUnsafeCustomBinary);
  return new Git(config, plugins);
}
init_git_response_error();
var simpleGit = gitInstanceFactory;

// src/git/disk-git-provider.ts
var fs5 = __toESM(require("fs"), 1);
var fsPromises = __toESM(require("fs/promises"), 1);
var path5 = __toESM(require("path"), 1);
var import_node_events3 = require("events");
var STATUS_REFRESH_DEBOUNCE_MS = 100;
var UNSTAGED_KEY_SUFFIX = "\0unstaged";
var IGNORED_GIT_PATHS = [
  // High-frequency noise
  "**/objects/**",
  "**/logs/**",
  "**/*.lock",
  // Temp files created during operations
  "**/COMMIT_EDITMSG",
  "**/FETCH_HEAD",
  "**/ORIG_HEAD",
  "**/MERGE_MSG",
  "**/SQUASH_MSG",
  "**/AUTO_MERGE",
  // Static/config files that don't affect status
  "**/hooks/**",
  "**/info/**",
  "**/description",
  "**/config",
  // NOTE: packed-refs is NOT ignored - it updates on push/fetch and affects commit graph
  "**/shallow",
  "**/commondir",
  "**/gitdir"
];
var DiskGitProvider = class _DiskGitProvider {
  gitRoot;
  cwd;
  // -------------------------------------------------------------------------
  // Internal Components
  // -------------------------------------------------------------------------
  git;
  watcher = null;
  watcherSubscriptions = [];
  disposed = false;
  /** Count of active git operations (don't refresh while > 0) */
  activeOperations = 0;
  /** Pending status refresh timer (debouncing) */
  refreshTimer = null;
  /** Last known status (for delta calculation) */
  lastStatus = null;
  /** Last known branch (for branch change detection) */
  lastBranch = null;
  /** Last known HEAD commit (for head change detection) */
  lastHead = null;
  /** Cached per-file diff stats (single source of truth for all diff stat queries) */
  perFileDiffStatsCache = null;
  /** Cache TTL for diff stats (ms) - short window to deduplicate concurrent calls */
  static DIFF_STATS_CACHE_TTL_MS = 100;
  // -------------------------------------------------------------------------
  // Event Emitters
  // -------------------------------------------------------------------------
  _onStatusChanged = new EventEmitter2();
  _onBranchChanged = new EventEmitter2();
  _onCommitCreated = new EventEmitter2();
  _onHeadChanged = new EventEmitter2();
  onStatusChanged = this._onStatusChanged.event;
  onBranchChanged = this._onBranchChanged.event;
  onCommitCreated = this._onCommitCreated.event;
  onHeadChanged = this._onHeadChanged.event;
  // -------------------------------------------------------------------------
  // Node.js-style Event Emitter (for jsonrpc-proxy compatibility)
  // -------------------------------------------------------------------------
  /**
   * Generic event emitter for all git events.
   * Used by jsonrpc-proxy to subscribe to all events via .on('event', handler).
   */
  _nodeEventEmitter = new import_node_events3.EventEmitter();
  /** Internal subscriptions to forward events to the generic emitter */
  _eventForwarders = [];
  // -------------------------------------------------------------------------
  // Constructor
  // -------------------------------------------------------------------------
  /**
   * Create a new git provider.
   *
   * @param gitRoot - The git repository root directory (contains .git/)
   * @param cwd - The working directory for relative path resolution
   */
  constructor(gitRoot, cwd) {
    this.gitRoot = path5.resolve(gitRoot);
    this.cwd = path5.resolve(cwd);
    this.git = simpleGit(this.gitRoot);
  }
  // -------------------------------------------------------------------------
  // Lifecycle
  // -------------------------------------------------------------------------
  /**
   * Start watching the .git directory for changes.
   *
   * This should be called after setting up event listeners.
   */
  async startWatching() {
    if (this.disposed || this.watcher) {
      return;
    }
    const gitDir = path5.join(this.gitRoot, ".git");
    let watchPath;
    try {
      const gitStat = fs5.statSync(gitDir);
      watchPath = gitStat.isFile() ? this.resolveGitDir(gitDir) : gitDir;
    } catch {
      return;
    }
    this.watcher = new ParcelFileWatcher(watchPath, {
      ignored: IGNORED_GIT_PATHS
    });
    this.watcherSubscriptions.push(
      this.watcher.onCreated(() => {
        this.scheduleStatusRefresh();
      }),
      this.watcher.onModified(() => {
        this.scheduleStatusRefresh();
      }),
      this.watcher.onDeleted(() => {
        this.scheduleStatusRefresh();
      }),
      this.watcher.onRenamed(() => {
        this.scheduleStatusRefresh();
      })
    );
    await this.watcher.watch();
    await this.initializeState();
  }
  /**
   * Check if currently watching for changes.
   */
  isWatching() {
    return this.watcher !== null && !this.disposed;
  }
  /**
   * Trigger a status refresh.
   *
   * This is called when working directory files change (detected by FileSystemV2).
   * Uses the same debouncing as internal .git directory changes.
   */
  triggerStatusRefresh() {
    this.scheduleStatusRefresh();
  }
  /**
   * Clean up all resources.
   */
  dispose() {
    if (this.disposed) {
      return;
    }
    this.disposed = true;
    if (this.refreshTimer) {
      clearTimeout(this.refreshTimer);
      this.refreshTimer = null;
    }
    for (const subscription of this.watcherSubscriptions) {
      subscription.dispose();
    }
    this.watcherSubscriptions = [];
    if (this.watcher) {
      this.watcher.dispose().catch((error) => {
        console.error("[DiskGitProvider] Error disposing watcher:", error);
      });
      this.watcher = null;
    }
    this._onStatusChanged.dispose();
    this._onBranchChanged.dispose();
    this._onCommitCreated.dispose();
    this._onHeadChanged.dispose();
  }
  // -------------------------------------------------------------------------
  // State Queries
  // -------------------------------------------------------------------------
  /**
   * Get complete repository status.
   */
  async getStatus() {
    const [statusResult, branchSummary] = await Promise.all([
      this.git.status(),
      this.git.branch()
    ]);
    return this.parseStatus(statusResult, branchSummary.current);
  }
  /**
   * Get status for a specific file.
   */
  async getFileStatus(filePath) {
    const status = await this.getStatus();
    const relativePath = this.toRelativePath(filePath);
    const exactMatch = status.files.get(relativePath);
    if (exactMatch) {
      return exactMatch;
    }
    if (isCaseInsensitiveFS) {
      const normalizedLookup = relativePath.toLowerCase();
      for (const [key, value] of status.files) {
        if (key.toLowerCase() === normalizedLookup) {
          return value;
        }
      }
    }
    return null;
  }
  /**
   * Get current branch name.
   *
   * Note: Uses raw git command instead of simple-git's branch() method
   * because rev-parse is ~35% faster (benchmarked at 40ms vs 65ms avg).
   */
  async getCurrentBranch() {
    const result = await this.git.raw(["rev-parse", "--abbrev-ref", "HEAD"]);
    return result.trim() || "HEAD";
  }
  /**
   * Get all branches (local and remote).
   */
  async getBranches() {
    const result = await this.git.raw([
      "for-each-ref",
      "--sort=-committerdate",
      "--format=%(refname:short)|%(refname)|%(committerdate:iso8601)|%(objectname:short)|%(subject)|%(HEAD)",
      "refs/heads/",
      "refs/remotes/"
    ]);
    const branches = [];
    const lines = result.split("\n").filter(Boolean);
    for (const line of lines) {
      const parts = line.split("|");
      if (parts.length < 5) continue;
      const name = parts[0]?.trim() || "";
      const fullRefname = parts[1]?.trim() || "";
      const dateStr = parts[2]?.trim() || "";
      const commit = parts[3]?.trim() || "";
      const message = parts[4]?.trim() || "";
      const isCurrentMarker = parts[5]?.trim() || "";
      if (!name) continue;
      if (name === "HEAD" || name.includes("HEAD")) {
        continue;
      }
      const isRemote = fullRefname.startsWith("refs/remotes/");
      const isCurrent = isCurrentMarker === "*";
      branches.push({
        name,
        isRemote,
        isCurrent,
        commit,
        upstream: void 0,
        lastCommitDate: dateStr ? new Date(dateStr) : void 0,
        lastCommitMessage: message || void 0
      });
    }
    return branches;
  }
  /**
   * Get diff for a specific file.
   */
  async getFileDiff(filePath, staged = false) {
    const relativePath = this.toRelativePath(filePath);
    if (staged) {
      return this.git.diff(["--cached", "--", relativePath]);
    }
    return this.git.diff(["--", relativePath]);
  }
  /**
   * Get file content at a specific ref.
   */
  async getFileAtRef(filePath, ref) {
    const relativePath = this.toRelativePath(filePath);
    return this.git.show([`${ref}:${relativePath}`]);
  }
  /**
   * Check if there are uncommitted changes.
   */
  async hasUncommittedChanges() {
    const status = await this.git.status();
    return !status.isClean();
  }
  /**
   * Check if there are commits not pushed to upstream.
   */
  async hasUnpushedCommits() {
    const status = await this.git.status();
    return status.ahead > 0;
  }
  /**
   * Get files changed between current HEAD and a base branch.
   *
   * Returns files that have been added, modified, or deleted
   * in the current branch compared to the base branch.
   */
  async getChangedFilesFromBranch(baseBranch) {
    try {
      const mergeBase = await this.git.raw(["merge-base", "HEAD", baseBranch]);
      const result = await this.git.diff([
        "--name-only",
        mergeBase.trim(),
        "HEAD"
      ]);
      return result.split("\n").map((line) => line.trim()).filter(Boolean);
    } catch (error) {
      console.error(
        "[DiskGitProvider] Failed to get files changed since branch:",
        error
      );
      return [];
    }
  }
  /**
   * Get git status relative to a base branch.
   *
   * Compares the base branch tip directly to the working directory.
   * This shows ALL files that differ between the base branch and your
   * current working state (both committed and uncommitted changes).
   *
   * For example, comparing to "main" shows what a PR would contain:
   * all differences between the tip of main and your working directory.
   */
  async getStatusFromBranch(baseBranch) {
    const statusMap = /* @__PURE__ */ new Map();
    try {
      const result = await this.git.diff(["--name-status", baseBranch]);
      const lines = result.split("\n");
      for (const line of lines) {
        if (!line.trim()) continue;
        const parts = line.split("	");
        if (parts.length < 2) continue;
        const statusCode = parts[0]?.trim();
        const filePath = parts.length >= 3 ? parts[2]?.trim() : parts[1]?.trim();
        if (!statusCode || !filePath) continue;
        let status = "modified";
        if (statusCode.startsWith("A")) {
          status = "added";
        } else if (statusCode.startsWith("D")) {
          status = "deleted";
        } else if (statusCode.startsWith("M")) {
          status = "modified";
        } else if (statusCode.startsWith("R")) {
          status = "renamed";
        } else if (statusCode.startsWith("C")) {
          status = "copied";
        }
        statusMap.set(filePath, {
          status,
          staged: false,
          // These are differences vs the branch, not staged
          path: filePath
        });
      }
    } catch (error) {
      console.error(
        "[DiskGitProvider] Failed to get status from branch:",
        error
      );
    }
    return statusMap;
  }
  /**
   * Get diff statistics for uncommitted changes (lines added/removed).
   *
   * Derives aggregated stats from the cached per-file diff stats.
   * This ensures a single source of truth and avoids redundant git operations.
   */
  async getUncommittedDiffStats() {
    try {
      const perFile = await this.getPerFileDiffStats();
      let totalAdded = 0;
      let totalRemoved = 0;
      const allFiles = /* @__PURE__ */ new Set();
      for (const [filePath, stat3] of perFile.staged) {
        totalAdded += stat3.added;
        totalRemoved += stat3.removed;
        allFiles.add(filePath);
      }
      for (const [filePath, stat3] of perFile.unstaged) {
        totalAdded += stat3.added;
        totalRemoved += stat3.removed;
        allFiles.add(filePath);
      }
      return {
        added: totalAdded,
        removed: totalRemoved,
        files: allFiles.size
      };
    } catch (error) {
      console.error("[DiskGitProvider] Failed to get diff stats:", error);
      return { added: 0, removed: 0, files: 0 };
    }
  }
  /**
   * Get per-file diff statistics for uncommitted changes.
   *
   * Returns lines added/removed for each changed file, split by staged/unstaged.
   * - Staged: `git diff --numstat --cached` (index vs HEAD)
   * - Unstaged: `git diff --numstat` (working tree vs index)
   *
   * Results are cached for a short window (100ms) to deduplicate concurrent calls.
   * This is the single source of truth for all diff stat queries.
   */
  async getPerFileDiffStats() {
    const now = Date.now();
    if (this.perFileDiffStatsCache && now - this.perFileDiffStatsCache.timestamp < _DiskGitProvider.DIFF_STATS_CACHE_TTL_MS) {
      return this.perFileDiffStatsCache.result;
    }
    const staged = /* @__PURE__ */ new Map();
    const unstaged = /* @__PURE__ */ new Map();
    const parseDiffOutput = (output, targetMap) => {
      const lines = output.trim().split("\n").filter(Boolean);
      for (const line of lines) {
        const [addedStr, removedStr, ...filenameParts] = line.split("	");
        const filename = filenameParts.join("	");
        if (!filename) continue;
        const added = addedStr === "-" ? 0 : parseInt(addedStr, 10) || 0;
        const removed = removedStr === "-" ? 0 : parseInt(removedStr, 10) || 0;
        targetMap.set(filename, { added, removed });
      }
    };
    try {
      const stagedOutput = await this.git.diff(["--numstat", "--cached"]);
      parseDiffOutput(stagedOutput, staged);
      const unstagedOutput = await this.git.diff(["--numstat"]);
      parseDiffOutput(unstagedOutput, unstaged);
      const status = await this.getStatus();
      const untrackedFiles = Array.from(status.files.entries()).filter(
        ([, fileStatus]) => fileStatus.status === "untracked"
      );
      const untrackedStats = await Promise.all(
        untrackedFiles.map(async ([filePath]) => {
          try {
            const fullPath = path5.join(this.gitRoot, filePath);
            const content = await fsPromises.readFile(fullPath, "utf-8");
            const lines = content.split("\n");
            const added = lines.length > 0 && lines[lines.length - 1] === "" ? lines.length - 1 : lines.length;
            return { filePath, added };
          } catch {
            return null;
          }
        })
      );
      for (const stat3 of untrackedStats) {
        if (stat3) {
          unstaged.set(stat3.filePath, { added: stat3.added, removed: 0 });
        }
      }
      const result = { staged, unstaged };
      this.perFileDiffStatsCache = { result, timestamp: now };
      return result;
    } catch (error) {
      console.error(
        "[DiskGitProvider] Failed to get per-file diff stats:",
        error
      );
      return { staged, unstaged };
    }
  }
  /**
   * Get the most recently modified dirty file.
   *
   * Uses file modification times to find the file the user
   * was most likely working on.
   */
  async getMostRecentDirtyFile() {
    try {
      const status = await this.git.status();
      if (status.files.length === 0) {
        return null;
      }
      const dirtyFiles = status.files.map((f) => f.path);
      let mostRecent = null;
      for (const filePath of dirtyFiles) {
        const absolutePath = path5.join(this.gitRoot, filePath);
        try {
          const stats = await fsPromises.stat(absolutePath);
          if (!mostRecent || stats.mtimeMs > mostRecent.mtime) {
            mostRecent = { path: filePath, mtime: stats.mtimeMs };
          }
        } catch {
        }
      }
      return mostRecent?.path ?? null;
    } catch (error) {
      console.error(
        "[DiskGitProvider] Failed to get most recent dirty file:",
        error
      );
      return null;
    }
  }
  /**
   * Get all dirty files with their modification timestamps.
   *
   * Returns files sorted by modification time (most recent first).
   */
  async getDirtyFilesWithTimes() {
    try {
      const status = await this.git.status();
      if (status.files.length === 0) {
        return [];
      }
      const filesWithTimes = [];
      for (const file of status.files) {
        const absolutePath = path5.join(this.gitRoot, file.path);
        try {
          const stats = await fsPromises.stat(absolutePath);
          filesWithTimes.push({
            path: file.path,
            mtime: stats.mtimeMs
          });
        } catch {
        }
      }
      filesWithTimes.sort((a, b) => b.mtime - a.mtime);
      return filesWithTimes;
    } catch (error) {
      console.error(
        "[DiskGitProvider] Failed to get dirty files with times:",
        error
      );
      return [];
    }
  }
  /**
   * Get the most recently modified file from recent commits.
   *
   * Fallback when there are no dirty files.
   */
  async getMostRecentCommittedFile(commitLimit = 10) {
    try {
      const log = await this.git.log({
        maxCount: commitLimit,
        "--name-only": null
      });
      const filesSet = /* @__PURE__ */ new Set();
      for (const commit of log.all) {
        const diff = commit.diff;
        if (diff?.files && Array.isArray(diff.files)) {
          for (const fileEntry of diff.files) {
            if (fileEntry.file) {
              filesSet.add(fileEntry.file);
            }
          }
        }
      }
      if (filesSet.size === 0) {
        return null;
      }
      let mostRecent = null;
      for (const filePath of filesSet) {
        const absolutePath = path5.join(this.gitRoot, filePath);
        try {
          const stats = await fsPromises.stat(absolutePath);
          if (!mostRecent || stats.mtimeMs > mostRecent.mtime) {
            mostRecent = { path: filePath, mtime: stats.mtimeMs };
          }
        } catch {
        }
      }
      return mostRecent?.path ?? null;
    } catch (error) {
      console.error(
        "[DiskGitProvider] Failed to get most recent committed file:",
        error
      );
      return null;
    }
  }
  // -------------------------------------------------------------------------
  // Commit History
  // -------------------------------------------------------------------------
  /**
   * Get commit history with pagination support.
   *
   * Returns commits in topological order (newest first) for correct
   * swimlane graph computation.
   */
  async getCommitHistory(options = {}) {
    const { limit = 50, skip = 0, ref } = options;
    try {
      const requestLimit = limit + 1;
      const format = "%H|%h|%s|%an|%ae|%at|%P|%D";
      const args = [
        "log",
        `--format=${format}`,
        "--topo-order",
        // Topological ordering for swimlane algorithm
        `-n`,
        String(requestLimit),
        `--skip=${skip}`
      ];
      if (ref) {
        args.push(ref);
      }
      const result = await this.git.raw(args);
      const lines = result.trim().split("\n").filter(Boolean);
      const hasMore = lines.length > limit;
      const commitLines = hasMore ? lines.slice(0, limit) : lines;
      const commits = commitLines.map((line) => {
        const parts = line.split("|");
        const [
          hash,
          shortHash,
          subject,
          author,
          email,
          timestamp,
          parents,
          refs
        ] = parts;
        return {
          id: hash || "",
          shortId: shortHash || "",
          subject: subject || "",
          message: subject || "",
          // Just subject for now, full message requires separate call
          author: author || "",
          authorEmail: email || "",
          timestamp: parseInt(timestamp || "0", 10) * 1e3,
          // Convert to milliseconds
          parentIds: parents ? parents.split(" ").filter(Boolean) : [],
          refs: refs ? refs.split(", ").filter(Boolean) : void 0
        };
      });
      return {
        commits,
        hasMore
      };
    } catch (error) {
      console.error("[DiskGitProvider] Failed to get commit history:", error);
      return {
        commits: [],
        hasMore: false
      };
    }
  }
  /**
   * Get a single commit by its hash.
   */
  async getCommit(commitId) {
    try {
      const format = "%H%x00%h%x00%s%x00%b%x00%an%x00%ae%x00%at%x00%P%x00%D";
      const result = await this.git.raw([
        "log",
        `-1`,
        `--format=${format}`,
        commitId
      ]);
      if (!result.trim()) {
        return null;
      }
      const parts = result.split("\0");
      if (parts.length < 8) {
        return null;
      }
      const [
        hash,
        shortHash,
        subject,
        body,
        author,
        email,
        timestamp,
        parents,
        refs
      ] = parts;
      const cleanBody = body?.trim() || "";
      const fullMessage = cleanBody ? `${subject}

${cleanBody}` : subject || "";
      return {
        id: hash || "",
        shortId: shortHash || "",
        subject: subject || "",
        message: fullMessage,
        author: author || "",
        authorEmail: email || "",
        timestamp: parseInt(timestamp || "0", 10) * 1e3,
        parentIds: parents ? parents.split(" ").filter(Boolean) : [],
        refs: refs ? refs.split(", ").filter(Boolean) : void 0
      };
    } catch {
      return null;
    }
  }
  /**
   * Get files changed in a specific commit.
   *
   * For merge commits, git diff-tree with a single commit shows a "combined diff"
   * (files differing from ALL parents), which is usually empty for clean merges.
   * To get the actual changes, we explicitly compare to the first parent using
   * `commit^1 commit` syntax. This works for both regular and merge commits.
   *
   * For root commits (no parent), we fall back to the single-commit syntax which
   * compares against an empty tree.
   */
  async getCommitFiles(commitId) {
    try {
      let result;
      let numstatResult;
      try {
        result = await this.git.raw([
          "diff-tree",
          "--no-commit-id",
          "--name-status",
          "-r",
          "--find-renames",
          "-M",
          `${commitId}^1`,
          commitId
        ]);
        numstatResult = await this.git.raw([
          "diff-tree",
          "--no-commit-id",
          "--numstat",
          "-r",
          "--find-renames",
          "-M",
          `${commitId}^1`,
          commitId
        ]);
      } catch {
        result = await this.git.raw([
          "diff-tree",
          "--no-commit-id",
          "--name-status",
          "-r",
          "--find-renames",
          "-M",
          commitId
        ]);
        numstatResult = await this.git.raw([
          "diff-tree",
          "--no-commit-id",
          "--numstat",
          "-r",
          "--find-renames",
          "-M",
          commitId
        ]);
      }
      const statsMap = /* @__PURE__ */ new Map();
      const numstatLines = numstatResult.trim().split("\n").filter(Boolean);
      for (const line of numstatLines) {
        const [additions, deletions, ...pathParts] = line.split("	");
        const filePath = pathParts.join("	");
        const isBinary = additions === "-" || deletions === "-";
        statsMap.set(filePath, {
          additions: isBinary ? 0 : parseInt(additions || "0", 10),
          deletions: isBinary ? 0 : parseInt(deletions || "0", 10),
          isBinary
        });
      }
      const files = [];
      const statusLines = result.trim().split("\n").filter(Boolean);
      for (const line of statusLines) {
        const parts = line.split("	");
        if (parts.length < 2) continue;
        const statusCode = parts[0]?.charAt(0) || "M";
        let filePath;
        let originalPath;
        if (statusCode === "R" || statusCode === "C") {
          originalPath = parts[1];
          filePath = parts[2] || parts[1] || "";
        } else {
          filePath = parts[1] || "";
        }
        const stats = statsMap.get(filePath) || {
          additions: 0,
          deletions: 0,
          isBinary: false
        };
        files.push({
          path: filePath,
          status: this.statusCodeToFileStatus(statusCode),
          originalPath,
          additions: stats.additions,
          deletions: stats.deletions,
          isBinary: stats.isBinary
        });
      }
      return files;
    } catch (error) {
      console.error("[DiskGitProvider] Failed to get commit files:", error);
      return [];
    }
  }
  /**
   * Get file content at a specific commit.
   */
  async getFileAtCommit(commitId, filePath) {
    try {
      const relativePath = this.toRelativePath(filePath);
      const result = await this.git.show([`${commitId}:${relativePath}`]);
      return result;
    } catch {
      return null;
    }
  }
  /**
   * Get tracked branch information for VS Code-style graph coloring.
   *
   * Returns information about three special branches:
   * 1. Current branch - where HEAD points (blue segment)
   * 2. Upstream - remote tracking branch (purple segment)
   * 3. Base - branch from which feature was created (orange segment)
   */
  async getTrackedBranches() {
    try {
      const currentBranchName = await this.getCurrentBranch();
      if (currentBranchName === "HEAD") {
        return { current: null, upstream: null, base: null };
      }
      const [currentCommitId, upstreamInfo, baseInfo] = await Promise.all([
        this.resolveRef("HEAD"),
        this.getUpstreamInfo(currentBranchName),
        this.getBaseBranchInfo(currentBranchName)
      ]);
      const current = currentCommitId ? {
        name: currentBranchName,
        displayName: currentBranchName,
        type: "current",
        commitId: currentCommitId
      } : null;
      return {
        current,
        upstream: upstreamInfo,
        base: baseInfo
      };
    } catch (error) {
      console.error("[DiskGitProvider] Failed to get tracked branches:", error);
      return { current: null, upstream: null, base: null };
    }
  }
  /**
   * Resolve a ref to its commit ID.
   */
  async resolveRef(ref) {
    try {
      const result = await this.git.revparse([ref]);
      return result.trim();
    } catch {
      return null;
    }
  }
  /**
   * Get upstream tracking branch info.
   */
  async getUpstreamInfo(branchName) {
    try {
      const upstreamRef = await this.git.revparse([
        "--abbrev-ref",
        `${branchName}@{upstream}`
      ]);
      const upstreamName = upstreamRef.trim();
      if (!upstreamName) {
        return null;
      }
      const commitId = await this.resolveRef(upstreamName);
      if (!commitId) {
        return null;
      }
      const slashIndex = upstreamName.indexOf("/");
      const remote = slashIndex > 0 ? upstreamName.slice(0, slashIndex) : void 0;
      return {
        name: upstreamName,
        displayName: upstreamName,
        type: "upstream",
        commitId,
        remote
      };
    } catch {
      return null;
    }
  }
  /**
   * Get base branch info (where the feature branch was created from).
   *
   * Strategy:
   * 1. Check git config for cached vscode-merge-base
   * 2. Parse reflog to find "Created from" entry
   * 3. Fall back to default branch (origin/main or origin/master)
   */
  async getBaseBranchInfo(branchName) {
    try {
      const configKey = `branch.${branchName}.vscode-merge-base`;
      try {
        const cachedBase = await this.git.raw(["config", "--get", configKey]);
        const baseName = cachedBase.trim();
        if (baseName) {
          const commitId = await this.resolveRef(baseName);
          if (commitId) {
            const slashIndex = baseName.indexOf("/");
            return {
              name: baseName,
              displayName: baseName,
              type: "base",
              commitId,
              remote: slashIndex > 0 ? baseName.slice(0, slashIndex) : void 0
            };
          }
        }
      } catch {
      }
      const baseBranch = await this.getBaseBranchFromReflog(branchName);
      if (baseBranch) {
        try {
          await this.git.raw(["config", configKey, baseBranch.name]);
        } catch {
        }
        return baseBranch;
      }
      const defaultBranch = await this.getDefaultBranch();
      if (defaultBranch) {
        try {
          await this.git.raw(["config", configKey, defaultBranch.name]);
        } catch {
        }
        return defaultBranch;
      }
      return null;
    } catch (error) {
      console.error("[DiskGitProvider] Failed to get base branch:", error);
      return null;
    }
  }
  /**
   * Try to determine base branch from reflog.
   */
  async getBaseBranchFromReflog(branchName) {
    try {
      const reflog = await this.git.raw([
        "reflog",
        "show",
        branchName,
        "--format=%gs"
      ]);
      const lines = reflog.trim().split("\n");
      for (const line of lines) {
        const match = line.match(/branch: Created from (.+)$/);
        if (match && match[1] && match[1] !== "HEAD") {
          const sourceBranch = match[1];
          try {
            const upstreamRef = await this.git.revparse([
              "--abbrev-ref",
              `${sourceBranch}@{upstream}`
            ]);
            const upstreamName = upstreamRef.trim();
            if (upstreamName) {
              const commitId = await this.resolveRef(upstreamName);
              if (commitId) {
                const slashIndex = upstreamName.indexOf("/");
                return {
                  name: upstreamName,
                  displayName: upstreamName,
                  type: "base",
                  commitId,
                  remote: slashIndex > 0 ? upstreamName.slice(0, slashIndex) : void 0
                };
              }
            }
          } catch {
            if (sourceBranch.includes("/")) {
              const commitId = await this.resolveRef(sourceBranch);
              if (commitId) {
                const slashIndex = sourceBranch.indexOf("/");
                return {
                  name: sourceBranch,
                  displayName: sourceBranch,
                  type: "base",
                  commitId,
                  remote: slashIndex > 0 ? sourceBranch.slice(0, slashIndex) : void 0
                };
              }
            }
          }
        }
      }
      return null;
    } catch {
      return null;
    }
  }
  /**
   * Get the default branch (origin/main or origin/master).
   */
  async getDefaultBranch() {
    for (const branchName of ["origin/main", "origin/master"]) {
      try {
        const commitId = await this.resolveRef(branchName);
        if (commitId) {
          return {
            name: branchName,
            displayName: branchName,
            type: "base",
            commitId,
            remote: "origin"
          };
        }
      } catch {
      }
    }
    return null;
  }
  /**
   * Convert git status code to GitFileStatusCode.
   */
  statusCodeToFileStatus(code) {
    switch (code) {
      case "A":
        return "added";
      case "D":
        return "deleted";
      case "M":
        return "modified";
      case "R":
        return "renamed";
      case "C":
        return "copied";
      case "U":
        return "unmerged";
      default:
        return "modified";
    }
  }
  /**
   * Revert changes to files (discard working tree modifications).
   *
   * This discards ONLY working tree changes, preserving any staged changes.
   * Mirrors VS Code's "Discard Changes" behavior.
   *
   * Handles different file types:
   * - Untracked files: Delete from filesystem
   * - All other files: Restore from index via `git checkout -- file`
   *   - If file has staged changes, reverts to staged version
   *   - If file has no staged changes, reverts to HEAD
   *
   * Note: Does NOT unstage files. Use unstage() separately if needed.
   */
  async revert(files) {
    await this.withOperationTracking(async () => {
      const relativePaths = files.map((f) => this.toRelativePath(f));
      const status = await this.getStatus();
      const filesToCheckout = [];
      const filesToDelete = [];
      for (const relPath of relativePaths) {
        const fileStatus = status.files.get(relPath);
        if (fileStatus?.status === "untracked") {
          filesToDelete.push(relPath);
        } else {
          filesToCheckout.push(relPath);
        }
      }
      await Promise.all(
        filesToDelete.map(async (relPath) => {
          const fullPath = path5.join(this.gitRoot, relPath);
          try {
            await fsPromises.unlink(fullPath);
          } catch {
          }
        })
      );
      if (filesToCheckout.length > 0) {
        await this.git.checkout(["--", ...filesToCheckout]);
      }
    });
  }
  // -------------------------------------------------------------------------
  // Operations
  // -------------------------------------------------------------------------
  /**
   * Stage files for commit.
   */
  async stage(files) {
    await this.withOperationTracking(async () => {
      const relativePaths = files.map((f) => this.toRelativePath(f));
      await this.git.add(relativePaths);
    });
  }
  /**
   * Unstage files (remove from index).
   */
  async unstage(files) {
    await this.withOperationTracking(async () => {
      const relativePaths = files.map((f) => this.toRelativePath(f));
      await this.git.reset(["HEAD", "--", ...relativePaths]);
    });
  }
  /**
   * Create a commit.
   */
  async commit(message, options) {
    return this.withOperationTracking(async () => {
      const commitOpts = {};
      if (options?.amend) {
        commitOpts["--amend"] = null;
      }
      if (options?.signoff) {
        commitOpts["--signoff"] = null;
      }
      if (options?.files && options.files.length > 0) {
        const relativePaths = options.files.map((f) => this.toRelativePath(f));
        await this.git.commit(message, relativePaths, commitOpts);
      } else {
        await this.git.commit(message, commitOpts);
      }
      const log = await this.git.log({ maxCount: 1 });
      const latestCommit = log.latest;
      if (!latestCommit) {
        throw new Error("Failed to get commit after creation");
      }
      const commit = {
        hash: latestCommit.hash,
        shortHash: latestCommit.hash.substring(0, 7),
        author: latestCommit.author_name,
        email: latestCommit.author_email,
        date: new Date(latestCommit.date),
        message: latestCommit.message,
        parents: latestCommit.refs ? latestCommit.refs.split(", ") : []
      };
      this._onCommitCreated.fire({ commit });
      return commit;
    });
  }
  /**
   * Checkout a branch or ref.
   *
   * @param ref - Branch name, tag, or commit hash
   * @param options - Checkout options (force)
   */
  async checkout(ref, options) {
    const previousBranch = await this.getCurrentBranch();
    const previousHead = await this.getHeadCommit();
    await this.withOperationTracking(async () => {
      const checkoutOptions = [];
      if (options?.force) {
        checkoutOptions.push("--force");
      }
      if (checkoutOptions.length > 0) {
        await this.git.checkout([...checkoutOptions, ref]);
      } else {
        await this.git.checkout(ref);
      }
    });
    const currentBranch = await this.getCurrentBranch();
    const currentHead = await this.getHeadCommit();
    if (previousBranch !== currentBranch) {
      this._onBranchChanged.fire({
        previousBranch,
        currentBranch
      });
    }
    if (previousHead !== currentHead) {
      this._onHeadChanged.fire({
        previousHead,
        currentHead,
        isBranchSwitch: previousBranch !== currentBranch
      });
    }
  }
  /**
   * Create a new branch and optionally switch to it.
   *
   * @param branchName - Name for the new branch
   * @param checkout - Whether to switch to the new branch (default: true)
   * @param startPoint - Optional ref to start the branch from (default: HEAD)
   */
  async createBranch(branchName, checkout = true, startPoint) {
    const previousBranch = await this.getCurrentBranch();
    await this.withOperationTracking(async () => {
      if (checkout) {
        const args = ["-b", branchName];
        if (startPoint) {
          args.push(startPoint);
        }
        await this.git.checkout(args);
      } else {
        const args = [branchName];
        if (startPoint) {
          args.push(startPoint);
        }
        await this.git.branch(args);
      }
    });
    if (checkout) {
      const currentBranch = await this.getCurrentBranch();
      if (previousBranch !== currentBranch) {
        this._onBranchChanged.fire({
          previousBranch,
          currentBranch
        });
      }
    }
  }
  /**
   * Stash current uncommitted changes.
   *
   * Saves both staged and unstaged changes to the stash.
   *
   * @param message - Optional message for the stash entry
   */
  async stash(message) {
    await this.withOperationTracking(async () => {
      if (message) {
        await this.git.stash(["push", "-m", message]);
      } else {
        await this.git.stash(["push"]);
      }
    });
  }
  /**
   * Apply and remove the most recent stash entry.
   *
   * Restores the previously stashed changes to the working directory.
   */
  async stashPop() {
    await this.withOperationTracking(async () => {
      await this.git.stash(["pop"]);
    });
  }
  /**
   * Push commits to remote.
   *
   * @param force - If true, use --force-with-lease for safer force push
   * @param setUpstream - If true, set upstream tracking (for new branches)
   */
  async push(force = false, setUpstream = false) {
    await this.withOperationTracking(async () => {
      const options = [];
      if (force) {
        options.push("--force-with-lease");
      }
      if (setUpstream) {
        options.push("--set-upstream", "origin", "HEAD");
      }
      await this.git.push(options);
    });
  }
  /**
   * Pull changes from remote.
   *
   * @param rebase - If true, use rebase instead of merge
   */
  async pull(rebase = false) {
    await this.withOperationTracking(async () => {
      if (rebase) {
        await this.git.pull(["--rebase"]);
      } else {
        await this.git.pull();
      }
    });
  }
  /**
   * Check if the current branch has an upstream (tracking) branch configured.
   *
   * @returns true if an upstream is configured, false otherwise
   */
  async hasUpstream() {
    try {
      const result = await this.git.raw([
        "rev-parse",
        "--abbrev-ref",
        "--symbolic-full-name",
        "@{u}"
      ]);
      return result.trim().length > 0;
    } catch {
      return false;
    }
  }
  // -------------------------------------------------------------------------
  // Internal: State Management
  // -------------------------------------------------------------------------
  /**
   * Initialize last known state for change detection.
   */
  async initializeState() {
    try {
      this.lastStatus = await this.getStatus();
      this.lastBranch = await this.getCurrentBranch();
      this.lastHead = await this.getHeadCommit();
    } catch (error) {
      console.error("[DiskGitProvider] Failed to initialize state:", error);
    }
  }
  /**
   * Get the current HEAD commit hash.
   */
  async getHeadCommit() {
    try {
      const result = await this.git.revparse(["HEAD"]);
      return result.trim();
    } catch {
      return "";
    }
  }
  // -------------------------------------------------------------------------
  // Internal: Status Parsing
  // -------------------------------------------------------------------------
  /**
   * Parse git status result into our GitStatus type.
   */
  parseStatus(statusResult, branch) {
    const files = /* @__PURE__ */ new Map();
    for (const file of statusResult.files) {
      const entries = this.parseFileStatuses(file);
      for (const entry of entries) {
        const key = entry.staged || !entry.hasIndexChanges ? entry.path : entry.path + UNSTAGED_KEY_SUFFIX;
        files.set(key, entry);
      }
    }
    return {
      branch: branch || "HEAD",
      upstream: statusResult.tracking || void 0,
      ahead: statusResult.ahead,
      behind: statusResult.behind,
      files
    };
  }
  /**
   * Parse a single file from simple-git into one or two GitFileStatus entries.
   *
   * For most files, returns a single entry. For partially staged files
   * (e.g., "MM" - modified in both index and working directory), returns
   * two entries: one for staged changes and one for unstaged changes.
   */
  parseFileStatuses(file) {
    const { path: filePath, index, working_dir } = file;
    const entries = [];
    if (index === "?" && working_dir === "?") {
      entries.push({
        path: filePath,
        status: "untracked",
        staged: false
      });
      return entries;
    }
    if (index === "!" && working_dir === "!") {
      entries.push({
        path: filePath,
        status: "ignored",
        staged: false
      });
      return entries;
    }
    if (index === "U" || working_dir === "U" || index === "A" && working_dir === "A" || index === "D" && working_dir === "D") {
      entries.push({
        path: filePath,
        status: "unmerged",
        staged: false
      });
      return entries;
    }
    const hasIndexChange = index !== " " && index !== "?";
    const hasWorkingDirChange = working_dir !== " " && working_dir !== "?";
    if (hasIndexChange) {
      entries.push({
        path: filePath,
        status: this.codeToStatus(index),
        staged: true,
        hasIndexChanges: true
      });
    }
    if (hasWorkingDirChange) {
      entries.push({
        path: filePath,
        status: this.codeToStatus(working_dir),
        staged: false,
        // hasIndexChanges indicates the diff should be Index  Working Dir
        // instead of HEAD  Working Dir
        hasIndexChanges: hasIndexChange
      });
    }
    return entries;
  }
  /**
   * Convert a single git status code to our status type.
   */
  codeToStatus(code) {
    switch (code) {
      case "M":
        return "modified";
      case "A":
        return "added";
      case "D":
        return "deleted";
      case "R":
        return "renamed";
      case "C":
        return "copied";
      default:
        return "modified";
    }
  }
  // -------------------------------------------------------------------------
  // Internal: Refresh Scheduling
  // -------------------------------------------------------------------------
  /**
   * Schedule a status refresh with debouncing.
   */
  scheduleStatusRefresh() {
    if (this.disposed) {
      return;
    }
    if (this.activeOperations > 0) {
      return;
    }
    if (this.refreshTimer) {
      clearTimeout(this.refreshTimer);
    }
    this.refreshTimer = setTimeout(() => {
      this.refreshTimer = null;
      this.refreshStatus();
    }, STATUS_REFRESH_DEBOUNCE_MS);
  }
  /**
   * Actually refresh status and emit events if changed.
   */
  async refreshStatus() {
    if (this.disposed) {
      return;
    }
    this.perFileDiffStatsCache = null;
    try {
      const currentStatus = await this.getStatus();
      const currentBranch = currentStatus.branch;
      const currentHead = await this.getHeadCommit();
      if (this.lastStatus) {
        const delta = this.calculateStatusDelta(this.lastStatus, currentStatus);
        const aheadBehindChanged = this.lastStatus.ahead !== currentStatus.ahead || this.lastStatus.behind !== currentStatus.behind;
        const headChanged = this.lastHead !== currentHead;
        const upstreamChanged = this.lastStatus.upstream !== currentStatus.upstream;
        if (delta.added.length > 0 || delta.modified.length > 0 || delta.removed.length > 0 || aheadBehindChanged || headChanged || upstreamChanged) {
          this._onStatusChanged.fire({
            status: currentStatus,
            ...delta
          });
        }
      }
      if (this.lastBranch && this.lastBranch !== currentBranch) {
        this._onBranchChanged.fire({
          previousBranch: this.lastBranch,
          currentBranch
        });
      }
      if (this.lastHead && this.lastHead !== currentHead) {
        this._onHeadChanged.fire({
          previousHead: this.lastHead,
          currentHead,
          isBranchSwitch: this.lastBranch !== currentBranch
        });
      }
      this.lastStatus = currentStatus;
      this.lastBranch = currentBranch;
      this.lastHead = currentHead;
    } catch (error) {
      console.error("[DiskGitProvider] Failed to refresh status:", error);
    }
  }
  /**
   * Calculate the delta between two status snapshots.
   */
  calculateStatusDelta(previous, current) {
    const added = [];
    const modified = [];
    const removed = [];
    for (const [filePath, currentFile] of current.files) {
      const previousFile = previous.files.get(filePath);
      if (!previousFile) {
        added.push(filePath);
      } else if (previousFile.status !== currentFile.status || previousFile.staged !== currentFile.staged) {
        modified.push(filePath);
      }
    }
    for (const filePath of previous.files.keys()) {
      if (!current.files.has(filePath)) {
        removed.push(filePath);
      }
    }
    return { added, modified, removed };
  }
  // -------------------------------------------------------------------------
  // Internal: Operation Tracking
  // -------------------------------------------------------------------------
  /**
   * Execute a git operation with tracking.
   *
   * While operations are active, status refresh is suppressed
   * to avoid thrashing.
   */
  async withOperationTracking(operation) {
    this.activeOperations++;
    try {
      return await operation();
    } finally {
      this.activeOperations--;
      if (this.activeOperations === 0) {
        this.scheduleStatusRefresh();
      }
    }
  }
  // -------------------------------------------------------------------------
  // Internal: Path Utilities
  // -------------------------------------------------------------------------
  /**
   * Convert a path to be relative to the git root.
   *
   * On case-insensitive filesystems (macOS, Windows), handles the case where
   * the file path and git root have different casings but refer to the same location.
   *
   * Always returns paths with forward slashes for Git compatibility.
   */
  toRelativePath(filePath) {
    const absolutePath = path5.isAbsolute(filePath) ? filePath : path5.resolve(this.cwd, filePath);
    let relativePath = path5.relative(this.gitRoot, absolutePath);
    if (relativePath.startsWith("..") && (process.platform === "darwin" || process.platform === "win32")) {
      const gitRootLower = this.gitRoot.toLowerCase();
      const absolutePathLower = absolutePath.toLowerCase();
      if (absolutePathLower.startsWith(gitRootLower)) {
        const relativePortion = absolutePath.slice(this.gitRoot.length);
        relativePath = relativePortion.replace(/^[/\\]/, "");
      }
    }
    return relativePath.split(path5.sep).join("/");
  }
  /**
   * Resolve the actual .git directory for worktrees.
   *
   * When using git worktrees, .git is a file containing:
   * "gitdir: /path/to/actual/.git/worktrees/name"
   */
  resolveGitDir(gitFile) {
    try {
      const content = fs5.readFileSync(gitFile, "utf8");
      const match = content.match(/gitdir:\s*(.+)/);
      if (match) {
        const gitDir = match[1].trim();
        return path5.isAbsolute(gitDir) ? gitDir : path5.resolve(path5.dirname(gitFile), gitDir);
      }
    } catch {
    }
    return gitFile;
  }
};
async function findGitRoot(cwd) {
  try {
    const git = simpleGit(cwd);
    const root = await git.revparse(["--show-toplevel"]);
    return root.trim() || null;
  } catch {
    return null;
  }
}
async function isGitAvailable() {
  try {
    const git = simpleGit();
    await git.version();
    return true;
  } catch {
    return false;
  }
}

// src/git/git-provider-service.ts
var DISPOSE_GRACE_PERIOD_MS = 5e3;
var GitProviderService = class _GitProviderService {
  // -------------------------------------------------------------------------
  // Singleton
  // -------------------------------------------------------------------------
  static instance = null;
  /**
   * Get the singleton instance of the service.
   */
  static getInstance() {
    if (!_GitProviderService.instance) {
      _GitProviderService.instance = new _GitProviderService();
    }
    return _GitProviderService.instance;
  }
  /**
   * Reset the singleton instance (for testing only).
   *
   * This disposes all providers and clears the singleton.
   * Should only be used in test cleanup.
   */
  static resetInstance() {
    if (_GitProviderService.instance) {
      _GitProviderService.instance.disposeAll();
      _GitProviderService.instance = null;
    }
  }
  // -------------------------------------------------------------------------
  // Internal State
  // -------------------------------------------------------------------------
  /** Map of git roots to provider entries */
  providers = /* @__PURE__ */ new Map();
  /** Map of pending provider creation promises to prevent race conditions */
  pendingCreations = /* @__PURE__ */ new Map();
  /** Cached result of git availability check */
  gitAvailableCache = void 0;
  /** Optional logging function */
  log;
  /**
   * Create a new GitProviderService.
   *
   * Can be instantiated directly with options, or accessed via getInstance()
   * for singleton usage.
   *
   * @param options - Configuration options
   */
  constructor(options = {}) {
    this.log = options.log;
  }
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  /**
   * Get a git provider for the specified directory.
   *
   * Automatically finds the git repository root containing the directory.
   * If a provider already exists for this repository, the reference count
   * is incremented and the existing provider is returned.
   *
   * @param cwd - The working directory (any directory within a git repo)
   * @returns The git provider instance and the git root path
   * @throws If the directory is not within a git repository
   */
  async getProvider(cwd) {
    const gitRoot = await this.findGitRoot(cwd);
    if (!gitRoot) {
      throw new Error(`Not a git repository: ${cwd}`);
    }
    const normalizedRoot = this.normalizePath(gitRoot);
    const existing = this.providers.get(normalizedRoot);
    if (existing) {
      if (existing.disposeTimer) {
        clearTimeout(existing.disposeTimer);
        existing.disposeTimer = void 0;
      }
      existing.refCount++;
      return { provider: existing.provider, gitRoot: normalizedRoot };
    }
    const pendingCreation = this.pendingCreations.get(normalizedRoot);
    if (pendingCreation) {
      const result = await pendingCreation;
      const entry = this.providers.get(normalizedRoot);
      if (entry) {
        entry.refCount++;
      }
      return result;
    }
    const creationPromise = this.createProvider(normalizedRoot, cwd);
    this.pendingCreations.set(normalizedRoot, creationPromise);
    try {
      const result = await creationPromise;
      return result;
    } finally {
      this.pendingCreations.delete(normalizedRoot);
    }
  }
  /**
   * Internal method to create a new provider.
   * Separated to support the pending creations pattern.
   */
  async createProvider(normalizedRoot, cwd) {
    const provider = new DiskGitProvider(normalizedRoot, cwd);
    await provider.startWatching();
    this.providers.set(normalizedRoot, {
      provider,
      refCount: 1
    });
    return { provider, gitRoot: normalizedRoot };
  }
  /**
   * Release a reference to a git provider.
   *
   * Decrements the reference count for the provider at the specified git root.
   * When the count reaches zero, a grace period timer is started. If no new
   * references are acquired within the grace period, the provider is disposed.
   *
   * @param gitRoot - The git repository root path
   */
  releaseProvider(gitRoot) {
    const normalizedRoot = this.normalizePath(gitRoot);
    const entry = this.providers.get(normalizedRoot);
    if (!entry) {
      console.warn(
        `[GitProviderService] Attempted to release unknown provider: ${normalizedRoot}`
      );
      return;
    }
    entry.refCount--;
    if (entry.refCount <= 0) {
      entry.disposeTimer = setTimeout(() => {
        this.disposeProvider(normalizedRoot);
      }, DISPOSE_GRACE_PERIOD_MS);
    }
  }
  /**
   * Immediately dispose a provider without waiting for grace period.
   *
   * This is primarily useful for testing or forced cleanup scenarios.
   *
   * @param gitRoot - The git repository root path
   */
  async forceDispose(gitRoot) {
    const normalizedRoot = this.normalizePath(gitRoot);
    await this.disposeProvider(normalizedRoot);
  }
  /**
   * Find the git repository root for a given path.
   *
   * Walks up the directory tree looking for a .git directory or file.
   *
   * @param startPath - The starting directory path
   * @returns The git root path, or null if not in a git repository
   */
  async findGitRoot(startPath) {
    let currentPath = path6.resolve(startPath);
    const root = path6.parse(currentPath).root;
    while (currentPath !== root) {
      const gitPath = path6.join(currentPath, ".git");
      try {
        await fs6.promises.access(gitPath);
        return currentPath;
      } catch {
        currentPath = path6.dirname(currentPath);
      }
    }
    const rootGitPath = path6.join(root, ".git");
    try {
      await fs6.promises.access(rootGitPath);
      return root;
    } catch {
      return null;
    }
  }
  /**
   * Get the current reference count for a provider.
   *
   * Returns 0 if no provider exists for the path.
   *
   * @param gitRoot - The git repository root path
   * @returns The current reference count
   */
  getRefCount(gitRoot) {
    const normalizedRoot = this.normalizePath(gitRoot);
    const entry = this.providers.get(normalizedRoot);
    return entry?.refCount ?? 0;
  }
  /**
   * Check if a provider exists for the given git root.
   *
   * @param gitRoot - The git repository root path
   * @returns True if a provider exists (regardless of refCount)
   */
  hasProvider(gitRoot) {
    const normalizedRoot = this.normalizePath(gitRoot);
    return this.providers.has(normalizedRoot);
  }
  /**
   * Get an existing provider without incrementing reference count.
   *
   * Use this for operations that rely on an active subscription holding
   * the provider reference. Returns null if no provider exists.
   *
   * @param gitRoot - The git repository root path
   * @returns The provider if it exists, null otherwise
   */
  getExistingProvider(gitRoot) {
    const normalizedRoot = this.normalizePath(gitRoot);
    return this.providers.get(normalizedRoot)?.provider ?? null;
  }
  /**
   * Get an existing provider by cwd without incrementing reference count.
   *
   * Finds the git root for the cwd and returns the provider if one exists.
   * Use this for operations that rely on an active subscription holding
   * the provider reference.
   *
   * @param cwd - The working directory (any directory within a git repo)
   * @returns The provider and git root if they exist, null otherwise
   */
  async getExistingProviderByCwd(cwd) {
    const gitRoot = await this.findGitRoot(cwd);
    if (!gitRoot) {
      return null;
    }
    const normalizedRoot = this.normalizePath(gitRoot);
    const entry = this.providers.get(normalizedRoot);
    if (!entry) {
      return null;
    }
    return { provider: entry.provider, gitRoot: normalizedRoot };
  }
  /**
   * Get the number of active providers.
   *
   * @returns The count of providers currently managed by this service
   */
  get providerCount() {
    return this.providers.size;
  }
  /**
   * Force dispose all providers immediately.
   *
   * This is primarily useful for testing or forced cleanup scenarios
   * such as application shutdown.
   */
  forceDisposeAll() {
    this.disposeAll();
  }
  // -------------------------------------------------------------------------
  // Compatibility Methods (for jsonrpc-proxy)
  // -------------------------------------------------------------------------
  /**
   * Acquire a provider reference for the specified directory.
   *
   * Alias for getProvider() - used by jsonrpc-proxy.
   *
   * @param cwd - The working directory path
   * @returns The git provider instance
   */
  async retain(cwd) {
    const result = await this.getProvider(cwd);
    return result.provider;
  }
  /**
   * Release a provider reference.
   *
   * Alias for releaseProvider() - used by jsonrpc-proxy.
   *
   * @param gitRoot - The git repository root path
   */
  release(gitRoot) {
    this.releaseProvider(gitRoot);
  }
  /**
   * Dispose the service and all providers.
   *
   * Used by jsonrpc-proxy during shutdown.
   */
  async dispose() {
    this.disposeAll();
  }
  /**
   * Get statistics about active providers.
   *
   * Useful for debugging and monitoring.
   *
   * @returns Object containing provider statistics
   */
  getStats() {
    const stats = /* @__PURE__ */ new Map();
    for (const [gitRoot, entry] of this.providers) {
      stats.set(gitRoot, {
        refCount: entry.refCount,
        hasPendingDispose: entry.disposeTimer !== null
      });
    }
    return { providers: stats };
  }
  /**
   * Notify that a file has changed in the working directory.
   *
   * This is called by FileSystemProviderService when files are modified.
   * If the file is within a git repository with an active provider,
   * it will trigger a status refresh.
   *
   * @param filePath - The absolute path to the changed file
   */
  async notifyFileChanged(filePath) {
    const gitRoot = await this.findGitRoot(filePath);
    if (!gitRoot) {
      return;
    }
    const normalizedRoot = this.normalizePath(gitRoot);
    const entry = this.providers.get(normalizedRoot);
    if (entry) {
      entry.provider.triggerStatusRefresh();
    }
  }
  /**
   * Check if git is available on the system.
   *
   * Tests by running `git --version`. Result is cached for performance.
   *
   * @returns True if git is installed and accessible
   */
  async isGitAvailable() {
    if (this.gitAvailableCache !== void 0) {
      return this.gitAvailableCache;
    }
    try {
      const git = simpleGit();
      await git.version();
      this.gitAvailableCache = true;
      return true;
    } catch {
      this.gitAvailableCache = false;
      return false;
    }
  }
  // -------------------------------------------------------------------------
  // Internal Methods
  // -------------------------------------------------------------------------
  /**
   * Normalize a path for consistent lookup.
   * Resolves to absolute path and handles case-insensitivity on macOS/Windows.
   */
  normalizePath(filePath) {
    const resolved = path6.resolve(filePath);
    return normalizePathForComparison(resolved);
  }
  /**
   * Dispose a provider and remove it from the map.
   */
  async disposeProvider(normalizedRoot) {
    const entry = this.providers.get(normalizedRoot);
    if (!entry) {
      return;
    }
    if (entry.disposeTimer) {
      clearTimeout(entry.disposeTimer);
    }
    this.providers.delete(normalizedRoot);
    entry.provider.dispose();
  }
  /**
   * Dispose all providers (used during service shutdown/reset).
   */
  disposeAll() {
    for (const [normalizedRoot, entry] of this.providers) {
      if (entry.disposeTimer) {
        clearTimeout(entry.disposeTimer);
      }
      try {
        entry.provider.dispose();
      } catch (error) {
        console.error(
          `[GitProviderService] Error disposing provider ${normalizedRoot}:`,
          error
        );
      }
    }
    this.providers.clear();
  }
};

// src/fs/fs-provider-service.ts
var DISPOSE_GRACE_PERIOD_MS2 = 5e3;
var FileSystemProviderService = class _FileSystemProviderService {
  // -------------------------------------------------------------------------
  // Singleton
  // -------------------------------------------------------------------------
  static instance = null;
  /**
   * Get the singleton instance of the service.
   */
  static getInstance() {
    if (!_FileSystemProviderService.instance) {
      _FileSystemProviderService.instance = new _FileSystemProviderService();
    }
    return _FileSystemProviderService.instance;
  }
  /**
   * Reset the singleton instance (for testing only).
   *
   * This disposes all providers and clears the singleton.
   * Should only be used in test cleanup.
   */
  static resetInstance() {
    if (_FileSystemProviderService.instance) {
      _FileSystemProviderService.instance.disposeAll();
      _FileSystemProviderService.instance = null;
    }
  }
  // -------------------------------------------------------------------------
  // Internal State
  // -------------------------------------------------------------------------
  /** Map of normalized paths to provider entries */
  providers = /* @__PURE__ */ new Map();
  /**
   * Map of pending provider creation promises to prevent race conditions.
   *
   * Even with simplified lifecycle (only subscriptions create providers),
   * concurrent subscriptions for the same cwd can still occur (multiple
   * windows, fast component remounts). This ensures only one provider
   * is created per cwd.
   */
  pendingCreations = /* @__PURE__ */ new Map();
  /** Optional logging function */
  log;
  /**
   * Create a new FileSystemProviderService.
   *
   * Can be instantiated directly with options, or accessed via getInstance()
   * for singleton usage.
   *
   * @param options - Configuration options
   */
  constructor(options = {}) {
    this.log = options.log;
  }
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  /**
   * Get a filesystem provider for the specified directory.
   *
   * This method is used by subscriptions to acquire provider references.
   * Operations use `getExistingProvider()` instead since they rely on
   * an active subscription holding the provider reference.
   *
   * If a provider already exists for this path, the reference count is
   * incremented and the existing provider is returned. If a provider is
   * in the grace period awaiting disposal, the timer is cancelled and
   * the provider is reused.
   *
   * @param cwd - The working directory path
   * @returns The filesystem provider instance
   */
  async getProvider(cwd) {
    const normalizedPath = this.normalizePath(cwd);
    const existing = this.providers.get(normalizedPath);
    if (existing) {
      if (existing.disposeTimer) {
        clearTimeout(existing.disposeTimer);
        existing.disposeTimer = void 0;
        if (!existing.fileChangeDisposable) {
          existing.fileChangeDisposable = existing.provider.onFileContentChanged((event) => {
            GitProviderService.getInstance().notifyFileChanged(event.path).catch(() => {
            });
          });
        }
        if (!existing.gitRoot) {
          GitProviderService.getInstance().getProvider(normalizedPath).then((result) => {
            existing.gitRoot = result.gitRoot;
          }).catch(() => {
          });
        }
      }
      existing.refCount++;
      return existing.provider;
    }
    const pendingCreation = this.pendingCreations.get(normalizedPath);
    if (pendingCreation) {
      const provider = await pendingCreation;
      const entry = this.providers.get(normalizedPath);
      if (entry) {
        entry.refCount++;
      }
      return provider;
    }
    const creationPromise = this.createProvider(normalizedPath);
    this.pendingCreations.set(normalizedPath, creationPromise);
    try {
      const provider = await creationPromise;
      return provider;
    } finally {
      this.pendingCreations.delete(normalizedPath);
    }
  }
  /**
   * Internal method to create a new provider.
   * Separated to support the pending creations pattern.
   */
  async createProvider(normalizedPath) {
    if (!fs7.existsSync(normalizedPath)) {
      throw new Error(
        `Cannot create local filesystem provider for non-existent path: ${normalizedPath}. If this is a remote/VM path, ensure sandboxId is passed through the component hierarchy.`
      );
    }
    const provider = new DiskFileSystemProvider(normalizedPath);
    await provider.startWatching();
    const fileChangeDisposable = provider.onFileContentChanged((event) => {
      GitProviderService.getInstance().notifyFileChanged(event.path).catch(() => {
      });
    });
    let gitRoot;
    try {
      const gitService = GitProviderService.getInstance();
      const gitResult = await gitService.getProvider(normalizedPath);
      gitRoot = gitResult.gitRoot;
    } catch {
    }
    this.providers.set(normalizedPath, {
      provider,
      refCount: 1,
      fileChangeDisposable,
      gitRoot
    });
    return provider;
  }
  /**
   * Release a reference to a filesystem provider.
   *
   * Decrements the reference count for the provider at the specified path.
   * When the count reaches zero, a grace period timer is started. If no
   * new references are acquired within the grace period, the provider
   * is disposed.
   *
   * @param cwd - The working directory path
   */
  releaseProvider(cwd) {
    const normalizedPath = this.normalizePath(cwd);
    const entry = this.providers.get(normalizedPath);
    if (!entry) {
      console.warn(
        `[FileSystemProviderService] Attempted to release unknown provider: ${normalizedPath}`
      );
      return;
    }
    entry.refCount--;
    if (entry.refCount <= 0) {
      if (entry.fileChangeDisposable) {
        entry.fileChangeDisposable.dispose();
        entry.fileChangeDisposable = void 0;
      }
      if (entry.gitRoot) {
        GitProviderService.getInstance().releaseProvider(entry.gitRoot);
        entry.gitRoot = void 0;
      }
      entry.disposeTimer = setTimeout(() => {
        this.disposeProvider(normalizedPath);
      }, DISPOSE_GRACE_PERIOD_MS2);
    }
  }
  /**
   * Immediately dispose a provider without waiting for grace period.
   *
   * This is primarily useful for testing or forced cleanup scenarios.
   *
   * @param cwd - The working directory path
   */
  async forceDispose(cwd) {
    const normalizedPath = this.normalizePath(cwd);
    await this.disposeProvider(normalizedPath);
  }
  /**
   * Get the current reference count for a provider.
   *
   * Returns 0 if no provider exists for the path.
   *
   * @param cwd - The working directory path
   * @returns The current reference count
   */
  getRefCount(cwd) {
    const normalizedPath = this.normalizePath(cwd);
    const entry = this.providers.get(normalizedPath);
    return entry?.refCount ?? 0;
  }
  /**
   * Check if a provider exists for the given path.
   *
   * @param cwd - The working directory path
   * @returns True if a provider exists (regardless of refCount)
   */
  hasProvider(cwd) {
    const normalizedPath = this.normalizePath(cwd);
    return this.providers.has(normalizedPath);
  }
  /**
   * Get an existing provider without incrementing reference count.
   *
   * Use this for operations that rely on an active subscription holding
   * the provider reference. Returns null if no provider exists.
   *
   * @param cwd - The working directory path
   * @returns The provider if it exists, null otherwise
   */
  getExistingProvider(cwd) {
    const normalizedPath = this.normalizePath(cwd);
    return this.providers.get(normalizedPath)?.provider ?? null;
  }
  /**
   * Get the number of active providers.
   *
   * @returns The count of providers currently managed by this service
   */
  get providerCount() {
    return this.providers.size;
  }
  /**
   * Force dispose all providers immediately.
   *
   * This is primarily useful for testing or forced cleanup scenarios
   * such as application shutdown.
   */
  forceDisposeAll() {
    this.disposeAll();
  }
  // -------------------------------------------------------------------------
  // Compatibility Methods (for jsonrpc-proxy)
  // -------------------------------------------------------------------------
  /**
   * Acquire a provider reference for the specified directory.
   *
   * Alias for getProvider() - used by jsonrpc-proxy.
   *
   * @param cwd - The working directory path
   * @returns The filesystem provider instance
   */
  async retain(cwd) {
    return this.getProvider(cwd);
  }
  /**
   * Release a provider reference.
   *
   * Alias for releaseProvider() - used by jsonrpc-proxy.
   *
   * @param cwd - The working directory path
   */
  release(cwd) {
    this.releaseProvider(cwd);
  }
  /**
   * Dispose the service and all providers.
   *
   * Used by jsonrpc-proxy during shutdown.
   */
  async dispose() {
    this.disposeAll();
  }
  /**
   * Get statistics about active providers.
   *
   * Useful for debugging and monitoring.
   *
   * @returns Object containing provider statistics
   */
  getStats() {
    const stats = /* @__PURE__ */ new Map();
    for (const [path11, entry] of this.providers) {
      stats.set(path11, {
        refCount: entry.refCount,
        hasPendingDispose: entry.disposeTimer !== null
      });
    }
    return { providers: stats };
  }
  // -------------------------------------------------------------------------
  // Internal Methods
  // -------------------------------------------------------------------------
  /**
   * Normalize a path for consistent lookup.
   *
   * Resolves to absolute path and handles platform-specific normalization.
   * On case-insensitive filesystems (macOS, Windows), also lowercases the path
   * to ensure consistent Map key lookups regardless of casing.
   */
  normalizePath(filePath) {
    const resolved = path7.resolve(filePath);
    if (process.platform === "darwin" || process.platform === "win32") {
      return resolved.toLowerCase();
    }
    return resolved;
  }
  /**
   * Dispose a provider and remove it from the map.
   */
  async disposeProvider(normalizedPath) {
    const entry = this.providers.get(normalizedPath);
    if (!entry) {
      return;
    }
    if (entry.disposeTimer) {
      clearTimeout(entry.disposeTimer);
    }
    if (entry.fileChangeDisposable) {
      entry.fileChangeDisposable.dispose();
    }
    if (entry.gitRoot) {
      GitProviderService.getInstance().releaseProvider(entry.gitRoot);
    }
    this.providers.delete(normalizedPath);
    entry.provider.dispose();
  }
  /**
   * Dispose all providers (used during service shutdown/reset).
   */
  disposeAll() {
    for (const [normalizedPath, entry] of this.providers) {
      if (entry.disposeTimer) {
        clearTimeout(entry.disposeTimer);
      }
      if (entry.fileChangeDisposable) {
        entry.fileChangeDisposable.dispose();
      }
      if (entry.gitRoot) {
        GitProviderService.getInstance().releaseProvider(entry.gitRoot);
      }
      try {
        entry.provider.dispose();
      } catch (error) {
        console.error(
          `[FileSystemProviderService] Error disposing provider ${normalizedPath}:`,
          error
        );
      }
    }
    this.providers.clear();
  }
};

// src/git/types.ts
function serializeGitStatus(status) {
  const files = {};
  for (const [path11, fileStatus] of status.files) {
    files[path11] = fileStatus;
  }
  return {
    branch: status.branch,
    upstream: status.upstream,
    ahead: status.ahead,
    behind: status.behind,
    files
  };
}

// src/version-check.ts
var CURRENT_VERSION = "0.4.1";
var RELEASE_REPO_URL = "https://raw.githubusercontent.com/avanderhoorn/tunnel-proxy-release/main/package.json";
var UPDATE_COMMAND = "npm install -g github:avanderhoorn/tunnel-proxy-release";
var RED = "\x1B[31m";
var GREEN = "\x1B[32m";
var YELLOW = "\x1B[33m";
var DIM = "\x1B[2m";
var RESET = "\x1B[0m";
var BOLD = "\x1B[1m";
function parseSemVer(version) {
  const [major, minor, patch] = version.split(".").map(Number);
  return { major, minor, patch };
}
function compareSemVer(a, b) {
  if (a.major !== b.major) return a.major - b.major;
  if (a.minor !== b.minor) return a.minor - b.minor;
  return a.patch - b.patch;
}
async function fetchLatestVersion() {
  try {
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), 5e3);
    const response = await fetch(RELEASE_REPO_URL, {
      signal: controller.signal
    });
    clearTimeout(timeout);
    if (!response.ok) return null;
    const pkg = await response.json();
    return pkg.version;
  } catch {
    return null;
  }
}
async function checkForUpdates() {
  if (CURRENT_VERSION.startsWith("__")) {
    return;
  }
  const latestVersion = await fetchLatestVersion();
  if (!latestVersion) {
    return;
  }
  const current = parseSemVer(CURRENT_VERSION);
  const latest = parseSemVer(latestVersion);
  const comparison = compareSemVer(current, latest);
  if (comparison < 0) {
    console.log(
      `  ${BOLD}${YELLOW}Update available:${RESET} ${RED}${CURRENT_VERSION}${RESET} \u2192 ${GREEN}${latestVersion}${RESET}`
    );
    console.log(`  ${DIM}Run: ${UPDATE_COMMAND}${RESET}`);
    console.log();
  }
}

// src/skills/loader.ts
var import_fs2 = require("fs");
var fs8 = __toESM(require("fs/promises"), 1);
var os4 = __toESM(require("os"), 1);
var path9 = __toESM(require("path"), 1);
var import_yaml = __toESM(require_dist3(), 1);

// src/skills/path-helpers.ts
var import_fs = require("fs");
var os3 = __toESM(require("os"), 1);
var path8 = __toESM(require("path"), 1);
var APP_DIRECTORY = ".copilot";
function getCopilotHome(settings, type) {
  let basePath;
  if (settings?.configDir) {
    basePath = settings.configDir;
  } else {
    const xdgHome = type === "config" ? process.env.XDG_CONFIG_HOME : process.env.XDG_STATE_HOME;
    if (xdgHome) {
      basePath = path8.join(xdgHome, APP_DIRECTORY);
    } else {
      basePath = path8.join(os3.homedir(), APP_DIRECTORY);
    }
  }
  if (type === "pkg") {
    return path8.join(basePath, "pkg");
  }
  return basePath;
}
function collectParentComponentDirs(startPath, componentType, convention, boundary) {
  const results = [];
  const normalizedBoundary = path8.normalize(boundary);
  let currentDir = path8.normalize(startPath);
  while (true) {
    const componentDir = path8.join(currentDir, convention, componentType);
    if ((0, import_fs.existsSync)(componentDir)) {
      results.push(componentDir);
    }
    if (currentDir === normalizedBoundary) {
      break;
    }
    const parentDir = path8.dirname(currentDir);
    if (parentDir === currentDir) {
      break;
    }
    currentDir = parentDir;
  }
  return results;
}
function getDisplayPath(filePath, cwd = process.cwd()) {
  const relativePath = path8.relative(cwd, filePath);
  return relativePath.startsWith("..") ? filePath : relativePath;
}

// ../../node_modules/zod/v3/external.js
var external_exports = {};
__export(external_exports, {
  BRAND: () => BRAND,
  DIRTY: () => DIRTY,
  EMPTY_PATH: () => EMPTY_PATH,
  INVALID: () => INVALID,
  NEVER: () => NEVER,
  OK: () => OK,
  ParseStatus: () => ParseStatus,
  Schema: () => ZodType,
  ZodAny: () => ZodAny,
  ZodArray: () => ZodArray,
  ZodBigInt: () => ZodBigInt,
  ZodBoolean: () => ZodBoolean,
  ZodBranded: () => ZodBranded,
  ZodCatch: () => ZodCatch,
  ZodDate: () => ZodDate,
  ZodDefault: () => ZodDefault,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodEffects: () => ZodEffects,
  ZodEnum: () => ZodEnum,
  ZodError: () => ZodError,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
  ZodFunction: () => ZodFunction,
  ZodIntersection: () => ZodIntersection,
  ZodIssueCode: () => ZodIssueCode,
  ZodLazy: () => ZodLazy,
  ZodLiteral: () => ZodLiteral,
  ZodMap: () => ZodMap,
  ZodNaN: () => ZodNaN,
  ZodNativeEnum: () => ZodNativeEnum,
  ZodNever: () => ZodNever,
  ZodNull: () => ZodNull,
  ZodNullable: () => ZodNullable,
  ZodNumber: () => ZodNumber,
  ZodObject: () => ZodObject,
  ZodOptional: () => ZodOptional,
  ZodParsedType: () => ZodParsedType,
  ZodPipeline: () => ZodPipeline,
  ZodPromise: () => ZodPromise,
  ZodReadonly: () => ZodReadonly,
  ZodRecord: () => ZodRecord,
  ZodSchema: () => ZodType,
  ZodSet: () => ZodSet,
  ZodString: () => ZodString,
  ZodSymbol: () => ZodSymbol,
  ZodTransformer: () => ZodEffects,
  ZodTuple: () => ZodTuple,
  ZodType: () => ZodType,
  ZodUndefined: () => ZodUndefined,
  ZodUnion: () => ZodUnion,
  ZodUnknown: () => ZodUnknown,
  ZodVoid: () => ZodVoid,
  addIssueToContext: () => addIssueToContext,
  any: () => anyType,
  array: () => arrayType,
  bigint: () => bigIntType,
  boolean: () => booleanType,
  coerce: () => coerce,
  custom: () => custom,
  date: () => dateType,
  datetimeRegex: () => datetimeRegex,
  defaultErrorMap: () => en_default,
  discriminatedUnion: () => discriminatedUnionType,
  effect: () => effectsType,
  enum: () => enumType,
  function: () => functionType,
  getErrorMap: () => getErrorMap,
  getParsedType: () => getParsedType,
  instanceof: () => instanceOfType,
  intersection: () => intersectionType,
  isAborted: () => isAborted,
  isAsync: () => isAsync,
  isDirty: () => isDirty,
  isValid: () => isValid,
  late: () => late,
  lazy: () => lazyType,
  literal: () => literalType,
  makeIssue: () => makeIssue,
  map: () => mapType,
  nan: () => nanType,
  nativeEnum: () => nativeEnumType,
  never: () => neverType,
  null: () => nullType,
  nullable: () => nullableType,
  number: () => numberType,
  object: () => objectType,
  objectUtil: () => objectUtil,
  oboolean: () => oboolean,
  onumber: () => onumber,
  optional: () => optionalType,
  ostring: () => ostring,
  pipeline: () => pipelineType,
  preprocess: () => preprocessType,
  promise: () => promiseType,
  quotelessJson: () => quotelessJson,
  record: () => recordType,
  set: () => setType,
  setErrorMap: () => setErrorMap,
  strictObject: () => strictObjectType,
  string: () => stringType,
  symbol: () => symbolType,
  transformer: () => effectsType,
  tuple: () => tupleType,
  undefined: () => undefinedType,
  union: () => unionType,
  unknown: () => unknownType,
  util: () => util,
  void: () => voidType
});

// ../../node_modules/zod/v3/helpers/util.js
var util;
(function(util2) {
  util2.assertEqual = (_) => {
  };
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first2, second) => {
    return {
      ...first2,
      ...second
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};

// ../../node_modules/zod/v3/ZodError.js
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var quotelessJson = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};
var ZodError = class _ZodError extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof _ZodError)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        const firstEl = sub.path[0];
        fieldErrors[firstEl] = fieldErrors[firstEl] || [];
        fieldErrors[firstEl].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};

// ../../node_modules/zod/v3/locales/en.js
var errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "bigint")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};
var en_default = errorMap;

// ../../node_modules/zod/v3/errors.js
var overrideErrorMap = en_default;
function setErrorMap(map) {
  overrideErrorMap = map;
}
function getErrorMap() {
  return overrideErrorMap;
}

// ../../node_modules/zod/v3/helpers/parseUtil.js
var makeIssue = (params) => {
  const { data, path: path11, errorMaps, issueData } = params;
  const fullPath = [...path11, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
var EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === en_default ? void 0 : en_default
      // then global default map
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}
var ParseStatus = class _ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return _ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = (value) => ({ status: "dirty", value });
var OK = (value) => ({ status: "valid", value });
var isAborted = (x) => x.status === "aborted";
var isDirty = (x) => x.status === "dirty";
var isValid = (x) => x.status === "valid";
var isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;

// ../../node_modules/zod/v3/helpers/errorUtil.js
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message?.message;
})(errorUtil || (errorUtil = {}));

// ../../node_modules/zod/v3/types.js
var ParseInputLazyPath = class {
  constructor(parent, value, path11, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path11;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (Array.isArray(this._key)) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
var handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message ?? ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: message ?? required_error ?? ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: message ?? invalid_type_error ?? ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
var ZodType = class {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    const ctx = {
      common: {
        issues: [],
        async: params?.async ?? false,
        contextualErrorMap: params?.errorMap
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  "~validate"(data) {
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if (err?.message?.toLowerCase()?.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params?.errorMap,
        async: true
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[0-9a-z]+$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var nanoidRegex = /^[a-z0-9_-]{21}$/i;
var jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
var durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
var emojiRegex;
var ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
var ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
var ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
var base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
var dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
var dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
  let secondsRegexSource = `[0-5]\\d`;
  if (args.precision) {
    secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
  }
  const secondsQuantifier = args.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version) {
  if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT(jwt, alg) {
  if (!jwtRegex.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    if (!header)
      return false;
    const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base64));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if ("typ" in decoded && decoded?.typ !== "JWT")
      return false;
    if (!decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch {
    return false;
  }
}
function isValidCidr(ip, version) {
  if ((version === "v4" || !version) && ipv4CidrRegex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6CidrRegex.test(ip)) {
    return true;
  }
  return false;
}
var ZodString = class _ZodString extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "nanoid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "duration",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "jwt") {
        if (!isValidJWT(input.data, check.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "jwt",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cidr") {
        if (!isValidCidr(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cidr",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64url") {
        if (!base64urlRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check) {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil.errToObj(message)
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof options?.precision === "undefined" ? null : options?.precision,
      offset: options?.offset ?? false,
      local: options?.local ?? false,
      ...errorUtil.errToObj(options?.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof options?.precision === "undefined" ? null : options?.precision,
      ...errorUtil.errToObj(options?.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options?.position,
      ...errorUtil.errToObj(options?.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodString.create = (params) => {
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: params?.coerce ?? false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
var ZodNumber = class _ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new _ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max = null;
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
};
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: params?.coerce || false,
    ...processCreateParams(params)
  });
};
var ZodBigInt = class _ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch {
        return this._getInvalidInput(input);
      }
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.bigint,
      received: ctx.parsedType
    });
    return INVALID;
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new _ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodBigInt.create = (params) => {
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: params?.coerce ?? false,
    ...processCreateParams(params)
  });
};
var ZodBoolean = class extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: params?.coerce || false,
    ...processCreateParams(params)
  });
};
var ZodDate = class _ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (Number.isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new _ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
};
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: params?.coerce || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
var ZodSymbol = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};
var ZodUndefined = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
var ZodNull = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
var ZodAny = class extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
var ZodUnknown = class extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
var ZodNever = class extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
};
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
var ZodVoid = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
var ZodArray = class _ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new _ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new _ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new _ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
var ZodObject = class _ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    this._cached = { shape, keys };
    return this._cached;
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") {
      } else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue, ctx) => {
          const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: errorUtil.errToObj(message).message ?? defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new _ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new _ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new _ZodObject({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    for (const key of util.objectKeys(mask)) {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new _ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    for (const key of util.objectKeys(this.shape)) {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new _ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    for (const key of util.objectKeys(this.shape)) {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    }
    return new _ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    for (const key of util.objectKeys(this.shape)) {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    }
    return new _ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
};
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
var ZodUnion = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
var getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return util.objectValues(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [void 0];
  } else if (type instanceof ZodNull) {
    return [null];
  } else if (type instanceof ZodOptional) {
    return [void 0, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodNullable) {
    return [null, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodBranded) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodReadonly) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodCatch) {
    return getDiscriminator(type._def.innerType);
  } else {
    return [];
  }
};
var ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new _ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
};
function mergeValues(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
var ZodIntersection = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
var ZodTuple = class _ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new _ZodTuple({
      ...this._def,
      rest
    });
  }
};
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
var ZodRecord = class _ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first2, second, third) {
    if (second instanceof ZodType) {
      return new _ZodRecord({
        keyType: first2,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new _ZodRecord({
      keyType: ZodString.create(),
      valueType: first2,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
};
var ZodMap = class extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
var ZodSet = class _ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new _ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new _ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
var ZodFunction = class _ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args) {
        const error = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          error.addIssue(makeArgsIssue(args, e));
          throw error;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error.addIssue(makeReturnsIssue(result, e));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new _ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new _ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new _ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
};
var ZodLazy = class extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
var ZodLiteral = class extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
var ZodEnum = class _ZodEnum extends ZodType {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!this._cache) {
      this._cache = new Set(this._def.values);
    }
    if (!this._cache.has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return _ZodEnum.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
};
ZodEnum.create = createZodEnum;
var ZodNativeEnum = class extends ZodType {
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!this._cache) {
      this._cache = new Set(util.getValidEnumValues(this._def.values));
    }
    if (!this._cache.has(input.data)) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
var ZodPromise = class extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
var ZodEffects = class extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID;
        if (result.status === "dirty")
          return DIRTY(result.value);
        if (status.value === "dirty")
          return DIRTY(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return INVALID;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return INVALID;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
            status: status.value,
            value: result
          }));
        });
      }
    }
    util.assertNever(effect);
  }
};
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
var ZodOptional = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
var ZodNullable = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
var ZodDefault = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};
var ZodCatch = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};
var ZodNaN = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
var BRAND = /* @__PURE__ */ Symbol("zod_brand");
var ZodBranded = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
var ZodPipeline = class _ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new _ZodPipeline({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
};
var ZodReadonly = class extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data) => {
      if (isValid(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodReadonly.create = (type, params) => {
  return new ZodReadonly({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
function cleanParams(params, data) {
  const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
  const p2 = typeof p === "string" ? { message: p } : p;
  return p2;
}
function custom(check, _params = {}, fatal) {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      const r = check(data);
      if (r instanceof Promise) {
        return r.then((r2) => {
          if (!r2) {
            const params = cleanParams(_params, data);
            const _fatal = params.fatal ?? fatal ?? true;
            ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
          }
        });
      }
      if (!r) {
        const params = cleanParams(_params, data);
        const _fatal = params.fatal ?? fatal ?? true;
        ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
      }
      return;
    });
  return ZodAny.create();
}
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params);
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var ostring = () => stringType().optional();
var onumber = () => numberType().optional();
var oboolean = () => booleanType().optional();
var coerce = {
  string: ((arg) => ZodString.create({ ...arg, coerce: true })),
  number: ((arg) => ZodNumber.create({ ...arg, coerce: true })),
  boolean: ((arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  })),
  bigint: ((arg) => ZodBigInt.create({ ...arg, coerce: true })),
  date: ((arg) => ZodDate.create({ ...arg, coerce: true }))
};
var NEVER = INVALID;

// src/skills/types.ts
var SKILL_NAME_REGEX = /^[a-zA-Z0-9-]+$/;
var skillFrontmatterSchema = external_exports.object({
  /** Unique identifier for the skill. Lowercase letters, numbers, and hyphens only. Max 64 chars. */
  name: external_exports.string().regex(SKILL_NAME_REGEX, "Skill name must contain only letters, numbers, and hyphens").max(64, "Skill name must be at most 64 characters"),
  /** Description of what the skill does and when to use it. Max 1024 chars. */
  description: external_exports.string().max(1024, "Skill description must be at most 1024 characters"),
  /** Optional comma-separated list of tools that are auto-allowed when skill is active. */
  "allowed-tools": external_exports.string().optional(),
  /** Whether this skill can be invoked by the user as a slash command. Defaults to true. */
  "user-invocable": external_exports.boolean().optional().default(true)
});
var commandFrontmatterSchema = external_exports.object({
  /** Optional name override. If not provided, derived from filename. */
  name: external_exports.string().regex(SKILL_NAME_REGEX, "Command name must contain only letters, numbers, and hyphens").max(64, "Command name must be at most 64 characters").optional(),
  /** Description of what the command does. Max 1024 chars. */
  description: external_exports.string().max(1024, "Command description must be at most 1024 characters"),
  /** Optional comma-separated list of tools that are auto-allowed when command is active. */
  "allowed-tools": external_exports.string().optional()
});

// src/skills/validator.ts
function validateSkillFrontmatter(frontmatter) {
  const result = skillFrontmatterSchema.safeParse(frontmatter);
  if (result.success) {
    return { success: true, data: result.data };
  }
  const errors = result.error.errors.map((e) => {
    const path11 = e.path.join(".");
    return path11 ? `${path11}: ${e.message}` : e.message;
  });
  return { success: false, errors };
}
function validateCommandFrontmatter(frontmatter) {
  const result = commandFrontmatterSchema.safeParse(frontmatter);
  if (result.success) {
    return { success: true, data: result.data };
  }
  const errors = result.error.errors.map((e) => {
    const path11 = e.path.join(".");
    return path11 ? `${path11}: ${e.message}` : e.message;
  });
  return { success: false, errors };
}

// src/skills/loader.ts
var COPILOT_SKILLS_DIRS_ENV = "COPILOT_SKILLS_DIRS";
var skillsCache;
function collectProjectDirs(convention, subdir, repoRoot, cwd) {
  if (cwd) {
    const boundary = repoRoot ?? os4.homedir();
    const dirs = collectParentComponentDirs(cwd, subdir, convention, boundary);
    return dirs.map((dir, index) => ({
      path: dir,
      source: index === 0 ? "project" : "inherited"
    }));
  }
  if (repoRoot) {
    return [{ path: path9.join(repoRoot, convention, subdir), source: "project" }];
  }
  return [];
}
function getSkillDirectories(repoRoot, customDirs = [], settings, additionalSources = [], cwd) {
  const projectDirs = [
    ...collectProjectDirs(".github", "skills", repoRoot, cwd),
    ...collectProjectDirs(".agents", "skills", repoRoot, cwd),
    ...collectProjectDirs(".claude", "skills", repoRoot, cwd)
  ];
  const personalDirs = [
    { path: path9.join(getCopilotHome(settings, "config"), "skills"), source: "personal-copilot" },
    { path: path9.join(os4.homedir(), ".claude", "skills"), source: "personal-claude" }
  ];
  const envDirs = process.env[COPILOT_SKILLS_DIRS_ENV]?.split(",").filter(Boolean) ?? [];
  const customSources = [...envDirs, ...customDirs].map((dir) => dir.trim()).filter(Boolean).map((dir) => ({ path: dir, source: "custom" }));
  const directories = [...projectDirs, ...personalDirs, ...additionalSources, ...customSources];
  return directories.filter((d) => (0, import_fs2.existsSync)(d.path));
}
function getCommandDirectories(repoRoot, cwd) {
  const projectDirs = collectProjectDirs(".claude", "commands", repoRoot, cwd);
  const personalDirs = [
    { path: path9.join(os4.homedir(), ".claude", "commands"), source: "personal-claude" }
  ];
  const directories = [...projectDirs, ...personalDirs];
  return directories.filter((d) => (0, import_fs2.existsSync)(d.path));
}
function parseMarkdownFrontmatter(content) {
  const normalizedContent = content.replace(/\r\n/g, "\n");
  const frontmatterRegex = /^---\s*\n([\s\S]*?)\n---\s*\n([\s\S]*)$/;
  const match = normalizedContent.match(frontmatterRegex);
  if (!match) {
    return { kind: "error", message: "missing or malformed YAML frontmatter" };
  }
  try {
    const frontmatter = import_yaml.default.parse(match[1]);
    const body = match[2];
    return { kind: "success", value: { frontmatter, body } };
  } catch (e) {
    const errorMsg = e instanceof Error ? e.message : "unknown error";
    return { kind: "error", message: `failed to parse YAML frontmatter: ${errorMsg}` };
  }
}
function getCanonicalPath(filePath) {
  try {
    return (0, import_fs2.realpathSync)(filePath);
  } catch {
    return void 0;
  }
}
function getUnsupportedFields(frontmatter, supportedFields) {
  if (!frontmatter || typeof frontmatter !== "object") {
    return [];
  }
  const frontmatterKeys = Object.keys(frontmatter);
  return frontmatterKeys.filter((field) => !supportedFields.includes(field));
}
async function parseSkillFile(filePath, source, pluginName) {
  let content;
  try {
    content = await fs8.readFile(filePath, "utf-8");
  } catch (e) {
    const errorMsg = e instanceof Error ? e.message : "unknown error";
    return { kind: "error", message: `failed to read file: ${errorMsg}` };
  }
  const parsed = parseMarkdownFrontmatter(content);
  if (parsed.kind === "error") {
    return parsed;
  }
  const warnings = [];
  const supportedFields = Object.keys(skillFrontmatterSchema.shape);
  const unsupportedFields = getUnsupportedFields(parsed.value.frontmatter, supportedFields);
  if (unsupportedFields.length > 0) {
    warnings.push(
      `unknown field${unsupportedFields.length > 1 ? "s" : ""} ignored: ${unsupportedFields.join(", ")}`
    );
  }
  const validation = validateSkillFrontmatter(parsed.value.frontmatter);
  if (!validation.success || !validation.data) {
    const errorDetails = validation.errors?.join("; ") ?? "validation failed";
    return { kind: "error", message: errorDetails };
  }
  const frontmatter = validation.data;
  const allowedTools = frontmatter["allowed-tools"]?.split(",").map((t) => t.trim()).filter(Boolean);
  const userInvocable = frontmatter["user-invocable"] !== false;
  return {
    kind: "success",
    value: {
      name: frontmatter.name,
      description: frontmatter.description,
      source,
      filePath,
      baseDir: path9.dirname(filePath),
      allowedTools,
      content,
      userInvocable,
      pluginName
    },
    warnings: warnings.length > 0 ? warnings : void 0
  };
}
function deriveCommandName(filename) {
  const name = filename.replace(/\.md$/i, "");
  if (!name || !SKILL_NAME_REGEX.test(name) || name.length > 64) {
    return null;
  }
  return name;
}
async function parseCommandFile(filePath, source, derivedName) {
  let content;
  try {
    content = await fs8.readFile(filePath, "utf-8");
  } catch (e) {
    const errorMsg = e instanceof Error ? e.message : "unknown error";
    return { kind: "error", message: `failed to read file: ${errorMsg}` };
  }
  const parsed = parseMarkdownFrontmatter(content);
  if (parsed.kind === "error") {
    return parsed;
  }
  const warnings = [];
  const supportedFields = Object.keys(commandFrontmatterSchema.shape);
  const unsupportedFields = getUnsupportedFields(parsed.value.frontmatter, supportedFields);
  if (unsupportedFields.length > 0) {
    warnings.push(
      `unknown field${unsupportedFields.length > 1 ? "s" : ""} ignored: ${unsupportedFields.join(", ")}`
    );
  }
  const validation = validateCommandFrontmatter(parsed.value.frontmatter);
  if (!validation.success || !validation.data) {
    const errorDetails = validation.errors?.join("; ") ?? "validation failed";
    return { kind: "error", message: errorDetails };
  }
  const frontmatter = validation.data;
  const name = frontmatter.name ?? derivedName;
  const allowedTools = frontmatter["allowed-tools"]?.split(",").map((t) => t.trim()).filter(Boolean);
  return {
    kind: "success",
    value: {
      name,
      description: frontmatter.description,
      source,
      filePath,
      baseDir: path9.dirname(filePath),
      allowedTools,
      content,
      userInvocable: true,
      isCommand: true
    },
    warnings: warnings.length > 0 ? warnings : void 0
  };
}
async function loadSkills(projectRoot, customDirs = [], useCache = true, settings, additionalSources = [], cwd) {
  const cacheKey = JSON.stringify({
    projectRoot: projectRoot || "__no_project__",
    customDirs: [...customDirs].sort(),
    configDir: settings?.configDir,
    envSkillDirs: process.env[COPILOT_SKILLS_DIRS_ENV],
    cwd: cwd || "__no_cwd__"
  });
  if (useCache && skillsCache?.has(cacheKey)) {
    return skillsCache.get(cacheKey);
  }
  const directories = getSkillDirectories(projectRoot, customDirs, settings, additionalSources, cwd);
  const skills = [];
  const warnings = [];
  const errors = [];
  const seenPaths = /* @__PURE__ */ new Set();
  const seenNames = /* @__PURE__ */ new Set();
  for (const dir of directories) {
    try {
      const directSkillMdPath = path9.join(dir.path, "SKILL.md");
      if ((0, import_fs2.existsSync)(directSkillMdPath)) {
        const canonicalPath = getCanonicalPath(directSkillMdPath);
        if (!canonicalPath || !seenPaths.has(canonicalPath)) {
          const displayPath = getDisplayPath(directSkillMdPath);
          const result = await parseSkillFile(directSkillMdPath, dir.source, dir.pluginName);
          if (result.kind === "error") {
            errors.push(`${displayPath}: ${result.message}`);
          } else if (!seenNames.has(result.value.name)) {
            if (result.warnings) {
              warnings.push(...result.warnings.map((w) => `${displayPath}: ${w}`));
            }
            if (canonicalPath) {
              seenPaths.add(canonicalPath);
            }
            seenNames.add(result.value.name);
            skills.push(result.value);
          }
        }
        continue;
      }
      const entries = await fs8.readdir(dir.path, { withFileTypes: true });
      for (const entry of entries) {
        if (!entry.isDirectory() && !entry.isSymbolicLink()) {
          continue;
        }
        const skillMdPath = path9.join(dir.path, entry.name, "SKILL.md");
        if (!(0, import_fs2.existsSync)(skillMdPath)) {
          continue;
        }
        const canonicalPath = getCanonicalPath(skillMdPath);
        if (canonicalPath && seenPaths.has(canonicalPath)) {
          continue;
        }
        const displayPath = getDisplayPath(skillMdPath);
        const result = await parseSkillFile(skillMdPath, dir.source, dir.pluginName);
        if (result.kind === "error") {
          errors.push(`${displayPath}: ${result.message}`);
          continue;
        }
        if (seenNames.has(result.value.name)) {
          continue;
        }
        if (result.warnings) {
          warnings.push(...result.warnings.map((w) => `${displayPath}: ${w}`));
        }
        if (canonicalPath) {
          seenPaths.add(canonicalPath);
        }
        seenNames.add(result.value.name);
        skills.push(result.value);
      }
    } catch {
      continue;
    }
  }
  const commandDirs = getCommandDirectories(projectRoot, cwd);
  for (const dir of commandDirs) {
    try {
      const entries = await fs8.readdir(dir.path, { withFileTypes: true });
      for (const entry of entries) {
        if (!entry.isFile() && !entry.isSymbolicLink() || !entry.name.toLowerCase().endsWith(".md")) {
          continue;
        }
        const derivedName = deriveCommandName(entry.name);
        if (!derivedName) {
          continue;
        }
        const commandPath = path9.join(dir.path, entry.name);
        const canonicalPath = getCanonicalPath(commandPath);
        if (canonicalPath && seenPaths.has(canonicalPath)) {
          continue;
        }
        const displayPath = getDisplayPath(commandPath);
        const result = await parseCommandFile(commandPath, dir.source, derivedName);
        if (result.kind === "error") {
          errors.push(`${displayPath}: ${result.message}`);
          continue;
        }
        if (seenNames.has(result.value.name)) {
          continue;
        }
        if (result.warnings) {
          warnings.push(...result.warnings.map((w) => `${displayPath}: ${w}`));
        }
        if (canonicalPath) {
          seenPaths.add(canonicalPath);
        }
        seenNames.add(result.value.name);
        skills.push(result.value);
      }
    } catch {
      continue;
    }
  }
  const loadResult = { skills, warnings, errors };
  skillsCache = skillsCache || /* @__PURE__ */ new Map();
  skillsCache.set(cacheKey, loadResult);
  return loadResult;
}

// src/skills/plugins.ts
var import_fs3 = require("fs");
var fs9 = __toESM(require("fs/promises"), 1);
var path10 = __toESM(require("path"), 1);
var INSTALLED_PLUGINS_DIR = "installed-plugins";
async function readInstalledPlugins(settings) {
  const configDir = getCopilotHome(settings, "config");
  const configPath = path10.join(configDir, "config.json");
  try {
    const raw = await fs9.readFile(configPath, "utf-8");
    const config = JSON.parse(raw);
    if (Array.isArray(config.installed_plugins)) {
      return config.installed_plugins;
    }
  } catch {
  }
  return [];
}
async function getPluginSkillSources(settings) {
  const plugins = await readInstalledPlugins(settings);
  const stateDir = getCopilotHome(settings, "state");
  const pluginsDir = path10.join(stateDir, INSTALLED_PLUGINS_DIR);
  const skillSources = [];
  for (const plugin of plugins) {
    if (!plugin.enabled) {
      continue;
    }
    const pluginDir = plugin.cache_path || path10.join(pluginsDir, `${plugin.name}@${plugin.marketplace}`);
    const skillsDir = path10.join(pluginDir, "skills");
    if ((0, import_fs3.existsSync)(skillsDir)) {
      skillSources.push({
        path: skillsDir,
        source: "plugin",
        pluginName: plugin.name
      });
    }
  }
  return skillSources;
}

// src/jsonrpc-proxy.ts
var import_node_child_process3 = require("child_process");
var import_promises2 = require("fs/promises");
var import_node_os2 = require("os");
var import_node_path5 = require("path");
function getGhCliToken() {
  try {
    const token = (0, import_node_child_process3.execSync)("gh auth token", {
      encoding: "utf-8",
      stdio: ["pipe", "pipe", "pipe"]
      // Suppress stderr
    }).trim();
    return token || void 0;
  } catch {
    return void 0;
  }
}
async function discoverSessionCwd(sessionId) {
  const sessionDir = (0, import_node_path5.join)((0, import_node_os2.homedir)(), ".copilot", "session-state", sessionId);
  try {
    const yaml = await (0, import_promises2.readFile)((0, import_node_path5.join)(sessionDir, "workspace.yaml"), "utf-8");
    const match = yaml.match(/^cwd:\s*(.+)$/m);
    if (match) {
      return match[1].trim();
    }
  } catch {
  }
  try {
    const content = await (0, import_promises2.readFile)((0, import_node_path5.join)(sessionDir, "events.jsonl"), "utf-8");
    const firstLine = content.slice(0, content.indexOf("\n"));
    if (firstLine.startsWith('{"type":"session.start"')) {
      const cwdMatch = firstLine.match(/"cwd":"([^"]+)"/);
      if (cwdMatch) {
        return cwdMatch[1];
      }
    }
  } catch {
  }
  return void 0;
}
function resolveCopilotToken(explicitToken) {
  if (explicitToken) {
    return explicitToken;
  }
  if (process.env.COPILOT_GITHUB_TOKEN) {
    return process.env.COPILOT_GITHUB_TOKEN;
  }
  const ghToken = getGhCliToken();
  if (ghToken) {
    return ghToken;
  }
  return void 0;
}
var BUILT_IN_COMMANDS = [
  {
    name: "/session",
    help: "Show current session information",
    category: "info",
    requiresRemote: true,
    opensDialog: "session"
  }
];
var DEFAULT_CLI_GRACE_PERIOD_MS = 5 * 60 * 1e3;
var CliPoolManager = class {
  pool = /* @__PURE__ */ new Map();
  cliPath;
  cliLogLevel;
  gracePeriodMs;
  log;
  cliEnv = {};
  constructor(options = {}) {
    this.cliPath = options.cliPath ?? "copilot";
    this.cliLogLevel = options.cliLogLevel ?? "info";
    this.gracePeriodMs = options.gracePeriodMs ?? DEFAULT_CLI_GRACE_PERIOD_MS;
    this.log = options.log ?? (() => {
    });
    const resolvedToken = resolveCopilotToken(options.copilotToken);
    this.cliEnv = resolvedToken ? { ...process.env, COPILOT_GITHUB_TOKEN: resolvedToken } : { ...process.env };
  }
  /**
   * Get or create a CLI process for the given cwd, incrementing its reference count.
   * If a grace period timer is pending, it will be cancelled.
   */
  async retain(cwd) {
    let entry = this.pool.get(cwd);
    if (entry) {
      if (entry.graceTimer) {
        clearTimeout(entry.graceTimer);
        entry.graceTimer = null;
        this.log("debug", `[CliPool] Cancelled grace timer for ${cwd}`);
      }
      if (entry.cli.isAlive) {
        try {
          await entry.cli.ping();
          entry.refCount++;
          this.log("info", `[CliPool] Reusing CLI for ${cwd} (refCount: ${entry.refCount})`);
          return entry.cli;
        } catch {
          this.log("debug", `[CliPool] CLI for ${cwd} is dead, recreating`);
          this.pool.delete(cwd);
          entry = void 0;
        }
      } else {
        this.pool.delete(cwd);
        entry = void 0;
      }
    }
    const cli = new CliProcess({
      cwd,
      cliPath: this.cliPath,
      logLevel: this.cliLogLevel,
      env: this.cliEnv,
      log: (level, message) => this.log(level, message)
    });
    await cli.spawn();
    try {
      await cli.ping();
    } catch (err) {
      await cli.kill();
      throw new Error(`CLI process failed to start: ${err}`);
    }
    this.pool.set(cwd, {
      cli,
      refCount: 1,
      graceTimer: null
    });
    this.log("info", `[CliPool] CLI process created for ${cwd} (refCount: 1)`);
    return cli;
  }
  /**
   * Release a CLI process for the given cwd, decrementing its reference count.
   * When refCount reaches 0, starts a grace period timer before killing the CLI.
   */
  release(cwd) {
    const entry = this.pool.get(cwd);
    if (!entry) {
      this.log("warn", `[CliPool] Attempted to release non-existent CLI for ${cwd}`);
      return;
    }
    entry.refCount = Math.max(0, entry.refCount - 1);
    this.log("info", `[CliPool] Released CLI for ${cwd} (refCount: ${entry.refCount})`);
    if (entry.refCount === 0) {
      this.log("info", `[CliPool] Starting ${this.gracePeriodMs}ms grace period for ${cwd}`);
      entry.graceTimer = setTimeout(() => {
        this.killCli(cwd);
      }, this.gracePeriodMs);
    }
  }
  /**
   * Kill a CLI process immediately (used after grace period or on dispose).
   */
  async killCli(cwd) {
    const entry = this.pool.get(cwd);
    if (!entry) return;
    if (entry.refCount > 0) {
      this.log("debug", `[CliPool] Skipping kill for ${cwd} (refCount: ${entry.refCount})`);
      return;
    }
    this.log("info", `[CliPool] Killing CLI process for ${cwd}`);
    this.pool.delete(cwd);
    if (entry.graceTimer) {
      clearTimeout(entry.graceTimer);
    }
    try {
      await entry.cli.kill();
    } catch (err) {
      this.log("debug", `[CliPool] Error killing CLI for ${cwd}: ${err}`);
    }
  }
  /**
   * Get a CLI for the cwd without incrementing refCount (for read-only operations).
   * Returns undefined if no CLI exists for this cwd.
   */
  get(cwd) {
    const entry = this.pool.get(cwd);
    return entry?.cli;
  }
  /**
   * Set up CLI request handler for tool calls and permission requests.
   * This should be called after retain() to wire up the handlers.
   */
  setupCliHandlers(cwd, onRequest, onNotification) {
    const entry = this.pool.get(cwd);
    if (!entry) return;
    entry.cli.on("request", onRequest);
    entry.cli.on("notification", onNotification);
  }
  /**
   * Dispose of all CLI processes immediately.
   */
  async dispose() {
    this.log("info", `[CliPool] Disposing all CLI processes (${this.pool.size} total)`);
    const entries = Array.from(this.pool.entries());
    this.pool.clear();
    for (const [cwd, entry] of entries) {
      if (entry.graceTimer) {
        clearTimeout(entry.graceTimer);
      }
      try {
        await entry.cli.kill();
      } catch (err) {
        this.log("debug", `[CliPool] Error killing CLI for ${cwd}: ${err}`);
      }
    }
  }
  /**
   * Get current pool statistics (for debugging/monitoring).
   */
  getStats() {
    return Array.from(this.pool.entries()).map(([cwd, entry]) => ({
      cwd,
      refCount: entry.refCount,
      hasGraceTimer: entry.graceTimer !== null
    }));
  }
};
var ClientConnection = class {
  constructor(clientStream, clientId, cliPoolManager, fsService, gitService, options = {}) {
    this.clientStream = clientStream;
    this.clientId = clientId;
    this.cliPoolManager = cliPoolManager;
    this.fsService = fsService;
    this.gitService = gitService;
    this.defaultCwd = options.cwd ?? process.cwd();
    this.logLevel = options.logLevel ?? "info";
    this.onLogCallback = options.onLog ?? (() => {
    });
  }
  // Track active sessions by ID (we no longer hold CopilotSession objects)
  sessionIds = /* @__PURE__ */ new Set();
  sessionCwds = /* @__PURE__ */ new Map();
  // Map sessionId -> CliProcess that owns it
  sessionClis = /* @__PURE__ */ new Map();
  // Track tools registered for each session (for external tool handling)
  sessionTools = /* @__PURE__ */ new Map();
  receiveBuffer = Buffer.alloc(0);
  defaultCwd;
  logLevel;
  onLogCallback;
  // Shared CLI pool manager (owned by JsonRpcProxyHost)
  cliPoolManager;
  // Track which cwds this connection has retained (for cleanup)
  retainedCwds = /* @__PURE__ */ new Set();
  // File search service for @-mention file picking
  fileSearchService = new FileSearchService();
  // Filesystem provider service (shared across connections)
  fsService;
  // Git provider service (shared across connections)
  gitService;
  // Pending callback requests from SDK -> client
  pendingToolCallRequests = /* @__PURE__ */ new Map();
  pendingPermissionRequests = /* @__PURE__ */ new Map();
  nextCallbackId = 1;
  // Subscription tracking
  nextSubscriptionId = 1;
  fsSubscriptions = /* @__PURE__ */ new Map();
  gitSubscriptions = /* @__PURE__ */ new Map();
  // Track which cwds have fs subscriptions (for provider retain/release)
  fsSubscriptionCwds = /* @__PURE__ */ new Map();
  // cwd -> subscription count
  // Guard against double cleanup
  isCleanedUp = false;
  // Cached skill discovery result (loaded lazily on first listSlashCommands call)
  skillCache = null;
  log(level, message) {
    if (level === "debug" && this.logLevel !== "debug") {
      return;
    }
    this.onLogCallback(level, message);
  }
  async start() {
    this.log("debug", `[${this.clientId}] Initializing CLI client...`);
    await this.getOrCreateCli(this.defaultCwd);
    this.log("debug", `[${this.clientId}] Default CLI ready (cwd: ${this.defaultCwd})`);
    this.clientStream.on("data", (data) => {
      this.handleClientData(data);
    });
    this.clientStream.on("close", () => {
      this.log("info", `Client disconnected: ${this.clientId}`);
      this.cleanup();
    });
    this.clientStream.on("error", (error) => {
      this.log("error", `[${this.clientId}] Client stream error: ${error.message}`);
      this.cleanup();
    });
  }
  /**
   * Get or create a CliProcess for the given working directory.
   * Uses the shared CLI pool manager with reference counting.
   */
  async getOrCreateCli(cwd) {
    if (this.retainedCwds.has(cwd)) {
      const existingCli = this.cliPoolManager.get(cwd);
      if (existingCli?.isAlive) {
        return existingCli;
      }
      this.retainedCwds.delete(cwd);
    }
    const cli = await this.cliPoolManager.retain(cwd);
    this.retainedCwds.add(cwd);
    cli.on("notification", (notification) => {
      this.handleCliNotification(notification);
    });
    cli.on("request", (request) => {
      this.handleCliRequest(cli, request);
    });
    cli.on("exit", (code) => {
      if (!this.isCleanedUp) {
        this.log("warn", `[${this.clientId}] CLI process exited with code ${code} (cwd: ${cwd})`);
      }
      this.retainedCwds.delete(cwd);
    });
    return cli;
  }
  /** Get the default CLI (for cwd-agnostic operations like session.list). */
  async getDefaultCli() {
    return this.getOrCreateCli(this.defaultCwd);
  }
  /**
   * Handle notifications from CLI (session.event).
   */
  handleCliNotification(notification) {
    if (notification.method === "session.event") {
      const params = notification.params;
      this.forwardSessionEvent(params.sessionId, params.event);
    }
  }
  /**
   * Handle incoming requests from CLI (tool.call, permission.request).
   */
  async handleCliRequest(cli, request) {
    if (request.method === "tool.call") {
      const params = request.params;
      try {
        const result = await this.handleToolCall(
          params.sessionId,
          params.toolCallId,
          params.toolName,
          params.arguments
        );
        const textResult = typeof result === "string" ? result : result.content;
        const isError = typeof result === "object" && result.isError;
        const cliResult = {
          result: {
            textResultForLlm: textResult,
            resultType: isError ? "failure" : "success",
            error: isError ? textResult : null
          }
        };
        await cli.sendResponse(request.id, cliResult);
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        await cli.sendResponse(request.id, {
          result: {
            textResultForLlm: errorMessage,
            resultType: "failure",
            error: errorMessage
          }
        });
      }
    } else if (request.method === "permission.request") {
      const params = request.params;
      try {
        const result = await this.handlePermissionRequest(
          params.permissionRequest,
          params.sessionId
        );
        await cli.sendResponse(request.id, { kind: result.kind, rules: result.rules });
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        await cli.sendResponse(request.id, void 0, {
          code: -32603,
          message: errorMessage
        });
      }
    }
  }
  /**
   * Stop this connection.
   * @param disposing If true, skip CLI release (pool is being disposed anyway)
   */
  stop(disposing = false) {
    this.cleanup(disposing);
  }
  cleanup(disposing = false) {
    if (this.isCleanedUp) {
      this.log("debug", `[${this.clientId}] Cleanup already done, skipping`);
      return;
    }
    this.isCleanedUp = true;
    if (this.sessionIds.size > 0) {
      this.log("debug", `[${this.clientId}] Clearing ${this.sessionIds.size} session(s)`);
    }
    this.sessionIds.clear();
    this.sessionCwds.clear();
    this.sessionClis.clear();
    this.sessionTools.clear();
    if (this.fsSubscriptions.size > 0) {
      this.log("debug", `[${this.clientId}] Cleaning up ${this.fsSubscriptions.size} fs subscription(s)`);
      for (const subscription of this.fsSubscriptions.values()) {
        try {
          subscription.cleanup();
        } catch {
        }
      }
      this.fsSubscriptions.clear();
      this.fsSubscriptionCwds.clear();
    }
    if (this.gitSubscriptions.size > 0) {
      this.log("debug", `[${this.clientId}] Cleaning up ${this.gitSubscriptions.size} git subscription(s)`);
      for (const subscription of this.gitSubscriptions.values()) {
        try {
          subscription.cleanup();
        } catch {
        }
      }
      this.gitSubscriptions.clear();
    }
    if (!disposing) {
      this.releaseClis();
    } else {
      this.retainedCwds.clear();
    }
    if (!this.clientStream.destroyed) {
      try {
        this.clientStream.destroy();
      } catch {
      }
    }
  }
  /**
   * Release all CLI processes this connection retained.
   * The shared pool manager handles the grace period before actually killing them.
   */
  releaseClis() {
    for (const cwd of this.retainedCwds) {
      this.log("debug", `[${this.clientId}] Releasing CLI for ${cwd}`);
      this.cliPoolManager.release(cwd);
    }
    this.retainedCwds.clear();
  }
  handleClientData(data) {
    this.receiveBuffer = Buffer.concat([this.receiveBuffer, data]);
    while (true) {
      const headerDelimiter = Buffer.from(HEADER_DELIMITER);
      const headerEndIndex = this.findSequence(this.receiveBuffer, headerDelimiter);
      if (headerEndIndex === -1) break;
      const headerSection = this.receiveBuffer.subarray(0, headerEndIndex).toString();
      const contentLengthMatch = headerSection.match(/Content-Length:\s*(\d+)/i);
      if (!contentLengthMatch) {
        this.receiveBuffer = this.receiveBuffer.subarray(headerEndIndex + headerDelimiter.length);
        continue;
      }
      const contentLength = parseInt(contentLengthMatch[1], 10);
      const bodyStart = headerEndIndex + headerDelimiter.length;
      if (this.receiveBuffer.length < bodyStart + contentLength) break;
      const body = this.receiveBuffer.subarray(bodyStart, bodyStart + contentLength).toString();
      this.receiveBuffer = this.receiveBuffer.subarray(bodyStart + contentLength);
      try {
        const message = JSON.parse(body);
        this.handleClientMessage(message);
      } catch (err) {
        this.log("error", `[${this.clientId}] Failed to parse client message: ${err}`);
      }
    }
  }
  findSequence(buffer, sequence) {
    for (let i = 0; i <= buffer.length - sequence.length; i++) {
      let found = true;
      for (let j = 0; j < sequence.length; j++) {
        if (buffer[i + j] !== sequence[j]) {
          found = false;
          break;
        }
      }
      if (found) return i;
    }
    return -1;
  }
  async handleClientMessage(message) {
    if ("id" in message && ("result" in message || "error" in message) && !("method" in message)) {
      const response = message;
      this.handleCallbackResponse(response);
      return;
    }
    if ("method" in message && "id" in message) {
      const request = message;
      try {
        switch (request.method) {
          // Client methods
          case "ping":
            await this.handlePing(request);
            break;
          case "getState":
            await this.handleGetState(request);
            break;
          // Session creation/management (support both old SDK names and new CLI names)
          case "session.create":
          case "createSession":
            await this.handleSessionCreate(request);
            break;
          case "session.resume":
          case "resumeSession":
            await this.handleSessionResume(request);
            break;
          case "session.list":
          case "listSessions":
            await this.handleSessionList(request);
            break;
          case "getLastSessionId":
            await this.handleGetLastSessionId(request);
            break;
          case "session.delete":
          case "deleteSession":
            await this.handleSessionDelete(request);
            break;
          // Slash commands
          case "listSlashCommands":
            await this.handleListSlashCommands(request);
            break;
          case "executeSlashCommand":
            await this.handleExecuteSlashCommand(request);
            break;
          // File search
          case "searchFiles":
            await this.handleSearchFiles(request);
            break;
          // Model selection (support both names)
          case "models.list":
          case "getModels":
            await this.handleModelsList(request);
            break;
          // Session methods
          case "session.send":
            await this.handleSessionSend(request);
            break;
          case "session.sendAndWait":
            await this.handleSessionSendAndWait(request);
            break;
          case "session.getMessages":
            await this.handleSessionGetMessages(request);
            break;
          case "session.abort":
            await this.handleSessionAbort(request);
            break;
          case "session.destroy":
            await this.handleSessionDestroy(request);
            break;
          // Filesystem methods
          case "fs.readDirectory":
            await this.handleFsReadDirectory(request);
            break;
          case "fs.readFile":
            await this.handleFsReadFile(request);
            break;
          case "fs.readTextFile":
            await this.handleFsReadTextFile(request);
            break;
          case "fs.stat":
            await this.handleFsStat(request);
            break;
          case "fs.exists":
            await this.handleFsExists(request);
            break;
          // Filesystem write methods
          case "fs.writeFile":
            await this.handleFsWriteFile(request);
            break;
          case "fs.writeTextFile":
            await this.handleFsWriteTextFile(request);
            break;
          case "fs.delete":
            await this.handleFsDelete(request);
            break;
          case "fs.rename":
            await this.handleFsRename(request);
            break;
          case "fs.createDirectory":
            await this.handleFsCreateDirectory(request);
            break;
          // Git methods
          case "git.status":
            await this.handleGitStatus(request);
            break;
          case "git.fileStatus":
            await this.handleGitFileStatus(request);
            break;
          case "git.branch":
            await this.handleGitBranch(request);
            break;
          case "git.branches":
            await this.handleGitBranches(request);
            break;
          case "git.fileDiff":
            await this.handleGitFileDiff(request);
            break;
          case "git.fileAtRef":
            await this.handleGitFileAtRef(request);
            break;
          case "git.hasUncommittedChanges":
            await this.handleGitHasUncommittedChanges(request);
            break;
          case "git.hasUnpushedCommits":
            await this.handleGitHasUnpushedCommits(request);
            break;
          case "git.uncommittedDiffStats":
            await this.handleGitUncommittedDiffStats(request);
            break;
          case "git.perFileDiffStats":
            await this.handleGitPerFileDiffStats(request);
            break;
          case "git.findRoot":
            await this.handleGitFindRoot(request);
            break;
          case "git.isAvailable":
            await this.handleGitIsAvailable(request);
            break;
          // Filesystem subscription methods
          case "fs.subscribe":
            await this.handleFsSubscribe(request);
            break;
          case "fs.unsubscribe":
            await this.handleFsUnsubscribe(request);
            break;
          // Git subscription methods
          case "git.subscribe":
            await this.handleGitSubscribe(request);
            break;
          case "git.unsubscribe":
            await this.handleGitUnsubscribe(request);
            break;
          // Git write methods
          case "git.stage":
            await this.handleGitStage(request);
            break;
          case "git.unstage":
            await this.handleGitUnstage(request);
            break;
          case "git.revert":
            await this.handleGitRevert(request);
            break;
          case "git.commit":
            await this.handleGitCommit(request);
            break;
          case "git.checkout":
            await this.handleGitCheckout(request);
            break;
          case "git.createBranch":
            await this.handleGitCreateBranch(request);
            break;
          case "git.push":
            await this.handleGitPush(request);
            break;
          case "git.pull":
            await this.handleGitPull(request);
            break;
          case "git.stash":
            await this.handleGitStash(request);
            break;
          case "git.stashPop":
            await this.handleGitStashPop(request);
            break;
          default:
            this.sendErrorResponse(request.id, -32601, `Method not found: ${request.method}`);
        }
      } catch (err) {
        this.log("error", `[${this.clientId}] Error handling ${request.method}: ${err}`);
        this.sendErrorResponse(request.id, -32603, `Internal error: ${err}`);
      }
    }
  }
  handleCallbackResponse(response) {
    const id = String(response.id);
    const toolCallPending = this.pendingToolCallRequests.get(id);
    if (toolCallPending) {
      this.pendingToolCallRequests.delete(id);
      if (response.error) {
        toolCallPending.reject(new Error(response.error.message));
      } else {
        const result = response.result;
        toolCallPending.resolve(result ?? "");
      }
      return;
    }
    const permissionPending = this.pendingPermissionRequests.get(id);
    if (permissionPending) {
      this.pendingPermissionRequests.delete(id);
      if (response.error) {
        permissionPending.reject(new Error(response.error.message));
      } else {
        const result = response.result;
        permissionPending.resolve(result ?? { kind: "denied-interactively-by-user" });
      }
      return;
    }
    this.log("debug", `[${this.clientId}] Received unexpected response: ${response.id}`);
  }
  // ==========================================================================
  // Client Methods
  // ==========================================================================
  async handlePing(request) {
    const cli = await this.getDefaultCli();
    await cli.sendRequest("ping", {});
    this.sendToClient({
      jsonrpc: "2.0",
      id: request.id,
      result: {
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        version: CURRENT_VERSION
      }
    });
  }
  async handleGetState(request) {
    const cli = await this.getDefaultCli();
    try {
      const isAlive = await cli.ping();
      this.sendToClient({
        jsonrpc: "2.0",
        id: request.id,
        result: isAlive ? "connected" : "disconnected"
      });
    } catch {
      this.sendToClient({
        jsonrpc: "2.0",
        id: request.id,
        result: "disconnected"
      });
    }
  }
  async handleSessionCreate(request) {
    const params = request.params;
    const cwd = params?.cwd ?? this.defaultCwd;
    this.log("debug", `[${this.clientId}] RPC -> session.create (model: ${params?.model}, cwd: ${cwd})`);
    const cli = await this.getOrCreateCli(cwd);
    const { directories: skillDirectories } = await this.ensureSkillsLoaded();
    const cliParams = {
      sessionId: params?.sessionId,
      model: params?.model,
      streaming: params?.streaming ?? true,
      systemMessage: params?.systemMessage,
      // Pass tool definitions to CLI (no handlers - CLI will send tool.call requests)
      tools: params?.tools,
      availableTools: params?.availableTools,
      excludedTools: params?.excludedTools,
      // Pass skill directories so the CLI creates the skill tool for the session
      skillDirectories: skillDirectories.length > 0 ? skillDirectories : void 0
    };
    const result = await cli.sendRequest("session.create", cliParams);
    const sessionId = result.sessionId;
    this.sessionIds.add(sessionId);
    this.sessionCwds.set(sessionId, cwd);
    this.sessionClis.set(sessionId, cli);
    if (params?.tools) {
      this.sessionTools.set(sessionId, params.tools);
    }
    this.log("info", `Session started: ${sessionId}`);
    this.sendToClient({
      jsonrpc: "2.0",
      id: request.id,
      result: {
        sessionId,
        model: params?.model
        // Echo back the requested model
      }
    });
  }
  async handleSessionResume(request) {
    const params = request.params;
    const sessionId = params?.sessionId;
    if (!sessionId) {
      this.sendErrorResponse(request.id, -32602, "Missing sessionId parameter");
      return;
    }
    this.log("debug", `[${this.clientId}] RPC -> session.resume: ${sessionId}`);
    if (this.sessionIds.has(sessionId)) {
      this.log("debug", `[${this.clientId}] Session ${sessionId} already active`);
      this.sendToClient({
        jsonrpc: "2.0",
        id: request.id,
        result: { sessionId }
      });
      return;
    }
    const cwd = await discoverSessionCwd(sessionId);
    const cli = await this.getOrCreateCli(cwd ?? this.defaultCwd);
    const { directories: skillDirectories } = await this.ensureSkillsLoaded();
    const cliParams = {
      sessionId,
      streaming: params?.streaming ?? true,
      disableResume: params?.disableResume ?? true,
      tools: params?.tools,
      // Pass skill directories so the CLI creates the skill tool for the session
      skillDirectories: skillDirectories.length > 0 ? skillDirectories : void 0
    };
    await cli.sendRequest("session.resume", cliParams);
    this.sessionIds.add(sessionId);
    this.sessionCwds.set(sessionId, cwd ?? this.defaultCwd);
    this.sessionClis.set(sessionId, cli);
    if (params?.tools) {
      this.sessionTools.set(sessionId, params.tools);
    }
    this.log("info", `Session resumed: ${sessionId}`);
    this.sendToClient({
      jsonrpc: "2.0",
      id: request.id,
      result: { sessionId }
    });
  }
  async handleSessionList(request) {
    const cli = await this.getDefaultCli();
    this.log("debug", `[${this.clientId}] RPC -> session.list`);
    const result = await cli.sendRequest("session.list", {});
    const sessions = result.sessions || [];
    this.log("debug", `[${this.clientId}] RPC <- session.list (${sessions.length} sessions)`);
    const sessionsWithCwd = await Promise.all(
      sessions.map(async (s) => {
        const cwd = await discoverSessionCwd(s.sessionId);
        return {
          sessionId: s.sessionId,
          startTime: s.startTime,
          modifiedTime: s.modifiedTime,
          summary: s.summary,
          isRemote: s.isRemote,
          cwd
        };
      })
    );
    this.sendToClient({
      jsonrpc: "2.0",
      id: request.id,
      result: { sessions: sessionsWithCwd }
    });
  }
  async handleGetLastSessionId(request) {
    const cli = await this.getDefaultCli();
    this.log("debug", `[${this.clientId}] RPC -> getLastSessionId (via session.list)`);
    const result = await cli.sendRequest("session.list", {});
    const sessions = result.sessions || [];
    const sorted2 = [...sessions].sort((a, b) => {
      const timeA = new Date(a.modifiedTime).getTime();
      const timeB = new Date(b.modifiedTime).getTime();
      return timeB - timeA;
    });
    const lastSessionId = sorted2.length > 0 ? sorted2[0].sessionId : void 0;
    this.sendToClient({
      jsonrpc: "2.0",
      id: request.id,
      result: lastSessionId
    });
  }
  async handleSessionDelete(request) {
    const params = request.params;
    const sessionId = params?.sessionId;
    if (!sessionId) {
      this.sendErrorResponse(request.id, -32602, "Missing sessionId parameter");
      return;
    }
    this.log("debug", `[${this.clientId}] RPC -> session.delete: ${sessionId}`);
    if (this.sessionIds.has(sessionId)) {
      this.sessionIds.delete(sessionId);
      this.sessionCwds.delete(sessionId);
      this.sessionClis.delete(sessionId);
      this.sessionTools.delete(sessionId);
    }
    const cli = await this.getDefaultCli();
    await cli.sendRequest("session.delete", { sessionId });
    this.sendToClient({
      jsonrpc: "2.0",
      id: request.id,
      result: null
    });
  }
  // ==========================================================================
  // Slash Commands
  // ==========================================================================
  /**
   * Discovers skills from the filesystem and converts them to SlashCommandInfo entries.
   * Results are cached  call clearSkillsCache() + set skillCache = null to reload.
   */
  async ensureSkillsLoaded() {
    if (this.skillCache) {
      return this.skillCache;
    }
    try {
      const repoRoot = await findGitRoot(this.defaultCwd);
      const pluginSources = await getPluginSkillSources();
      const { skills } = await loadSkills(
        repoRoot ?? void 0,
        [],
        true,
        void 0,
        pluginSources,
        this.defaultCwd
      );
      const userInvocable = skills.filter((s) => s.userInvocable);
      const commands = userInvocable.map((skill) => {
        const commandName = skill.pluginName ? `/${skill.pluginName}:${skill.name}` : `/${skill.name}`;
        return {
          name: commandName,
          help: skill.description.length > 60 ? skill.description.substring(0, 57) + "..." : skill.description,
          category: "skill",
          requiresRemote: true
        };
      });
      const directories = getSkillDirectories(repoRoot ?? void 0, [], void 0, pluginSources, this.defaultCwd).map((d) => d.path);
      this.skillCache = { commands, skills: userInvocable, directories };
      if (commands.length > 0) {
        this.log("debug", `[${this.clientId}] Loaded ${commands.length} skill slash commands from ${directories.length} directories`);
      }
      return this.skillCache;
    } catch (err) {
      this.log("warn", `[${this.clientId}] Failed to load skills: ${err}`);
      return { commands: [], skills: [], directories: [] };
    }
  }
  async handleListSlashCommands(request) {
    this.log("debug", `[${this.clientId}] RPC -> listSlashCommands`);
    const { commands: skillCommands } = await this.ensureSkillsLoaded();
    this.sendToClient({
      jsonrpc: "2.0",
      id: request.id,
      result: { commands: [...BUILT_IN_COMMANDS, ...skillCommands] }
    });
  }
  async handleExecuteSlashCommand(request) {
    const params = request.params;
    const command = params?.command;
    const sessionId = params?.sessionId;
    if (!command) {
      this.sendErrorResponse(request.id, -32602, "Missing command parameter");
      return;
    }
    this.log("info", `[${this.clientId}] RPC -> executeSlashCommand: ${command}`);
    const trimmed2 = command.trim();
    const parts = trimmed2.split(/\s+/);
    const commandName = parts[0].toLowerCase();
    const args = parts.slice(1);
    const result = await this.executeSlashCommandInternal(commandName, args, sessionId);
    const response = {
      success: result.kind !== "message" || result.type !== "error",
      result
    };
    this.sendToClient({
      jsonrpc: "2.0",
      id: request.id,
      result: response
    });
  }
  async executeSlashCommandInternal(commandName, args, sessionId) {
    const cmd = BUILT_IN_COMMANDS.find(
      (c) => c.name === commandName || c.aliases?.includes(commandName)
    );
    if (cmd) {
      switch (cmd.name) {
        case "/session": {
          const cwd = sessionId ? this.sessionCwds.get(sessionId) ?? this.defaultCwd : this.defaultCwd;
          return {
            kind: "open-dialog",
            dialog: "session",
            data: {
              sessionId: sessionId ?? "No active session",
              workingDirectory: cwd
            }
          };
        }
        default:
          return {
            kind: "message",
            type: "error",
            text: `Unknown command: ${cmd.name}`
          };
      }
    }
    const { skills } = await this.ensureSkillsLoaded();
    const skill = skills.find((s) => {
      const name = s.pluginName ? `/${s.pluginName}:${s.name}` : `/${s.name}`;
      return name.toLowerCase() === commandName;
    });
    if (skill) {
      const userPrompt = args.join(" ").trim();
      const displayMessage = userPrompt ? `/${skill.name} ${userPrompt}` : `/${skill.name}`;
      const agentPrompt = userPrompt ? `Use the skill tool to invoke the "${skill.name}" skill, then follow the skill's instructions to help with: ${userPrompt}` : `Use the skill tool to invoke the "${skill.name}" skill, then follow the skill's instructions.`;
      return {
        kind: "agent-message",
        displayMessage,
        agentPrompt
      };
    }
    return {
      kind: "message",
      type: "error",
      text: `Unknown command: ${commandName}`
    };
  }
  // ==========================================================================
  // File Search
  // ==========================================================================
  async handleSearchFiles(request) {
    const params = request.params;
    if (!params?.cwd) {
      this.sendErrorResponse(request.id, -32602, "Missing cwd parameter");
      return;
    }
    this.log("debug", `[${this.clientId}] RPC -> searchFiles: "${params.query}" in ${params.cwd}`);
    try {
      const result = await this.fileSearchService.search(params);
      this.log("debug", `[${this.clientId}] RPC <- searchFiles: ${result.results.length} results`);
      this.sendToClient({
        jsonrpc: "2.0",
        id: request.id,
        result
      });
    } catch (err) {
      this.log("error", `[${this.clientId}] File search failed: ${err}`);
      this.sendErrorResponse(request.id, -32603, `File search failed: ${err}`);
    }
  }
  // ==========================================================================
  // Filesystem Methods
  // ==========================================================================
  async handleFsReadDirectory(request) {
    const params = request.params;
    if (!params?.cwd || !params?.dirPath) {
      this.sendErrorResponse(request.id, -32602, "Missing cwd or dirPath parameter");
      return;
    }
    this.log("debug", `[${this.clientId}] RPC -> fs.readDirectory: ${params.dirPath}`);
    try {
      const provider = await this.fsService.retain(params.cwd);
      try {
        const entries = await provider.readDirectory(params.dirPath);
        this.log("debug", `[${this.clientId}] RPC <- fs.readDirectory: ${entries.length} entries`);
        this.sendToClient({
          jsonrpc: "2.0",
          id: request.id,
          result: { entries }
        });
      } finally {
        this.fsService.release(params.cwd);
      }
    } catch (err) {
      this.log("error", `[${this.clientId}] fs.readDirectory failed: ${err}`);
      this.sendErrorResponse(request.id, -32603, `fs.readDirectory failed: ${err}`);
    }
  }
  async handleFsReadFile(request) {
    const params = request.params;
    if (!params?.cwd || !params?.filePath) {
      this.sendErrorResponse(request.id, -32602, "Missing cwd or filePath parameter");
      return;
    }
    this.log("debug", `[${this.clientId}] RPC -> fs.readFile: ${params.filePath}`);
    try {
      const provider = await this.fsService.retain(params.cwd);
      try {
        const content = await provider.readFile((0, import_node_path5.join)(params.cwd, params.filePath));
        const base64Content = Buffer.from(content).toString("base64");
        this.log("debug", `[${this.clientId}] RPC <- fs.readFile: ${content.length} bytes`);
        this.sendToClient({
          jsonrpc: "2.0",
          id: request.id,
          result: { content: base64Content }
        });
      } finally {
        this.fsService.release(params.cwd);
      }
    } catch (err) {
      this.log("error", `[${this.clientId}] fs.readFile failed: ${err}`);
      this.sendErrorResponse(request.id, -32603, `fs.readFile failed: ${err}`);
    }
  }
  async handleFsReadTextFile(request) {
    const params = request.params;
    if (!params?.cwd || !params?.filePath) {
      this.sendErrorResponse(request.id, -32602, "Missing cwd or filePath parameter");
      return;
    }
    this.log("debug", `[${this.clientId}] RPC -> fs.readTextFile: ${params.filePath}`);
    try {
      const provider = await this.fsService.retain(params.cwd);
      try {
        const content = await provider.readTextFile((0, import_node_path5.join)(params.cwd, params.filePath));
        this.log("debug", `[${this.clientId}] RPC <- fs.readTextFile: ${content.length} chars`);
        this.sendToClient({
          jsonrpc: "2.0",
          id: request.id,
          result: { content }
        });
      } finally {
        this.fsService.release(params.cwd);
      }
    } catch (err) {
      this.log("error", `[${this.clientId}] fs.readTextFile failed: ${err}`);
      this.sendErrorResponse(request.id, -32603, `fs.readTextFile failed: ${err}`);
    }
  }
  async handleFsStat(request) {
    const params = request.params;
    if (!params?.cwd || !params?.path) {
      this.sendErrorResponse(request.id, -32602, "Missing cwd or path parameter");
      return;
    }
    this.log("debug", `[${this.clientId}] RPC -> fs.stat: ${params.path}`);
    try {
      const provider = await this.fsService.retain(params.cwd);
      try {
        const stat3 = await provider.stat(params.path);
        this.log("debug", `[${this.clientId}] RPC <- fs.stat: ${stat3.type}, ${stat3.size} bytes`);
        this.sendToClient({
          jsonrpc: "2.0",
          id: request.id,
          result: { stat: stat3 }
        });
      } finally {
        this.fsService.release(params.cwd);
      }
    } catch (err) {
      this.log("error", `[${this.clientId}] fs.stat failed: ${err}`);
      this.sendErrorResponse(request.id, -32603, `fs.stat failed: ${err}`);
    }
  }
  async handleFsExists(request) {
    const params = request.params;
    if (!params?.cwd || !params?.path) {
      this.sendErrorResponse(request.id, -32602, "Missing cwd or path parameter");
      return;
    }
    this.log("debug", `[${this.clientId}] RPC -> fs.exists: ${params.path}`);
    try {
      const provider = await this.fsService.retain(params.cwd);
      try {
        const exists2 = await provider.exists(params.path);
        this.log("debug", `[${this.clientId}] RPC <- fs.exists: ${exists2}`);
        this.sendToClient({
          jsonrpc: "2.0",
          id: request.id,
          result: { exists: exists2 }
        });
      } finally {
        this.fsService.release(params.cwd);
      }
    } catch (err) {
      this.log("error", `[${this.clientId}] fs.exists failed: ${err}`);
      this.sendErrorResponse(request.id, -32603, `fs.exists failed: ${err}`);
    }
  }
  // ==========================================================================
  // Filesystem Write Methods
  // ==========================================================================
  async handleFsWriteFile(request) {
    const params = request.params;
    if (!params?.cwd || !params?.filePath || params?.content === void 0) {
      this.sendErrorResponse(request.id, -32602, "Missing cwd, filePath, or content parameter");
      return;
    }
    this.log("debug", `[${this.clientId}] RPC -> fs.writeFile: ${params.filePath}`);
    try {
      const provider = await this.fsService.retain(params.cwd);
      try {
        const content = new Uint8Array(Buffer.from(params.content, "base64"));
        await provider.writeFile(params.filePath, content);
        this.log("debug", `[${this.clientId}] RPC <- fs.writeFile: ${content.length} bytes written`);
        this.sendToClient({
          jsonrpc: "2.0",
          id: request.id,
          result: null
        });
      } finally {
        this.fsService.release(params.cwd);
      }
    } catch (err) {
      this.log("error", `[${this.clientId}] fs.writeFile failed: ${err}`);
      this.sendErrorResponse(request.id, -32603, `fs.writeFile failed: ${err}`);
    }
  }
  async handleFsWriteTextFile(request) {
    const params = request.params;
    if (!params?.cwd || !params?.filePath || params?.content === void 0) {
      this.sendErrorResponse(request.id, -32602, "Missing cwd, filePath, or content parameter");
      return;
    }
    this.log("debug", `[${this.clientId}] RPC -> fs.writeTextFile: ${params.filePath}`);
    try {
      const provider = await this.fsService.retain(params.cwd);
      try {
        const content = new TextEncoder().encode(params.content);
        await provider.writeFile(params.filePath, content);
        this.log("debug", `[${this.clientId}] RPC <- fs.writeTextFile: ${params.content.length} chars written`);
        this.sendToClient({
          jsonrpc: "2.0",
          id: request.id,
          result: null
        });
      } finally {
        this.fsService.release(params.cwd);
      }
    } catch (err) {
      this.log("error", `[${this.clientId}] fs.writeTextFile failed: ${err}`);
      this.sendErrorResponse(request.id, -32603, `fs.writeTextFile failed: ${err}`);
    }
  }
  async handleFsDelete(request) {
    const params = request.params;
    if (!params?.cwd || !params?.path) {
      this.sendErrorResponse(request.id, -32602, "Missing cwd or path parameter");
      return;
    }
    this.log("debug", `[${this.clientId}] RPC -> fs.delete: ${params.path} (recursive: ${params.recursive ?? false})`);
    try {
      const provider = await this.fsService.retain(params.cwd);
      try {
        await provider.delete(params.path, { recursive: params.recursive ?? false });
        this.log("debug", `[${this.clientId}] RPC <- fs.delete: success`);
        this.sendToClient({
          jsonrpc: "2.0",
          id: request.id,
          result: null
        });
      } finally {
        this.fsService.release(params.cwd);
      }
    } catch (err) {
      this.log("error", `[${this.clientId}] fs.delete failed: ${err}`);
      this.sendErrorResponse(request.id, -32603, `fs.delete failed: ${err}`);
    }
  }
  async handleFsRename(request) {
    const params = request.params;
    if (!params?.cwd || !params?.oldPath || !params?.newPath) {
      this.sendErrorResponse(request.id, -32602, "Missing cwd, oldPath, or newPath parameter");
      return;
    }
    this.log("debug", `[${this.clientId}] RPC -> fs.rename: ${params.oldPath} -> ${params.newPath}`);
    try {
      const provider = await this.fsService.retain(params.cwd);
      try {
        await provider.rename(params.oldPath, params.newPath);
        this.log("debug", `[${this.clientId}] RPC <- fs.rename: success`);
        this.sendToClient({
          jsonrpc: "2.0",
          id: request.id,
          result: null
        });
      } finally {
        this.fsService.release(params.cwd);
      }
    } catch (err) {
      this.log("error", `[${this.clientId}] fs.rename failed: ${err}`);
      this.sendErrorResponse(request.id, -32603, `fs.rename failed: ${err}`);
    }
  }
  async handleFsCreateDirectory(request) {
    const params = request.params;
    if (!params?.cwd || !params?.dirPath) {
      this.sendErrorResponse(request.id, -32602, "Missing cwd or dirPath parameter");
      return;
    }
    this.log("debug", `[${this.clientId}] RPC -> fs.createDirectory: ${params.dirPath}`);
    try {
      const provider = await this.fsService.retain(params.cwd);
      try {
        await provider.createDirectory(params.dirPath);
        this.log("debug", `[${this.clientId}] RPC <- fs.createDirectory: success`);
        this.sendToClient({
          jsonrpc: "2.0",
          id: request.id,
          result: null
        });
      } finally {
        this.fsService.release(params.cwd);
      }
    } catch (err) {
      this.log("error", `[${this.clientId}] fs.createDirectory failed: ${err}`);
      this.sendErrorResponse(request.id, -32603, `fs.createDirectory failed: ${err}`);
    }
  }
  // ==========================================================================
  // Git Methods
  // ==========================================================================
  async handleGitStatus(request) {
    const params = request.params;
    if (!params?.cwd) {
      this.sendErrorResponse(request.id, -32602, "Missing cwd parameter");
      return;
    }
    this.log("debug", `[${this.clientId}] RPC -> git.status: ${params.cwd}`);
    try {
      const provider = await this.gitService.retain(params.cwd);
      if (!provider) {
        this.sendToClient({
          jsonrpc: "2.0",
          id: request.id,
          result: { status: null }
        });
        return;
      }
      try {
        const status = await provider.getStatus();
        const serialized = serializeGitStatus(status);
        this.log("debug", `[${this.clientId}] RPC <- git.status: ${status.branch}, ${status.files.size} files`);
        this.sendToClient({
          jsonrpc: "2.0",
          id: request.id,
          result: { status: serialized }
        });
      } finally {
        this.gitService.release(provider.gitRoot);
      }
    } catch (err) {
      this.log("error", `[${this.clientId}] git.status failed: ${err}`);
      this.sendErrorResponse(request.id, -32603, `git.status failed: ${err}`);
    }
  }
  async handleGitFileStatus(request) {
    const params = request.params;
    if (!params?.cwd || !params?.filePath) {
      this.sendErrorResponse(request.id, -32602, "Missing cwd or filePath parameter");
      return;
    }
    this.log("debug", `[${this.clientId}] RPC -> git.fileStatus: ${params.filePath}`);
    try {
      const provider = await this.gitService.retain(params.cwd);
      if (!provider) {
        this.sendToClient({
          jsonrpc: "2.0",
          id: request.id,
          result: { status: null }
        });
        return;
      }
      try {
        const status = await provider.getFileStatus(params.filePath);
        this.log("debug", `[${this.clientId}] RPC <- git.fileStatus: ${status?.status ?? "not found"}`);
        this.sendToClient({
          jsonrpc: "2.0",
          id: request.id,
          result: { status }
        });
      } finally {
        this.gitService.release(provider.gitRoot);
      }
    } catch (err) {
      this.log("error", `[${this.clientId}] git.fileStatus failed: ${err}`);
      this.sendErrorResponse(request.id, -32603, `git.fileStatus failed: ${err}`);
    }
  }
  async handleGitBranch(request) {
    const params = request.params;
    if (!params?.cwd) {
      this.sendErrorResponse(request.id, -32602, "Missing cwd parameter");
      return;
    }
    this.log("debug", `[${this.clientId}] RPC -> git.branch: ${params.cwd}`);
    try {
      const provider = await this.gitService.retain(params.cwd);
      if (!provider) {
        this.sendToClient({
          jsonrpc: "2.0",
          id: request.id,
          result: { branch: null }
        });
        return;
      }
      try {
        const branch = await provider.getCurrentBranch();
        this.log("debug", `[${this.clientId}] RPC <- git.branch: ${branch}`);
        this.sendToClient({
          jsonrpc: "2.0",
          id: request.id,
          result: { branch }
        });
      } finally {
        this.gitService.release(provider.gitRoot);
      }
    } catch (err) {
      this.log("error", `[${this.clientId}] git.branch failed: ${err}`);
      this.sendErrorResponse(request.id, -32603, `git.branch failed: ${err}`);
    }
  }
  async handleGitBranches(request) {
    const params = request.params;
    if (!params?.cwd) {
      this.sendErrorResponse(request.id, -32602, "Missing cwd parameter");
      return;
    }
    this.log("debug", `[${this.clientId}] RPC -> git.branches: ${params.cwd}`);
    try {
      const provider = await this.gitService.retain(params.cwd);
      if (!provider) {
        this.sendToClient({
          jsonrpc: "2.0",
          id: request.id,
          result: { branches: [] }
        });
        return;
      }
      try {
        const branches = await provider.getBranches();
        this.log("debug", `[${this.clientId}] RPC <- git.branches: ${branches.length} branches`);
        this.sendToClient({
          jsonrpc: "2.0",
          id: request.id,
          result: { branches }
        });
      } finally {
        this.gitService.release(provider.gitRoot);
      }
    } catch (err) {
      this.log("error", `[${this.clientId}] git.branches failed: ${err}`);
      this.sendErrorResponse(request.id, -32603, `git.branches failed: ${err}`);
    }
  }
  async handleGitFileDiff(request) {
    const params = request.params;
    if (!params?.cwd || !params?.filePath) {
      this.sendErrorResponse(request.id, -32602, "Missing cwd or filePath parameter");
      return;
    }
    this.log("debug", `[${this.clientId}] RPC -> git.fileDiff: ${params.filePath} (staged: ${params.staged ?? false})`);
    try {
      const provider = await this.gitService.retain(params.cwd);
      if (!provider) {
        this.sendToClient({
          jsonrpc: "2.0",
          id: request.id,
          result: { diff: null }
        });
        return;
      }
      try {
        const diff = await provider.getFileDiff(params.filePath, params.staged);
        this.log("debug", `[${this.clientId}] RPC <- git.fileDiff: ${diff.length} chars`);
        this.sendToClient({
          jsonrpc: "2.0",
          id: request.id,
          result: { diff }
        });
      } finally {
        this.gitService.release(provider.gitRoot);
      }
    } catch (err) {
      this.log("error", `[${this.clientId}] git.fileDiff failed: ${err}`);
      this.sendErrorResponse(request.id, -32603, `git.fileDiff failed: ${err}`);
    }
  }
  async handleGitFileAtRef(request) {
    const params = request.params;
    if (!params?.cwd || !params?.filePath || !params?.ref) {
      this.sendErrorResponse(request.id, -32602, "Missing cwd, filePath, or ref parameter");
      return;
    }
    this.log("debug", `[${this.clientId}] RPC -> git.fileAtRef: ${params.filePath} at ${params.ref}`);
    try {
      const provider = await this.gitService.retain(params.cwd);
      if (!provider) {
        this.sendToClient({
          jsonrpc: "2.0",
          id: request.id,
          result: { content: null }
        });
        return;
      }
      try {
        const content = await provider.getFileAtRef(params.filePath, params.ref);
        this.log("debug", `[${this.clientId}] RPC <- git.fileAtRef: ${content.length} chars`);
        this.sendToClient({
          jsonrpc: "2.0",
          id: request.id,
          result: { content }
        });
      } finally {
        this.gitService.release(provider.gitRoot);
      }
    } catch (err) {
      this.log("error", `[${this.clientId}] git.fileAtRef failed: ${err}`);
      this.sendErrorResponse(request.id, -32603, `git.fileAtRef failed: ${err}`);
    }
  }
  async handleGitHasUncommittedChanges(request) {
    const params = request.params;
    if (!params?.cwd) {
      this.sendErrorResponse(request.id, -32602, "Missing cwd parameter");
      return;
    }
    this.log("debug", `[${this.clientId}] RPC -> git.hasUncommittedChanges: ${params.cwd}`);
    try {
      const provider = await this.gitService.retain(params.cwd);
      if (!provider) {
        this.sendToClient({
          jsonrpc: "2.0",
          id: request.id,
          result: { hasChanges: false }
        });
        return;
      }
      try {
        const hasChanges = await provider.hasUncommittedChanges();
        this.log("debug", `[${this.clientId}] RPC <- git.hasUncommittedChanges: ${hasChanges}`);
        this.sendToClient({
          jsonrpc: "2.0",
          id: request.id,
          result: { hasChanges }
        });
      } finally {
        this.gitService.release(provider.gitRoot);
      }
    } catch (err) {
      this.log("error", `[${this.clientId}] git.hasUncommittedChanges failed: ${err}`);
      this.sendErrorResponse(request.id, -32603, `git.hasUncommittedChanges failed: ${err}`);
    }
  }
  async handleGitHasUnpushedCommits(request) {
    const params = request.params;
    if (!params?.cwd) {
      this.sendErrorResponse(request.id, -32602, "Missing cwd parameter");
      return;
    }
    this.log("debug", `[${this.clientId}] RPC -> git.hasUnpushedCommits: ${params.cwd}`);
    try {
      const provider = await this.gitService.retain(params.cwd);
      if (!provider) {
        this.sendToClient({
          jsonrpc: "2.0",
          id: request.id,
          result: { hasUnpushed: false }
        });
        return;
      }
      try {
        const hasUnpushed = await provider.hasUnpushedCommits();
        this.log("debug", `[${this.clientId}] RPC <- git.hasUnpushedCommits: ${hasUnpushed}`);
        this.sendToClient({
          jsonrpc: "2.0",
          id: request.id,
          result: { hasUnpushed }
        });
      } finally {
        this.gitService.release(provider.gitRoot);
      }
    } catch (err) {
      this.log("error", `[${this.clientId}] git.hasUnpushedCommits failed: ${err}`);
      this.sendErrorResponse(request.id, -32603, `git.hasUnpushedCommits failed: ${err}`);
    }
  }
  async handleGitUncommittedDiffStats(request) {
    const params = request.params;
    if (!params?.cwd) {
      this.sendErrorResponse(request.id, -32602, "Missing cwd parameter");
      return;
    }
    this.log("debug", `[${this.clientId}] RPC -> git.uncommittedDiffStats: ${params.cwd}`);
    try {
      const provider = await this.gitService.retain(params.cwd);
      if (!provider) {
        this.sendToClient({
          jsonrpc: "2.0",
          id: request.id,
          result: { stats: null }
        });
        return;
      }
      try {
        const stats = await provider.getUncommittedDiffStats();
        this.log("debug", `[${this.clientId}] RPC <- git.uncommittedDiffStats: +${stats.added} -${stats.removed}`);
        this.sendToClient({
          jsonrpc: "2.0",
          id: request.id,
          result: { stats }
        });
      } finally {
        this.gitService.release(provider.gitRoot);
      }
    } catch (err) {
      this.log("error", `[${this.clientId}] git.uncommittedDiffStats failed: ${err}`);
      this.sendErrorResponse(request.id, -32603, `git.uncommittedDiffStats failed: ${err}`);
    }
  }
  async handleGitPerFileDiffStats(request) {
    const params = request.params;
    if (!params?.cwd) {
      this.sendErrorResponse(request.id, -32602, "Missing cwd parameter");
      return;
    }
    this.log("debug", `[${this.clientId}] RPC -> git.perFileDiffStats: ${params.cwd}`);
    try {
      const provider = await this.gitService.retain(params.cwd);
      if (!provider) {
        this.sendToClient({
          jsonrpc: "2.0",
          id: request.id,
          result: { staged: {}, unstaged: {} }
        });
        return;
      }
      try {
        const stats = await provider.getPerFileDiffStats();
        this.log("debug", `[${this.clientId}] RPC <- git.perFileDiffStats: staged=${stats.staged.size} unstaged=${stats.unstaged.size}`);
        this.sendToClient({
          jsonrpc: "2.0",
          id: request.id,
          result: {
            staged: Object.fromEntries(stats.staged),
            unstaged: Object.fromEntries(stats.unstaged)
          }
        });
      } finally {
        this.gitService.release(provider.gitRoot);
      }
    } catch (err) {
      this.log("error", `[${this.clientId}] git.perFileDiffStats failed: ${err}`);
      this.sendErrorResponse(request.id, -32603, `git.perFileDiffStats failed: ${err}`);
    }
  }
  async handleGitFindRoot(request) {
    const params = request.params;
    if (!params?.cwd) {
      this.sendErrorResponse(request.id, -32602, "Missing cwd parameter");
      return;
    }
    this.log("debug", `[${this.clientId}] RPC -> git.findRoot: ${params.cwd}`);
    try {
      const gitRoot = await findGitRoot(params.cwd);
      this.log("debug", `[${this.clientId}] RPC <- git.findRoot: ${gitRoot ?? "not found"}`);
      this.sendToClient({
        jsonrpc: "2.0",
        id: request.id,
        result: { gitRoot }
      });
    } catch (err) {
      this.log("error", `[${this.clientId}] git.findRoot failed: ${err}`);
      this.sendErrorResponse(request.id, -32603, `git.findRoot failed: ${err}`);
    }
  }
  async handleGitIsAvailable(request) {
    this.log("debug", `[${this.clientId}] RPC -> git.isAvailable`);
    try {
      const available = await isGitAvailable();
      this.log("debug", `[${this.clientId}] RPC <- git.isAvailable: ${available}`);
      this.sendToClient({
        jsonrpc: "2.0",
        id: request.id,
        result: { available }
      });
    } catch (err) {
      this.log("error", `[${this.clientId}] git.isAvailable failed: ${err}`);
      this.sendErrorResponse(request.id, -32603, `git.isAvailable failed: ${err}`);
    }
  }
  // ==========================================================================
  // Filesystem Subscription Handlers
  // ==========================================================================
  async handleFsSubscribe(request) {
    const params = request.params;
    const cwd = params?.cwd ?? this.defaultCwd;
    const type = params?.type ?? "all";
    const filterPath = params?.path;
    this.log("debug", `[${this.clientId}] RPC -> fs.subscribe (cwd: ${cwd}, type: ${type}, path: ${filterPath ?? "all"})`);
    try {
      const provider = await this.fsService.retain(cwd);
      const currentCount = this.fsSubscriptionCwds.get(cwd) ?? 0;
      this.fsSubscriptionCwds.set(cwd, currentCount + 1);
      const subscriptionId = `fs-${this.clientId}-${this.nextSubscriptionId++}`;
      const forwardEvent = (eventType, event) => {
        if (type === "directory" && eventType !== "directoryChanged") return;
        if (type === "file" && eventType === "directoryChanged") return;
        if (filterPath) {
          const eventPath = event.path ?? event.oldPath ?? event.newPath ?? "";
          if (!eventPath.startsWith(filterPath) && eventPath !== filterPath) return;
        }
        this.sendToClient({
          jsonrpc: "2.0",
          method: `fs.${eventType}`,
          params: {
            subscriptionId,
            type: eventType,
            ...event
          }
        });
      };
      const disposables = [
        provider.onDirectoryListingChanged((e) => forwardEvent("directoryChanged", e)),
        provider.onFileContentChanged((e) => forwardEvent("fileChanged", e)),
        provider.onFileRenamed((e) => forwardEvent("fileRenamed", e)),
        provider.onFileDeleted((e) => forwardEvent("fileDeleted", e))
      ];
      const cleanup = () => {
        disposables.forEach((d) => d.dispose());
        const count = this.fsSubscriptionCwds.get(cwd) ?? 0;
        if (count <= 1) {
          this.fsSubscriptionCwds.delete(cwd);
          this.fsService.release(cwd);
        } else {
          this.fsSubscriptionCwds.set(cwd, count - 1);
        }
      };
      this.fsSubscriptions.set(subscriptionId, {
        cwd,
        type,
        path: filterPath,
        cleanup
      });
      this.log("debug", `[${this.clientId}] RPC <- fs.subscribe: ${subscriptionId}`);
      this.sendToClient({
        jsonrpc: "2.0",
        id: request.id,
        result: { subscriptionId }
      });
    } catch (err) {
      this.log("error", `[${this.clientId}] fs.subscribe failed: ${err}`);
      this.sendErrorResponse(request.id, -32603, `fs.subscribe failed: ${err}`);
    }
  }
  async handleFsUnsubscribe(request) {
    const params = request.params;
    const subscriptionId = params?.subscriptionId;
    this.log("debug", `[${this.clientId}] RPC -> fs.unsubscribe (${subscriptionId})`);
    if (!subscriptionId) {
      this.sendErrorResponse(request.id, -32602, "Missing subscriptionId parameter");
      return;
    }
    const subscription = this.fsSubscriptions.get(subscriptionId);
    if (!subscription) {
      this.sendErrorResponse(request.id, -32602, `Unknown subscription: ${subscriptionId}`);
      return;
    }
    subscription.cleanup();
    this.fsSubscriptions.delete(subscriptionId);
    this.log("debug", `[${this.clientId}] RPC <- fs.unsubscribe: success`);
    this.sendToClient({
      jsonrpc: "2.0",
      id: request.id,
      result: null
    });
  }
  // ==========================================================================
  // Git Subscription Handlers
  // ==========================================================================
  async handleGitSubscribe(request) {
    const params = request.params;
    const cwd = params?.cwd ?? this.defaultCwd;
    this.log("debug", `[${this.clientId}] RPC -> git.subscribe (cwd: ${cwd})`);
    try {
      const provider = await this.gitService.retain(cwd);
      if (!provider) {
        this.log("debug", `[${this.clientId}] RPC <- git.subscribe: not a git repo`);
        this.sendToClient({
          jsonrpc: "2.0",
          id: request.id,
          result: { subscriptionId: null, gitRoot: null }
        });
        return;
      }
      const gitRoot = provider.gitRoot;
      const subscriptionId = `git-${this.clientId}-${this.nextSubscriptionId++}`;
      const forwardEvent = (eventType, event) => {
        this.sendToClient({
          jsonrpc: "2.0",
          method: `git.${eventType}`,
          params: {
            subscriptionId,
            type: eventType,
            gitRoot,
            ...event
          }
        });
      };
      const disposables = [
        provider.onStatusChanged((e) => forwardEvent("statusChanged", {
          ...e,
          status: serializeGitStatus(e.status)
        })),
        provider.onBranchChanged((e) => forwardEvent("branchChanged", e)),
        provider.onCommitCreated((e) => forwardEvent("commitCreated", e)),
        provider.onHeadChanged((e) => forwardEvent("headChanged", e))
      ];
      const cleanup = () => {
        disposables.forEach((d) => d.dispose());
        this.gitService.release(gitRoot);
      };
      this.gitSubscriptions.set(subscriptionId, {
        gitRoot,
        cleanup
      });
      this.log("debug", `[${this.clientId}] RPC <- git.subscribe: ${subscriptionId} (gitRoot: ${gitRoot})`);
      this.sendToClient({
        jsonrpc: "2.0",
        id: request.id,
        result: { subscriptionId, gitRoot }
      });
    } catch (err) {
      const message = err instanceof Error ? err.message : String(err);
      const logLevel = message.includes("Not a git repository") ? "debug" : "error";
      this.log(logLevel, `[${this.clientId}] git.subscribe failed: ${err}`);
      this.sendErrorResponse(request.id, -32603, `git.subscribe failed: ${err}`);
    }
  }
  async handleGitUnsubscribe(request) {
    const params = request.params;
    const subscriptionId = params?.subscriptionId;
    this.log("debug", `[${this.clientId}] RPC -> git.unsubscribe (${subscriptionId})`);
    if (!subscriptionId) {
      this.sendErrorResponse(request.id, -32602, "Missing subscriptionId parameter");
      return;
    }
    const subscription = this.gitSubscriptions.get(subscriptionId);
    if (!subscription) {
      this.sendErrorResponse(request.id, -32602, `Unknown subscription: ${subscriptionId}`);
      return;
    }
    subscription.cleanup();
    this.gitSubscriptions.delete(subscriptionId);
    this.log("debug", `[${this.clientId}] RPC <- git.unsubscribe: success`);
    this.sendToClient({
      jsonrpc: "2.0",
      id: request.id,
      result: null
    });
  }
  // ==========================================================================
  // Git Write Methods
  // ==========================================================================
  async handleGitStage(request) {
    const params = request.params;
    if (!params?.cwd || !params?.files || !Array.isArray(params.files)) {
      this.sendErrorResponse(request.id, -32602, "Missing cwd or files parameter");
      return;
    }
    this.log("debug", `[${this.clientId}] RPC -> git.stage: ${params.files.length} files`);
    try {
      const provider = await this.gitService.retain(params.cwd);
      if (!provider) {
        this.sendErrorResponse(request.id, -32603, "Not a git repository");
        return;
      }
      try {
        await provider.stage(params.files);
        this.log("debug", `[${this.clientId}] RPC <- git.stage: success`);
        this.sendToClient({
          jsonrpc: "2.0",
          id: request.id,
          result: null
        });
      } finally {
        this.gitService.release(provider.gitRoot);
      }
    } catch (err) {
      this.log("error", `[${this.clientId}] git.stage failed: ${err}`);
      this.sendErrorResponse(request.id, -32603, `git.stage failed: ${err}`);
    }
  }
  async handleGitUnstage(request) {
    const params = request.params;
    if (!params?.cwd || !params?.files || !Array.isArray(params.files)) {
      this.sendErrorResponse(request.id, -32602, "Missing cwd or files parameter");
      return;
    }
    this.log("debug", `[${this.clientId}] RPC -> git.unstage: ${params.files.length} files`);
    try {
      const provider = await this.gitService.retain(params.cwd);
      if (!provider) {
        this.sendErrorResponse(request.id, -32603, "Not a git repository");
        return;
      }
      try {
        await provider.unstage(params.files);
        this.log("debug", `[${this.clientId}] RPC <- git.unstage: success`);
        this.sendToClient({
          jsonrpc: "2.0",
          id: request.id,
          result: null
        });
      } finally {
        this.gitService.release(provider.gitRoot);
      }
    } catch (err) {
      this.log("error", `[${this.clientId}] git.unstage failed: ${err}`);
      this.sendErrorResponse(request.id, -32603, `git.unstage failed: ${err}`);
    }
  }
  async handleGitRevert(request) {
    const params = request.params;
    if (!params?.cwd || !params?.files || !Array.isArray(params.files)) {
      this.sendErrorResponse(request.id, -32602, "Missing cwd or files parameter");
      return;
    }
    this.log("debug", `[${this.clientId}] RPC -> git.revert: ${params.files.length} files`);
    try {
      const provider = await this.gitService.retain(params.cwd);
      if (!provider) {
        this.sendErrorResponse(request.id, -32603, "Not a git repository");
        return;
      }
      try {
        await provider.revert(params.files);
        this.log("debug", `[${this.clientId}] RPC <- git.revert: success`);
        this.sendToClient({
          jsonrpc: "2.0",
          id: request.id,
          result: null
        });
      } finally {
        this.gitService.release(provider.gitRoot);
      }
    } catch (err) {
      this.log("error", `[${this.clientId}] git.revert failed: ${err}`);
      this.sendErrorResponse(request.id, -32603, `git.revert failed: ${err}`);
    }
  }
  async handleGitCommit(request) {
    const params = request.params;
    if (!params?.cwd || !params?.message) {
      this.sendErrorResponse(request.id, -32602, "Missing cwd or message parameter");
      return;
    }
    this.log("debug", `[${this.clientId}] RPC -> git.commit: "${params.message.substring(0, 50)}..."`);
    try {
      const provider = await this.gitService.retain(params.cwd);
      if (!provider) {
        this.sendErrorResponse(request.id, -32603, "Not a git repository");
        return;
      }
      try {
        const result = await provider.commit(params.message, params.options);
        this.log("debug", `[${this.clientId}] RPC <- git.commit: ${result.hash}`);
        this.sendToClient({
          jsonrpc: "2.0",
          id: request.id,
          result
        });
      } finally {
        this.gitService.release(provider.gitRoot);
      }
    } catch (err) {
      this.log("error", `[${this.clientId}] git.commit failed: ${err}`);
      this.sendErrorResponse(request.id, -32603, `git.commit failed: ${err}`);
    }
  }
  async handleGitCheckout(request) {
    const params = request.params;
    if (!params?.cwd || !params?.ref) {
      this.sendErrorResponse(request.id, -32602, "Missing cwd or ref parameter");
      return;
    }
    this.log("debug", `[${this.clientId}] RPC -> git.checkout: ${params.ref}`);
    try {
      const provider = await this.gitService.retain(params.cwd);
      if (!provider) {
        this.sendErrorResponse(request.id, -32603, "Not a git repository");
        return;
      }
      try {
        await provider.checkout(params.ref, { force: params.force ?? false });
        this.log("debug", `[${this.clientId}] RPC <- git.checkout: success`);
        this.sendToClient({
          jsonrpc: "2.0",
          id: request.id,
          result: null
        });
      } finally {
        this.gitService.release(provider.gitRoot);
      }
    } catch (err) {
      this.log("error", `[${this.clientId}] git.checkout failed: ${err}`);
      this.sendErrorResponse(request.id, -32603, `git.checkout failed: ${err}`);
    }
  }
  async handleGitCreateBranch(request) {
    const params = request.params;
    if (!params?.cwd || !params?.branchName) {
      this.sendErrorResponse(request.id, -32602, "Missing cwd or branchName parameter");
      return;
    }
    this.log("debug", `[${this.clientId}] RPC -> git.createBranch: ${params.branchName}`);
    try {
      const provider = await this.gitService.retain(params.cwd);
      if (!provider) {
        this.sendErrorResponse(request.id, -32603, "Not a git repository");
        return;
      }
      try {
        await provider.createBranch(params.branchName, params.checkout ?? false, params.startPoint);
        this.log("debug", `[${this.clientId}] RPC <- git.createBranch: success`);
        this.sendToClient({
          jsonrpc: "2.0",
          id: request.id,
          result: null
        });
      } finally {
        this.gitService.release(provider.gitRoot);
      }
    } catch (err) {
      this.log("error", `[${this.clientId}] git.createBranch failed: ${err}`);
      this.sendErrorResponse(request.id, -32603, `git.createBranch failed: ${err}`);
    }
  }
  async handleGitPush(request) {
    const params = request.params;
    if (!params?.cwd) {
      this.sendErrorResponse(request.id, -32602, "Missing cwd parameter");
      return;
    }
    this.log("debug", `[${this.clientId}] RPC -> git.push (force: ${params.force ?? false})`);
    try {
      const provider = await this.gitService.retain(params.cwd);
      if (!provider) {
        this.sendErrorResponse(request.id, -32603, "Not a git repository");
        return;
      }
      try {
        await provider.push(params.force ?? false, params.setUpstream ?? false);
        this.log("debug", `[${this.clientId}] RPC <- git.push: success`);
        this.sendToClient({
          jsonrpc: "2.0",
          id: request.id,
          result: null
        });
      } finally {
        this.gitService.release(provider.gitRoot);
      }
    } catch (err) {
      this.log("error", `[${this.clientId}] git.push failed: ${err}`);
      this.sendErrorResponse(request.id, -32603, `git.push failed: ${err}`);
    }
  }
  async handleGitPull(request) {
    const params = request.params;
    if (!params?.cwd) {
      this.sendErrorResponse(request.id, -32602, "Missing cwd parameter");
      return;
    }
    this.log("debug", `[${this.clientId}] RPC -> git.pull (rebase: ${params.rebase ?? false})`);
    try {
      const provider = await this.gitService.retain(params.cwd);
      if (!provider) {
        this.sendErrorResponse(request.id, -32603, "Not a git repository");
        return;
      }
      try {
        await provider.pull(params.rebase ?? false);
        this.log("debug", `[${this.clientId}] RPC <- git.pull: success`);
        this.sendToClient({
          jsonrpc: "2.0",
          id: request.id,
          result: null
        });
      } finally {
        this.gitService.release(provider.gitRoot);
      }
    } catch (err) {
      this.log("error", `[${this.clientId}] git.pull failed: ${err}`);
      this.sendErrorResponse(request.id, -32603, `git.pull failed: ${err}`);
    }
  }
  async handleGitStash(request) {
    const params = request.params;
    if (!params?.cwd) {
      this.sendErrorResponse(request.id, -32602, "Missing cwd parameter");
      return;
    }
    this.log("debug", `[${this.clientId}] RPC -> git.stash`);
    try {
      const provider = await this.gitService.retain(params.cwd);
      if (!provider) {
        this.sendErrorResponse(request.id, -32603, "Not a git repository");
        return;
      }
      try {
        await provider.stash(params.message);
        this.log("debug", `[${this.clientId}] RPC <- git.stash: success`);
        this.sendToClient({
          jsonrpc: "2.0",
          id: request.id,
          result: null
        });
      } finally {
        this.gitService.release(provider.gitRoot);
      }
    } catch (err) {
      this.log("error", `[${this.clientId}] git.stash failed: ${err}`);
      this.sendErrorResponse(request.id, -32603, `git.stash failed: ${err}`);
    }
  }
  async handleGitStashPop(request) {
    const params = request.params;
    if (!params?.cwd) {
      this.sendErrorResponse(request.id, -32602, "Missing cwd parameter");
      return;
    }
    this.log("debug", `[${this.clientId}] RPC -> git.stashPop`);
    try {
      const provider = await this.gitService.retain(params.cwd);
      if (!provider) {
        this.sendErrorResponse(request.id, -32603, "Not a git repository");
        return;
      }
      try {
        await provider.stashPop();
        this.log("debug", `[${this.clientId}] RPC <- git.stashPop: success`);
        this.sendToClient({
          jsonrpc: "2.0",
          id: request.id,
          result: null
        });
      } finally {
        this.gitService.release(provider.gitRoot);
      }
    } catch (err) {
      this.log("error", `[${this.clientId}] git.stashPop failed: ${err}`);
      this.sendErrorResponse(request.id, -32603, `git.stashPop failed: ${err}`);
    }
  }
  // ==========================================================================
  // Model Selection
  // ==========================================================================
  async handleModelsList(request) {
    this.log("debug", `[${this.clientId}] RPC -> models.list`);
    const response = {
      models: SUPPORTED_MODELS,
      defaultModel: DEFAULT_MODEL
      // currentModel could be tracked per-session if needed
    };
    this.sendToClient({
      jsonrpc: "2.0",
      id: request.id,
      result: response
    });
  }
  // ==========================================================================
  // Session Methods
  // ==========================================================================
  async handleSessionSend(request) {
    const params = request.params;
    const sessionId = params?.sessionId;
    const prompt = params?.prompt;
    if (!sessionId) {
      this.sendErrorResponse(request.id, -32602, "Missing sessionId parameter");
      return;
    }
    if (!prompt) {
      this.sendErrorResponse(request.id, -32602, "Missing prompt parameter");
      return;
    }
    const cli = this.sessionClis.get(sessionId);
    if (!cli) {
      this.sendErrorResponse(request.id, -32600, `Session not found: ${sessionId}`);
      return;
    }
    const truncatedPrompt = prompt.length > 50 ? `${prompt.substring(0, 50)}...` : prompt;
    this.log("info", `Prompt received: "${truncatedPrompt}" (cwd: ${this.sessionCwds.get(sessionId) ?? this.defaultCwd})`);
    await cli.sendRequest("session.send", {
      sessionId,
      prompt,
      mode: params?.mode
    });
    this.sendToClient({
      jsonrpc: "2.0",
      id: request.id,
      result: {}
    });
  }
  async handleSessionSendAndWait(request) {
    const params = request.params;
    const sessionId = params?.sessionId;
    const prompt = params?.prompt;
    if (!sessionId) {
      this.sendErrorResponse(request.id, -32602, "Missing sessionId parameter");
      return;
    }
    if (!prompt) {
      this.sendErrorResponse(request.id, -32602, "Missing prompt parameter");
      return;
    }
    const cli = this.sessionClis.get(sessionId);
    if (!cli) {
      this.sendErrorResponse(request.id, -32600, `Session not found: ${sessionId}`);
      return;
    }
    const truncatedPrompt = prompt.length > 50 ? `${prompt.substring(0, 50)}...` : prompt;
    this.log("info", `Prompt received (sendAndWait): "${truncatedPrompt}" (cwd: ${this.sessionCwds.get(sessionId) ?? this.defaultCwd})`);
    const timeout = params?.timeout ?? 3e5;
    const events = [];
    const waitForIdle = new Promise((resolve8, reject) => {
      const timeoutId = setTimeout(() => {
        cleanup();
        reject(new Error("session.sendAndWait timeout"));
      }, timeout);
      const handler = (notification) => {
        if (notification.method === "session.event") {
          const eventParams = notification.params;
          if (eventParams.sessionId === sessionId) {
            events.push(eventParams.event);
            if (eventParams.event.type === "session.idle") {
              cleanup();
              resolve8(events);
            }
          }
        }
      };
      const cleanup = () => {
        clearTimeout(timeoutId);
        cli.off("notification", handler);
      };
      cli.on("notification", handler);
    });
    await cli.sendRequest("session.send", {
      sessionId,
      prompt,
      mode: params?.mode
    });
    try {
      const collectedEvents = await waitForIdle;
      const assistantMessage = [...collectedEvents].reverse().find((e) => e.type === "assistant.message");
      this.sendToClient({
        jsonrpc: "2.0",
        id: request.id,
        result: assistantMessage ?? null
      });
    } catch (err) {
      this.sendErrorResponse(request.id, -32603, `sendAndWait failed: ${err}`);
    }
  }
  async handleSessionGetMessages(request) {
    const params = request.params;
    const sessionId = params?.sessionId;
    if (!sessionId) {
      this.sendErrorResponse(request.id, -32602, "Missing sessionId parameter");
      return;
    }
    const cli = this.sessionClis.get(sessionId);
    if (!cli) {
      this.sendErrorResponse(request.id, -32600, `Session not found: ${sessionId}`);
      return;
    }
    this.log("debug", `[${this.clientId}] RPC -> session.getMessages: ${sessionId}`);
    const result = await cli.sendRequest("session.getMessages", { sessionId });
    this.sendToClient({
      jsonrpc: "2.0",
      id: request.id,
      result: result.events ?? []
    });
  }
  async handleSessionAbort(request) {
    const params = request.params;
    const sessionId = params?.sessionId;
    if (!sessionId) {
      this.sendErrorResponse(request.id, -32602, "Missing sessionId parameter");
      return;
    }
    const cli = this.sessionClis.get(sessionId);
    if (!cli) {
      this.sendErrorResponse(request.id, -32600, `Session not found: ${sessionId}`);
      return;
    }
    this.log("debug", `[${this.clientId}] RPC -> session.abort: ${sessionId}`);
    await cli.sendRequest("session.abort", { sessionId });
    this.sendToClient({
      jsonrpc: "2.0",
      id: request.id,
      result: null
    });
  }
  async handleSessionDestroy(request) {
    const params = request.params;
    const sessionId = params?.sessionId;
    if (!sessionId) {
      this.sendErrorResponse(request.id, -32602, "Missing sessionId parameter");
      return;
    }
    const cli = this.sessionClis.get(sessionId);
    if (!cli) {
      this.sendErrorResponse(request.id, -32600, `Session not found: ${sessionId}`);
      return;
    }
    this.log("info", `Session ended: ${sessionId}`);
    await cli.sendRequest("session.destroy", { sessionId });
    this.sessionIds.delete(sessionId);
    this.sessionCwds.delete(sessionId);
    this.sessionClis.delete(sessionId);
    this.sessionTools.delete(sessionId);
    this.sendToClient({
      jsonrpc: "2.0",
      id: request.id,
      result: null
    });
  }
  // ==========================================================================
  // Event Forwarding
  // ==========================================================================
  forwardSessionEvent(sessionId, event) {
    this.log("debug", `[${this.clientId}] \u2190 session.event (${sessionId}): ${event.type}`);
    this.sendToClient({
      jsonrpc: "2.0",
      method: "session.event",
      params: {
        sessionId,
        event
      }
    });
  }
  // ==========================================================================
  // Callback Handling (CLI -> Client)
  // ==========================================================================
  async handleToolCall(sessionId, toolCallId, toolName, args) {
    const callbackId = String(this.nextCallbackId++);
    this.log("debug", `[${this.clientId}] RPC -> tool.call: ${toolName}`);
    this.sendToClient({
      jsonrpc: "2.0",
      id: callbackId,
      method: "tool.call",
      params: {
        sessionId,
        toolCallId,
        toolName,
        arguments: args
      }
    });
    return new Promise((resolve8, reject) => {
      const timeout = setTimeout(() => {
        this.pendingToolCallRequests.delete(callbackId);
        reject(new Error("Tool call request timeout"));
      }, 3e5);
      this.pendingToolCallRequests.set(callbackId, {
        resolve: (result) => {
          clearTimeout(timeout);
          resolve8(result);
        },
        reject: (error) => {
          clearTimeout(timeout);
          reject(error);
        }
      });
    });
  }
  async handlePermissionRequest(request, sessionId) {
    const callbackId = String(this.nextCallbackId++);
    this.log("debug", `[${this.clientId}] RPC -> permission.request: ${request.kind}`);
    this.sendToClient({
      jsonrpc: "2.0",
      id: callbackId,
      method: "permission.request",
      params: {
        sessionId,
        permissionRequest: request
      }
    });
    return new Promise((resolve8, reject) => {
      const timeout = setTimeout(() => {
        this.pendingPermissionRequests.delete(callbackId);
        reject(new Error("Permission request timeout"));
      }, 6e4);
      this.pendingPermissionRequests.set(callbackId, {
        resolve: (result) => {
          clearTimeout(timeout);
          resolve8(result);
        },
        reject: (error) => {
          clearTimeout(timeout);
          reject(error);
        }
      });
    });
  }
  // ==========================================================================
  // Utilities
  // ==========================================================================
  sendErrorResponse(id, code, message) {
    this.sendToClient({
      jsonrpc: "2.0",
      id,
      error: { code, message }
    });
  }
  sendToClient(message) {
    if (this.clientStream.destroyed) return;
    const encoded = encodeJsonRpcMessageToBuffer(message);
    this.clientStream.write(encoded);
  }
};
var JsonRpcProxyHost = class {
  clients = /* @__PURE__ */ new Map();
  options;
  cliPoolManager;
  fsService;
  gitService;
  constructor(options = {}) {
    this.options = options;
    this.cliPoolManager = new CliPoolManager({
      cliPath: options.cliPath,
      cliLogLevel: options.cliLogLevel,
      gracePeriodMs: options.cliGracePeriodMs,
      copilotToken: options.copilotToken,
      log: options.onLog
    });
    this.fsService = new FileSystemProviderService({
      log: options.onLog
    });
    this.gitService = new GitProviderService({
      log: options.onLog
    });
  }
  /**
   * Handle a new client connection from the tunnel.
   */
  async handleClient(stream, clientId) {
    const connection = new ClientConnection(stream, clientId, this.cliPoolManager, this.fsService, this.gitService, this.options);
    this.clients.set(clientId, connection);
    await connection.start();
  }
  /**
   * Handle client disconnection.
   */
  handleClientDisconnect(clientId) {
    const connection = this.clients.get(clientId);
    if (connection) {
      connection.stop();
      this.clients.delete(clientId);
    }
  }
  /**
   * Stop all client connections and dispose of CLI pool.
   */
  async stop() {
    await this.cliPoolManager.dispose();
    await this.fsService.dispose();
    await this.gitService.dispose();
    for (const connection of this.clients.values()) {
      connection.stop(true);
    }
    this.clients.clear();
  }
  /**
   * Get current CLI pool statistics (for debugging/monitoring).
   */
  getCliPoolStats() {
    return this.cliPoolManager.getStats();
  }
};

// src/logger.ts
var LOG_LEVEL_PRIORITY = {
  debug: 0,
  info: 1,
  warn: 2,
  error: 3
};
function formatTimestamp() {
  const now = /* @__PURE__ */ new Date();
  const hours = String(now.getHours()).padStart(2, "0");
  const minutes = String(now.getMinutes()).padStart(2, "0");
  const seconds = String(now.getSeconds()).padStart(2, "0");
  return `${hours}:${minutes}:${seconds}`;
}
function formatLevel(level) {
  return level.toUpperCase().padEnd(5);
}
function createLogger2(options) {
  const minLevel = options.level;
  const minPriority = LOG_LEVEL_PRIORITY[minLevel];
  function shouldLog(level) {
    return LOG_LEVEL_PRIORITY[level] >= minPriority;
  }
  function log(level, message) {
    if (!shouldLog(level)) return;
    const timestamp = formatTimestamp();
    const levelStr = formatLevel(level);
    if (message.includes("\n")) {
      const lines = message.split("\n");
      for (const line of lines) {
        console.log(`[${timestamp}] [${levelStr}] ${line}`);
      }
    } else {
      console.log(`[${timestamp}] [${levelStr}] ${message}`);
    }
  }
  return {
    debug: (message) => log("debug", message),
    info: (message) => log("info", message),
    warn: (message) => log("warn", message),
    error: (message) => log("error", message),
    log,
    blank: () => console.log(""),
    getLevel: () => minLevel
  };
}
function createLogCallback(logger) {
  return (level, message) => logger.log(level, message);
}

// src/banner.ts
var GREEN2 = "\x1B[32m";
var CYAN = "\x1B[36m";
var MAGENTA = "\x1B[35m";
var DIM2 = "\x1B[2m";
var RESET2 = "\x1B[0m";
var BOLD2 = "\x1B[1m";
function printBanner() {
  const version = CURRENT_VERSION.startsWith("__") ? "dev" : `v${CURRENT_VERSION}`;
  const url = "https://gh.io/copilot-tunnel";
  const iconL1 = `${CYAN}\u256D\u2500\u256E\u256D\u2500\u256E${RESET2}`;
  const iconL2 = `${CYAN}\u2570\u2500\u256F\u2570\u2500\u256F${RESET2}`;
  const iconL3 = `${MAGENTA}\u2588${RESET2} ${GREEN2}\u2598\u259D${RESET2} ${MAGENTA}\u2588${RESET2}`;
  const iconL4 = `${MAGENTA}\u2594\u2594\u2594\u2594${RESET2}`;
  const titleLine = `${MAGENTA}${BOLD2}GitHub Copilot Tunnel Host${RESET2}  ${DIM2}${version}${RESET2}`;
  const descLine = `${DIM2}Making your sessions available online.${RESET2}`;
  const urlLine = `${DIM2}See ${RESET2}${CYAN}${url}${RESET2}`;
  const line1 = `  ${iconL1}`;
  const line2 = `  ${iconL2}  ${titleLine}`;
  const line3 = `  ${iconL3}  ${descLine}`;
  const line4 = `   ${iconL4}   ${urlLine}`;
  console.log();
  console.log(line1);
  console.log(line2);
  console.log(line3);
  console.log(line4);
  console.log();
}

// src/sdk-proxy.ts
var GITHUB_CLIENT_ID2 = "Iv1.e7b89e013f801f03";
var GITHUB_TOKEN_URL2 = "https://github.com/login/oauth/access_token";
var program2 = new Command();
program2.name("remote-sdk-host").description("Host a Remote SDK session via Dev Tunnels").version(CURRENT_VERSION).option("-d, --debug", "Enable verbose debug logging").option("-p, --port <number>", "Port for local SDK connection", "0").action(runHost);
program2.command("logout").description("Clear stored GitHub credentials").action(runLogout);
var tunnelCmd = program2.command("tunnel").description("Manage stored tunnel configuration").action(runTunnelInfo);
tunnelCmd.command("clear").description("Clear stored tunnel configuration").action(runTunnelClear);
tunnelCmd.command("regenerate").option("-d, --debug", "Enable verbose debug logging").option("-p, --port <number>", "Port for local SDK connection", "0").description("Clear stored tunnel and create a fresh one").action(runTunnelRegenerate);
program2.parse();
async function runHost(options) {
  printBanner();
  checkForUpdates().catch(() => {
  });
  const logLevel = options.debug ? "debug" : "info";
  const port = parseInt(options.port || "0", 10);
  const logger = createLogger2({ level: logLevel });
  const logCallback = createLogCallback(logger);
  const proxyHost = new JsonRpcProxyHost({
    cliPath: "copilot",
    cwd: process.cwd(),
    cliLogLevel: "info",
    logLevel,
    onLog: logCallback
  });
  const tunnelAdapter = createTunnelHostAdapter({
    port,
    logLevel,
    onLog: logCallback,
    onStatusChange: (status) => {
    },
    onAuth: (message, uri, userCode) => {
      logger.blank();
      logger.info("=== GitHub Authentication ===");
      logger.info(`Visit: ${uri}`);
      logger.info(`Enter code: ${userCode}`);
      logger.blank();
    }
  });
  tunnelAdapter.onClientConnected((stream, clientId) => {
    logger.info(`Client connected: ${clientId}`);
    proxyHost.handleClient(stream, clientId).catch((error) => {
      logger.error(`Error handling client ${clientId}: ${error}`);
    });
  });
  tunnelAdapter.onClientDisconnected((clientId) => {
    proxyHost.handleClientDisconnect(clientId);
  });
  logger.debug("Starting tunnel...");
  let tunnelInfo;
  try {
    tunnelInfo = await tunnelAdapter.start();
  } catch (error) {
    logger.error(`Failed to start tunnel: ${error}`);
    process.exit(1);
  }
  if (tunnelInfo.username) {
    logger.info(`Using stored credentials (${tunnelInfo.username})`);
    logger.info("To switch accounts, run: remote-sdk-host logout");
  }
  logger.blank();
  logger.info("=== Tunnel Ready ===");
  logger.info(`Tunnel ID: ${tunnelInfo.tunnelId}`);
  logger.info(`Cluster:   ${tunnelInfo.clusterId}`);
  logger.info(`Port:      ${tunnelInfo.port}`);
  logger.blank();
  let isShuttingDown = false;
  const shutdown = async () => {
    if (isShuttingDown) return;
    isShuttingDown = true;
    logger.blank();
    logger.info("Shutting down...");
    const ignoreShutdownErrors = (err) => {
      if (err.message?.includes("stream was destroyed") || err.message?.includes("ERR_STREAM_DESTROYED")) {
        return;
      }
      logger.warn(`Shutdown error: ${err.message}`);
    };
    process.on("uncaughtException", ignoreShutdownErrors);
    process.on("unhandledRejection", ignoreShutdownErrors);
    try {
      await proxyHost.stop();
    } catch {
    }
    try {
      await tunnelAdapter.stop();
    } catch {
    }
    process.exit(0);
  };
  process.on("SIGINT", shutdown);
  process.on("SIGTERM", shutdown);
}
async function runLogout() {
  try {
    await clearTokenData();
    console.log("Credentials cleared.");
  } catch (error) {
    console.error(`Failed to clear credentials: ${error}`);
    process.exit(1);
  }
}
async function runTunnelInfo() {
  const configPath = getConfigPath();
  console.log(`Config file: ${configPath}`);
  console.log();
  try {
    const config = await loadTunnelConfig();
    if (config) {
      console.log("Stored tunnel configuration:");
      console.log(`  Tunnel ID: ${config.tunnelId}`);
      console.log(`  Cluster:   ${config.clusterId}`);
      console.log(`  Created:   ${config.createdAt}`);
    } else {
      console.log("No stored tunnel configuration.");
    }
  } catch (error) {
    console.error(`Failed to read tunnel config: ${error}`);
    process.exit(1);
  }
}
async function refreshAccessToken(refreshToken) {
  const response = await fetch(GITHUB_TOKEN_URL2, {
    method: "POST",
    headers: {
      Accept: "application/json",
      "Content-Type": "application/json"
    },
    body: JSON.stringify({
      client_id: GITHUB_CLIENT_ID2,
      refresh_token: refreshToken,
      grant_type: "refresh_token"
    })
  });
  if (!response.ok) {
    throw new Error(`Failed to refresh token: ${response.statusText}`);
  }
  const token = await response.json();
  if (token.error) {
    throw new Error(`Token refresh error: ${token.error_description || token.error}`);
  }
  if (!token.access_token) {
    throw new Error("Token refresh failed: no access token in response");
  }
  const now = Date.now();
  return {
    accessToken: token.access_token,
    refreshToken: token.refresh_token || refreshToken,
    expiresAt: now + (token.expires_in || 28800) * 1e3,
    refreshExpiresAt: now + (token.refresh_token_expires_in || 15638400) * 1e3
  };
}
async function getValidToken() {
  let tokenData = await loadTokenData();
  if (!tokenData) {
    return null;
  }
  const now = Date.now();
  const accessTokenExpired = tokenData.expiresAt < now + 5 * 60 * 1e3;
  const refreshTokenExpired = tokenData.refreshExpiresAt < now + 5 * 60 * 1e3;
  if (!accessTokenExpired) {
    return tokenData.accessToken;
  }
  if (accessTokenExpired && !refreshTokenExpired && tokenData.refreshToken) {
    try {
      const oldUsername = tokenData.username;
      tokenData = await refreshAccessToken(tokenData.refreshToken);
      tokenData.username = oldUsername;
      await saveTokenData(tokenData);
      return tokenData.accessToken;
    } catch {
      return null;
    }
  }
  return null;
}
async function runTunnelClear() {
  try {
    const githubToken = await getValidToken();
    if (githubToken) {
      console.log("Deleting tunnels from server...");
      const managementClient = new import_dev_tunnels_management2.TunnelManagementHttpClient(
        "RemoteSdkBridge/1.0",
        import_dev_tunnels_management2.ManagementApiVersions.Version20230927preview,
        () => Promise.resolve(`github ${githubToken}`)
      );
      const tunnels = await managementClient.listTunnels(
        void 0,
        // global search
        void 0,
        // default domain
        { labels: [TUNNEL_LABEL] }
      );
      if (tunnels.length > 0) {
        for (const tunnel of tunnels) {
          console.log(`  Deleting tunnel ${tunnel.tunnelId}...`);
          await managementClient.deleteTunnel(tunnel);
        }
        console.log(`Deleted ${tunnels.length} tunnel(s) from server.`);
      } else {
        console.log("No tunnels found with label.");
      }
    } else {
      console.log("No valid credentials found - only clearing local config.");
      console.log("(Run the host first to authenticate if you want to delete remote tunnels.)");
    }
    await clearTunnelConfig();
    console.log("Local tunnel configuration cleared.");
  } catch (error) {
    console.error(`Failed to clear tunnel config: ${error}`);
    process.exit(1);
  }
}
async function runTunnelRegenerate(options) {
  try {
    await clearTunnelConfig();
    console.log("Cleared stored tunnel configuration.");
    console.log();
  } catch (error) {
    console.error(`Failed to clear tunnel config: ${error}`);
    process.exit(1);
  }
  await runHost(options);
}
/*! Bundled license information:

mime-db/index.js:
  (*!
   * mime-db
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015-2022 Douglas Christopher Wilson
   * MIT Licensed
   *)

mime-types/index.js:
  (*!
   * mime-types
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

axios/dist/node/axios.cjs:
  (*! Axios v1.13.2 Copyright (c) 2025 Matt Zabriskie and contributors *)
*/
